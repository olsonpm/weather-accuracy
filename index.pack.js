module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!******************************!*\
  !*** ./src/server/routes.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';


	//---------//
	// Imports //
	//---------//

	const compression = __webpack_require__(/*! compression */ 1)
	  , express = __webpack_require__(/*! express */ 24)
	  , initApi = __webpack_require__(/*! ./init-api */ 88)
	  , Routes = __webpack_require__(/*! ../shared/routes */ 389)
	  ;


	//------//
	// Init //
	//------//

	const app = express()
	  , path = __webpack_require__(/*! path */ 11)
	  , routesInst = new Routes()
	  ;


	//------//
	// Main //
	//------//

	const getRequestListener = letsencryptDir => {
	  const routeSeq = routesInst.routeSeq()
	    , singlePage = path.join(__dirname, 'index.html')
	    ;

	  app.use(compression());

	  if (letsencryptDir) {
	    app.use(express.static(letsencryptDir, {
	      dotfiles: 'allow'
	    }));
	  }

	  app.use(express.static(path.join(__dirname, 'static')));

	  routeSeq
	    .where(r => r.name !== "otherwise")
	    .each(r => {
	      app.get(
	        r.url
	        , (req, res) => { res.sendFile(singlePage); }
	      );
	    });

	  initApi(app);

	  // special cases
	  app.get('/', (req, res) => {
	    res.sendFile(singlePage);
	  });
	  app.get("*", (req, res) => {
	    res.status(404);
	    res.sendFile(singlePage);
	  });

	  return app;
	};


	//---------//
	// Exports //
	//---------//

	module.exports = { getRequestListener };


/***/ },
/* 1 */
/*!********************************!*\
  !*** ./~/compression/index.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * compression
	 * Copyright(c) 2010 Sencha Inc.
	 * Copyright(c) 2011 TJ Holowaychuk
	 * Copyright(c) 2014 Jonathan Ong
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict'

	/**
	 * Module dependencies.
	 * @private
	 */

	var accepts = __webpack_require__(/*! accepts */ 2)
	var bytes = __webpack_require__(/*! bytes */ 12)
	var compressible = __webpack_require__(/*! compressible */ 13)
	var debug = __webpack_require__(/*! debug */ 14)('compression')
	var onHeaders = __webpack_require__(/*! on-headers */ 21)
	var vary = __webpack_require__(/*! vary */ 22)
	var zlib = __webpack_require__(/*! zlib */ 23)

	/**
	 * Module exports.
	 */

	module.exports = compression
	module.exports.filter = shouldCompress

	/**
	 * Module variables.
	 * @private
	 */

	var cacheControlNoTransformRegExp = /(?:^|,)\s*?no-transform\s*?(?:,|$)/

	/**
	 * Compress response data with gzip / deflate.
	 *
	 * @param {Object} [options]
	 * @return {Function} middleware
	 * @public
	 */

	function compression (options) {
	  var opts = options || {}

	  // options
	  var filter = opts.filter || shouldCompress
	  var threshold = bytes.parse(opts.threshold)

	  if (threshold == null) {
	    threshold = 1024
	  }

	  return function compression (req, res, next) {
	    var ended = false
	    var length
	    var listeners = []
	    var stream

	    var _end = res.end
	    var _on = res.on
	    var _write = res.write

	    // flush
	    res.flush = function flush () {
	      if (stream) {
	        stream.flush()
	      }
	    }

	    // proxy

	    res.write = function write (chunk, encoding) {
	      if (ended) {
	        return false
	      }

	      if (!this._header) {
	        this._implicitHeader()
	      }

	      return stream
	        ? stream.write(new Buffer(chunk, encoding))
	        : _write.call(this, chunk, encoding)
	    }

	    res.end = function end (chunk, encoding) {
	      if (ended) {
	        return false
	      }

	      if (!this._header) {
	        // estimate the length
	        if (!this.getHeader('Content-Length')) {
	          length = chunkLength(chunk, encoding)
	        }

	        this._implicitHeader()
	      }

	      if (!stream) {
	        return _end.call(this, chunk, encoding)
	      }

	      // mark ended
	      ended = true

	      // write Buffer for Node.js 0.8
	      return chunk
	        ? stream.end(new Buffer(chunk, encoding))
	        : stream.end()
	    }

	    res.on = function on (type, listener) {
	      if (!listeners || type !== 'drain') {
	        return _on.call(this, type, listener)
	      }

	      if (stream) {
	        return stream.on(type, listener)
	      }

	      // buffer listeners for future stream
	      listeners.push([type, listener])

	      return this
	    }

	    function nocompress (msg) {
	      debug('no compression: %s', msg)
	      addListeners(res, _on, listeners)
	      listeners = null
	    }

	    onHeaders(res, function onResponseHeaders () {
	      // determine if request is filtered
	      if (!filter(req, res)) {
	        nocompress('filtered')
	        return
	      }

	      // determine if the entity should be transformed
	      if (!shouldTransform(req, res)) {
	        nocompress('no transform')
	        return
	      }

	      // vary
	      vary(res, 'Accept-Encoding')

	      // content-length below threshold
	      if (Number(res.getHeader('Content-Length')) < threshold || length < threshold) {
	        nocompress('size below threshold')
	        return
	      }

	      var encoding = res.getHeader('Content-Encoding') || 'identity'

	      // already encoded
	      if (encoding !== 'identity') {
	        nocompress('already encoded')
	        return
	      }

	      // head
	      if (req.method === 'HEAD') {
	        nocompress('HEAD request')
	        return
	      }

	      // compression method
	      var accept = accepts(req)
	      var method = accept.encoding(['gzip', 'deflate', 'identity'])

	      // we really don't prefer deflate
	      if (method === 'deflate' && accept.encoding(['gzip'])) {
	        method = accept.encoding(['gzip', 'identity'])
	      }

	      // negotiation failed
	      if (!method || method === 'identity') {
	        nocompress('not acceptable')
	        return
	      }

	      // compression stream
	      debug('%s compression', method)
	      stream = method === 'gzip'
	        ? zlib.createGzip(opts)
	        : zlib.createDeflate(opts)

	      // add buffered listeners to stream
	      addListeners(stream, stream.on, listeners)

	      // header fields
	      res.setHeader('Content-Encoding', method)
	      res.removeHeader('Content-Length')

	      // compression
	      stream.on('data', function onStreamData (chunk) {
	        if (_write.call(res, chunk) === false) {
	          stream.pause()
	        }
	      })

	      stream.on('end', function onStreamEnd () {
	        _end.call(res)
	      })

	      _on.call(res, 'drain', function onResponseDrain () {
	        stream.resume()
	      })
	    })

	    next()
	  }
	}

	/**
	 * Add bufferred listeners to stream
	 * @private
	 */

	function addListeners (stream, on, listeners) {
	  for (var i = 0; i < listeners.length; i++) {
	    on.apply(stream, listeners[i])
	  }
	}

	/**
	 * Get the length of a given chunk
	 */

	function chunkLength (chunk, encoding) {
	  if (!chunk) {
	    return 0
	  }

	  return !Buffer.isBuffer(chunk)
	    ? Buffer.byteLength(chunk, encoding)
	    : chunk.length
	}

	/**
	 * Default filter function.
	 * @private
	 */

	function shouldCompress (req, res) {
	  var type = res.getHeader('Content-Type')

	  if (type === undefined || !compressible(type)) {
	    debug('%s not compressible', type)
	    return false
	  }

	  return true
	}

	/**
	 * Determine if the entity should be transformed.
	 * @private
	 */

	function shouldTransform (req, res) {
	  var cacheControl = res.getHeader('Cache-Control')

	  // Don't compress for Cache-Control: no-transform
	  // https://tools.ietf.org/html/rfc7234#section-5.2.2.4
	  return !cacheControl ||
	    !cacheControlNoTransformRegExp.test(cacheControl)
	}


/***/ },
/* 2 */
/*!****************************!*\
  !*** ./~/accepts/index.js ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * accepts
	 * Copyright(c) 2014 Jonathan Ong
	 * Copyright(c) 2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict'

	/**
	 * Module dependencies.
	 * @private
	 */

	var Negotiator = __webpack_require__(/*! negotiator */ 3)
	var mime = __webpack_require__(/*! mime-types */ 8)

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = Accepts

	/**
	 * Create a new Accepts object for the given req.
	 *
	 * @param {object} req
	 * @public
	 */

	function Accepts(req) {
	  if (!(this instanceof Accepts))
	    return new Accepts(req)

	  this.headers = req.headers
	  this.negotiator = new Negotiator(req)
	}

	/**
	 * Check if the given `type(s)` is acceptable, returning
	 * the best match when true, otherwise `undefined`, in which
	 * case you should respond with 406 "Not Acceptable".
	 *
	 * The `type` value may be a single mime type string
	 * such as "application/json", the extension name
	 * such as "json" or an array `["json", "html", "text/plain"]`. When a list
	 * or array is given the _best_ match, if any is returned.
	 *
	 * Examples:
	 *
	 *     // Accept: text/html
	 *     this.types('html');
	 *     // => "html"
	 *
	 *     // Accept: text/*, application/json
	 *     this.types('html');
	 *     // => "html"
	 *     this.types('text/html');
	 *     // => "text/html"
	 *     this.types('json', 'text');
	 *     // => "json"
	 *     this.types('application/json');
	 *     // => "application/json"
	 *
	 *     // Accept: text/*, application/json
	 *     this.types('image/png');
	 *     this.types('png');
	 *     // => undefined
	 *
	 *     // Accept: text/*;q=.5, application/json
	 *     this.types(['html', 'json']);
	 *     this.types('html', 'json');
	 *     // => "json"
	 *
	 * @param {String|Array} types...
	 * @return {String|Array|Boolean}
	 * @public
	 */

	Accepts.prototype.type =
	Accepts.prototype.types = function (types_) {
	  var types = types_

	  // support flattened arguments
	  if (types && !Array.isArray(types)) {
	    types = new Array(arguments.length)
	    for (var i = 0; i < types.length; i++) {
	      types[i] = arguments[i]
	    }
	  }

	  // no types, return all requested types
	  if (!types || types.length === 0) {
	    return this.negotiator.mediaTypes()
	  }

	  if (!this.headers.accept) return types[0];
	  var mimes = types.map(extToMime);
	  var accepts = this.negotiator.mediaTypes(mimes.filter(validMime));
	  var first = accepts[0];
	  if (!first) return false;
	  return types[mimes.indexOf(first)];
	}

	/**
	 * Return accepted encodings or best fit based on `encodings`.
	 *
	 * Given `Accept-Encoding: gzip, deflate`
	 * an array sorted by quality is returned:
	 *
	 *     ['gzip', 'deflate']
	 *
	 * @param {String|Array} encodings...
	 * @return {String|Array}
	 * @public
	 */

	Accepts.prototype.encoding =
	Accepts.prototype.encodings = function (encodings_) {
	  var encodings = encodings_

	  // support flattened arguments
	  if (encodings && !Array.isArray(encodings)) {
	    encodings = new Array(arguments.length)
	    for (var i = 0; i < encodings.length; i++) {
	      encodings[i] = arguments[i]
	    }
	  }

	  // no encodings, return all requested encodings
	  if (!encodings || encodings.length === 0) {
	    return this.negotiator.encodings()
	  }

	  return this.negotiator.encodings(encodings)[0] || false
	}

	/**
	 * Return accepted charsets or best fit based on `charsets`.
	 *
	 * Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`
	 * an array sorted by quality is returned:
	 *
	 *     ['utf-8', 'utf-7', 'iso-8859-1']
	 *
	 * @param {String|Array} charsets...
	 * @return {String|Array}
	 * @public
	 */

	Accepts.prototype.charset =
	Accepts.prototype.charsets = function (charsets_) {
	  var charsets = charsets_

	  // support flattened arguments
	  if (charsets && !Array.isArray(charsets)) {
	    charsets = new Array(arguments.length)
	    for (var i = 0; i < charsets.length; i++) {
	      charsets[i] = arguments[i]
	    }
	  }

	  // no charsets, return all requested charsets
	  if (!charsets || charsets.length === 0) {
	    return this.negotiator.charsets()
	  }

	  return this.negotiator.charsets(charsets)[0] || false
	}

	/**
	 * Return accepted languages or best fit based on `langs`.
	 *
	 * Given `Accept-Language: en;q=0.8, es, pt`
	 * an array sorted by quality is returned:
	 *
	 *     ['es', 'pt', 'en']
	 *
	 * @param {String|Array} langs...
	 * @return {Array|String}
	 * @public
	 */

	Accepts.prototype.lang =
	Accepts.prototype.langs =
	Accepts.prototype.language =
	Accepts.prototype.languages = function (languages_) {
	  var languages = languages_

	  // support flattened arguments
	  if (languages && !Array.isArray(languages)) {
	    languages = new Array(arguments.length)
	    for (var i = 0; i < languages.length; i++) {
	      languages[i] = arguments[i]
	    }
	  }

	  // no languages, return all requested languages
	  if (!languages || languages.length === 0) {
	    return this.negotiator.languages()
	  }

	  return this.negotiator.languages(languages)[0] || false
	}

	/**
	 * Convert extnames to mime.
	 *
	 * @param {String} type
	 * @return {String}
	 * @private
	 */

	function extToMime(type) {
	  return type.indexOf('/') === -1
	    ? mime.lookup(type)
	    : type
	}

	/**
	 * Check if mime is valid.
	 *
	 * @param {String} type
	 * @return {String}
	 * @private
	 */

	function validMime(type) {
	  return typeof type === 'string';
	}


/***/ },
/* 3 */
/*!*******************************!*\
  !*** ./~/negotiator/index.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * negotiator
	 * Copyright(c) 2012 Federico Romero
	 * Copyright(c) 2012-2014 Isaac Z. Schlueter
	 * Copyright(c) 2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Cached loaded submodules.
	 * @private
	 */

	var modules = Object.create(null);

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = Negotiator;
	module.exports.Negotiator = Negotiator;

	/**
	 * Create a Negotiator instance from a request.
	 * @param {object} request
	 * @public
	 */

	function Negotiator(request) {
	  if (!(this instanceof Negotiator)) {
	    return new Negotiator(request);
	  }

	  this.request = request;
	}

	Negotiator.prototype.charset = function charset(available) {
	  var set = this.charsets(available);
	  return set && set[0];
	};

	Negotiator.prototype.charsets = function charsets(available) {
	  var preferredCharsets = loadModule('charset').preferredCharsets;
	  return preferredCharsets(this.request.headers['accept-charset'], available);
	};

	Negotiator.prototype.encoding = function encoding(available) {
	  var set = this.encodings(available);
	  return set && set[0];
	};

	Negotiator.prototype.encodings = function encodings(available) {
	  var preferredEncodings = loadModule('encoding').preferredEncodings;
	  return preferredEncodings(this.request.headers['accept-encoding'], available);
	};

	Negotiator.prototype.language = function language(available) {
	  var set = this.languages(available);
	  return set && set[0];
	};

	Negotiator.prototype.languages = function languages(available) {
	  var preferredLanguages = loadModule('language').preferredLanguages;
	  return preferredLanguages(this.request.headers['accept-language'], available);
	};

	Negotiator.prototype.mediaType = function mediaType(available) {
	  var set = this.mediaTypes(available);
	  return set && set[0];
	};

	Negotiator.prototype.mediaTypes = function mediaTypes(available) {
	  var preferredMediaTypes = loadModule('mediaType').preferredMediaTypes;
	  return preferredMediaTypes(this.request.headers.accept, available);
	};

	// Backwards compatibility
	Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
	Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
	Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
	Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
	Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
	Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
	Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
	Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;

	/**
	 * Load the given module.
	 * @private
	 */

	function loadModule(moduleName) {
	  var module = modules[moduleName];

	  if (module !== undefined) {
	    return module;
	  }

	  // This uses a switch for static require analysis
	  switch (moduleName) {
	    case 'charset':
	      module = __webpack_require__(/*! ./lib/charset */ 4);
	      break;
	    case 'encoding':
	      module = __webpack_require__(/*! ./lib/encoding */ 5);
	      break;
	    case 'language':
	      module = __webpack_require__(/*! ./lib/language */ 6);
	      break;
	    case 'mediaType':
	      module = __webpack_require__(/*! ./lib/mediaType */ 7);
	      break;
	    default:
	      throw new Error('Cannot find module \'' + moduleName + '\'');
	  }

	  // Store to prevent invoking require()
	  modules[moduleName] = module;

	  return module;
	}


/***/ },
/* 4 */
/*!*************************************!*\
  !*** ./~/negotiator/lib/charset.js ***!
  \*************************************/
/***/ function(module, exports) {

	/**
	 * negotiator
	 * Copyright(c) 2012 Isaac Z. Schlueter
	 * Copyright(c) 2014 Federico Romero
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = preferredCharsets;
	module.exports.preferredCharsets = preferredCharsets;

	/**
	 * Module variables.
	 * @private
	 */

	var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;

	/**
	 * Parse the Accept-Charset header.
	 * @private
	 */

	function parseAcceptCharset(accept) {
	  var accepts = accept.split(',');

	  for (var i = 0, j = 0; i < accepts.length; i++) {
	    var charset = parseCharset(accepts[i].trim(), i);

	    if (charset) {
	      accepts[j++] = charset;
	    }
	  }

	  // trim accepts
	  accepts.length = j;

	  return accepts;
	}

	/**
	 * Parse a charset from the Accept-Charset header.
	 * @private
	 */

	function parseCharset(str, i) {
	  var match = simpleCharsetRegExp.exec(str);
	  if (!match) return null;

	  var charset = match[1];
	  var q = 1;
	  if (match[2]) {
	    var params = match[2].split(';')
	    for (var i = 0; i < params.length; i ++) {
	      var p = params[i].trim().split('=');
	      if (p[0] === 'q') {
	        q = parseFloat(p[1]);
	        break;
	      }
	    }
	  }

	  return {
	    charset: charset,
	    q: q,
	    i: i
	  };
	}

	/**
	 * Get the priority of a charset.
	 * @private
	 */

	function getCharsetPriority(charset, accepted, index) {
	  var priority = {o: -1, q: 0, s: 0};

	  for (var i = 0; i < accepted.length; i++) {
	    var spec = specify(charset, accepted[i], index);

	    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
	      priority = spec;
	    }
	  }

	  return priority;
	}

	/**
	 * Get the specificity of the charset.
	 * @private
	 */

	function specify(charset, spec, index) {
	  var s = 0;
	  if(spec.charset.toLowerCase() === charset.toLowerCase()){
	    s |= 1;
	  } else if (spec.charset !== '*' ) {
	    return null
	  }

	  return {
	    i: index,
	    o: spec.i,
	    q: spec.q,
	    s: s
	  }
	}

	/**
	 * Get the preferred charsets from an Accept-Charset header.
	 * @public
	 */

	function preferredCharsets(accept, provided) {
	  // RFC 2616 sec 14.2: no header = *
	  var accepts = parseAcceptCharset(accept === undefined ? '*' : accept || '');

	  if (!provided) {
	    // sorted list of all charsets
	    return accepts
	      .filter(isQuality)
	      .sort(compareSpecs)
	      .map(getFullCharset);
	  }

	  var priorities = provided.map(function getPriority(type, index) {
	    return getCharsetPriority(type, accepts, index);
	  });

	  // sorted list of accepted charsets
	  return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
	    return provided[priorities.indexOf(priority)];
	  });
	}

	/**
	 * Compare two specs.
	 * @private
	 */

	function compareSpecs(a, b) {
	  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
	}

	/**
	 * Get full charset string.
	 * @private
	 */

	function getFullCharset(spec) {
	  return spec.charset;
	}

	/**
	 * Check if a spec has any quality.
	 * @private
	 */

	function isQuality(spec) {
	  return spec.q > 0;
	}


/***/ },
/* 5 */
/*!**************************************!*\
  !*** ./~/negotiator/lib/encoding.js ***!
  \**************************************/
/***/ function(module, exports) {

	/**
	 * negotiator
	 * Copyright(c) 2012 Isaac Z. Schlueter
	 * Copyright(c) 2014 Federico Romero
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = preferredEncodings;
	module.exports.preferredEncodings = preferredEncodings;

	/**
	 * Module variables.
	 * @private
	 */

	var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;

	/**
	 * Parse the Accept-Encoding header.
	 * @private
	 */

	function parseAcceptEncoding(accept) {
	  var accepts = accept.split(',');
	  var hasIdentity = false;
	  var minQuality = 1;

	  for (var i = 0, j = 0; i < accepts.length; i++) {
	    var encoding = parseEncoding(accepts[i].trim(), i);

	    if (encoding) {
	      accepts[j++] = encoding;
	      hasIdentity = hasIdentity || specify('identity', encoding);
	      minQuality = Math.min(minQuality, encoding.q || 1);
	    }
	  }

	  if (!hasIdentity) {
	    /*
	     * If identity doesn't explicitly appear in the accept-encoding header,
	     * it's added to the list of acceptable encoding with the lowest q
	     */
	    accepts[j++] = {
	      encoding: 'identity',
	      q: minQuality,
	      i: i
	    };
	  }

	  // trim accepts
	  accepts.length = j;

	  return accepts;
	}

	/**
	 * Parse an encoding from the Accept-Encoding header.
	 * @private
	 */

	function parseEncoding(str, i) {
	  var match = simpleEncodingRegExp.exec(str);
	  if (!match) return null;

	  var encoding = match[1];
	  var q = 1;
	  if (match[2]) {
	    var params = match[2].split(';');
	    for (var i = 0; i < params.length; i ++) {
	      var p = params[i].trim().split('=');
	      if (p[0] === 'q') {
	        q = parseFloat(p[1]);
	        break;
	      }
	    }
	  }

	  return {
	    encoding: encoding,
	    q: q,
	    i: i
	  };
	}

	/**
	 * Get the priority of an encoding.
	 * @private
	 */

	function getEncodingPriority(encoding, accepted, index) {
	  var priority = {o: -1, q: 0, s: 0};

	  for (var i = 0; i < accepted.length; i++) {
	    var spec = specify(encoding, accepted[i], index);

	    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
	      priority = spec;
	    }
	  }

	  return priority;
	}

	/**
	 * Get the specificity of the encoding.
	 * @private
	 */

	function specify(encoding, spec, index) {
	  var s = 0;
	  if(spec.encoding.toLowerCase() === encoding.toLowerCase()){
	    s |= 1;
	  } else if (spec.encoding !== '*' ) {
	    return null
	  }

	  return {
	    i: index,
	    o: spec.i,
	    q: spec.q,
	    s: s
	  }
	};

	/**
	 * Get the preferred encodings from an Accept-Encoding header.
	 * @public
	 */

	function preferredEncodings(accept, provided) {
	  var accepts = parseAcceptEncoding(accept || '');

	  if (!provided) {
	    // sorted list of all encodings
	    return accepts
	      .filter(isQuality)
	      .sort(compareSpecs)
	      .map(getFullEncoding);
	  }

	  var priorities = provided.map(function getPriority(type, index) {
	    return getEncodingPriority(type, accepts, index);
	  });

	  // sorted list of accepted encodings
	  return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {
	    return provided[priorities.indexOf(priority)];
	  });
	}

	/**
	 * Compare two specs.
	 * @private
	 */

	function compareSpecs(a, b) {
	  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
	}

	/**
	 * Get full encoding string.
	 * @private
	 */

	function getFullEncoding(spec) {
	  return spec.encoding;
	}

	/**
	 * Check if a spec has any quality.
	 * @private
	 */

	function isQuality(spec) {
	  return spec.q > 0;
	}


/***/ },
/* 6 */
/*!**************************************!*\
  !*** ./~/negotiator/lib/language.js ***!
  \**************************************/
/***/ function(module, exports) {

	/**
	 * negotiator
	 * Copyright(c) 2012 Isaac Z. Schlueter
	 * Copyright(c) 2014 Federico Romero
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = preferredLanguages;
	module.exports.preferredLanguages = preferredLanguages;

	/**
	 * Module variables.
	 * @private
	 */

	var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;

	/**
	 * Parse the Accept-Language header.
	 * @private
	 */

	function parseAcceptLanguage(accept) {
	  var accepts = accept.split(',');

	  for (var i = 0, j = 0; i < accepts.length; i++) {
	    var langauge = parseLanguage(accepts[i].trim(), i);

	    if (langauge) {
	      accepts[j++] = langauge;
	    }
	  }

	  // trim accepts
	  accepts.length = j;

	  return accepts;
	}

	/**
	 * Parse a language from the Accept-Language header.
	 * @private
	 */

	function parseLanguage(str, i) {
	  var match = simpleLanguageRegExp.exec(str);
	  if (!match) return null;

	  var prefix = match[1],
	      suffix = match[2],
	      full = prefix;

	  if (suffix) full += "-" + suffix;

	  var q = 1;
	  if (match[3]) {
	    var params = match[3].split(';')
	    for (var i = 0; i < params.length; i ++) {
	      var p = params[i].split('=');
	      if (p[0] === 'q') q = parseFloat(p[1]);
	    }
	  }

	  return {
	    prefix: prefix,
	    suffix: suffix,
	    q: q,
	    i: i,
	    full: full
	  };
	}

	/**
	 * Get the priority of a language.
	 * @private
	 */

	function getLanguagePriority(language, accepted, index) {
	  var priority = {o: -1, q: 0, s: 0};

	  for (var i = 0; i < accepted.length; i++) {
	    var spec = specify(language, accepted[i], index);

	    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
	      priority = spec;
	    }
	  }

	  return priority;
	}

	/**
	 * Get the specificity of the language.
	 * @private
	 */

	function specify(language, spec, index) {
	  var p = parseLanguage(language)
	  if (!p) return null;
	  var s = 0;
	  if(spec.full.toLowerCase() === p.full.toLowerCase()){
	    s |= 4;
	  } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
	    s |= 2;
	  } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
	    s |= 1;
	  } else if (spec.full !== '*' ) {
	    return null
	  }

	  return {
	    i: index,
	    o: spec.i,
	    q: spec.q,
	    s: s
	  }
	};

	/**
	 * Get the preferred languages from an Accept-Language header.
	 * @public
	 */

	function preferredLanguages(accept, provided) {
	  // RFC 2616 sec 14.4: no header = *
	  var accepts = parseAcceptLanguage(accept === undefined ? '*' : accept || '');

	  if (!provided) {
	    // sorted list of all languages
	    return accepts
	      .filter(isQuality)
	      .sort(compareSpecs)
	      .map(getFullLanguage);
	  }

	  var priorities = provided.map(function getPriority(type, index) {
	    return getLanguagePriority(type, accepts, index);
	  });

	  // sorted list of accepted languages
	  return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
	    return provided[priorities.indexOf(priority)];
	  });
	}

	/**
	 * Compare two specs.
	 * @private
	 */

	function compareSpecs(a, b) {
	  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
	}

	/**
	 * Get full language string.
	 * @private
	 */

	function getFullLanguage(spec) {
	  return spec.full;
	}

	/**
	 * Check if a spec has any quality.
	 * @private
	 */

	function isQuality(spec) {
	  return spec.q > 0;
	}


/***/ },
/* 7 */
/*!***************************************!*\
  !*** ./~/negotiator/lib/mediaType.js ***!
  \***************************************/
/***/ function(module, exports) {

	/**
	 * negotiator
	 * Copyright(c) 2012 Isaac Z. Schlueter
	 * Copyright(c) 2014 Federico Romero
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = preferredMediaTypes;
	module.exports.preferredMediaTypes = preferredMediaTypes;

	/**
	 * Module variables.
	 * @private
	 */

	var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;

	/**
	 * Parse the Accept header.
	 * @private
	 */

	function parseAccept(accept) {
	  var accepts = splitMediaTypes(accept);

	  for (var i = 0, j = 0; i < accepts.length; i++) {
	    var mediaType = parseMediaType(accepts[i].trim(), i);

	    if (mediaType) {
	      accepts[j++] = mediaType;
	    }
	  }

	  // trim accepts
	  accepts.length = j;

	  return accepts;
	}

	/**
	 * Parse a media type from the Accept header.
	 * @private
	 */

	function parseMediaType(str, i) {
	  var match = simpleMediaTypeRegExp.exec(str);
	  if (!match) return null;

	  var params = Object.create(null);
	  var q = 1;
	  var subtype = match[2];
	  var type = match[1];

	  if (match[3]) {
	    var kvps = splitParameters(match[3]).map(splitKeyValuePair);

	    for (var j = 0; j < kvps.length; j++) {
	      var pair = kvps[j];
	      var key = pair[0].toLowerCase();
	      var val = pair[1];

	      // get the value, unwrapping quotes
	      var value = val && val[0] === '"' && val[val.length - 1] === '"'
	        ? val.substr(1, val.length - 2)
	        : val;

	      if (key === 'q') {
	        q = parseFloat(value);
	        break;
	      }

	      // store parameter
	      params[key] = value;
	    }
	  }

	  return {
	    type: type,
	    subtype: subtype,
	    params: params,
	    q: q,
	    i: i
	  };
	}

	/**
	 * Get the priority of a media type.
	 * @private
	 */

	function getMediaTypePriority(type, accepted, index) {
	  var priority = {o: -1, q: 0, s: 0};

	  for (var i = 0; i < accepted.length; i++) {
	    var spec = specify(type, accepted[i], index);

	    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
	      priority = spec;
	    }
	  }

	  return priority;
	}

	/**
	 * Get the specificity of the media type.
	 * @private
	 */

	function specify(type, spec, index) {
	  var p = parseMediaType(type);
	  var s = 0;

	  if (!p) {
	    return null;
	  }

	  if(spec.type.toLowerCase() == p.type.toLowerCase()) {
	    s |= 4
	  } else if(spec.type != '*') {
	    return null;
	  }

	  if(spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
	    s |= 2
	  } else if(spec.subtype != '*') {
	    return null;
	  }

	  var keys = Object.keys(spec.params);
	  if (keys.length > 0) {
	    if (keys.every(function (k) {
	      return spec.params[k] == '*' || (spec.params[k] || '').toLowerCase() == (p.params[k] || '').toLowerCase();
	    })) {
	      s |= 1
	    } else {
	      return null
	    }
	  }

	  return {
	    i: index,
	    o: spec.i,
	    q: spec.q,
	    s: s,
	  }
	}

	/**
	 * Get the preferred media types from an Accept header.
	 * @public
	 */

	function preferredMediaTypes(accept, provided) {
	  // RFC 2616 sec 14.2: no header = */*
	  var accepts = parseAccept(accept === undefined ? '*/*' : accept || '');

	  if (!provided) {
	    // sorted list of all types
	    return accepts
	      .filter(isQuality)
	      .sort(compareSpecs)
	      .map(getFullType);
	  }

	  var priorities = provided.map(function getPriority(type, index) {
	    return getMediaTypePriority(type, accepts, index);
	  });

	  // sorted list of accepted types
	  return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
	    return provided[priorities.indexOf(priority)];
	  });
	}

	/**
	 * Compare two specs.
	 * @private
	 */

	function compareSpecs(a, b) {
	  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;
	}

	/**
	 * Get full type string.
	 * @private
	 */

	function getFullType(spec) {
	  return spec.type + '/' + spec.subtype;
	}

	/**
	 * Check if a spec has any quality.
	 * @private
	 */

	function isQuality(spec) {
	  return spec.q > 0;
	}

	/**
	 * Count the number of quotes in a string.
	 * @private
	 */

	function quoteCount(string) {
	  var count = 0;
	  var index = 0;

	  while ((index = string.indexOf('"', index)) !== -1) {
	    count++;
	    index++;
	  }

	  return count;
	}

	/**
	 * Split a key value pair.
	 * @private
	 */

	function splitKeyValuePair(str) {
	  var index = str.indexOf('=');
	  var key;
	  var val;

	  if (index === -1) {
	    key = str;
	  } else {
	    key = str.substr(0, index);
	    val = str.substr(index + 1);
	  }

	  return [key, val];
	}

	/**
	 * Split an Accept header into media types.
	 * @private
	 */

	function splitMediaTypes(accept) {
	  var accepts = accept.split(',');

	  for (var i = 1, j = 0; i < accepts.length; i++) {
	    if (quoteCount(accepts[j]) % 2 == 0) {
	      accepts[++j] = accepts[i];
	    } else {
	      accepts[j] += ',' + accepts[i];
	    }
	  }

	  // trim accepts
	  accepts.length = j + 1;

	  return accepts;
	}

	/**
	 * Split a string of parameters.
	 * @private
	 */

	function splitParameters(str) {
	  var parameters = str.split(';');

	  for (var i = 1, j = 0; i < parameters.length; i++) {
	    if (quoteCount(parameters[j]) % 2 == 0) {
	      parameters[++j] = parameters[i];
	    } else {
	      parameters[j] += ';' + parameters[i];
	    }
	  }

	  // trim parameters
	  parameters.length = j + 1;

	  for (var i = 0; i < parameters.length; i++) {
	    parameters[i] = parameters[i].trim();
	  }

	  return parameters;
	}


/***/ },
/* 8 */
/*!*******************************!*\
  !*** ./~/mime-types/index.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * mime-types
	 * Copyright(c) 2014 Jonathan Ong
	 * Copyright(c) 2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict'

	/**
	 * Module dependencies.
	 * @private
	 */

	var db = __webpack_require__(/*! mime-db */ 9)
	var extname = __webpack_require__(/*! path */ 11).extname

	/**
	 * Module variables.
	 * @private
	 */

	var extractTypeRegExp = /^\s*([^;\s]*)(?:;|\s|$)/
	var textTypeRegExp = /^text\//i

	/**
	 * Module exports.
	 * @public
	 */

	exports.charset = charset
	exports.charsets = { lookup: charset }
	exports.contentType = contentType
	exports.extension = extension
	exports.extensions = Object.create(null)
	exports.lookup = lookup
	exports.types = Object.create(null)

	// Populate the extensions/types maps
	populateMaps(exports.extensions, exports.types)

	/**
	 * Get the default charset for a MIME type.
	 *
	 * @param {string} type
	 * @return {boolean|string}
	 */

	function charset (type) {
	  if (!type || typeof type !== 'string') {
	    return false
	  }

	  // TODO: use media-typer
	  var match = extractTypeRegExp.exec(type)
	  var mime = match && db[match[1].toLowerCase()]

	  if (mime && mime.charset) {
	    return mime.charset
	  }

	  // default text/* to utf-8
	  if (match && textTypeRegExp.test(match[1])) {
	    return 'UTF-8'
	  }

	  return false
	}

	/**
	 * Create a full Content-Type header given a MIME type or extension.
	 *
	 * @param {string} str
	 * @return {boolean|string}
	 */

	function contentType (str) {
	  // TODO: should this even be in this module?
	  if (!str || typeof str !== 'string') {
	    return false
	  }

	  var mime = str.indexOf('/') === -1
	    ? exports.lookup(str)
	    : str

	  if (!mime) {
	    return false
	  }

	  // TODO: use content-type or other module
	  if (mime.indexOf('charset') === -1) {
	    var charset = exports.charset(mime)
	    if (charset) mime += '; charset=' + charset.toLowerCase()
	  }

	  return mime
	}

	/**
	 * Get the default extension for a MIME type.
	 *
	 * @param {string} type
	 * @return {boolean|string}
	 */

	function extension (type) {
	  if (!type || typeof type !== 'string') {
	    return false
	  }

	  // TODO: use media-typer
	  var match = extractTypeRegExp.exec(type)

	  // get extensions
	  var exts = match && exports.extensions[match[1].toLowerCase()]

	  if (!exts || !exts.length) {
	    return false
	  }

	  return exts[0]
	}

	/**
	 * Lookup the MIME type for a file path/extension.
	 *
	 * @param {string} path
	 * @return {boolean|string}
	 */

	function lookup (path) {
	  if (!path || typeof path !== 'string') {
	    return false
	  }

	  // get the extension ("ext" or ".ext" or full path)
	  var extension = extname('x.' + path)
	    .toLowerCase()
	    .substr(1)

	  if (!extension) {
	    return false
	  }

	  return exports.types[extension] || false
	}

	/**
	 * Populate the extensions and types maps.
	 * @private
	 */

	function populateMaps (extensions, types) {
	  // source preference (least -> most)
	  var preference = ['nginx', 'apache', undefined, 'iana']

	  Object.keys(db).forEach(function forEachMimeType (type) {
	    var mime = db[type]
	    var exts = mime.extensions

	    if (!exts || !exts.length) {
	      return
	    }

	    // mime -> extensions
	    extensions[type] = exts

	    // extension -> mime
	    for (var i = 0; i < exts.length; i++) {
	      var extension = exts[i]

	      if (types[extension]) {
	        var from = preference.indexOf(db[types[extension]].source)
	        var to = preference.indexOf(mime.source)

	        if (types[extension] !== 'application/octet-stream' &&
	          from > to || (from === to && types[extension].substr(0, 12) === 'application/')) {
	          // skip the remapping
	          continue
	        }
	      }

	      // set the extension -> mime
	      types[extension] = type
	    }
	  })
	}


/***/ },
/* 9 */
/*!****************************!*\
  !*** ./~/mime-db/index.js ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * mime-db
	 * Copyright(c) 2014 Jonathan Ong
	 * MIT Licensed
	 */

	/**
	 * Module exports.
	 */

	module.exports = __webpack_require__(/*! ./db.json */ 10)


/***/ },
/* 10 */
/*!***************************!*\
  !*** ./~/mime-db/db.json ***!
  \***************************/
/***/ function(module, exports) {

	module.exports = {
		"application/1d-interleaved-parityfec": {
			"source": "iana"
		},
		"application/3gpdash-qoe-report+xml": {
			"source": "iana"
		},
		"application/3gpp-ims+xml": {
			"source": "iana"
		},
		"application/a2l": {
			"source": "iana"
		},
		"application/activemessage": {
			"source": "iana"
		},
		"application/alto-costmap+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-costmapfilter+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-directory+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-endpointcost+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-endpointcostparams+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-endpointprop+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-endpointpropparams+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-error+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-networkmap+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-networkmapfilter+json": {
			"source": "iana",
			"compressible": true
		},
		"application/aml": {
			"source": "iana"
		},
		"application/andrew-inset": {
			"source": "iana",
			"extensions": [
				"ez"
			]
		},
		"application/applefile": {
			"source": "iana"
		},
		"application/applixware": {
			"source": "apache",
			"extensions": [
				"aw"
			]
		},
		"application/atf": {
			"source": "iana"
		},
		"application/atfx": {
			"source": "iana"
		},
		"application/atom+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"atom"
			]
		},
		"application/atomcat+xml": {
			"source": "iana",
			"extensions": [
				"atomcat"
			]
		},
		"application/atomdeleted+xml": {
			"source": "iana"
		},
		"application/atomicmail": {
			"source": "iana"
		},
		"application/atomsvc+xml": {
			"source": "iana",
			"extensions": [
				"atomsvc"
			]
		},
		"application/atxml": {
			"source": "iana"
		},
		"application/auth-policy+xml": {
			"source": "iana"
		},
		"application/bacnet-xdd+zip": {
			"source": "iana"
		},
		"application/batch-smtp": {
			"source": "iana"
		},
		"application/bdoc": {
			"compressible": false,
			"extensions": [
				"bdoc"
			]
		},
		"application/beep+xml": {
			"source": "iana"
		},
		"application/calendar+json": {
			"source": "iana",
			"compressible": true
		},
		"application/calendar+xml": {
			"source": "iana"
		},
		"application/call-completion": {
			"source": "iana"
		},
		"application/cals-1840": {
			"source": "iana"
		},
		"application/cbor": {
			"source": "iana"
		},
		"application/ccmp+xml": {
			"source": "iana"
		},
		"application/ccxml+xml": {
			"source": "iana",
			"extensions": [
				"ccxml"
			]
		},
		"application/cdfx+xml": {
			"source": "iana"
		},
		"application/cdmi-capability": {
			"source": "iana",
			"extensions": [
				"cdmia"
			]
		},
		"application/cdmi-container": {
			"source": "iana",
			"extensions": [
				"cdmic"
			]
		},
		"application/cdmi-domain": {
			"source": "iana",
			"extensions": [
				"cdmid"
			]
		},
		"application/cdmi-object": {
			"source": "iana",
			"extensions": [
				"cdmio"
			]
		},
		"application/cdmi-queue": {
			"source": "iana",
			"extensions": [
				"cdmiq"
			]
		},
		"application/cdni": {
			"source": "iana"
		},
		"application/cea": {
			"source": "iana"
		},
		"application/cea-2018+xml": {
			"source": "iana"
		},
		"application/cellml+xml": {
			"source": "iana"
		},
		"application/cfw": {
			"source": "iana"
		},
		"application/clue_info+xml": {
			"source": "iana"
		},
		"application/cms": {
			"source": "iana"
		},
		"application/cnrp+xml": {
			"source": "iana"
		},
		"application/coap-group+json": {
			"source": "iana",
			"compressible": true
		},
		"application/commonground": {
			"source": "iana"
		},
		"application/conference-info+xml": {
			"source": "iana"
		},
		"application/cpl+xml": {
			"source": "iana"
		},
		"application/csrattrs": {
			"source": "iana"
		},
		"application/csta+xml": {
			"source": "iana"
		},
		"application/cstadata+xml": {
			"source": "iana"
		},
		"application/csvm+json": {
			"source": "iana",
			"compressible": true
		},
		"application/cu-seeme": {
			"source": "apache",
			"extensions": [
				"cu"
			]
		},
		"application/cybercash": {
			"source": "iana"
		},
		"application/dart": {
			"compressible": true
		},
		"application/dash+xml": {
			"source": "iana",
			"extensions": [
				"mpd"
			]
		},
		"application/dashdelta": {
			"source": "iana"
		},
		"application/davmount+xml": {
			"source": "iana",
			"extensions": [
				"davmount"
			]
		},
		"application/dca-rft": {
			"source": "iana"
		},
		"application/dcd": {
			"source": "iana"
		},
		"application/dec-dx": {
			"source": "iana"
		},
		"application/dialog-info+xml": {
			"source": "iana"
		},
		"application/dicom": {
			"source": "iana"
		},
		"application/dii": {
			"source": "iana"
		},
		"application/dit": {
			"source": "iana"
		},
		"application/dns": {
			"source": "iana"
		},
		"application/docbook+xml": {
			"source": "apache",
			"extensions": [
				"dbk"
			]
		},
		"application/dskpp+xml": {
			"source": "iana"
		},
		"application/dssc+der": {
			"source": "iana",
			"extensions": [
				"dssc"
			]
		},
		"application/dssc+xml": {
			"source": "iana",
			"extensions": [
				"xdssc"
			]
		},
		"application/dvcs": {
			"source": "iana"
		},
		"application/ecmascript": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"ecma"
			]
		},
		"application/edi-consent": {
			"source": "iana"
		},
		"application/edi-x12": {
			"source": "iana",
			"compressible": false
		},
		"application/edifact": {
			"source": "iana",
			"compressible": false
		},
		"application/efi": {
			"source": "iana"
		},
		"application/emergencycalldata.comment+xml": {
			"source": "iana"
		},
		"application/emergencycalldata.deviceinfo+xml": {
			"source": "iana"
		},
		"application/emergencycalldata.providerinfo+xml": {
			"source": "iana"
		},
		"application/emergencycalldata.serviceinfo+xml": {
			"source": "iana"
		},
		"application/emergencycalldata.subscriberinfo+xml": {
			"source": "iana"
		},
		"application/emma+xml": {
			"source": "iana",
			"extensions": [
				"emma"
			]
		},
		"application/emotionml+xml": {
			"source": "iana"
		},
		"application/encaprtp": {
			"source": "iana"
		},
		"application/epp+xml": {
			"source": "iana"
		},
		"application/epub+zip": {
			"source": "iana",
			"extensions": [
				"epub"
			]
		},
		"application/eshop": {
			"source": "iana"
		},
		"application/exi": {
			"source": "iana",
			"extensions": [
				"exi"
			]
		},
		"application/fastinfoset": {
			"source": "iana"
		},
		"application/fastsoap": {
			"source": "iana"
		},
		"application/fdt+xml": {
			"source": "iana"
		},
		"application/fits": {
			"source": "iana"
		},
		"application/font-sfnt": {
			"source": "iana"
		},
		"application/font-tdpfr": {
			"source": "iana",
			"extensions": [
				"pfr"
			]
		},
		"application/font-woff": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"woff"
			]
		},
		"application/font-woff2": {
			"compressible": false,
			"extensions": [
				"woff2"
			]
		},
		"application/framework-attributes+xml": {
			"source": "iana"
		},
		"application/geo+json": {
			"source": "iana",
			"compressible": true
		},
		"application/gml+xml": {
			"source": "apache",
			"extensions": [
				"gml"
			]
		},
		"application/gpx+xml": {
			"source": "apache",
			"extensions": [
				"gpx"
			]
		},
		"application/gxf": {
			"source": "apache",
			"extensions": [
				"gxf"
			]
		},
		"application/gzip": {
			"source": "iana",
			"compressible": false
		},
		"application/h224": {
			"source": "iana"
		},
		"application/held+xml": {
			"source": "iana"
		},
		"application/http": {
			"source": "iana"
		},
		"application/hyperstudio": {
			"source": "iana",
			"extensions": [
				"stk"
			]
		},
		"application/ibe-key-request+xml": {
			"source": "iana"
		},
		"application/ibe-pkg-reply+xml": {
			"source": "iana"
		},
		"application/ibe-pp-data": {
			"source": "iana"
		},
		"application/iges": {
			"source": "iana"
		},
		"application/im-iscomposing+xml": {
			"source": "iana"
		},
		"application/index": {
			"source": "iana"
		},
		"application/index.cmd": {
			"source": "iana"
		},
		"application/index.obj": {
			"source": "iana"
		},
		"application/index.response": {
			"source": "iana"
		},
		"application/index.vnd": {
			"source": "iana"
		},
		"application/inkml+xml": {
			"source": "iana",
			"extensions": [
				"ink",
				"inkml"
			]
		},
		"application/iotp": {
			"source": "iana"
		},
		"application/ipfix": {
			"source": "iana",
			"extensions": [
				"ipfix"
			]
		},
		"application/ipp": {
			"source": "iana"
		},
		"application/isup": {
			"source": "iana"
		},
		"application/its+xml": {
			"source": "iana"
		},
		"application/java-archive": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"jar",
				"war",
				"ear"
			]
		},
		"application/java-serialized-object": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"ser"
			]
		},
		"application/java-vm": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"class"
			]
		},
		"application/javascript": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": [
				"js"
			]
		},
		"application/jose": {
			"source": "iana"
		},
		"application/jose+json": {
			"source": "iana",
			"compressible": true
		},
		"application/jrd+json": {
			"source": "iana",
			"compressible": true
		},
		"application/json": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": [
				"json",
				"map"
			]
		},
		"application/json-patch+json": {
			"source": "iana",
			"compressible": true
		},
		"application/json-seq": {
			"source": "iana"
		},
		"application/json5": {
			"extensions": [
				"json5"
			]
		},
		"application/jsonml+json": {
			"source": "apache",
			"compressible": true,
			"extensions": [
				"jsonml"
			]
		},
		"application/jwk+json": {
			"source": "iana",
			"compressible": true
		},
		"application/jwk-set+json": {
			"source": "iana",
			"compressible": true
		},
		"application/jwt": {
			"source": "iana"
		},
		"application/kpml-request+xml": {
			"source": "iana"
		},
		"application/kpml-response+xml": {
			"source": "iana"
		},
		"application/ld+json": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"jsonld"
			]
		},
		"application/lgr+xml": {
			"source": "iana"
		},
		"application/link-format": {
			"source": "iana"
		},
		"application/load-control+xml": {
			"source": "iana"
		},
		"application/lost+xml": {
			"source": "iana",
			"extensions": [
				"lostxml"
			]
		},
		"application/lostsync+xml": {
			"source": "iana"
		},
		"application/lxf": {
			"source": "iana"
		},
		"application/mac-binhex40": {
			"source": "iana",
			"extensions": [
				"hqx"
			]
		},
		"application/mac-compactpro": {
			"source": "apache",
			"extensions": [
				"cpt"
			]
		},
		"application/macwriteii": {
			"source": "iana"
		},
		"application/mads+xml": {
			"source": "iana",
			"extensions": [
				"mads"
			]
		},
		"application/manifest+json": {
			"charset": "UTF-8",
			"compressible": true,
			"extensions": [
				"webmanifest"
			]
		},
		"application/marc": {
			"source": "iana",
			"extensions": [
				"mrc"
			]
		},
		"application/marcxml+xml": {
			"source": "iana",
			"extensions": [
				"mrcx"
			]
		},
		"application/mathematica": {
			"source": "iana",
			"extensions": [
				"ma",
				"nb",
				"mb"
			]
		},
		"application/mathml+xml": {
			"source": "iana",
			"extensions": [
				"mathml"
			]
		},
		"application/mathml-content+xml": {
			"source": "iana"
		},
		"application/mathml-presentation+xml": {
			"source": "iana"
		},
		"application/mbms-associated-procedure-description+xml": {
			"source": "iana"
		},
		"application/mbms-deregister+xml": {
			"source": "iana"
		},
		"application/mbms-envelope+xml": {
			"source": "iana"
		},
		"application/mbms-msk+xml": {
			"source": "iana"
		},
		"application/mbms-msk-response+xml": {
			"source": "iana"
		},
		"application/mbms-protection-description+xml": {
			"source": "iana"
		},
		"application/mbms-reception-report+xml": {
			"source": "iana"
		},
		"application/mbms-register+xml": {
			"source": "iana"
		},
		"application/mbms-register-response+xml": {
			"source": "iana"
		},
		"application/mbms-schedule+xml": {
			"source": "iana"
		},
		"application/mbms-user-service-description+xml": {
			"source": "iana"
		},
		"application/mbox": {
			"source": "iana",
			"extensions": [
				"mbox"
			]
		},
		"application/media-policy-dataset+xml": {
			"source": "iana"
		},
		"application/media_control+xml": {
			"source": "iana"
		},
		"application/mediaservercontrol+xml": {
			"source": "iana",
			"extensions": [
				"mscml"
			]
		},
		"application/merge-patch+json": {
			"source": "iana",
			"compressible": true
		},
		"application/metalink+xml": {
			"source": "apache",
			"extensions": [
				"metalink"
			]
		},
		"application/metalink4+xml": {
			"source": "iana",
			"extensions": [
				"meta4"
			]
		},
		"application/mets+xml": {
			"source": "iana",
			"extensions": [
				"mets"
			]
		},
		"application/mf4": {
			"source": "iana"
		},
		"application/mikey": {
			"source": "iana"
		},
		"application/mods+xml": {
			"source": "iana",
			"extensions": [
				"mods"
			]
		},
		"application/moss-keys": {
			"source": "iana"
		},
		"application/moss-signature": {
			"source": "iana"
		},
		"application/mosskey-data": {
			"source": "iana"
		},
		"application/mosskey-request": {
			"source": "iana"
		},
		"application/mp21": {
			"source": "iana",
			"extensions": [
				"m21",
				"mp21"
			]
		},
		"application/mp4": {
			"source": "iana",
			"extensions": [
				"mp4s",
				"m4p"
			]
		},
		"application/mpeg4-generic": {
			"source": "iana"
		},
		"application/mpeg4-iod": {
			"source": "iana"
		},
		"application/mpeg4-iod-xmt": {
			"source": "iana"
		},
		"application/mrb-consumer+xml": {
			"source": "iana"
		},
		"application/mrb-publish+xml": {
			"source": "iana"
		},
		"application/msc-ivr+xml": {
			"source": "iana"
		},
		"application/msc-mixer+xml": {
			"source": "iana"
		},
		"application/msword": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"doc",
				"dot"
			]
		},
		"application/mxf": {
			"source": "iana",
			"extensions": [
				"mxf"
			]
		},
		"application/nasdata": {
			"source": "iana"
		},
		"application/news-checkgroups": {
			"source": "iana"
		},
		"application/news-groupinfo": {
			"source": "iana"
		},
		"application/news-transmission": {
			"source": "iana"
		},
		"application/nlsml+xml": {
			"source": "iana"
		},
		"application/nss": {
			"source": "iana"
		},
		"application/ocsp-request": {
			"source": "iana"
		},
		"application/ocsp-response": {
			"source": "iana"
		},
		"application/octet-stream": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"bin",
				"dms",
				"lrf",
				"mar",
				"so",
				"dist",
				"distz",
				"pkg",
				"bpk",
				"dump",
				"elc",
				"deploy",
				"exe",
				"dll",
				"deb",
				"dmg",
				"iso",
				"img",
				"msi",
				"msp",
				"msm",
				"buffer"
			]
		},
		"application/oda": {
			"source": "iana",
			"extensions": [
				"oda"
			]
		},
		"application/odx": {
			"source": "iana"
		},
		"application/oebps-package+xml": {
			"source": "iana",
			"extensions": [
				"opf"
			]
		},
		"application/ogg": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"ogx"
			]
		},
		"application/omdoc+xml": {
			"source": "apache",
			"extensions": [
				"omdoc"
			]
		},
		"application/onenote": {
			"source": "apache",
			"extensions": [
				"onetoc",
				"onetoc2",
				"onetmp",
				"onepkg"
			]
		},
		"application/oxps": {
			"source": "iana",
			"extensions": [
				"oxps"
			]
		},
		"application/p2p-overlay+xml": {
			"source": "iana"
		},
		"application/parityfec": {
			"source": "iana"
		},
		"application/patch-ops-error+xml": {
			"source": "iana",
			"extensions": [
				"xer"
			]
		},
		"application/pdf": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"pdf"
			]
		},
		"application/pdx": {
			"source": "iana"
		},
		"application/pgp-encrypted": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"pgp"
			]
		},
		"application/pgp-keys": {
			"source": "iana"
		},
		"application/pgp-signature": {
			"source": "iana",
			"extensions": [
				"asc",
				"sig"
			]
		},
		"application/pics-rules": {
			"source": "apache",
			"extensions": [
				"prf"
			]
		},
		"application/pidf+xml": {
			"source": "iana"
		},
		"application/pidf-diff+xml": {
			"source": "iana"
		},
		"application/pkcs10": {
			"source": "iana",
			"extensions": [
				"p10"
			]
		},
		"application/pkcs12": {
			"source": "iana"
		},
		"application/pkcs7-mime": {
			"source": "iana",
			"extensions": [
				"p7m",
				"p7c"
			]
		},
		"application/pkcs7-signature": {
			"source": "iana",
			"extensions": [
				"p7s"
			]
		},
		"application/pkcs8": {
			"source": "iana",
			"extensions": [
				"p8"
			]
		},
		"application/pkix-attr-cert": {
			"source": "iana",
			"extensions": [
				"ac"
			]
		},
		"application/pkix-cert": {
			"source": "iana",
			"extensions": [
				"cer"
			]
		},
		"application/pkix-crl": {
			"source": "iana",
			"extensions": [
				"crl"
			]
		},
		"application/pkix-pkipath": {
			"source": "iana",
			"extensions": [
				"pkipath"
			]
		},
		"application/pkixcmp": {
			"source": "iana",
			"extensions": [
				"pki"
			]
		},
		"application/pls+xml": {
			"source": "iana",
			"extensions": [
				"pls"
			]
		},
		"application/poc-settings+xml": {
			"source": "iana"
		},
		"application/postscript": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"ai",
				"eps",
				"ps"
			]
		},
		"application/ppsp-tracker+json": {
			"source": "iana",
			"compressible": true
		},
		"application/problem+json": {
			"source": "iana",
			"compressible": true
		},
		"application/problem+xml": {
			"source": "iana"
		},
		"application/provenance+xml": {
			"source": "iana"
		},
		"application/prs.alvestrand.titrax-sheet": {
			"source": "iana"
		},
		"application/prs.cww": {
			"source": "iana",
			"extensions": [
				"cww"
			]
		},
		"application/prs.hpub+zip": {
			"source": "iana"
		},
		"application/prs.nprend": {
			"source": "iana"
		},
		"application/prs.plucker": {
			"source": "iana"
		},
		"application/prs.rdf-xml-crypt": {
			"source": "iana"
		},
		"application/prs.xsf+xml": {
			"source": "iana"
		},
		"application/pskc+xml": {
			"source": "iana",
			"extensions": [
				"pskcxml"
			]
		},
		"application/qsig": {
			"source": "iana"
		},
		"application/raptorfec": {
			"source": "iana"
		},
		"application/rdap+json": {
			"source": "iana",
			"compressible": true
		},
		"application/rdf+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"rdf"
			]
		},
		"application/reginfo+xml": {
			"source": "iana",
			"extensions": [
				"rif"
			]
		},
		"application/relax-ng-compact-syntax": {
			"source": "iana",
			"extensions": [
				"rnc"
			]
		},
		"application/remote-printing": {
			"source": "iana"
		},
		"application/reputon+json": {
			"source": "iana",
			"compressible": true
		},
		"application/resource-lists+xml": {
			"source": "iana",
			"extensions": [
				"rl"
			]
		},
		"application/resource-lists-diff+xml": {
			"source": "iana",
			"extensions": [
				"rld"
			]
		},
		"application/rfc+xml": {
			"source": "iana"
		},
		"application/riscos": {
			"source": "iana"
		},
		"application/rlmi+xml": {
			"source": "iana"
		},
		"application/rls-services+xml": {
			"source": "iana",
			"extensions": [
				"rs"
			]
		},
		"application/rpki-ghostbusters": {
			"source": "iana",
			"extensions": [
				"gbr"
			]
		},
		"application/rpki-manifest": {
			"source": "iana",
			"extensions": [
				"mft"
			]
		},
		"application/rpki-roa": {
			"source": "iana",
			"extensions": [
				"roa"
			]
		},
		"application/rpki-updown": {
			"source": "iana"
		},
		"application/rsd+xml": {
			"source": "apache",
			"extensions": [
				"rsd"
			]
		},
		"application/rss+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": [
				"rss"
			]
		},
		"application/rtf": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"rtf"
			]
		},
		"application/rtploopback": {
			"source": "iana"
		},
		"application/rtx": {
			"source": "iana"
		},
		"application/samlassertion+xml": {
			"source": "iana"
		},
		"application/samlmetadata+xml": {
			"source": "iana"
		},
		"application/sbml+xml": {
			"source": "iana",
			"extensions": [
				"sbml"
			]
		},
		"application/scaip+xml": {
			"source": "iana"
		},
		"application/scim+json": {
			"source": "iana",
			"compressible": true
		},
		"application/scvp-cv-request": {
			"source": "iana",
			"extensions": [
				"scq"
			]
		},
		"application/scvp-cv-response": {
			"source": "iana",
			"extensions": [
				"scs"
			]
		},
		"application/scvp-vp-request": {
			"source": "iana",
			"extensions": [
				"spq"
			]
		},
		"application/scvp-vp-response": {
			"source": "iana",
			"extensions": [
				"spp"
			]
		},
		"application/sdp": {
			"source": "iana",
			"extensions": [
				"sdp"
			]
		},
		"application/sep+xml": {
			"source": "iana"
		},
		"application/sep-exi": {
			"source": "iana"
		},
		"application/session-info": {
			"source": "iana"
		},
		"application/set-payment": {
			"source": "iana"
		},
		"application/set-payment-initiation": {
			"source": "iana",
			"extensions": [
				"setpay"
			]
		},
		"application/set-registration": {
			"source": "iana"
		},
		"application/set-registration-initiation": {
			"source": "iana",
			"extensions": [
				"setreg"
			]
		},
		"application/sgml": {
			"source": "iana"
		},
		"application/sgml-open-catalog": {
			"source": "iana"
		},
		"application/shf+xml": {
			"source": "iana",
			"extensions": [
				"shf"
			]
		},
		"application/sieve": {
			"source": "iana"
		},
		"application/simple-filter+xml": {
			"source": "iana"
		},
		"application/simple-message-summary": {
			"source": "iana"
		},
		"application/simplesymbolcontainer": {
			"source": "iana"
		},
		"application/slate": {
			"source": "iana"
		},
		"application/smil": {
			"source": "iana"
		},
		"application/smil+xml": {
			"source": "iana",
			"extensions": [
				"smi",
				"smil"
			]
		},
		"application/smpte336m": {
			"source": "iana"
		},
		"application/soap+fastinfoset": {
			"source": "iana"
		},
		"application/soap+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/sparql-query": {
			"source": "iana",
			"extensions": [
				"rq"
			]
		},
		"application/sparql-results+xml": {
			"source": "iana",
			"extensions": [
				"srx"
			]
		},
		"application/spirits-event+xml": {
			"source": "iana"
		},
		"application/sql": {
			"source": "iana"
		},
		"application/srgs": {
			"source": "iana",
			"extensions": [
				"gram"
			]
		},
		"application/srgs+xml": {
			"source": "iana",
			"extensions": [
				"grxml"
			]
		},
		"application/sru+xml": {
			"source": "iana",
			"extensions": [
				"sru"
			]
		},
		"application/ssdl+xml": {
			"source": "apache",
			"extensions": [
				"ssdl"
			]
		},
		"application/ssml+xml": {
			"source": "iana",
			"extensions": [
				"ssml"
			]
		},
		"application/tamp-apex-update": {
			"source": "iana"
		},
		"application/tamp-apex-update-confirm": {
			"source": "iana"
		},
		"application/tamp-community-update": {
			"source": "iana"
		},
		"application/tamp-community-update-confirm": {
			"source": "iana"
		},
		"application/tamp-error": {
			"source": "iana"
		},
		"application/tamp-sequence-adjust": {
			"source": "iana"
		},
		"application/tamp-sequence-adjust-confirm": {
			"source": "iana"
		},
		"application/tamp-status-query": {
			"source": "iana"
		},
		"application/tamp-status-response": {
			"source": "iana"
		},
		"application/tamp-update": {
			"source": "iana"
		},
		"application/tamp-update-confirm": {
			"source": "iana"
		},
		"application/tar": {
			"compressible": true
		},
		"application/tei+xml": {
			"source": "iana",
			"extensions": [
				"tei",
				"teicorpus"
			]
		},
		"application/thraud+xml": {
			"source": "iana",
			"extensions": [
				"tfi"
			]
		},
		"application/timestamp-query": {
			"source": "iana"
		},
		"application/timestamp-reply": {
			"source": "iana"
		},
		"application/timestamped-data": {
			"source": "iana",
			"extensions": [
				"tsd"
			]
		},
		"application/ttml+xml": {
			"source": "iana"
		},
		"application/tve-trigger": {
			"source": "iana"
		},
		"application/ulpfec": {
			"source": "iana"
		},
		"application/urc-grpsheet+xml": {
			"source": "iana"
		},
		"application/urc-ressheet+xml": {
			"source": "iana"
		},
		"application/urc-targetdesc+xml": {
			"source": "iana"
		},
		"application/urc-uisocketdesc+xml": {
			"source": "iana"
		},
		"application/vcard+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vcard+xml": {
			"source": "iana"
		},
		"application/vemmi": {
			"source": "iana"
		},
		"application/vividence.scriptfile": {
			"source": "apache"
		},
		"application/vnd.3gpp-prose+xml": {
			"source": "iana"
		},
		"application/vnd.3gpp-prose-pc3ch+xml": {
			"source": "iana"
		},
		"application/vnd.3gpp.access-transfer-events+xml": {
			"source": "iana"
		},
		"application/vnd.3gpp.bsf+xml": {
			"source": "iana"
		},
		"application/vnd.3gpp.mid-call+xml": {
			"source": "iana"
		},
		"application/vnd.3gpp.pic-bw-large": {
			"source": "iana",
			"extensions": [
				"plb"
			]
		},
		"application/vnd.3gpp.pic-bw-small": {
			"source": "iana",
			"extensions": [
				"psb"
			]
		},
		"application/vnd.3gpp.pic-bw-var": {
			"source": "iana",
			"extensions": [
				"pvb"
			]
		},
		"application/vnd.3gpp.sms": {
			"source": "iana"
		},
		"application/vnd.3gpp.sms+xml": {
			"source": "iana"
		},
		"application/vnd.3gpp.srvcc-ext+xml": {
			"source": "iana"
		},
		"application/vnd.3gpp.srvcc-info+xml": {
			"source": "iana"
		},
		"application/vnd.3gpp.state-and-event-info+xml": {
			"source": "iana"
		},
		"application/vnd.3gpp.ussd+xml": {
			"source": "iana"
		},
		"application/vnd.3gpp2.bcmcsinfo+xml": {
			"source": "iana"
		},
		"application/vnd.3gpp2.sms": {
			"source": "iana"
		},
		"application/vnd.3gpp2.tcap": {
			"source": "iana",
			"extensions": [
				"tcap"
			]
		},
		"application/vnd.3lightssoftware.imagescal": {
			"source": "iana"
		},
		"application/vnd.3m.post-it-notes": {
			"source": "iana",
			"extensions": [
				"pwn"
			]
		},
		"application/vnd.accpac.simply.aso": {
			"source": "iana",
			"extensions": [
				"aso"
			]
		},
		"application/vnd.accpac.simply.imp": {
			"source": "iana",
			"extensions": [
				"imp"
			]
		},
		"application/vnd.acucobol": {
			"source": "iana",
			"extensions": [
				"acu"
			]
		},
		"application/vnd.acucorp": {
			"source": "iana",
			"extensions": [
				"atc",
				"acutc"
			]
		},
		"application/vnd.adobe.air-application-installer-package+zip": {
			"source": "apache",
			"extensions": [
				"air"
			]
		},
		"application/vnd.adobe.flash.movie": {
			"source": "iana"
		},
		"application/vnd.adobe.formscentral.fcdt": {
			"source": "iana",
			"extensions": [
				"fcdt"
			]
		},
		"application/vnd.adobe.fxp": {
			"source": "iana",
			"extensions": [
				"fxp",
				"fxpl"
			]
		},
		"application/vnd.adobe.partial-upload": {
			"source": "iana"
		},
		"application/vnd.adobe.xdp+xml": {
			"source": "iana",
			"extensions": [
				"xdp"
			]
		},
		"application/vnd.adobe.xfdf": {
			"source": "iana",
			"extensions": [
				"xfdf"
			]
		},
		"application/vnd.aether.imp": {
			"source": "iana"
		},
		"application/vnd.ah-barcode": {
			"source": "iana"
		},
		"application/vnd.ahead.space": {
			"source": "iana",
			"extensions": [
				"ahead"
			]
		},
		"application/vnd.airzip.filesecure.azf": {
			"source": "iana",
			"extensions": [
				"azf"
			]
		},
		"application/vnd.airzip.filesecure.azs": {
			"source": "iana",
			"extensions": [
				"azs"
			]
		},
		"application/vnd.amazon.ebook": {
			"source": "apache",
			"extensions": [
				"azw"
			]
		},
		"application/vnd.amazon.mobi8-ebook": {
			"source": "iana"
		},
		"application/vnd.americandynamics.acc": {
			"source": "iana",
			"extensions": [
				"acc"
			]
		},
		"application/vnd.amiga.ami": {
			"source": "iana",
			"extensions": [
				"ami"
			]
		},
		"application/vnd.amundsen.maze+xml": {
			"source": "iana"
		},
		"application/vnd.android.package-archive": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"apk"
			]
		},
		"application/vnd.anki": {
			"source": "iana"
		},
		"application/vnd.anser-web-certificate-issue-initiation": {
			"source": "iana",
			"extensions": [
				"cii"
			]
		},
		"application/vnd.anser-web-funds-transfer-initiation": {
			"source": "apache",
			"extensions": [
				"fti"
			]
		},
		"application/vnd.antix.game-component": {
			"source": "iana",
			"extensions": [
				"atx"
			]
		},
		"application/vnd.apache.thrift.binary": {
			"source": "iana"
		},
		"application/vnd.apache.thrift.compact": {
			"source": "iana"
		},
		"application/vnd.apache.thrift.json": {
			"source": "iana"
		},
		"application/vnd.api+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.apple.installer+xml": {
			"source": "iana",
			"extensions": [
				"mpkg"
			]
		},
		"application/vnd.apple.mpegurl": {
			"source": "iana",
			"extensions": [
				"m3u8"
			]
		},
		"application/vnd.apple.pkpass": {
			"compressible": false,
			"extensions": [
				"pkpass"
			]
		},
		"application/vnd.arastra.swi": {
			"source": "iana"
		},
		"application/vnd.aristanetworks.swi": {
			"source": "iana",
			"extensions": [
				"swi"
			]
		},
		"application/vnd.artsquare": {
			"source": "iana"
		},
		"application/vnd.astraea-software.iota": {
			"source": "iana",
			"extensions": [
				"iota"
			]
		},
		"application/vnd.audiograph": {
			"source": "iana",
			"extensions": [
				"aep"
			]
		},
		"application/vnd.autopackage": {
			"source": "iana"
		},
		"application/vnd.avistar+xml": {
			"source": "iana"
		},
		"application/vnd.balsamiq.bmml+xml": {
			"source": "iana"
		},
		"application/vnd.balsamiq.bmpr": {
			"source": "iana"
		},
		"application/vnd.bekitzur-stech+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.biopax.rdf+xml": {
			"source": "iana"
		},
		"application/vnd.blueice.multipass": {
			"source": "iana",
			"extensions": [
				"mpm"
			]
		},
		"application/vnd.bluetooth.ep.oob": {
			"source": "iana"
		},
		"application/vnd.bluetooth.le.oob": {
			"source": "iana"
		},
		"application/vnd.bmi": {
			"source": "iana",
			"extensions": [
				"bmi"
			]
		},
		"application/vnd.businessobjects": {
			"source": "iana",
			"extensions": [
				"rep"
			]
		},
		"application/vnd.cab-jscript": {
			"source": "iana"
		},
		"application/vnd.canon-cpdl": {
			"source": "iana"
		},
		"application/vnd.canon-lips": {
			"source": "iana"
		},
		"application/vnd.cendio.thinlinc.clientconf": {
			"source": "iana"
		},
		"application/vnd.century-systems.tcp_stream": {
			"source": "iana"
		},
		"application/vnd.chemdraw+xml": {
			"source": "iana",
			"extensions": [
				"cdxml"
			]
		},
		"application/vnd.chess-pgn": {
			"source": "iana"
		},
		"application/vnd.chipnuts.karaoke-mmd": {
			"source": "iana",
			"extensions": [
				"mmd"
			]
		},
		"application/vnd.cinderella": {
			"source": "iana",
			"extensions": [
				"cdy"
			]
		},
		"application/vnd.cirpack.isdn-ext": {
			"source": "iana"
		},
		"application/vnd.citationstyles.style+xml": {
			"source": "iana"
		},
		"application/vnd.claymore": {
			"source": "iana",
			"extensions": [
				"cla"
			]
		},
		"application/vnd.cloanto.rp9": {
			"source": "iana",
			"extensions": [
				"rp9"
			]
		},
		"application/vnd.clonk.c4group": {
			"source": "iana",
			"extensions": [
				"c4g",
				"c4d",
				"c4f",
				"c4p",
				"c4u"
			]
		},
		"application/vnd.cluetrust.cartomobile-config": {
			"source": "iana",
			"extensions": [
				"c11amc"
			]
		},
		"application/vnd.cluetrust.cartomobile-config-pkg": {
			"source": "iana",
			"extensions": [
				"c11amz"
			]
		},
		"application/vnd.coffeescript": {
			"source": "iana"
		},
		"application/vnd.collection+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.collection.doc+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.collection.next+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.comicbook+zip": {
			"source": "iana"
		},
		"application/vnd.commerce-battelle": {
			"source": "iana"
		},
		"application/vnd.commonspace": {
			"source": "iana",
			"extensions": [
				"csp"
			]
		},
		"application/vnd.contact.cmsg": {
			"source": "iana",
			"extensions": [
				"cdbcmsg"
			]
		},
		"application/vnd.coreos.ignition+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.cosmocaller": {
			"source": "iana",
			"extensions": [
				"cmc"
			]
		},
		"application/vnd.crick.clicker": {
			"source": "iana",
			"extensions": [
				"clkx"
			]
		},
		"application/vnd.crick.clicker.keyboard": {
			"source": "iana",
			"extensions": [
				"clkk"
			]
		},
		"application/vnd.crick.clicker.palette": {
			"source": "iana",
			"extensions": [
				"clkp"
			]
		},
		"application/vnd.crick.clicker.template": {
			"source": "iana",
			"extensions": [
				"clkt"
			]
		},
		"application/vnd.crick.clicker.wordbank": {
			"source": "iana",
			"extensions": [
				"clkw"
			]
		},
		"application/vnd.criticaltools.wbs+xml": {
			"source": "iana",
			"extensions": [
				"wbs"
			]
		},
		"application/vnd.ctc-posml": {
			"source": "iana",
			"extensions": [
				"pml"
			]
		},
		"application/vnd.ctct.ws+xml": {
			"source": "iana"
		},
		"application/vnd.cups-pdf": {
			"source": "iana"
		},
		"application/vnd.cups-postscript": {
			"source": "iana"
		},
		"application/vnd.cups-ppd": {
			"source": "iana",
			"extensions": [
				"ppd"
			]
		},
		"application/vnd.cups-raster": {
			"source": "iana"
		},
		"application/vnd.cups-raw": {
			"source": "iana"
		},
		"application/vnd.curl": {
			"source": "iana"
		},
		"application/vnd.curl.car": {
			"source": "apache",
			"extensions": [
				"car"
			]
		},
		"application/vnd.curl.pcurl": {
			"source": "apache",
			"extensions": [
				"pcurl"
			]
		},
		"application/vnd.cyan.dean.root+xml": {
			"source": "iana"
		},
		"application/vnd.cybank": {
			"source": "iana"
		},
		"application/vnd.d2l.coursepackage1p0+zip": {
			"source": "iana"
		},
		"application/vnd.dart": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"dart"
			]
		},
		"application/vnd.data-vision.rdz": {
			"source": "iana",
			"extensions": [
				"rdz"
			]
		},
		"application/vnd.debian.binary-package": {
			"source": "iana"
		},
		"application/vnd.dece.data": {
			"source": "iana",
			"extensions": [
				"uvf",
				"uvvf",
				"uvd",
				"uvvd"
			]
		},
		"application/vnd.dece.ttml+xml": {
			"source": "iana",
			"extensions": [
				"uvt",
				"uvvt"
			]
		},
		"application/vnd.dece.unspecified": {
			"source": "iana",
			"extensions": [
				"uvx",
				"uvvx"
			]
		},
		"application/vnd.dece.zip": {
			"source": "iana",
			"extensions": [
				"uvz",
				"uvvz"
			]
		},
		"application/vnd.denovo.fcselayout-link": {
			"source": "iana",
			"extensions": [
				"fe_launch"
			]
		},
		"application/vnd.desmume-movie": {
			"source": "iana"
		},
		"application/vnd.desmume.movie": {
			"source": "apache"
		},
		"application/vnd.dir-bi.plate-dl-nosuffix": {
			"source": "iana"
		},
		"application/vnd.dm.delegation+xml": {
			"source": "iana"
		},
		"application/vnd.dna": {
			"source": "iana",
			"extensions": [
				"dna"
			]
		},
		"application/vnd.document+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dolby.mlp": {
			"source": "apache",
			"extensions": [
				"mlp"
			]
		},
		"application/vnd.dolby.mobile.1": {
			"source": "iana"
		},
		"application/vnd.dolby.mobile.2": {
			"source": "iana"
		},
		"application/vnd.doremir.scorecloud-binary-document": {
			"source": "iana"
		},
		"application/vnd.dpgraph": {
			"source": "iana",
			"extensions": [
				"dpg"
			]
		},
		"application/vnd.dreamfactory": {
			"source": "iana",
			"extensions": [
				"dfac"
			]
		},
		"application/vnd.drive+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ds-keypoint": {
			"source": "apache",
			"extensions": [
				"kpxx"
			]
		},
		"application/vnd.dtg.local": {
			"source": "iana"
		},
		"application/vnd.dtg.local.flash": {
			"source": "iana"
		},
		"application/vnd.dtg.local.html": {
			"source": "iana"
		},
		"application/vnd.dvb.ait": {
			"source": "iana",
			"extensions": [
				"ait"
			]
		},
		"application/vnd.dvb.dvbj": {
			"source": "iana"
		},
		"application/vnd.dvb.esgcontainer": {
			"source": "iana"
		},
		"application/vnd.dvb.ipdcdftnotifaccess": {
			"source": "iana"
		},
		"application/vnd.dvb.ipdcesgaccess": {
			"source": "iana"
		},
		"application/vnd.dvb.ipdcesgaccess2": {
			"source": "iana"
		},
		"application/vnd.dvb.ipdcesgpdd": {
			"source": "iana"
		},
		"application/vnd.dvb.ipdcroaming": {
			"source": "iana"
		},
		"application/vnd.dvb.iptv.alfec-base": {
			"source": "iana"
		},
		"application/vnd.dvb.iptv.alfec-enhancement": {
			"source": "iana"
		},
		"application/vnd.dvb.notif-aggregate-root+xml": {
			"source": "iana"
		},
		"application/vnd.dvb.notif-container+xml": {
			"source": "iana"
		},
		"application/vnd.dvb.notif-generic+xml": {
			"source": "iana"
		},
		"application/vnd.dvb.notif-ia-msglist+xml": {
			"source": "iana"
		},
		"application/vnd.dvb.notif-ia-registration-request+xml": {
			"source": "iana"
		},
		"application/vnd.dvb.notif-ia-registration-response+xml": {
			"source": "iana"
		},
		"application/vnd.dvb.notif-init+xml": {
			"source": "iana"
		},
		"application/vnd.dvb.pfr": {
			"source": "iana"
		},
		"application/vnd.dvb.service": {
			"source": "iana",
			"extensions": [
				"svc"
			]
		},
		"application/vnd.dxr": {
			"source": "iana"
		},
		"application/vnd.dynageo": {
			"source": "iana",
			"extensions": [
				"geo"
			]
		},
		"application/vnd.dzr": {
			"source": "iana"
		},
		"application/vnd.easykaraoke.cdgdownload": {
			"source": "iana"
		},
		"application/vnd.ecdis-update": {
			"source": "iana"
		},
		"application/vnd.ecowin.chart": {
			"source": "iana",
			"extensions": [
				"mag"
			]
		},
		"application/vnd.ecowin.filerequest": {
			"source": "iana"
		},
		"application/vnd.ecowin.fileupdate": {
			"source": "iana"
		},
		"application/vnd.ecowin.series": {
			"source": "iana"
		},
		"application/vnd.ecowin.seriesrequest": {
			"source": "iana"
		},
		"application/vnd.ecowin.seriesupdate": {
			"source": "iana"
		},
		"application/vnd.emclient.accessrequest+xml": {
			"source": "iana"
		},
		"application/vnd.enliven": {
			"source": "iana",
			"extensions": [
				"nml"
			]
		},
		"application/vnd.enphase.envoy": {
			"source": "iana"
		},
		"application/vnd.eprints.data+xml": {
			"source": "iana"
		},
		"application/vnd.epson.esf": {
			"source": "iana",
			"extensions": [
				"esf"
			]
		},
		"application/vnd.epson.msf": {
			"source": "iana",
			"extensions": [
				"msf"
			]
		},
		"application/vnd.epson.quickanime": {
			"source": "iana",
			"extensions": [
				"qam"
			]
		},
		"application/vnd.epson.salt": {
			"source": "iana",
			"extensions": [
				"slt"
			]
		},
		"application/vnd.epson.ssf": {
			"source": "iana",
			"extensions": [
				"ssf"
			]
		},
		"application/vnd.ericsson.quickcall": {
			"source": "iana"
		},
		"application/vnd.espass-espass+zip": {
			"source": "iana"
		},
		"application/vnd.eszigno3+xml": {
			"source": "iana",
			"extensions": [
				"es3",
				"et3"
			]
		},
		"application/vnd.etsi.aoc+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.asic-e+zip": {
			"source": "iana"
		},
		"application/vnd.etsi.asic-s+zip": {
			"source": "iana"
		},
		"application/vnd.etsi.cug+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.iptvcommand+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.iptvdiscovery+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.iptvprofile+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.iptvsad-bc+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.iptvsad-cod+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.iptvsad-npvr+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.iptvservice+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.iptvsync+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.iptvueprofile+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.mcid+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.mheg5": {
			"source": "iana"
		},
		"application/vnd.etsi.overload-control-policy-dataset+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.pstn+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.sci+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.simservs+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.timestamp-token": {
			"source": "iana"
		},
		"application/vnd.etsi.tsl+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.tsl.der": {
			"source": "iana"
		},
		"application/vnd.eudora.data": {
			"source": "iana"
		},
		"application/vnd.ezpix-album": {
			"source": "iana",
			"extensions": [
				"ez2"
			]
		},
		"application/vnd.ezpix-package": {
			"source": "iana",
			"extensions": [
				"ez3"
			]
		},
		"application/vnd.f-secure.mobile": {
			"source": "iana"
		},
		"application/vnd.fastcopy-disk-image": {
			"source": "iana"
		},
		"application/vnd.fdf": {
			"source": "iana",
			"extensions": [
				"fdf"
			]
		},
		"application/vnd.fdsn.mseed": {
			"source": "iana",
			"extensions": [
				"mseed"
			]
		},
		"application/vnd.fdsn.seed": {
			"source": "iana",
			"extensions": [
				"seed",
				"dataless"
			]
		},
		"application/vnd.ffsns": {
			"source": "iana"
		},
		"application/vnd.filmit.zfc": {
			"source": "iana"
		},
		"application/vnd.fints": {
			"source": "iana"
		},
		"application/vnd.firemonkeys.cloudcell": {
			"source": "iana"
		},
		"application/vnd.flographit": {
			"source": "iana",
			"extensions": [
				"gph"
			]
		},
		"application/vnd.fluxtime.clip": {
			"source": "iana",
			"extensions": [
				"ftc"
			]
		},
		"application/vnd.font-fontforge-sfd": {
			"source": "iana"
		},
		"application/vnd.framemaker": {
			"source": "iana",
			"extensions": [
				"fm",
				"frame",
				"maker",
				"book"
			]
		},
		"application/vnd.frogans.fnc": {
			"source": "iana",
			"extensions": [
				"fnc"
			]
		},
		"application/vnd.frogans.ltf": {
			"source": "iana",
			"extensions": [
				"ltf"
			]
		},
		"application/vnd.fsc.weblaunch": {
			"source": "iana",
			"extensions": [
				"fsc"
			]
		},
		"application/vnd.fujitsu.oasys": {
			"source": "iana",
			"extensions": [
				"oas"
			]
		},
		"application/vnd.fujitsu.oasys2": {
			"source": "iana",
			"extensions": [
				"oa2"
			]
		},
		"application/vnd.fujitsu.oasys3": {
			"source": "iana",
			"extensions": [
				"oa3"
			]
		},
		"application/vnd.fujitsu.oasysgp": {
			"source": "iana",
			"extensions": [
				"fg5"
			]
		},
		"application/vnd.fujitsu.oasysprs": {
			"source": "iana",
			"extensions": [
				"bh2"
			]
		},
		"application/vnd.fujixerox.art-ex": {
			"source": "iana"
		},
		"application/vnd.fujixerox.art4": {
			"source": "iana"
		},
		"application/vnd.fujixerox.ddd": {
			"source": "iana",
			"extensions": [
				"ddd"
			]
		},
		"application/vnd.fujixerox.docuworks": {
			"source": "iana",
			"extensions": [
				"xdw"
			]
		},
		"application/vnd.fujixerox.docuworks.binder": {
			"source": "iana",
			"extensions": [
				"xbd"
			]
		},
		"application/vnd.fujixerox.docuworks.container": {
			"source": "iana"
		},
		"application/vnd.fujixerox.hbpl": {
			"source": "iana"
		},
		"application/vnd.fut-misnet": {
			"source": "iana"
		},
		"application/vnd.fuzzysheet": {
			"source": "iana",
			"extensions": [
				"fzs"
			]
		},
		"application/vnd.genomatix.tuxedo": {
			"source": "iana",
			"extensions": [
				"txd"
			]
		},
		"application/vnd.geo+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.geocube+xml": {
			"source": "iana"
		},
		"application/vnd.geogebra.file": {
			"source": "iana",
			"extensions": [
				"ggb"
			]
		},
		"application/vnd.geogebra.tool": {
			"source": "iana",
			"extensions": [
				"ggt"
			]
		},
		"application/vnd.geometry-explorer": {
			"source": "iana",
			"extensions": [
				"gex",
				"gre"
			]
		},
		"application/vnd.geonext": {
			"source": "iana",
			"extensions": [
				"gxt"
			]
		},
		"application/vnd.geoplan": {
			"source": "iana",
			"extensions": [
				"g2w"
			]
		},
		"application/vnd.geospace": {
			"source": "iana",
			"extensions": [
				"g3w"
			]
		},
		"application/vnd.gerber": {
			"source": "iana"
		},
		"application/vnd.globalplatform.card-content-mgt": {
			"source": "iana"
		},
		"application/vnd.globalplatform.card-content-mgt-response": {
			"source": "iana"
		},
		"application/vnd.gmx": {
			"source": "iana",
			"extensions": [
				"gmx"
			]
		},
		"application/vnd.google-apps.document": {
			"compressible": false,
			"extensions": [
				"gdoc"
			]
		},
		"application/vnd.google-apps.presentation": {
			"compressible": false,
			"extensions": [
				"gslides"
			]
		},
		"application/vnd.google-apps.spreadsheet": {
			"compressible": false,
			"extensions": [
				"gsheet"
			]
		},
		"application/vnd.google-earth.kml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"kml"
			]
		},
		"application/vnd.google-earth.kmz": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"kmz"
			]
		},
		"application/vnd.gov.sk.e-form+xml": {
			"source": "iana"
		},
		"application/vnd.gov.sk.e-form+zip": {
			"source": "iana"
		},
		"application/vnd.gov.sk.xmldatacontainer+xml": {
			"source": "iana"
		},
		"application/vnd.grafeq": {
			"source": "iana",
			"extensions": [
				"gqf",
				"gqs"
			]
		},
		"application/vnd.gridmp": {
			"source": "iana"
		},
		"application/vnd.groove-account": {
			"source": "iana",
			"extensions": [
				"gac"
			]
		},
		"application/vnd.groove-help": {
			"source": "iana",
			"extensions": [
				"ghf"
			]
		},
		"application/vnd.groove-identity-message": {
			"source": "iana",
			"extensions": [
				"gim"
			]
		},
		"application/vnd.groove-injector": {
			"source": "iana",
			"extensions": [
				"grv"
			]
		},
		"application/vnd.groove-tool-message": {
			"source": "iana",
			"extensions": [
				"gtm"
			]
		},
		"application/vnd.groove-tool-template": {
			"source": "iana",
			"extensions": [
				"tpl"
			]
		},
		"application/vnd.groove-vcard": {
			"source": "iana",
			"extensions": [
				"vcg"
			]
		},
		"application/vnd.hal+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hal+xml": {
			"source": "iana",
			"extensions": [
				"hal"
			]
		},
		"application/vnd.handheld-entertainment+xml": {
			"source": "iana",
			"extensions": [
				"zmm"
			]
		},
		"application/vnd.hbci": {
			"source": "iana",
			"extensions": [
				"hbci"
			]
		},
		"application/vnd.hcl-bireports": {
			"source": "iana"
		},
		"application/vnd.hdt": {
			"source": "iana"
		},
		"application/vnd.heroku+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hhe.lesson-player": {
			"source": "iana",
			"extensions": [
				"les"
			]
		},
		"application/vnd.hp-hpgl": {
			"source": "iana",
			"extensions": [
				"hpgl"
			]
		},
		"application/vnd.hp-hpid": {
			"source": "iana",
			"extensions": [
				"hpid"
			]
		},
		"application/vnd.hp-hps": {
			"source": "iana",
			"extensions": [
				"hps"
			]
		},
		"application/vnd.hp-jlyt": {
			"source": "iana",
			"extensions": [
				"jlt"
			]
		},
		"application/vnd.hp-pcl": {
			"source": "iana",
			"extensions": [
				"pcl"
			]
		},
		"application/vnd.hp-pclxl": {
			"source": "iana",
			"extensions": [
				"pclxl"
			]
		},
		"application/vnd.httphone": {
			"source": "iana"
		},
		"application/vnd.hydrostatix.sof-data": {
			"source": "iana",
			"extensions": [
				"sfd-hdstx"
			]
		},
		"application/vnd.hyperdrive+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hzn-3d-crossword": {
			"source": "iana"
		},
		"application/vnd.ibm.afplinedata": {
			"source": "iana"
		},
		"application/vnd.ibm.electronic-media": {
			"source": "iana"
		},
		"application/vnd.ibm.minipay": {
			"source": "iana",
			"extensions": [
				"mpy"
			]
		},
		"application/vnd.ibm.modcap": {
			"source": "iana",
			"extensions": [
				"afp",
				"listafp",
				"list3820"
			]
		},
		"application/vnd.ibm.rights-management": {
			"source": "iana",
			"extensions": [
				"irm"
			]
		},
		"application/vnd.ibm.secure-container": {
			"source": "iana",
			"extensions": [
				"sc"
			]
		},
		"application/vnd.iccprofile": {
			"source": "iana",
			"extensions": [
				"icc",
				"icm"
			]
		},
		"application/vnd.ieee.1905": {
			"source": "iana"
		},
		"application/vnd.igloader": {
			"source": "iana",
			"extensions": [
				"igl"
			]
		},
		"application/vnd.immervision-ivp": {
			"source": "iana",
			"extensions": [
				"ivp"
			]
		},
		"application/vnd.immervision-ivu": {
			"source": "iana",
			"extensions": [
				"ivu"
			]
		},
		"application/vnd.ims.imsccv1p1": {
			"source": "iana"
		},
		"application/vnd.ims.imsccv1p2": {
			"source": "iana"
		},
		"application/vnd.ims.imsccv1p3": {
			"source": "iana"
		},
		"application/vnd.ims.lis.v2.result+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolconsumerprofile+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolproxy+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolproxy.id+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolsettings+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolsettings.simple+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.informedcontrol.rms+xml": {
			"source": "iana"
		},
		"application/vnd.informix-visionary": {
			"source": "iana"
		},
		"application/vnd.infotech.project": {
			"source": "iana"
		},
		"application/vnd.infotech.project+xml": {
			"source": "iana"
		},
		"application/vnd.innopath.wamp.notification": {
			"source": "iana"
		},
		"application/vnd.insors.igm": {
			"source": "iana",
			"extensions": [
				"igm"
			]
		},
		"application/vnd.intercon.formnet": {
			"source": "iana",
			"extensions": [
				"xpw",
				"xpx"
			]
		},
		"application/vnd.intergeo": {
			"source": "iana",
			"extensions": [
				"i2g"
			]
		},
		"application/vnd.intertrust.digibox": {
			"source": "iana"
		},
		"application/vnd.intertrust.nncp": {
			"source": "iana"
		},
		"application/vnd.intu.qbo": {
			"source": "iana",
			"extensions": [
				"qbo"
			]
		},
		"application/vnd.intu.qfx": {
			"source": "iana",
			"extensions": [
				"qfx"
			]
		},
		"application/vnd.iptc.g2.catalogitem+xml": {
			"source": "iana"
		},
		"application/vnd.iptc.g2.conceptitem+xml": {
			"source": "iana"
		},
		"application/vnd.iptc.g2.knowledgeitem+xml": {
			"source": "iana"
		},
		"application/vnd.iptc.g2.newsitem+xml": {
			"source": "iana"
		},
		"application/vnd.iptc.g2.newsmessage+xml": {
			"source": "iana"
		},
		"application/vnd.iptc.g2.packageitem+xml": {
			"source": "iana"
		},
		"application/vnd.iptc.g2.planningitem+xml": {
			"source": "iana"
		},
		"application/vnd.ipunplugged.rcprofile": {
			"source": "iana",
			"extensions": [
				"rcprofile"
			]
		},
		"application/vnd.irepository.package+xml": {
			"source": "iana",
			"extensions": [
				"irp"
			]
		},
		"application/vnd.is-xpr": {
			"source": "iana",
			"extensions": [
				"xpr"
			]
		},
		"application/vnd.isac.fcs": {
			"source": "iana",
			"extensions": [
				"fcs"
			]
		},
		"application/vnd.jam": {
			"source": "iana",
			"extensions": [
				"jam"
			]
		},
		"application/vnd.japannet-directory-service": {
			"source": "iana"
		},
		"application/vnd.japannet-jpnstore-wakeup": {
			"source": "iana"
		},
		"application/vnd.japannet-payment-wakeup": {
			"source": "iana"
		},
		"application/vnd.japannet-registration": {
			"source": "iana"
		},
		"application/vnd.japannet-registration-wakeup": {
			"source": "iana"
		},
		"application/vnd.japannet-setstore-wakeup": {
			"source": "iana"
		},
		"application/vnd.japannet-verification": {
			"source": "iana"
		},
		"application/vnd.japannet-verification-wakeup": {
			"source": "iana"
		},
		"application/vnd.jcp.javame.midlet-rms": {
			"source": "iana",
			"extensions": [
				"rms"
			]
		},
		"application/vnd.jisp": {
			"source": "iana",
			"extensions": [
				"jisp"
			]
		},
		"application/vnd.joost.joda-archive": {
			"source": "iana",
			"extensions": [
				"joda"
			]
		},
		"application/vnd.jsk.isdn-ngn": {
			"source": "iana"
		},
		"application/vnd.kahootz": {
			"source": "iana",
			"extensions": [
				"ktz",
				"ktr"
			]
		},
		"application/vnd.kde.karbon": {
			"source": "iana",
			"extensions": [
				"karbon"
			]
		},
		"application/vnd.kde.kchart": {
			"source": "iana",
			"extensions": [
				"chrt"
			]
		},
		"application/vnd.kde.kformula": {
			"source": "iana",
			"extensions": [
				"kfo"
			]
		},
		"application/vnd.kde.kivio": {
			"source": "iana",
			"extensions": [
				"flw"
			]
		},
		"application/vnd.kde.kontour": {
			"source": "iana",
			"extensions": [
				"kon"
			]
		},
		"application/vnd.kde.kpresenter": {
			"source": "iana",
			"extensions": [
				"kpr",
				"kpt"
			]
		},
		"application/vnd.kde.kspread": {
			"source": "iana",
			"extensions": [
				"ksp"
			]
		},
		"application/vnd.kde.kword": {
			"source": "iana",
			"extensions": [
				"kwd",
				"kwt"
			]
		},
		"application/vnd.kenameaapp": {
			"source": "iana",
			"extensions": [
				"htke"
			]
		},
		"application/vnd.kidspiration": {
			"source": "iana",
			"extensions": [
				"kia"
			]
		},
		"application/vnd.kinar": {
			"source": "iana",
			"extensions": [
				"kne",
				"knp"
			]
		},
		"application/vnd.koan": {
			"source": "iana",
			"extensions": [
				"skp",
				"skd",
				"skt",
				"skm"
			]
		},
		"application/vnd.kodak-descriptor": {
			"source": "iana",
			"extensions": [
				"sse"
			]
		},
		"application/vnd.las.las+xml": {
			"source": "iana",
			"extensions": [
				"lasxml"
			]
		},
		"application/vnd.liberty-request+xml": {
			"source": "iana"
		},
		"application/vnd.llamagraphics.life-balance.desktop": {
			"source": "iana",
			"extensions": [
				"lbd"
			]
		},
		"application/vnd.llamagraphics.life-balance.exchange+xml": {
			"source": "iana",
			"extensions": [
				"lbe"
			]
		},
		"application/vnd.lotus-1-2-3": {
			"source": "iana",
			"extensions": [
				"123"
			]
		},
		"application/vnd.lotus-approach": {
			"source": "iana",
			"extensions": [
				"apr"
			]
		},
		"application/vnd.lotus-freelance": {
			"source": "iana",
			"extensions": [
				"pre"
			]
		},
		"application/vnd.lotus-notes": {
			"source": "iana",
			"extensions": [
				"nsf"
			]
		},
		"application/vnd.lotus-organizer": {
			"source": "iana",
			"extensions": [
				"org"
			]
		},
		"application/vnd.lotus-screencam": {
			"source": "iana",
			"extensions": [
				"scm"
			]
		},
		"application/vnd.lotus-wordpro": {
			"source": "iana",
			"extensions": [
				"lwp"
			]
		},
		"application/vnd.macports.portpkg": {
			"source": "iana",
			"extensions": [
				"portpkg"
			]
		},
		"application/vnd.mapbox-vector-tile": {
			"source": "iana"
		},
		"application/vnd.marlin.drm.actiontoken+xml": {
			"source": "iana"
		},
		"application/vnd.marlin.drm.conftoken+xml": {
			"source": "iana"
		},
		"application/vnd.marlin.drm.license+xml": {
			"source": "iana"
		},
		"application/vnd.marlin.drm.mdcf": {
			"source": "iana"
		},
		"application/vnd.mason+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.maxmind.maxmind-db": {
			"source": "iana"
		},
		"application/vnd.mcd": {
			"source": "iana",
			"extensions": [
				"mcd"
			]
		},
		"application/vnd.medcalcdata": {
			"source": "iana",
			"extensions": [
				"mc1"
			]
		},
		"application/vnd.mediastation.cdkey": {
			"source": "iana",
			"extensions": [
				"cdkey"
			]
		},
		"application/vnd.meridian-slingshot": {
			"source": "iana"
		},
		"application/vnd.mfer": {
			"source": "iana",
			"extensions": [
				"mwf"
			]
		},
		"application/vnd.mfmp": {
			"source": "iana",
			"extensions": [
				"mfm"
			]
		},
		"application/vnd.micro+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.micrografx.flo": {
			"source": "iana",
			"extensions": [
				"flo"
			]
		},
		"application/vnd.micrografx.igx": {
			"source": "iana",
			"extensions": [
				"igx"
			]
		},
		"application/vnd.microsoft.portable-executable": {
			"source": "iana"
		},
		"application/vnd.miele+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.mif": {
			"source": "iana",
			"extensions": [
				"mif"
			]
		},
		"application/vnd.minisoft-hp3000-save": {
			"source": "iana"
		},
		"application/vnd.mitsubishi.misty-guard.trustweb": {
			"source": "iana"
		},
		"application/vnd.mobius.daf": {
			"source": "iana",
			"extensions": [
				"daf"
			]
		},
		"application/vnd.mobius.dis": {
			"source": "iana",
			"extensions": [
				"dis"
			]
		},
		"application/vnd.mobius.mbk": {
			"source": "iana",
			"extensions": [
				"mbk"
			]
		},
		"application/vnd.mobius.mqy": {
			"source": "iana",
			"extensions": [
				"mqy"
			]
		},
		"application/vnd.mobius.msl": {
			"source": "iana",
			"extensions": [
				"msl"
			]
		},
		"application/vnd.mobius.plc": {
			"source": "iana",
			"extensions": [
				"plc"
			]
		},
		"application/vnd.mobius.txf": {
			"source": "iana",
			"extensions": [
				"txf"
			]
		},
		"application/vnd.mophun.application": {
			"source": "iana",
			"extensions": [
				"mpn"
			]
		},
		"application/vnd.mophun.certificate": {
			"source": "iana",
			"extensions": [
				"mpc"
			]
		},
		"application/vnd.motorola.flexsuite": {
			"source": "iana"
		},
		"application/vnd.motorola.flexsuite.adsi": {
			"source": "iana"
		},
		"application/vnd.motorola.flexsuite.fis": {
			"source": "iana"
		},
		"application/vnd.motorola.flexsuite.gotap": {
			"source": "iana"
		},
		"application/vnd.motorola.flexsuite.kmr": {
			"source": "iana"
		},
		"application/vnd.motorola.flexsuite.ttc": {
			"source": "iana"
		},
		"application/vnd.motorola.flexsuite.wem": {
			"source": "iana"
		},
		"application/vnd.motorola.iprm": {
			"source": "iana"
		},
		"application/vnd.mozilla.xul+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"xul"
			]
		},
		"application/vnd.ms-3mfdocument": {
			"source": "iana"
		},
		"application/vnd.ms-artgalry": {
			"source": "iana",
			"extensions": [
				"cil"
			]
		},
		"application/vnd.ms-asf": {
			"source": "iana"
		},
		"application/vnd.ms-cab-compressed": {
			"source": "iana",
			"extensions": [
				"cab"
			]
		},
		"application/vnd.ms-color.iccprofile": {
			"source": "apache"
		},
		"application/vnd.ms-excel": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"xls",
				"xlm",
				"xla",
				"xlc",
				"xlt",
				"xlw"
			]
		},
		"application/vnd.ms-excel.addin.macroenabled.12": {
			"source": "iana",
			"extensions": [
				"xlam"
			]
		},
		"application/vnd.ms-excel.sheet.binary.macroenabled.12": {
			"source": "iana",
			"extensions": [
				"xlsb"
			]
		},
		"application/vnd.ms-excel.sheet.macroenabled.12": {
			"source": "iana",
			"extensions": [
				"xlsm"
			]
		},
		"application/vnd.ms-excel.template.macroenabled.12": {
			"source": "iana",
			"extensions": [
				"xltm"
			]
		},
		"application/vnd.ms-fontobject": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"eot"
			]
		},
		"application/vnd.ms-htmlhelp": {
			"source": "iana",
			"extensions": [
				"chm"
			]
		},
		"application/vnd.ms-ims": {
			"source": "iana",
			"extensions": [
				"ims"
			]
		},
		"application/vnd.ms-lrm": {
			"source": "iana",
			"extensions": [
				"lrm"
			]
		},
		"application/vnd.ms-office.activex+xml": {
			"source": "iana"
		},
		"application/vnd.ms-officetheme": {
			"source": "iana",
			"extensions": [
				"thmx"
			]
		},
		"application/vnd.ms-opentype": {
			"source": "apache",
			"compressible": true
		},
		"application/vnd.ms-package.obfuscated-opentype": {
			"source": "apache"
		},
		"application/vnd.ms-pki.seccat": {
			"source": "apache",
			"extensions": [
				"cat"
			]
		},
		"application/vnd.ms-pki.stl": {
			"source": "apache",
			"extensions": [
				"stl"
			]
		},
		"application/vnd.ms-playready.initiator+xml": {
			"source": "iana"
		},
		"application/vnd.ms-powerpoint": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"ppt",
				"pps",
				"pot"
			]
		},
		"application/vnd.ms-powerpoint.addin.macroenabled.12": {
			"source": "iana",
			"extensions": [
				"ppam"
			]
		},
		"application/vnd.ms-powerpoint.presentation.macroenabled.12": {
			"source": "iana",
			"extensions": [
				"pptm"
			]
		},
		"application/vnd.ms-powerpoint.slide.macroenabled.12": {
			"source": "iana",
			"extensions": [
				"sldm"
			]
		},
		"application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
			"source": "iana",
			"extensions": [
				"ppsm"
			]
		},
		"application/vnd.ms-powerpoint.template.macroenabled.12": {
			"source": "iana",
			"extensions": [
				"potm"
			]
		},
		"application/vnd.ms-printdevicecapabilities+xml": {
			"source": "iana"
		},
		"application/vnd.ms-printing.printticket+xml": {
			"source": "apache"
		},
		"application/vnd.ms-printschematicket+xml": {
			"source": "iana"
		},
		"application/vnd.ms-project": {
			"source": "iana",
			"extensions": [
				"mpp",
				"mpt"
			]
		},
		"application/vnd.ms-tnef": {
			"source": "iana"
		},
		"application/vnd.ms-windows.devicepairing": {
			"source": "iana"
		},
		"application/vnd.ms-windows.nwprinting.oob": {
			"source": "iana"
		},
		"application/vnd.ms-windows.printerpairing": {
			"source": "iana"
		},
		"application/vnd.ms-windows.wsd.oob": {
			"source": "iana"
		},
		"application/vnd.ms-wmdrm.lic-chlg-req": {
			"source": "iana"
		},
		"application/vnd.ms-wmdrm.lic-resp": {
			"source": "iana"
		},
		"application/vnd.ms-wmdrm.meter-chlg-req": {
			"source": "iana"
		},
		"application/vnd.ms-wmdrm.meter-resp": {
			"source": "iana"
		},
		"application/vnd.ms-word.document.macroenabled.12": {
			"source": "iana",
			"extensions": [
				"docm"
			]
		},
		"application/vnd.ms-word.template.macroenabled.12": {
			"source": "iana",
			"extensions": [
				"dotm"
			]
		},
		"application/vnd.ms-works": {
			"source": "iana",
			"extensions": [
				"wps",
				"wks",
				"wcm",
				"wdb"
			]
		},
		"application/vnd.ms-wpl": {
			"source": "iana",
			"extensions": [
				"wpl"
			]
		},
		"application/vnd.ms-xpsdocument": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"xps"
			]
		},
		"application/vnd.msa-disk-image": {
			"source": "iana"
		},
		"application/vnd.mseq": {
			"source": "iana",
			"extensions": [
				"mseq"
			]
		},
		"application/vnd.msign": {
			"source": "iana"
		},
		"application/vnd.multiad.creator": {
			"source": "iana"
		},
		"application/vnd.multiad.creator.cif": {
			"source": "iana"
		},
		"application/vnd.music-niff": {
			"source": "iana"
		},
		"application/vnd.musician": {
			"source": "iana",
			"extensions": [
				"mus"
			]
		},
		"application/vnd.muvee.style": {
			"source": "iana",
			"extensions": [
				"msty"
			]
		},
		"application/vnd.mynfc": {
			"source": "iana",
			"extensions": [
				"taglet"
			]
		},
		"application/vnd.ncd.control": {
			"source": "iana"
		},
		"application/vnd.ncd.reference": {
			"source": "iana"
		},
		"application/vnd.nearst.inv+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.nervana": {
			"source": "iana"
		},
		"application/vnd.netfpx": {
			"source": "iana"
		},
		"application/vnd.neurolanguage.nlu": {
			"source": "iana",
			"extensions": [
				"nlu"
			]
		},
		"application/vnd.nintendo.nitro.rom": {
			"source": "iana"
		},
		"application/vnd.nintendo.snes.rom": {
			"source": "iana"
		},
		"application/vnd.nitf": {
			"source": "iana",
			"extensions": [
				"ntf",
				"nitf"
			]
		},
		"application/vnd.noblenet-directory": {
			"source": "iana",
			"extensions": [
				"nnd"
			]
		},
		"application/vnd.noblenet-sealer": {
			"source": "iana",
			"extensions": [
				"nns"
			]
		},
		"application/vnd.noblenet-web": {
			"source": "iana",
			"extensions": [
				"nnw"
			]
		},
		"application/vnd.nokia.catalogs": {
			"source": "iana"
		},
		"application/vnd.nokia.conml+wbxml": {
			"source": "iana"
		},
		"application/vnd.nokia.conml+xml": {
			"source": "iana"
		},
		"application/vnd.nokia.iptv.config+xml": {
			"source": "iana"
		},
		"application/vnd.nokia.isds-radio-presets": {
			"source": "iana"
		},
		"application/vnd.nokia.landmark+wbxml": {
			"source": "iana"
		},
		"application/vnd.nokia.landmark+xml": {
			"source": "iana"
		},
		"application/vnd.nokia.landmarkcollection+xml": {
			"source": "iana"
		},
		"application/vnd.nokia.n-gage.ac+xml": {
			"source": "iana"
		},
		"application/vnd.nokia.n-gage.data": {
			"source": "iana",
			"extensions": [
				"ngdat"
			]
		},
		"application/vnd.nokia.n-gage.symbian.install": {
			"source": "iana",
			"extensions": [
				"n-gage"
			]
		},
		"application/vnd.nokia.ncd": {
			"source": "iana"
		},
		"application/vnd.nokia.pcd+wbxml": {
			"source": "iana"
		},
		"application/vnd.nokia.pcd+xml": {
			"source": "iana"
		},
		"application/vnd.nokia.radio-preset": {
			"source": "iana",
			"extensions": [
				"rpst"
			]
		},
		"application/vnd.nokia.radio-presets": {
			"source": "iana",
			"extensions": [
				"rpss"
			]
		},
		"application/vnd.novadigm.edm": {
			"source": "iana",
			"extensions": [
				"edm"
			]
		},
		"application/vnd.novadigm.edx": {
			"source": "iana",
			"extensions": [
				"edx"
			]
		},
		"application/vnd.novadigm.ext": {
			"source": "iana",
			"extensions": [
				"ext"
			]
		},
		"application/vnd.ntt-local.content-share": {
			"source": "iana"
		},
		"application/vnd.ntt-local.file-transfer": {
			"source": "iana"
		},
		"application/vnd.ntt-local.ogw_remote-access": {
			"source": "iana"
		},
		"application/vnd.ntt-local.sip-ta_remote": {
			"source": "iana"
		},
		"application/vnd.ntt-local.sip-ta_tcp_stream": {
			"source": "iana"
		},
		"application/vnd.oasis.opendocument.chart": {
			"source": "iana",
			"extensions": [
				"odc"
			]
		},
		"application/vnd.oasis.opendocument.chart-template": {
			"source": "iana",
			"extensions": [
				"otc"
			]
		},
		"application/vnd.oasis.opendocument.database": {
			"source": "iana",
			"extensions": [
				"odb"
			]
		},
		"application/vnd.oasis.opendocument.formula": {
			"source": "iana",
			"extensions": [
				"odf"
			]
		},
		"application/vnd.oasis.opendocument.formula-template": {
			"source": "iana",
			"extensions": [
				"odft"
			]
		},
		"application/vnd.oasis.opendocument.graphics": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"odg"
			]
		},
		"application/vnd.oasis.opendocument.graphics-template": {
			"source": "iana",
			"extensions": [
				"otg"
			]
		},
		"application/vnd.oasis.opendocument.image": {
			"source": "iana",
			"extensions": [
				"odi"
			]
		},
		"application/vnd.oasis.opendocument.image-template": {
			"source": "iana",
			"extensions": [
				"oti"
			]
		},
		"application/vnd.oasis.opendocument.presentation": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"odp"
			]
		},
		"application/vnd.oasis.opendocument.presentation-template": {
			"source": "iana",
			"extensions": [
				"otp"
			]
		},
		"application/vnd.oasis.opendocument.spreadsheet": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"ods"
			]
		},
		"application/vnd.oasis.opendocument.spreadsheet-template": {
			"source": "iana",
			"extensions": [
				"ots"
			]
		},
		"application/vnd.oasis.opendocument.text": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"odt"
			]
		},
		"application/vnd.oasis.opendocument.text-master": {
			"source": "iana",
			"extensions": [
				"odm"
			]
		},
		"application/vnd.oasis.opendocument.text-template": {
			"source": "iana",
			"extensions": [
				"ott"
			]
		},
		"application/vnd.oasis.opendocument.text-web": {
			"source": "iana",
			"extensions": [
				"oth"
			]
		},
		"application/vnd.obn": {
			"source": "iana"
		},
		"application/vnd.oftn.l10n+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.contentaccessdownload+xml": {
			"source": "iana"
		},
		"application/vnd.oipf.contentaccessstreaming+xml": {
			"source": "iana"
		},
		"application/vnd.oipf.cspg-hexbinary": {
			"source": "iana"
		},
		"application/vnd.oipf.dae.svg+xml": {
			"source": "iana"
		},
		"application/vnd.oipf.dae.xhtml+xml": {
			"source": "iana"
		},
		"application/vnd.oipf.mippvcontrolmessage+xml": {
			"source": "iana"
		},
		"application/vnd.oipf.pae.gem": {
			"source": "iana"
		},
		"application/vnd.oipf.spdiscovery+xml": {
			"source": "iana"
		},
		"application/vnd.oipf.spdlist+xml": {
			"source": "iana"
		},
		"application/vnd.oipf.ueprofile+xml": {
			"source": "iana"
		},
		"application/vnd.oipf.userprofile+xml": {
			"source": "iana"
		},
		"application/vnd.olpc-sugar": {
			"source": "iana",
			"extensions": [
				"xo"
			]
		},
		"application/vnd.oma-scws-config": {
			"source": "iana"
		},
		"application/vnd.oma-scws-http-request": {
			"source": "iana"
		},
		"application/vnd.oma-scws-http-response": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.associated-procedure-parameter+xml": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.drm-trigger+xml": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.imd+xml": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.ltkm": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.notification+xml": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.provisioningtrigger": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.sgboot": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.sgdd+xml": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.sgdu": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.simple-symbol-container": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.smartcard-trigger+xml": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.sprov+xml": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.stkm": {
			"source": "iana"
		},
		"application/vnd.oma.cab-address-book+xml": {
			"source": "iana"
		},
		"application/vnd.oma.cab-feature-handler+xml": {
			"source": "iana"
		},
		"application/vnd.oma.cab-pcc+xml": {
			"source": "iana"
		},
		"application/vnd.oma.cab-subs-invite+xml": {
			"source": "iana"
		},
		"application/vnd.oma.cab-user-prefs+xml": {
			"source": "iana"
		},
		"application/vnd.oma.dcd": {
			"source": "iana"
		},
		"application/vnd.oma.dcdc": {
			"source": "iana"
		},
		"application/vnd.oma.dd2+xml": {
			"source": "iana",
			"extensions": [
				"dd2"
			]
		},
		"application/vnd.oma.drm.risd+xml": {
			"source": "iana"
		},
		"application/vnd.oma.group-usage-list+xml": {
			"source": "iana"
		},
		"application/vnd.oma.lwm2m+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.lwm2m+tlv": {
			"source": "iana"
		},
		"application/vnd.oma.pal+xml": {
			"source": "iana"
		},
		"application/vnd.oma.poc.detailed-progress-report+xml": {
			"source": "iana"
		},
		"application/vnd.oma.poc.final-report+xml": {
			"source": "iana"
		},
		"application/vnd.oma.poc.groups+xml": {
			"source": "iana"
		},
		"application/vnd.oma.poc.invocation-descriptor+xml": {
			"source": "iana"
		},
		"application/vnd.oma.poc.optimized-progress-report+xml": {
			"source": "iana"
		},
		"application/vnd.oma.push": {
			"source": "iana"
		},
		"application/vnd.oma.scidm.messages+xml": {
			"source": "iana"
		},
		"application/vnd.oma.xcap-directory+xml": {
			"source": "iana"
		},
		"application/vnd.omads-email+xml": {
			"source": "iana"
		},
		"application/vnd.omads-file+xml": {
			"source": "iana"
		},
		"application/vnd.omads-folder+xml": {
			"source": "iana"
		},
		"application/vnd.omaloc-supl-init": {
			"source": "iana"
		},
		"application/vnd.onepager": {
			"source": "iana"
		},
		"application/vnd.openblox.game+xml": {
			"source": "iana"
		},
		"application/vnd.openblox.game-binary": {
			"source": "iana"
		},
		"application/vnd.openeye.oeb": {
			"source": "iana"
		},
		"application/vnd.openofficeorg.extension": {
			"source": "apache",
			"extensions": [
				"oxt"
			]
		},
		"application/vnd.openxmlformats-officedocument.custom-properties+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.drawing+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.extended-properties+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml-template": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.presentation": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"pptx"
			]
		},
		"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slide": {
			"source": "iana",
			"extensions": [
				"sldx"
			]
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
			"source": "iana",
			"extensions": [
				"ppsx"
			]
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.template": {
			"source": "apache",
			"extensions": [
				"potx"
			]
		},
		"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml-template": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"xlsx"
			]
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
			"source": "apache",
			"extensions": [
				"xltx"
			]
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.theme+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.themeoverride+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.vmldrawing": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml-template": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"docx"
			]
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
			"source": "apache",
			"extensions": [
				"dotx"
			]
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-package.core-properties+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-package.relationships+xml": {
			"source": "iana"
		},
		"application/vnd.oracle.resource+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.orange.indata": {
			"source": "iana"
		},
		"application/vnd.osa.netdeploy": {
			"source": "iana"
		},
		"application/vnd.osgeo.mapguide.package": {
			"source": "iana",
			"extensions": [
				"mgp"
			]
		},
		"application/vnd.osgi.bundle": {
			"source": "iana"
		},
		"application/vnd.osgi.dp": {
			"source": "iana",
			"extensions": [
				"dp"
			]
		},
		"application/vnd.osgi.subsystem": {
			"source": "iana",
			"extensions": [
				"esa"
			]
		},
		"application/vnd.otps.ct-kip+xml": {
			"source": "iana"
		},
		"application/vnd.oxli.countgraph": {
			"source": "iana"
		},
		"application/vnd.pagerduty+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.palm": {
			"source": "iana",
			"extensions": [
				"pdb",
				"pqa",
				"oprc"
			]
		},
		"application/vnd.panoply": {
			"source": "iana"
		},
		"application/vnd.paos+xml": {
			"source": "iana"
		},
		"application/vnd.paos.xml": {
			"source": "apache"
		},
		"application/vnd.pawaafile": {
			"source": "iana",
			"extensions": [
				"paw"
			]
		},
		"application/vnd.pcos": {
			"source": "iana"
		},
		"application/vnd.pg.format": {
			"source": "iana",
			"extensions": [
				"str"
			]
		},
		"application/vnd.pg.osasli": {
			"source": "iana",
			"extensions": [
				"ei6"
			]
		},
		"application/vnd.piaccess.application-licence": {
			"source": "iana"
		},
		"application/vnd.picsel": {
			"source": "iana",
			"extensions": [
				"efif"
			]
		},
		"application/vnd.pmi.widget": {
			"source": "iana",
			"extensions": [
				"wg"
			]
		},
		"application/vnd.poc.group-advertisement+xml": {
			"source": "iana"
		},
		"application/vnd.pocketlearn": {
			"source": "iana",
			"extensions": [
				"plf"
			]
		},
		"application/vnd.powerbuilder6": {
			"source": "iana",
			"extensions": [
				"pbd"
			]
		},
		"application/vnd.powerbuilder6-s": {
			"source": "iana"
		},
		"application/vnd.powerbuilder7": {
			"source": "iana"
		},
		"application/vnd.powerbuilder7-s": {
			"source": "iana"
		},
		"application/vnd.powerbuilder75": {
			"source": "iana"
		},
		"application/vnd.powerbuilder75-s": {
			"source": "iana"
		},
		"application/vnd.preminet": {
			"source": "iana"
		},
		"application/vnd.previewsystems.box": {
			"source": "iana",
			"extensions": [
				"box"
			]
		},
		"application/vnd.proteus.magazine": {
			"source": "iana",
			"extensions": [
				"mgz"
			]
		},
		"application/vnd.publishare-delta-tree": {
			"source": "iana",
			"extensions": [
				"qps"
			]
		},
		"application/vnd.pvi.ptid1": {
			"source": "iana",
			"extensions": [
				"ptid"
			]
		},
		"application/vnd.pwg-multiplexed": {
			"source": "iana"
		},
		"application/vnd.pwg-xhtml-print+xml": {
			"source": "iana"
		},
		"application/vnd.qualcomm.brew-app-res": {
			"source": "iana"
		},
		"application/vnd.quarantainenet": {
			"source": "iana"
		},
		"application/vnd.quark.quarkxpress": {
			"source": "iana",
			"extensions": [
				"qxd",
				"qxt",
				"qwd",
				"qwt",
				"qxl",
				"qxb"
			]
		},
		"application/vnd.quobject-quoxdocument": {
			"source": "iana"
		},
		"application/vnd.radisys.moml+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-audit+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-audit-conf+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-audit-conn+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-audit-dialog+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-audit-stream+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-conf+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-dialog+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-dialog-base+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-dialog-fax-detect+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-dialog-group+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-dialog-speech+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-dialog-transform+xml": {
			"source": "iana"
		},
		"application/vnd.rainstor.data": {
			"source": "iana"
		},
		"application/vnd.rapid": {
			"source": "iana"
		},
		"application/vnd.rar": {
			"source": "iana"
		},
		"application/vnd.realvnc.bed": {
			"source": "iana",
			"extensions": [
				"bed"
			]
		},
		"application/vnd.recordare.musicxml": {
			"source": "iana",
			"extensions": [
				"mxl"
			]
		},
		"application/vnd.recordare.musicxml+xml": {
			"source": "iana",
			"extensions": [
				"musicxml"
			]
		},
		"application/vnd.renlearn.rlprint": {
			"source": "iana"
		},
		"application/vnd.rig.cryptonote": {
			"source": "iana",
			"extensions": [
				"cryptonote"
			]
		},
		"application/vnd.rim.cod": {
			"source": "apache",
			"extensions": [
				"cod"
			]
		},
		"application/vnd.rn-realmedia": {
			"source": "apache",
			"extensions": [
				"rm"
			]
		},
		"application/vnd.rn-realmedia-vbr": {
			"source": "apache",
			"extensions": [
				"rmvb"
			]
		},
		"application/vnd.route66.link66+xml": {
			"source": "iana",
			"extensions": [
				"link66"
			]
		},
		"application/vnd.rs-274x": {
			"source": "iana"
		},
		"application/vnd.ruckus.download": {
			"source": "iana"
		},
		"application/vnd.s3sms": {
			"source": "iana"
		},
		"application/vnd.sailingtracker.track": {
			"source": "iana",
			"extensions": [
				"st"
			]
		},
		"application/vnd.sbm.cid": {
			"source": "iana"
		},
		"application/vnd.sbm.mid2": {
			"source": "iana"
		},
		"application/vnd.scribus": {
			"source": "iana"
		},
		"application/vnd.sealed.3df": {
			"source": "iana"
		},
		"application/vnd.sealed.csf": {
			"source": "iana"
		},
		"application/vnd.sealed.doc": {
			"source": "iana"
		},
		"application/vnd.sealed.eml": {
			"source": "iana"
		},
		"application/vnd.sealed.mht": {
			"source": "iana"
		},
		"application/vnd.sealed.net": {
			"source": "iana"
		},
		"application/vnd.sealed.ppt": {
			"source": "iana"
		},
		"application/vnd.sealed.tiff": {
			"source": "iana"
		},
		"application/vnd.sealed.xls": {
			"source": "iana"
		},
		"application/vnd.sealedmedia.softseal.html": {
			"source": "iana"
		},
		"application/vnd.sealedmedia.softseal.pdf": {
			"source": "iana"
		},
		"application/vnd.seemail": {
			"source": "iana",
			"extensions": [
				"see"
			]
		},
		"application/vnd.sema": {
			"source": "iana",
			"extensions": [
				"sema"
			]
		},
		"application/vnd.semd": {
			"source": "iana",
			"extensions": [
				"semd"
			]
		},
		"application/vnd.semf": {
			"source": "iana",
			"extensions": [
				"semf"
			]
		},
		"application/vnd.shana.informed.formdata": {
			"source": "iana",
			"extensions": [
				"ifm"
			]
		},
		"application/vnd.shana.informed.formtemplate": {
			"source": "iana",
			"extensions": [
				"itp"
			]
		},
		"application/vnd.shana.informed.interchange": {
			"source": "iana",
			"extensions": [
				"iif"
			]
		},
		"application/vnd.shana.informed.package": {
			"source": "iana",
			"extensions": [
				"ipk"
			]
		},
		"application/vnd.simtech-mindmapper": {
			"source": "iana",
			"extensions": [
				"twd",
				"twds"
			]
		},
		"application/vnd.siren+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.smaf": {
			"source": "iana",
			"extensions": [
				"mmf"
			]
		},
		"application/vnd.smart.notebook": {
			"source": "iana"
		},
		"application/vnd.smart.teacher": {
			"source": "iana",
			"extensions": [
				"teacher"
			]
		},
		"application/vnd.software602.filler.form+xml": {
			"source": "iana"
		},
		"application/vnd.software602.filler.form-xml-zip": {
			"source": "iana"
		},
		"application/vnd.solent.sdkm+xml": {
			"source": "iana",
			"extensions": [
				"sdkm",
				"sdkd"
			]
		},
		"application/vnd.spotfire.dxp": {
			"source": "iana",
			"extensions": [
				"dxp"
			]
		},
		"application/vnd.spotfire.sfs": {
			"source": "iana",
			"extensions": [
				"sfs"
			]
		},
		"application/vnd.sss-cod": {
			"source": "iana"
		},
		"application/vnd.sss-dtf": {
			"source": "iana"
		},
		"application/vnd.sss-ntf": {
			"source": "iana"
		},
		"application/vnd.stardivision.calc": {
			"source": "apache",
			"extensions": [
				"sdc"
			]
		},
		"application/vnd.stardivision.draw": {
			"source": "apache",
			"extensions": [
				"sda"
			]
		},
		"application/vnd.stardivision.impress": {
			"source": "apache",
			"extensions": [
				"sdd"
			]
		},
		"application/vnd.stardivision.math": {
			"source": "apache",
			"extensions": [
				"smf"
			]
		},
		"application/vnd.stardivision.writer": {
			"source": "apache",
			"extensions": [
				"sdw",
				"vor"
			]
		},
		"application/vnd.stardivision.writer-global": {
			"source": "apache",
			"extensions": [
				"sgl"
			]
		},
		"application/vnd.stepmania.package": {
			"source": "iana",
			"extensions": [
				"smzip"
			]
		},
		"application/vnd.stepmania.stepchart": {
			"source": "iana",
			"extensions": [
				"sm"
			]
		},
		"application/vnd.street-stream": {
			"source": "iana"
		},
		"application/vnd.sun.wadl+xml": {
			"source": "iana"
		},
		"application/vnd.sun.xml.calc": {
			"source": "apache",
			"extensions": [
				"sxc"
			]
		},
		"application/vnd.sun.xml.calc.template": {
			"source": "apache",
			"extensions": [
				"stc"
			]
		},
		"application/vnd.sun.xml.draw": {
			"source": "apache",
			"extensions": [
				"sxd"
			]
		},
		"application/vnd.sun.xml.draw.template": {
			"source": "apache",
			"extensions": [
				"std"
			]
		},
		"application/vnd.sun.xml.impress": {
			"source": "apache",
			"extensions": [
				"sxi"
			]
		},
		"application/vnd.sun.xml.impress.template": {
			"source": "apache",
			"extensions": [
				"sti"
			]
		},
		"application/vnd.sun.xml.math": {
			"source": "apache",
			"extensions": [
				"sxm"
			]
		},
		"application/vnd.sun.xml.writer": {
			"source": "apache",
			"extensions": [
				"sxw"
			]
		},
		"application/vnd.sun.xml.writer.global": {
			"source": "apache",
			"extensions": [
				"sxg"
			]
		},
		"application/vnd.sun.xml.writer.template": {
			"source": "apache",
			"extensions": [
				"stw"
			]
		},
		"application/vnd.sus-calendar": {
			"source": "iana",
			"extensions": [
				"sus",
				"susp"
			]
		},
		"application/vnd.svd": {
			"source": "iana",
			"extensions": [
				"svd"
			]
		},
		"application/vnd.swiftview-ics": {
			"source": "iana"
		},
		"application/vnd.symbian.install": {
			"source": "apache",
			"extensions": [
				"sis",
				"sisx"
			]
		},
		"application/vnd.syncml+xml": {
			"source": "iana",
			"extensions": [
				"xsm"
			]
		},
		"application/vnd.syncml.dm+wbxml": {
			"source": "iana",
			"extensions": [
				"bdm"
			]
		},
		"application/vnd.syncml.dm+xml": {
			"source": "iana",
			"extensions": [
				"xdm"
			]
		},
		"application/vnd.syncml.dm.notification": {
			"source": "iana"
		},
		"application/vnd.syncml.dmddf+wbxml": {
			"source": "iana"
		},
		"application/vnd.syncml.dmddf+xml": {
			"source": "iana"
		},
		"application/vnd.syncml.dmtnds+wbxml": {
			"source": "iana"
		},
		"application/vnd.syncml.dmtnds+xml": {
			"source": "iana"
		},
		"application/vnd.syncml.ds.notification": {
			"source": "iana"
		},
		"application/vnd.tao.intent-module-archive": {
			"source": "iana",
			"extensions": [
				"tao"
			]
		},
		"application/vnd.tcpdump.pcap": {
			"source": "iana",
			"extensions": [
				"pcap",
				"cap",
				"dmp"
			]
		},
		"application/vnd.tmd.mediaflex.api+xml": {
			"source": "iana"
		},
		"application/vnd.tml": {
			"source": "iana"
		},
		"application/vnd.tmobile-livetv": {
			"source": "iana",
			"extensions": [
				"tmo"
			]
		},
		"application/vnd.trid.tpt": {
			"source": "iana",
			"extensions": [
				"tpt"
			]
		},
		"application/vnd.triscape.mxs": {
			"source": "iana",
			"extensions": [
				"mxs"
			]
		},
		"application/vnd.trueapp": {
			"source": "iana",
			"extensions": [
				"tra"
			]
		},
		"application/vnd.truedoc": {
			"source": "iana"
		},
		"application/vnd.ubisoft.webplayer": {
			"source": "iana"
		},
		"application/vnd.ufdl": {
			"source": "iana",
			"extensions": [
				"ufd",
				"ufdl"
			]
		},
		"application/vnd.uiq.theme": {
			"source": "iana",
			"extensions": [
				"utz"
			]
		},
		"application/vnd.umajin": {
			"source": "iana",
			"extensions": [
				"umj"
			]
		},
		"application/vnd.unity": {
			"source": "iana",
			"extensions": [
				"unityweb"
			]
		},
		"application/vnd.uoml+xml": {
			"source": "iana",
			"extensions": [
				"uoml"
			]
		},
		"application/vnd.uplanet.alert": {
			"source": "iana"
		},
		"application/vnd.uplanet.alert-wbxml": {
			"source": "iana"
		},
		"application/vnd.uplanet.bearer-choice": {
			"source": "iana"
		},
		"application/vnd.uplanet.bearer-choice-wbxml": {
			"source": "iana"
		},
		"application/vnd.uplanet.cacheop": {
			"source": "iana"
		},
		"application/vnd.uplanet.cacheop-wbxml": {
			"source": "iana"
		},
		"application/vnd.uplanet.channel": {
			"source": "iana"
		},
		"application/vnd.uplanet.channel-wbxml": {
			"source": "iana"
		},
		"application/vnd.uplanet.list": {
			"source": "iana"
		},
		"application/vnd.uplanet.list-wbxml": {
			"source": "iana"
		},
		"application/vnd.uplanet.listcmd": {
			"source": "iana"
		},
		"application/vnd.uplanet.listcmd-wbxml": {
			"source": "iana"
		},
		"application/vnd.uplanet.signal": {
			"source": "iana"
		},
		"application/vnd.uri-map": {
			"source": "iana"
		},
		"application/vnd.valve.source.material": {
			"source": "iana"
		},
		"application/vnd.vcx": {
			"source": "iana",
			"extensions": [
				"vcx"
			]
		},
		"application/vnd.vd-study": {
			"source": "iana"
		},
		"application/vnd.vectorworks": {
			"source": "iana"
		},
		"application/vnd.vel+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.verimatrix.vcas": {
			"source": "iana"
		},
		"application/vnd.vidsoft.vidconference": {
			"source": "iana"
		},
		"application/vnd.visio": {
			"source": "iana",
			"extensions": [
				"vsd",
				"vst",
				"vss",
				"vsw"
			]
		},
		"application/vnd.visionary": {
			"source": "iana",
			"extensions": [
				"vis"
			]
		},
		"application/vnd.vividence.scriptfile": {
			"source": "iana"
		},
		"application/vnd.vsf": {
			"source": "iana",
			"extensions": [
				"vsf"
			]
		},
		"application/vnd.wap.sic": {
			"source": "iana"
		},
		"application/vnd.wap.slc": {
			"source": "iana"
		},
		"application/vnd.wap.wbxml": {
			"source": "iana",
			"extensions": [
				"wbxml"
			]
		},
		"application/vnd.wap.wmlc": {
			"source": "iana",
			"extensions": [
				"wmlc"
			]
		},
		"application/vnd.wap.wmlscriptc": {
			"source": "iana",
			"extensions": [
				"wmlsc"
			]
		},
		"application/vnd.webturbo": {
			"source": "iana",
			"extensions": [
				"wtb"
			]
		},
		"application/vnd.wfa.p2p": {
			"source": "iana"
		},
		"application/vnd.wfa.wsc": {
			"source": "iana"
		},
		"application/vnd.windows.devicepairing": {
			"source": "iana"
		},
		"application/vnd.wmc": {
			"source": "iana"
		},
		"application/vnd.wmf.bootstrap": {
			"source": "iana"
		},
		"application/vnd.wolfram.mathematica": {
			"source": "iana"
		},
		"application/vnd.wolfram.mathematica.package": {
			"source": "iana"
		},
		"application/vnd.wolfram.player": {
			"source": "iana",
			"extensions": [
				"nbp"
			]
		},
		"application/vnd.wordperfect": {
			"source": "iana",
			"extensions": [
				"wpd"
			]
		},
		"application/vnd.wqd": {
			"source": "iana",
			"extensions": [
				"wqd"
			]
		},
		"application/vnd.wrq-hp3000-labelled": {
			"source": "iana"
		},
		"application/vnd.wt.stf": {
			"source": "iana",
			"extensions": [
				"stf"
			]
		},
		"application/vnd.wv.csp+wbxml": {
			"source": "iana"
		},
		"application/vnd.wv.csp+xml": {
			"source": "iana"
		},
		"application/vnd.wv.ssp+xml": {
			"source": "iana"
		},
		"application/vnd.xacml+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.xara": {
			"source": "iana",
			"extensions": [
				"xar"
			]
		},
		"application/vnd.xfdl": {
			"source": "iana",
			"extensions": [
				"xfdl"
			]
		},
		"application/vnd.xfdl.webform": {
			"source": "iana"
		},
		"application/vnd.xmi+xml": {
			"source": "iana"
		},
		"application/vnd.xmpie.cpkg": {
			"source": "iana"
		},
		"application/vnd.xmpie.dpkg": {
			"source": "iana"
		},
		"application/vnd.xmpie.plan": {
			"source": "iana"
		},
		"application/vnd.xmpie.ppkg": {
			"source": "iana"
		},
		"application/vnd.xmpie.xlim": {
			"source": "iana"
		},
		"application/vnd.yamaha.hv-dic": {
			"source": "iana",
			"extensions": [
				"hvd"
			]
		},
		"application/vnd.yamaha.hv-script": {
			"source": "iana",
			"extensions": [
				"hvs"
			]
		},
		"application/vnd.yamaha.hv-voice": {
			"source": "iana",
			"extensions": [
				"hvp"
			]
		},
		"application/vnd.yamaha.openscoreformat": {
			"source": "iana",
			"extensions": [
				"osf"
			]
		},
		"application/vnd.yamaha.openscoreformat.osfpvg+xml": {
			"source": "iana",
			"extensions": [
				"osfpvg"
			]
		},
		"application/vnd.yamaha.remote-setup": {
			"source": "iana"
		},
		"application/vnd.yamaha.smaf-audio": {
			"source": "iana",
			"extensions": [
				"saf"
			]
		},
		"application/vnd.yamaha.smaf-phrase": {
			"source": "iana",
			"extensions": [
				"spf"
			]
		},
		"application/vnd.yamaha.through-ngn": {
			"source": "iana"
		},
		"application/vnd.yamaha.tunnel-udpencap": {
			"source": "iana"
		},
		"application/vnd.yaoweme": {
			"source": "iana"
		},
		"application/vnd.yellowriver-custom-menu": {
			"source": "iana",
			"extensions": [
				"cmp"
			]
		},
		"application/vnd.zul": {
			"source": "iana",
			"extensions": [
				"zir",
				"zirz"
			]
		},
		"application/vnd.zzazz.deck+xml": {
			"source": "iana",
			"extensions": [
				"zaz"
			]
		},
		"application/voicexml+xml": {
			"source": "iana",
			"extensions": [
				"vxml"
			]
		},
		"application/vq-rtcpxr": {
			"source": "iana"
		},
		"application/watcherinfo+xml": {
			"source": "iana"
		},
		"application/whoispp-query": {
			"source": "iana"
		},
		"application/whoispp-response": {
			"source": "iana"
		},
		"application/widget": {
			"source": "iana",
			"extensions": [
				"wgt"
			]
		},
		"application/winhlp": {
			"source": "apache",
			"extensions": [
				"hlp"
			]
		},
		"application/wita": {
			"source": "iana"
		},
		"application/wordperfect5.1": {
			"source": "iana"
		},
		"application/wsdl+xml": {
			"source": "iana",
			"extensions": [
				"wsdl"
			]
		},
		"application/wspolicy+xml": {
			"source": "iana",
			"extensions": [
				"wspolicy"
			]
		},
		"application/x-7z-compressed": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"7z"
			]
		},
		"application/x-abiword": {
			"source": "apache",
			"extensions": [
				"abw"
			]
		},
		"application/x-ace-compressed": {
			"source": "apache",
			"extensions": [
				"ace"
			]
		},
		"application/x-amf": {
			"source": "apache"
		},
		"application/x-apple-diskimage": {
			"source": "apache",
			"extensions": [
				"dmg"
			]
		},
		"application/x-authorware-bin": {
			"source": "apache",
			"extensions": [
				"aab",
				"x32",
				"u32",
				"vox"
			]
		},
		"application/x-authorware-map": {
			"source": "apache",
			"extensions": [
				"aam"
			]
		},
		"application/x-authorware-seg": {
			"source": "apache",
			"extensions": [
				"aas"
			]
		},
		"application/x-bcpio": {
			"source": "apache",
			"extensions": [
				"bcpio"
			]
		},
		"application/x-bdoc": {
			"compressible": false,
			"extensions": [
				"bdoc"
			]
		},
		"application/x-bittorrent": {
			"source": "apache",
			"extensions": [
				"torrent"
			]
		},
		"application/x-blorb": {
			"source": "apache",
			"extensions": [
				"blb",
				"blorb"
			]
		},
		"application/x-bzip": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"bz"
			]
		},
		"application/x-bzip2": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"bz2",
				"boz"
			]
		},
		"application/x-cbr": {
			"source": "apache",
			"extensions": [
				"cbr",
				"cba",
				"cbt",
				"cbz",
				"cb7"
			]
		},
		"application/x-cdlink": {
			"source": "apache",
			"extensions": [
				"vcd"
			]
		},
		"application/x-cfs-compressed": {
			"source": "apache",
			"extensions": [
				"cfs"
			]
		},
		"application/x-chat": {
			"source": "apache",
			"extensions": [
				"chat"
			]
		},
		"application/x-chess-pgn": {
			"source": "apache",
			"extensions": [
				"pgn"
			]
		},
		"application/x-chrome-extension": {
			"extensions": [
				"crx"
			]
		},
		"application/x-cocoa": {
			"source": "nginx",
			"extensions": [
				"cco"
			]
		},
		"application/x-compress": {
			"source": "apache"
		},
		"application/x-conference": {
			"source": "apache",
			"extensions": [
				"nsc"
			]
		},
		"application/x-cpio": {
			"source": "apache",
			"extensions": [
				"cpio"
			]
		},
		"application/x-csh": {
			"source": "apache",
			"extensions": [
				"csh"
			]
		},
		"application/x-deb": {
			"compressible": false
		},
		"application/x-debian-package": {
			"source": "apache",
			"extensions": [
				"deb",
				"udeb"
			]
		},
		"application/x-dgc-compressed": {
			"source": "apache",
			"extensions": [
				"dgc"
			]
		},
		"application/x-director": {
			"source": "apache",
			"extensions": [
				"dir",
				"dcr",
				"dxr",
				"cst",
				"cct",
				"cxt",
				"w3d",
				"fgd",
				"swa"
			]
		},
		"application/x-doom": {
			"source": "apache",
			"extensions": [
				"wad"
			]
		},
		"application/x-dtbncx+xml": {
			"source": "apache",
			"extensions": [
				"ncx"
			]
		},
		"application/x-dtbook+xml": {
			"source": "apache",
			"extensions": [
				"dtb"
			]
		},
		"application/x-dtbresource+xml": {
			"source": "apache",
			"extensions": [
				"res"
			]
		},
		"application/x-dvi": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"dvi"
			]
		},
		"application/x-envoy": {
			"source": "apache",
			"extensions": [
				"evy"
			]
		},
		"application/x-eva": {
			"source": "apache",
			"extensions": [
				"eva"
			]
		},
		"application/x-font-bdf": {
			"source": "apache",
			"extensions": [
				"bdf"
			]
		},
		"application/x-font-dos": {
			"source": "apache"
		},
		"application/x-font-framemaker": {
			"source": "apache"
		},
		"application/x-font-ghostscript": {
			"source": "apache",
			"extensions": [
				"gsf"
			]
		},
		"application/x-font-libgrx": {
			"source": "apache"
		},
		"application/x-font-linux-psf": {
			"source": "apache",
			"extensions": [
				"psf"
			]
		},
		"application/x-font-otf": {
			"source": "apache",
			"compressible": true,
			"extensions": [
				"otf"
			]
		},
		"application/x-font-pcf": {
			"source": "apache",
			"extensions": [
				"pcf"
			]
		},
		"application/x-font-snf": {
			"source": "apache",
			"extensions": [
				"snf"
			]
		},
		"application/x-font-speedo": {
			"source": "apache"
		},
		"application/x-font-sunos-news": {
			"source": "apache"
		},
		"application/x-font-ttf": {
			"source": "apache",
			"compressible": true,
			"extensions": [
				"ttf",
				"ttc"
			]
		},
		"application/x-font-type1": {
			"source": "apache",
			"extensions": [
				"pfa",
				"pfb",
				"pfm",
				"afm"
			]
		},
		"application/x-font-vfont": {
			"source": "apache"
		},
		"application/x-freearc": {
			"source": "apache",
			"extensions": [
				"arc"
			]
		},
		"application/x-futuresplash": {
			"source": "apache",
			"extensions": [
				"spl"
			]
		},
		"application/x-gca-compressed": {
			"source": "apache",
			"extensions": [
				"gca"
			]
		},
		"application/x-glulx": {
			"source": "apache",
			"extensions": [
				"ulx"
			]
		},
		"application/x-gnumeric": {
			"source": "apache",
			"extensions": [
				"gnumeric"
			]
		},
		"application/x-gramps-xml": {
			"source": "apache",
			"extensions": [
				"gramps"
			]
		},
		"application/x-gtar": {
			"source": "apache",
			"extensions": [
				"gtar"
			]
		},
		"application/x-gzip": {
			"source": "apache"
		},
		"application/x-hdf": {
			"source": "apache",
			"extensions": [
				"hdf"
			]
		},
		"application/x-httpd-php": {
			"compressible": true,
			"extensions": [
				"php"
			]
		},
		"application/x-install-instructions": {
			"source": "apache",
			"extensions": [
				"install"
			]
		},
		"application/x-iso9660-image": {
			"source": "apache",
			"extensions": [
				"iso"
			]
		},
		"application/x-java-archive-diff": {
			"source": "nginx",
			"extensions": [
				"jardiff"
			]
		},
		"application/x-java-jnlp-file": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"jnlp"
			]
		},
		"application/x-javascript": {
			"compressible": true
		},
		"application/x-latex": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"latex"
			]
		},
		"application/x-lua-bytecode": {
			"extensions": [
				"luac"
			]
		},
		"application/x-lzh-compressed": {
			"source": "apache",
			"extensions": [
				"lzh",
				"lha"
			]
		},
		"application/x-makeself": {
			"source": "nginx",
			"extensions": [
				"run"
			]
		},
		"application/x-mie": {
			"source": "apache",
			"extensions": [
				"mie"
			]
		},
		"application/x-mobipocket-ebook": {
			"source": "apache",
			"extensions": [
				"prc",
				"mobi"
			]
		},
		"application/x-mpegurl": {
			"compressible": false
		},
		"application/x-ms-application": {
			"source": "apache",
			"extensions": [
				"application"
			]
		},
		"application/x-ms-shortcut": {
			"source": "apache",
			"extensions": [
				"lnk"
			]
		},
		"application/x-ms-wmd": {
			"source": "apache",
			"extensions": [
				"wmd"
			]
		},
		"application/x-ms-wmz": {
			"source": "apache",
			"extensions": [
				"wmz"
			]
		},
		"application/x-ms-xbap": {
			"source": "apache",
			"extensions": [
				"xbap"
			]
		},
		"application/x-msaccess": {
			"source": "apache",
			"extensions": [
				"mdb"
			]
		},
		"application/x-msbinder": {
			"source": "apache",
			"extensions": [
				"obd"
			]
		},
		"application/x-mscardfile": {
			"source": "apache",
			"extensions": [
				"crd"
			]
		},
		"application/x-msclip": {
			"source": "apache",
			"extensions": [
				"clp"
			]
		},
		"application/x-msdos-program": {
			"extensions": [
				"exe"
			]
		},
		"application/x-msdownload": {
			"source": "apache",
			"extensions": [
				"exe",
				"dll",
				"com",
				"bat",
				"msi"
			]
		},
		"application/x-msmediaview": {
			"source": "apache",
			"extensions": [
				"mvb",
				"m13",
				"m14"
			]
		},
		"application/x-msmetafile": {
			"source": "apache",
			"extensions": [
				"wmf",
				"wmz",
				"emf",
				"emz"
			]
		},
		"application/x-msmoney": {
			"source": "apache",
			"extensions": [
				"mny"
			]
		},
		"application/x-mspublisher": {
			"source": "apache",
			"extensions": [
				"pub"
			]
		},
		"application/x-msschedule": {
			"source": "apache",
			"extensions": [
				"scd"
			]
		},
		"application/x-msterminal": {
			"source": "apache",
			"extensions": [
				"trm"
			]
		},
		"application/x-mswrite": {
			"source": "apache",
			"extensions": [
				"wri"
			]
		},
		"application/x-netcdf": {
			"source": "apache",
			"extensions": [
				"nc",
				"cdf"
			]
		},
		"application/x-ns-proxy-autoconfig": {
			"compressible": true,
			"extensions": [
				"pac"
			]
		},
		"application/x-nzb": {
			"source": "apache",
			"extensions": [
				"nzb"
			]
		},
		"application/x-perl": {
			"source": "nginx",
			"extensions": [
				"pl",
				"pm"
			]
		},
		"application/x-pilot": {
			"source": "nginx",
			"extensions": [
				"prc",
				"pdb"
			]
		},
		"application/x-pkcs12": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"p12",
				"pfx"
			]
		},
		"application/x-pkcs7-certificates": {
			"source": "apache",
			"extensions": [
				"p7b",
				"spc"
			]
		},
		"application/x-pkcs7-certreqresp": {
			"source": "apache",
			"extensions": [
				"p7r"
			]
		},
		"application/x-rar-compressed": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"rar"
			]
		},
		"application/x-redhat-package-manager": {
			"source": "nginx",
			"extensions": [
				"rpm"
			]
		},
		"application/x-research-info-systems": {
			"source": "apache",
			"extensions": [
				"ris"
			]
		},
		"application/x-sea": {
			"source": "nginx",
			"extensions": [
				"sea"
			]
		},
		"application/x-sh": {
			"source": "apache",
			"compressible": true,
			"extensions": [
				"sh"
			]
		},
		"application/x-shar": {
			"source": "apache",
			"extensions": [
				"shar"
			]
		},
		"application/x-shockwave-flash": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"swf"
			]
		},
		"application/x-silverlight-app": {
			"source": "apache",
			"extensions": [
				"xap"
			]
		},
		"application/x-sql": {
			"source": "apache",
			"extensions": [
				"sql"
			]
		},
		"application/x-stuffit": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"sit"
			]
		},
		"application/x-stuffitx": {
			"source": "apache",
			"extensions": [
				"sitx"
			]
		},
		"application/x-subrip": {
			"source": "apache",
			"extensions": [
				"srt"
			]
		},
		"application/x-sv4cpio": {
			"source": "apache",
			"extensions": [
				"sv4cpio"
			]
		},
		"application/x-sv4crc": {
			"source": "apache",
			"extensions": [
				"sv4crc"
			]
		},
		"application/x-t3vm-image": {
			"source": "apache",
			"extensions": [
				"t3"
			]
		},
		"application/x-tads": {
			"source": "apache",
			"extensions": [
				"gam"
			]
		},
		"application/x-tar": {
			"source": "apache",
			"compressible": true,
			"extensions": [
				"tar"
			]
		},
		"application/x-tcl": {
			"source": "apache",
			"extensions": [
				"tcl",
				"tk"
			]
		},
		"application/x-tex": {
			"source": "apache",
			"extensions": [
				"tex"
			]
		},
		"application/x-tex-tfm": {
			"source": "apache",
			"extensions": [
				"tfm"
			]
		},
		"application/x-texinfo": {
			"source": "apache",
			"extensions": [
				"texinfo",
				"texi"
			]
		},
		"application/x-tgif": {
			"source": "apache",
			"extensions": [
				"obj"
			]
		},
		"application/x-ustar": {
			"source": "apache",
			"extensions": [
				"ustar"
			]
		},
		"application/x-wais-source": {
			"source": "apache",
			"extensions": [
				"src"
			]
		},
		"application/x-web-app-manifest+json": {
			"compressible": true,
			"extensions": [
				"webapp"
			]
		},
		"application/x-www-form-urlencoded": {
			"source": "iana",
			"compressible": true
		},
		"application/x-x509-ca-cert": {
			"source": "apache",
			"extensions": [
				"der",
				"crt",
				"pem"
			]
		},
		"application/x-xfig": {
			"source": "apache",
			"extensions": [
				"fig"
			]
		},
		"application/x-xliff+xml": {
			"source": "apache",
			"extensions": [
				"xlf"
			]
		},
		"application/x-xpinstall": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"xpi"
			]
		},
		"application/x-xz": {
			"source": "apache",
			"extensions": [
				"xz"
			]
		},
		"application/x-zmachine": {
			"source": "apache",
			"extensions": [
				"z1",
				"z2",
				"z3",
				"z4",
				"z5",
				"z6",
				"z7",
				"z8"
			]
		},
		"application/x400-bp": {
			"source": "iana"
		},
		"application/xacml+xml": {
			"source": "iana"
		},
		"application/xaml+xml": {
			"source": "apache",
			"extensions": [
				"xaml"
			]
		},
		"application/xcap-att+xml": {
			"source": "iana"
		},
		"application/xcap-caps+xml": {
			"source": "iana"
		},
		"application/xcap-diff+xml": {
			"source": "iana",
			"extensions": [
				"xdf"
			]
		},
		"application/xcap-el+xml": {
			"source": "iana"
		},
		"application/xcap-error+xml": {
			"source": "iana"
		},
		"application/xcap-ns+xml": {
			"source": "iana"
		},
		"application/xcon-conference-info+xml": {
			"source": "iana"
		},
		"application/xcon-conference-info-diff+xml": {
			"source": "iana"
		},
		"application/xenc+xml": {
			"source": "iana",
			"extensions": [
				"xenc"
			]
		},
		"application/xhtml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"xhtml",
				"xht"
			]
		},
		"application/xhtml-voice+xml": {
			"source": "apache"
		},
		"application/xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"xml",
				"xsl",
				"xsd",
				"rng"
			]
		},
		"application/xml-dtd": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"dtd"
			]
		},
		"application/xml-external-parsed-entity": {
			"source": "iana"
		},
		"application/xml-patch+xml": {
			"source": "iana"
		},
		"application/xmpp+xml": {
			"source": "iana"
		},
		"application/xop+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"xop"
			]
		},
		"application/xproc+xml": {
			"source": "apache",
			"extensions": [
				"xpl"
			]
		},
		"application/xslt+xml": {
			"source": "iana",
			"extensions": [
				"xslt"
			]
		},
		"application/xspf+xml": {
			"source": "apache",
			"extensions": [
				"xspf"
			]
		},
		"application/xv+xml": {
			"source": "iana",
			"extensions": [
				"mxml",
				"xhvml",
				"xvml",
				"xvm"
			]
		},
		"application/yang": {
			"source": "iana",
			"extensions": [
				"yang"
			]
		},
		"application/yin+xml": {
			"source": "iana",
			"extensions": [
				"yin"
			]
		},
		"application/zip": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"zip"
			]
		},
		"application/zlib": {
			"source": "iana"
		},
		"audio/1d-interleaved-parityfec": {
			"source": "iana"
		},
		"audio/32kadpcm": {
			"source": "iana"
		},
		"audio/3gpp": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"3gpp"
			]
		},
		"audio/3gpp2": {
			"source": "iana"
		},
		"audio/ac3": {
			"source": "iana"
		},
		"audio/adpcm": {
			"source": "apache",
			"extensions": [
				"adp"
			]
		},
		"audio/amr": {
			"source": "iana"
		},
		"audio/amr-wb": {
			"source": "iana"
		},
		"audio/amr-wb+": {
			"source": "iana"
		},
		"audio/aptx": {
			"source": "iana"
		},
		"audio/asc": {
			"source": "iana"
		},
		"audio/atrac-advanced-lossless": {
			"source": "iana"
		},
		"audio/atrac-x": {
			"source": "iana"
		},
		"audio/atrac3": {
			"source": "iana"
		},
		"audio/basic": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"au",
				"snd"
			]
		},
		"audio/bv16": {
			"source": "iana"
		},
		"audio/bv32": {
			"source": "iana"
		},
		"audio/clearmode": {
			"source": "iana"
		},
		"audio/cn": {
			"source": "iana"
		},
		"audio/dat12": {
			"source": "iana"
		},
		"audio/dls": {
			"source": "iana"
		},
		"audio/dsr-es201108": {
			"source": "iana"
		},
		"audio/dsr-es202050": {
			"source": "iana"
		},
		"audio/dsr-es202211": {
			"source": "iana"
		},
		"audio/dsr-es202212": {
			"source": "iana"
		},
		"audio/dv": {
			"source": "iana"
		},
		"audio/dvi4": {
			"source": "iana"
		},
		"audio/eac3": {
			"source": "iana"
		},
		"audio/encaprtp": {
			"source": "iana"
		},
		"audio/evrc": {
			"source": "iana"
		},
		"audio/evrc-qcp": {
			"source": "iana"
		},
		"audio/evrc0": {
			"source": "iana"
		},
		"audio/evrc1": {
			"source": "iana"
		},
		"audio/evrcb": {
			"source": "iana"
		},
		"audio/evrcb0": {
			"source": "iana"
		},
		"audio/evrcb1": {
			"source": "iana"
		},
		"audio/evrcnw": {
			"source": "iana"
		},
		"audio/evrcnw0": {
			"source": "iana"
		},
		"audio/evrcnw1": {
			"source": "iana"
		},
		"audio/evrcwb": {
			"source": "iana"
		},
		"audio/evrcwb0": {
			"source": "iana"
		},
		"audio/evrcwb1": {
			"source": "iana"
		},
		"audio/evs": {
			"source": "iana"
		},
		"audio/fwdred": {
			"source": "iana"
		},
		"audio/g711-0": {
			"source": "iana"
		},
		"audio/g719": {
			"source": "iana"
		},
		"audio/g722": {
			"source": "iana"
		},
		"audio/g7221": {
			"source": "iana"
		},
		"audio/g723": {
			"source": "iana"
		},
		"audio/g726-16": {
			"source": "iana"
		},
		"audio/g726-24": {
			"source": "iana"
		},
		"audio/g726-32": {
			"source": "iana"
		},
		"audio/g726-40": {
			"source": "iana"
		},
		"audio/g728": {
			"source": "iana"
		},
		"audio/g729": {
			"source": "iana"
		},
		"audio/g7291": {
			"source": "iana"
		},
		"audio/g729d": {
			"source": "iana"
		},
		"audio/g729e": {
			"source": "iana"
		},
		"audio/gsm": {
			"source": "iana"
		},
		"audio/gsm-efr": {
			"source": "iana"
		},
		"audio/gsm-hr-08": {
			"source": "iana"
		},
		"audio/ilbc": {
			"source": "iana"
		},
		"audio/ip-mr_v2.5": {
			"source": "iana"
		},
		"audio/isac": {
			"source": "apache"
		},
		"audio/l16": {
			"source": "iana"
		},
		"audio/l20": {
			"source": "iana"
		},
		"audio/l24": {
			"source": "iana",
			"compressible": false
		},
		"audio/l8": {
			"source": "iana"
		},
		"audio/lpc": {
			"source": "iana"
		},
		"audio/midi": {
			"source": "apache",
			"extensions": [
				"mid",
				"midi",
				"kar",
				"rmi"
			]
		},
		"audio/mobile-xmf": {
			"source": "iana"
		},
		"audio/mp3": {
			"compressible": false,
			"extensions": [
				"mp3"
			]
		},
		"audio/mp4": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"m4a",
				"mp4a"
			]
		},
		"audio/mp4a-latm": {
			"source": "iana"
		},
		"audio/mpa": {
			"source": "iana"
		},
		"audio/mpa-robust": {
			"source": "iana"
		},
		"audio/mpeg": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"mpga",
				"mp2",
				"mp2a",
				"mp3",
				"m2a",
				"m3a"
			]
		},
		"audio/mpeg4-generic": {
			"source": "iana"
		},
		"audio/musepack": {
			"source": "apache"
		},
		"audio/ogg": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"oga",
				"ogg",
				"spx"
			]
		},
		"audio/opus": {
			"source": "iana"
		},
		"audio/parityfec": {
			"source": "iana"
		},
		"audio/pcma": {
			"source": "iana"
		},
		"audio/pcma-wb": {
			"source": "iana"
		},
		"audio/pcmu": {
			"source": "iana"
		},
		"audio/pcmu-wb": {
			"source": "iana"
		},
		"audio/prs.sid": {
			"source": "iana"
		},
		"audio/qcelp": {
			"source": "iana"
		},
		"audio/raptorfec": {
			"source": "iana"
		},
		"audio/red": {
			"source": "iana"
		},
		"audio/rtp-enc-aescm128": {
			"source": "iana"
		},
		"audio/rtp-midi": {
			"source": "iana"
		},
		"audio/rtploopback": {
			"source": "iana"
		},
		"audio/rtx": {
			"source": "iana"
		},
		"audio/s3m": {
			"source": "apache",
			"extensions": [
				"s3m"
			]
		},
		"audio/silk": {
			"source": "apache",
			"extensions": [
				"sil"
			]
		},
		"audio/smv": {
			"source": "iana"
		},
		"audio/smv-qcp": {
			"source": "iana"
		},
		"audio/smv0": {
			"source": "iana"
		},
		"audio/sp-midi": {
			"source": "iana"
		},
		"audio/speex": {
			"source": "iana"
		},
		"audio/t140c": {
			"source": "iana"
		},
		"audio/t38": {
			"source": "iana"
		},
		"audio/telephone-event": {
			"source": "iana"
		},
		"audio/tone": {
			"source": "iana"
		},
		"audio/uemclip": {
			"source": "iana"
		},
		"audio/ulpfec": {
			"source": "iana"
		},
		"audio/vdvi": {
			"source": "iana"
		},
		"audio/vmr-wb": {
			"source": "iana"
		},
		"audio/vnd.3gpp.iufp": {
			"source": "iana"
		},
		"audio/vnd.4sb": {
			"source": "iana"
		},
		"audio/vnd.audiokoz": {
			"source": "iana"
		},
		"audio/vnd.celp": {
			"source": "iana"
		},
		"audio/vnd.cisco.nse": {
			"source": "iana"
		},
		"audio/vnd.cmles.radio-events": {
			"source": "iana"
		},
		"audio/vnd.cns.anp1": {
			"source": "iana"
		},
		"audio/vnd.cns.inf1": {
			"source": "iana"
		},
		"audio/vnd.dece.audio": {
			"source": "iana",
			"extensions": [
				"uva",
				"uvva"
			]
		},
		"audio/vnd.digital-winds": {
			"source": "iana",
			"extensions": [
				"eol"
			]
		},
		"audio/vnd.dlna.adts": {
			"source": "iana"
		},
		"audio/vnd.dolby.heaac.1": {
			"source": "iana"
		},
		"audio/vnd.dolby.heaac.2": {
			"source": "iana"
		},
		"audio/vnd.dolby.mlp": {
			"source": "iana"
		},
		"audio/vnd.dolby.mps": {
			"source": "iana"
		},
		"audio/vnd.dolby.pl2": {
			"source": "iana"
		},
		"audio/vnd.dolby.pl2x": {
			"source": "iana"
		},
		"audio/vnd.dolby.pl2z": {
			"source": "iana"
		},
		"audio/vnd.dolby.pulse.1": {
			"source": "iana"
		},
		"audio/vnd.dra": {
			"source": "iana",
			"extensions": [
				"dra"
			]
		},
		"audio/vnd.dts": {
			"source": "iana",
			"extensions": [
				"dts"
			]
		},
		"audio/vnd.dts.hd": {
			"source": "iana",
			"extensions": [
				"dtshd"
			]
		},
		"audio/vnd.dvb.file": {
			"source": "iana"
		},
		"audio/vnd.everad.plj": {
			"source": "iana"
		},
		"audio/vnd.hns.audio": {
			"source": "iana"
		},
		"audio/vnd.lucent.voice": {
			"source": "iana",
			"extensions": [
				"lvp"
			]
		},
		"audio/vnd.ms-playready.media.pya": {
			"source": "iana",
			"extensions": [
				"pya"
			]
		},
		"audio/vnd.nokia.mobile-xmf": {
			"source": "iana"
		},
		"audio/vnd.nortel.vbk": {
			"source": "iana"
		},
		"audio/vnd.nuera.ecelp4800": {
			"source": "iana",
			"extensions": [
				"ecelp4800"
			]
		},
		"audio/vnd.nuera.ecelp7470": {
			"source": "iana",
			"extensions": [
				"ecelp7470"
			]
		},
		"audio/vnd.nuera.ecelp9600": {
			"source": "iana",
			"extensions": [
				"ecelp9600"
			]
		},
		"audio/vnd.octel.sbc": {
			"source": "iana"
		},
		"audio/vnd.qcelp": {
			"source": "iana"
		},
		"audio/vnd.rhetorex.32kadpcm": {
			"source": "iana"
		},
		"audio/vnd.rip": {
			"source": "iana",
			"extensions": [
				"rip"
			]
		},
		"audio/vnd.rn-realaudio": {
			"compressible": false
		},
		"audio/vnd.sealedmedia.softseal.mpeg": {
			"source": "iana"
		},
		"audio/vnd.vmx.cvsd": {
			"source": "iana"
		},
		"audio/vnd.wave": {
			"compressible": false
		},
		"audio/vorbis": {
			"source": "iana",
			"compressible": false
		},
		"audio/vorbis-config": {
			"source": "iana"
		},
		"audio/wav": {
			"compressible": false,
			"extensions": [
				"wav"
			]
		},
		"audio/wave": {
			"compressible": false,
			"extensions": [
				"wav"
			]
		},
		"audio/webm": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"weba"
			]
		},
		"audio/x-aac": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"aac"
			]
		},
		"audio/x-aiff": {
			"source": "apache",
			"extensions": [
				"aif",
				"aiff",
				"aifc"
			]
		},
		"audio/x-caf": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"caf"
			]
		},
		"audio/x-flac": {
			"source": "apache",
			"extensions": [
				"flac"
			]
		},
		"audio/x-m4a": {
			"source": "nginx",
			"extensions": [
				"m4a"
			]
		},
		"audio/x-matroska": {
			"source": "apache",
			"extensions": [
				"mka"
			]
		},
		"audio/x-mpegurl": {
			"source": "apache",
			"extensions": [
				"m3u"
			]
		},
		"audio/x-ms-wax": {
			"source": "apache",
			"extensions": [
				"wax"
			]
		},
		"audio/x-ms-wma": {
			"source": "apache",
			"extensions": [
				"wma"
			]
		},
		"audio/x-pn-realaudio": {
			"source": "apache",
			"extensions": [
				"ram",
				"ra"
			]
		},
		"audio/x-pn-realaudio-plugin": {
			"source": "apache",
			"extensions": [
				"rmp"
			]
		},
		"audio/x-realaudio": {
			"source": "nginx",
			"extensions": [
				"ra"
			]
		},
		"audio/x-tta": {
			"source": "apache"
		},
		"audio/x-wav": {
			"source": "apache",
			"extensions": [
				"wav"
			]
		},
		"audio/xm": {
			"source": "apache",
			"extensions": [
				"xm"
			]
		},
		"chemical/x-cdx": {
			"source": "apache",
			"extensions": [
				"cdx"
			]
		},
		"chemical/x-cif": {
			"source": "apache",
			"extensions": [
				"cif"
			]
		},
		"chemical/x-cmdf": {
			"source": "apache",
			"extensions": [
				"cmdf"
			]
		},
		"chemical/x-cml": {
			"source": "apache",
			"extensions": [
				"cml"
			]
		},
		"chemical/x-csml": {
			"source": "apache",
			"extensions": [
				"csml"
			]
		},
		"chemical/x-pdb": {
			"source": "apache"
		},
		"chemical/x-xyz": {
			"source": "apache",
			"extensions": [
				"xyz"
			]
		},
		"font/opentype": {
			"compressible": true,
			"extensions": [
				"otf"
			]
		},
		"image/bmp": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"bmp"
			]
		},
		"image/cgm": {
			"source": "iana",
			"extensions": [
				"cgm"
			]
		},
		"image/dicom-rle": {
			"source": "iana"
		},
		"image/emf": {
			"source": "iana"
		},
		"image/fits": {
			"source": "iana"
		},
		"image/g3fax": {
			"source": "iana",
			"extensions": [
				"g3"
			]
		},
		"image/gif": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"gif"
			]
		},
		"image/ief": {
			"source": "iana",
			"extensions": [
				"ief"
			]
		},
		"image/jls": {
			"source": "iana"
		},
		"image/jp2": {
			"source": "iana"
		},
		"image/jpeg": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"jpeg",
				"jpg",
				"jpe"
			]
		},
		"image/jpm": {
			"source": "iana"
		},
		"image/jpx": {
			"source": "iana"
		},
		"image/ktx": {
			"source": "iana",
			"extensions": [
				"ktx"
			]
		},
		"image/naplps": {
			"source": "iana"
		},
		"image/pjpeg": {
			"compressible": false
		},
		"image/png": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"png"
			]
		},
		"image/prs.btif": {
			"source": "iana",
			"extensions": [
				"btif"
			]
		},
		"image/prs.pti": {
			"source": "iana"
		},
		"image/pwg-raster": {
			"source": "iana"
		},
		"image/sgi": {
			"source": "apache",
			"extensions": [
				"sgi"
			]
		},
		"image/svg+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"svg",
				"svgz"
			]
		},
		"image/t38": {
			"source": "iana"
		},
		"image/tiff": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"tiff",
				"tif"
			]
		},
		"image/tiff-fx": {
			"source": "iana"
		},
		"image/vnd.adobe.photoshop": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"psd"
			]
		},
		"image/vnd.airzip.accelerator.azv": {
			"source": "iana"
		},
		"image/vnd.cns.inf2": {
			"source": "iana"
		},
		"image/vnd.dece.graphic": {
			"source": "iana",
			"extensions": [
				"uvi",
				"uvvi",
				"uvg",
				"uvvg"
			]
		},
		"image/vnd.djvu": {
			"source": "iana",
			"extensions": [
				"djvu",
				"djv"
			]
		},
		"image/vnd.dvb.subtitle": {
			"source": "iana",
			"extensions": [
				"sub"
			]
		},
		"image/vnd.dwg": {
			"source": "iana",
			"extensions": [
				"dwg"
			]
		},
		"image/vnd.dxf": {
			"source": "iana",
			"extensions": [
				"dxf"
			]
		},
		"image/vnd.fastbidsheet": {
			"source": "iana",
			"extensions": [
				"fbs"
			]
		},
		"image/vnd.fpx": {
			"source": "iana",
			"extensions": [
				"fpx"
			]
		},
		"image/vnd.fst": {
			"source": "iana",
			"extensions": [
				"fst"
			]
		},
		"image/vnd.fujixerox.edmics-mmr": {
			"source": "iana",
			"extensions": [
				"mmr"
			]
		},
		"image/vnd.fujixerox.edmics-rlc": {
			"source": "iana",
			"extensions": [
				"rlc"
			]
		},
		"image/vnd.globalgraphics.pgb": {
			"source": "iana"
		},
		"image/vnd.microsoft.icon": {
			"source": "iana"
		},
		"image/vnd.mix": {
			"source": "iana"
		},
		"image/vnd.mozilla.apng": {
			"source": "iana"
		},
		"image/vnd.ms-modi": {
			"source": "iana",
			"extensions": [
				"mdi"
			]
		},
		"image/vnd.ms-photo": {
			"source": "apache",
			"extensions": [
				"wdp"
			]
		},
		"image/vnd.net-fpx": {
			"source": "iana",
			"extensions": [
				"npx"
			]
		},
		"image/vnd.radiance": {
			"source": "iana"
		},
		"image/vnd.sealed.png": {
			"source": "iana"
		},
		"image/vnd.sealedmedia.softseal.gif": {
			"source": "iana"
		},
		"image/vnd.sealedmedia.softseal.jpg": {
			"source": "iana"
		},
		"image/vnd.svf": {
			"source": "iana"
		},
		"image/vnd.tencent.tap": {
			"source": "iana"
		},
		"image/vnd.valve.source.texture": {
			"source": "iana"
		},
		"image/vnd.wap.wbmp": {
			"source": "iana",
			"extensions": [
				"wbmp"
			]
		},
		"image/vnd.xiff": {
			"source": "iana",
			"extensions": [
				"xif"
			]
		},
		"image/vnd.zbrush.pcx": {
			"source": "iana"
		},
		"image/webp": {
			"source": "apache",
			"extensions": [
				"webp"
			]
		},
		"image/wmf": {
			"source": "iana"
		},
		"image/x-3ds": {
			"source": "apache",
			"extensions": [
				"3ds"
			]
		},
		"image/x-cmu-raster": {
			"source": "apache",
			"extensions": [
				"ras"
			]
		},
		"image/x-cmx": {
			"source": "apache",
			"extensions": [
				"cmx"
			]
		},
		"image/x-freehand": {
			"source": "apache",
			"extensions": [
				"fh",
				"fhc",
				"fh4",
				"fh5",
				"fh7"
			]
		},
		"image/x-icon": {
			"source": "apache",
			"compressible": true,
			"extensions": [
				"ico"
			]
		},
		"image/x-jng": {
			"source": "nginx",
			"extensions": [
				"jng"
			]
		},
		"image/x-mrsid-image": {
			"source": "apache",
			"extensions": [
				"sid"
			]
		},
		"image/x-ms-bmp": {
			"source": "nginx",
			"compressible": true,
			"extensions": [
				"bmp"
			]
		},
		"image/x-pcx": {
			"source": "apache",
			"extensions": [
				"pcx"
			]
		},
		"image/x-pict": {
			"source": "apache",
			"extensions": [
				"pic",
				"pct"
			]
		},
		"image/x-portable-anymap": {
			"source": "apache",
			"extensions": [
				"pnm"
			]
		},
		"image/x-portable-bitmap": {
			"source": "apache",
			"extensions": [
				"pbm"
			]
		},
		"image/x-portable-graymap": {
			"source": "apache",
			"extensions": [
				"pgm"
			]
		},
		"image/x-portable-pixmap": {
			"source": "apache",
			"extensions": [
				"ppm"
			]
		},
		"image/x-rgb": {
			"source": "apache",
			"extensions": [
				"rgb"
			]
		},
		"image/x-tga": {
			"source": "apache",
			"extensions": [
				"tga"
			]
		},
		"image/x-xbitmap": {
			"source": "apache",
			"extensions": [
				"xbm"
			]
		},
		"image/x-xcf": {
			"compressible": false
		},
		"image/x-xpixmap": {
			"source": "apache",
			"extensions": [
				"xpm"
			]
		},
		"image/x-xwindowdump": {
			"source": "apache",
			"extensions": [
				"xwd"
			]
		},
		"message/cpim": {
			"source": "iana"
		},
		"message/delivery-status": {
			"source": "iana"
		},
		"message/disposition-notification": {
			"source": "iana"
		},
		"message/external-body": {
			"source": "iana"
		},
		"message/feedback-report": {
			"source": "iana"
		},
		"message/global": {
			"source": "iana"
		},
		"message/global-delivery-status": {
			"source": "iana"
		},
		"message/global-disposition-notification": {
			"source": "iana"
		},
		"message/global-headers": {
			"source": "iana"
		},
		"message/http": {
			"source": "iana",
			"compressible": false
		},
		"message/imdn+xml": {
			"source": "iana",
			"compressible": true
		},
		"message/news": {
			"source": "iana"
		},
		"message/partial": {
			"source": "iana",
			"compressible": false
		},
		"message/rfc822": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"eml",
				"mime"
			]
		},
		"message/s-http": {
			"source": "iana"
		},
		"message/sip": {
			"source": "iana"
		},
		"message/sipfrag": {
			"source": "iana"
		},
		"message/tracking-status": {
			"source": "iana"
		},
		"message/vnd.si.simp": {
			"source": "iana"
		},
		"message/vnd.wfa.wsc": {
			"source": "iana"
		},
		"model/gltf+json": {
			"source": "iana",
			"compressible": true
		},
		"model/iges": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"igs",
				"iges"
			]
		},
		"model/mesh": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"msh",
				"mesh",
				"silo"
			]
		},
		"model/vnd.collada+xml": {
			"source": "iana",
			"extensions": [
				"dae"
			]
		},
		"model/vnd.dwf": {
			"source": "iana",
			"extensions": [
				"dwf"
			]
		},
		"model/vnd.flatland.3dml": {
			"source": "iana"
		},
		"model/vnd.gdl": {
			"source": "iana",
			"extensions": [
				"gdl"
			]
		},
		"model/vnd.gs-gdl": {
			"source": "apache"
		},
		"model/vnd.gs.gdl": {
			"source": "iana"
		},
		"model/vnd.gtw": {
			"source": "iana",
			"extensions": [
				"gtw"
			]
		},
		"model/vnd.moml+xml": {
			"source": "iana"
		},
		"model/vnd.mts": {
			"source": "iana",
			"extensions": [
				"mts"
			]
		},
		"model/vnd.opengex": {
			"source": "iana"
		},
		"model/vnd.parasolid.transmit.binary": {
			"source": "iana"
		},
		"model/vnd.parasolid.transmit.text": {
			"source": "iana"
		},
		"model/vnd.rosette.annotated-data-model": {
			"source": "iana"
		},
		"model/vnd.valve.source.compiled-map": {
			"source": "iana"
		},
		"model/vnd.vtu": {
			"source": "iana",
			"extensions": [
				"vtu"
			]
		},
		"model/vrml": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"wrl",
				"vrml"
			]
		},
		"model/x3d+binary": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"x3db",
				"x3dbz"
			]
		},
		"model/x3d+fastinfoset": {
			"source": "iana"
		},
		"model/x3d+vrml": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"x3dv",
				"x3dvz"
			]
		},
		"model/x3d+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"x3d",
				"x3dz"
			]
		},
		"model/x3d-vrml": {
			"source": "iana"
		},
		"multipart/alternative": {
			"source": "iana",
			"compressible": false
		},
		"multipart/appledouble": {
			"source": "iana"
		},
		"multipart/byteranges": {
			"source": "iana"
		},
		"multipart/digest": {
			"source": "iana"
		},
		"multipart/encrypted": {
			"source": "iana",
			"compressible": false
		},
		"multipart/form-data": {
			"source": "iana",
			"compressible": false
		},
		"multipart/header-set": {
			"source": "iana"
		},
		"multipart/mixed": {
			"source": "iana",
			"compressible": false
		},
		"multipart/parallel": {
			"source": "iana"
		},
		"multipart/related": {
			"source": "iana",
			"compressible": false
		},
		"multipart/report": {
			"source": "iana"
		},
		"multipart/signed": {
			"source": "iana",
			"compressible": false
		},
		"multipart/voice-message": {
			"source": "iana"
		},
		"multipart/x-mixed-replace": {
			"source": "iana"
		},
		"text/1d-interleaved-parityfec": {
			"source": "iana"
		},
		"text/cache-manifest": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"appcache",
				"manifest"
			]
		},
		"text/calendar": {
			"source": "iana",
			"extensions": [
				"ics",
				"ifb"
			]
		},
		"text/calender": {
			"compressible": true
		},
		"text/cmd": {
			"compressible": true
		},
		"text/coffeescript": {
			"extensions": [
				"coffee",
				"litcoffee"
			]
		},
		"text/css": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"css"
			]
		},
		"text/csv": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"csv"
			]
		},
		"text/csv-schema": {
			"source": "iana"
		},
		"text/directory": {
			"source": "iana"
		},
		"text/dns": {
			"source": "iana"
		},
		"text/ecmascript": {
			"source": "iana"
		},
		"text/encaprtp": {
			"source": "iana"
		},
		"text/enriched": {
			"source": "iana"
		},
		"text/fwdred": {
			"source": "iana"
		},
		"text/grammar-ref-list": {
			"source": "iana"
		},
		"text/hjson": {
			"extensions": [
				"hjson"
			]
		},
		"text/html": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"html",
				"htm",
				"shtml"
			]
		},
		"text/jade": {
			"extensions": [
				"jade"
			]
		},
		"text/javascript": {
			"source": "iana",
			"compressible": true
		},
		"text/jcr-cnd": {
			"source": "iana"
		},
		"text/jsx": {
			"compressible": true,
			"extensions": [
				"jsx"
			]
		},
		"text/less": {
			"extensions": [
				"less"
			]
		},
		"text/markdown": {
			"source": "iana"
		},
		"text/mathml": {
			"source": "nginx",
			"extensions": [
				"mml"
			]
		},
		"text/mizar": {
			"source": "iana"
		},
		"text/n3": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"n3"
			]
		},
		"text/parameters": {
			"source": "iana"
		},
		"text/parityfec": {
			"source": "iana"
		},
		"text/plain": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"txt",
				"text",
				"conf",
				"def",
				"list",
				"log",
				"in",
				"ini"
			]
		},
		"text/provenance-notation": {
			"source": "iana"
		},
		"text/prs.fallenstein.rst": {
			"source": "iana"
		},
		"text/prs.lines.tag": {
			"source": "iana",
			"extensions": [
				"dsc"
			]
		},
		"text/prs.prop.logic": {
			"source": "iana"
		},
		"text/raptorfec": {
			"source": "iana"
		},
		"text/red": {
			"source": "iana"
		},
		"text/rfc822-headers": {
			"source": "iana"
		},
		"text/richtext": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"rtx"
			]
		},
		"text/rtf": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"rtf"
			]
		},
		"text/rtp-enc-aescm128": {
			"source": "iana"
		},
		"text/rtploopback": {
			"source": "iana"
		},
		"text/rtx": {
			"source": "iana"
		},
		"text/sgml": {
			"source": "iana",
			"extensions": [
				"sgml",
				"sgm"
			]
		},
		"text/slim": {
			"extensions": [
				"slim",
				"slm"
			]
		},
		"text/stylus": {
			"extensions": [
				"stylus",
				"styl"
			]
		},
		"text/t140": {
			"source": "iana"
		},
		"text/tab-separated-values": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"tsv"
			]
		},
		"text/troff": {
			"source": "iana",
			"extensions": [
				"t",
				"tr",
				"roff",
				"man",
				"me",
				"ms"
			]
		},
		"text/turtle": {
			"source": "iana",
			"extensions": [
				"ttl"
			]
		},
		"text/ulpfec": {
			"source": "iana"
		},
		"text/uri-list": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"uri",
				"uris",
				"urls"
			]
		},
		"text/vcard": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"vcard"
			]
		},
		"text/vnd.a": {
			"source": "iana"
		},
		"text/vnd.abc": {
			"source": "iana"
		},
		"text/vnd.ascii-art": {
			"source": "iana"
		},
		"text/vnd.curl": {
			"source": "iana",
			"extensions": [
				"curl"
			]
		},
		"text/vnd.curl.dcurl": {
			"source": "apache",
			"extensions": [
				"dcurl"
			]
		},
		"text/vnd.curl.mcurl": {
			"source": "apache",
			"extensions": [
				"mcurl"
			]
		},
		"text/vnd.curl.scurl": {
			"source": "apache",
			"extensions": [
				"scurl"
			]
		},
		"text/vnd.debian.copyright": {
			"source": "iana"
		},
		"text/vnd.dmclientscript": {
			"source": "iana"
		},
		"text/vnd.dvb.subtitle": {
			"source": "iana",
			"extensions": [
				"sub"
			]
		},
		"text/vnd.esmertec.theme-descriptor": {
			"source": "iana"
		},
		"text/vnd.fly": {
			"source": "iana",
			"extensions": [
				"fly"
			]
		},
		"text/vnd.fmi.flexstor": {
			"source": "iana",
			"extensions": [
				"flx"
			]
		},
		"text/vnd.graphviz": {
			"source": "iana",
			"extensions": [
				"gv"
			]
		},
		"text/vnd.in3d.3dml": {
			"source": "iana",
			"extensions": [
				"3dml"
			]
		},
		"text/vnd.in3d.spot": {
			"source": "iana",
			"extensions": [
				"spot"
			]
		},
		"text/vnd.iptc.newsml": {
			"source": "iana"
		},
		"text/vnd.iptc.nitf": {
			"source": "iana"
		},
		"text/vnd.latex-z": {
			"source": "iana"
		},
		"text/vnd.motorola.reflex": {
			"source": "iana"
		},
		"text/vnd.ms-mediapackage": {
			"source": "iana"
		},
		"text/vnd.net2phone.commcenter.command": {
			"source": "iana"
		},
		"text/vnd.radisys.msml-basic-layout": {
			"source": "iana"
		},
		"text/vnd.si.uricatalogue": {
			"source": "iana"
		},
		"text/vnd.sun.j2me.app-descriptor": {
			"source": "iana",
			"extensions": [
				"jad"
			]
		},
		"text/vnd.trolltech.linguist": {
			"source": "iana"
		},
		"text/vnd.wap.si": {
			"source": "iana"
		},
		"text/vnd.wap.sl": {
			"source": "iana"
		},
		"text/vnd.wap.wml": {
			"source": "iana",
			"extensions": [
				"wml"
			]
		},
		"text/vnd.wap.wmlscript": {
			"source": "iana",
			"extensions": [
				"wmls"
			]
		},
		"text/vtt": {
			"charset": "UTF-8",
			"compressible": true,
			"extensions": [
				"vtt"
			]
		},
		"text/x-asm": {
			"source": "apache",
			"extensions": [
				"s",
				"asm"
			]
		},
		"text/x-c": {
			"source": "apache",
			"extensions": [
				"c",
				"cc",
				"cxx",
				"cpp",
				"h",
				"hh",
				"dic"
			]
		},
		"text/x-component": {
			"source": "nginx",
			"extensions": [
				"htc"
			]
		},
		"text/x-fortran": {
			"source": "apache",
			"extensions": [
				"f",
				"for",
				"f77",
				"f90"
			]
		},
		"text/x-gwt-rpc": {
			"compressible": true
		},
		"text/x-handlebars-template": {
			"extensions": [
				"hbs"
			]
		},
		"text/x-java-source": {
			"source": "apache",
			"extensions": [
				"java"
			]
		},
		"text/x-jquery-tmpl": {
			"compressible": true
		},
		"text/x-lua": {
			"extensions": [
				"lua"
			]
		},
		"text/x-markdown": {
			"compressible": true,
			"extensions": [
				"markdown",
				"md",
				"mkd"
			]
		},
		"text/x-nfo": {
			"source": "apache",
			"extensions": [
				"nfo"
			]
		},
		"text/x-opml": {
			"source": "apache",
			"extensions": [
				"opml"
			]
		},
		"text/x-pascal": {
			"source": "apache",
			"extensions": [
				"p",
				"pas"
			]
		},
		"text/x-processing": {
			"compressible": true,
			"extensions": [
				"pde"
			]
		},
		"text/x-sass": {
			"extensions": [
				"sass"
			]
		},
		"text/x-scss": {
			"extensions": [
				"scss"
			]
		},
		"text/x-setext": {
			"source": "apache",
			"extensions": [
				"etx"
			]
		},
		"text/x-sfv": {
			"source": "apache",
			"extensions": [
				"sfv"
			]
		},
		"text/x-suse-ymp": {
			"compressible": true,
			"extensions": [
				"ymp"
			]
		},
		"text/x-uuencode": {
			"source": "apache",
			"extensions": [
				"uu"
			]
		},
		"text/x-vcalendar": {
			"source": "apache",
			"extensions": [
				"vcs"
			]
		},
		"text/x-vcard": {
			"source": "apache",
			"extensions": [
				"vcf"
			]
		},
		"text/xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"xml"
			]
		},
		"text/xml-external-parsed-entity": {
			"source": "iana"
		},
		"text/yaml": {
			"extensions": [
				"yaml",
				"yml"
			]
		},
		"video/1d-interleaved-parityfec": {
			"source": "apache"
		},
		"video/3gpp": {
			"source": "apache",
			"extensions": [
				"3gp",
				"3gpp"
			]
		},
		"video/3gpp-tt": {
			"source": "apache"
		},
		"video/3gpp2": {
			"source": "apache",
			"extensions": [
				"3g2"
			]
		},
		"video/bmpeg": {
			"source": "apache"
		},
		"video/bt656": {
			"source": "apache"
		},
		"video/celb": {
			"source": "apache"
		},
		"video/dv": {
			"source": "apache"
		},
		"video/encaprtp": {
			"source": "apache"
		},
		"video/h261": {
			"source": "apache",
			"extensions": [
				"h261"
			]
		},
		"video/h263": {
			"source": "apache",
			"extensions": [
				"h263"
			]
		},
		"video/h263-1998": {
			"source": "apache"
		},
		"video/h263-2000": {
			"source": "apache"
		},
		"video/h264": {
			"source": "apache",
			"extensions": [
				"h264"
			]
		},
		"video/h264-rcdo": {
			"source": "apache"
		},
		"video/h264-svc": {
			"source": "apache"
		},
		"video/h265": {
			"source": "apache"
		},
		"video/iso.segment": {
			"source": "apache"
		},
		"video/jpeg": {
			"source": "apache",
			"extensions": [
				"jpgv"
			]
		},
		"video/jpeg2000": {
			"source": "apache"
		},
		"video/jpm": {
			"source": "apache",
			"extensions": [
				"jpm",
				"jpgm"
			]
		},
		"video/mj2": {
			"source": "apache",
			"extensions": [
				"mj2",
				"mjp2"
			]
		},
		"video/mp1s": {
			"source": "apache"
		},
		"video/mp2p": {
			"source": "apache"
		},
		"video/mp2t": {
			"source": "apache",
			"extensions": [
				"ts"
			]
		},
		"video/mp4": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"mp4",
				"mp4v",
				"mpg4"
			]
		},
		"video/mp4v-es": {
			"source": "apache"
		},
		"video/mpeg": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"mpeg",
				"mpg",
				"mpe",
				"m1v",
				"m2v"
			]
		},
		"video/mpeg4-generic": {
			"source": "apache"
		},
		"video/mpv": {
			"source": "apache"
		},
		"video/nv": {
			"source": "apache"
		},
		"video/ogg": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"ogv"
			]
		},
		"video/parityfec": {
			"source": "apache"
		},
		"video/pointer": {
			"source": "apache"
		},
		"video/quicktime": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"qt",
				"mov"
			]
		},
		"video/raptorfec": {
			"source": "apache"
		},
		"video/raw": {
			"source": "apache"
		},
		"video/rtp-enc-aescm128": {
			"source": "apache"
		},
		"video/rtploopback": {
			"source": "apache"
		},
		"video/rtx": {
			"source": "apache"
		},
		"video/smpte292m": {
			"source": "apache"
		},
		"video/ulpfec": {
			"source": "apache"
		},
		"video/vc1": {
			"source": "apache"
		},
		"video/vnd.cctv": {
			"source": "apache"
		},
		"video/vnd.dece.hd": {
			"source": "apache",
			"extensions": [
				"uvh",
				"uvvh"
			]
		},
		"video/vnd.dece.mobile": {
			"source": "apache",
			"extensions": [
				"uvm",
				"uvvm"
			]
		},
		"video/vnd.dece.mp4": {
			"source": "apache"
		},
		"video/vnd.dece.pd": {
			"source": "apache",
			"extensions": [
				"uvp",
				"uvvp"
			]
		},
		"video/vnd.dece.sd": {
			"source": "apache",
			"extensions": [
				"uvs",
				"uvvs"
			]
		},
		"video/vnd.dece.video": {
			"source": "apache",
			"extensions": [
				"uvv",
				"uvvv"
			]
		},
		"video/vnd.directv.mpeg": {
			"source": "apache"
		},
		"video/vnd.directv.mpeg-tts": {
			"source": "apache"
		},
		"video/vnd.dlna.mpeg-tts": {
			"source": "apache"
		},
		"video/vnd.dvb.file": {
			"source": "apache",
			"extensions": [
				"dvb"
			]
		},
		"video/vnd.fvt": {
			"source": "apache",
			"extensions": [
				"fvt"
			]
		},
		"video/vnd.hns.video": {
			"source": "apache"
		},
		"video/vnd.iptvforum.1dparityfec-1010": {
			"source": "apache"
		},
		"video/vnd.iptvforum.1dparityfec-2005": {
			"source": "apache"
		},
		"video/vnd.iptvforum.2dparityfec-1010": {
			"source": "apache"
		},
		"video/vnd.iptvforum.2dparityfec-2005": {
			"source": "apache"
		},
		"video/vnd.iptvforum.ttsavc": {
			"source": "apache"
		},
		"video/vnd.iptvforum.ttsmpeg2": {
			"source": "apache"
		},
		"video/vnd.motorola.video": {
			"source": "apache"
		},
		"video/vnd.motorola.videop": {
			"source": "apache"
		},
		"video/vnd.mpegurl": {
			"source": "apache",
			"extensions": [
				"mxu",
				"m4u"
			]
		},
		"video/vnd.ms-playready.media.pyv": {
			"source": "apache",
			"extensions": [
				"pyv"
			]
		},
		"video/vnd.nokia.interleaved-multimedia": {
			"source": "apache"
		},
		"video/vnd.nokia.videovoip": {
			"source": "apache"
		},
		"video/vnd.objectvideo": {
			"source": "apache"
		},
		"video/vnd.radgamettools.bink": {
			"source": "apache"
		},
		"video/vnd.radgamettools.smacker": {
			"source": "apache"
		},
		"video/vnd.sealed.mpeg1": {
			"source": "apache"
		},
		"video/vnd.sealed.mpeg4": {
			"source": "apache"
		},
		"video/vnd.sealed.swf": {
			"source": "apache"
		},
		"video/vnd.sealedmedia.softseal.mov": {
			"source": "apache"
		},
		"video/vnd.uvvu.mp4": {
			"source": "apache",
			"extensions": [
				"uvu",
				"uvvu"
			]
		},
		"video/vnd.vivo": {
			"source": "apache",
			"extensions": [
				"viv"
			]
		},
		"video/vp8": {
			"source": "apache"
		},
		"video/webm": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"webm"
			]
		},
		"video/x-f4v": {
			"source": "apache",
			"extensions": [
				"f4v"
			]
		},
		"video/x-fli": {
			"source": "apache",
			"extensions": [
				"fli"
			]
		},
		"video/x-flv": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"flv"
			]
		},
		"video/x-m4v": {
			"source": "apache",
			"extensions": [
				"m4v"
			]
		},
		"video/x-matroska": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"mkv",
				"mk3d",
				"mks"
			]
		},
		"video/x-mng": {
			"source": "apache",
			"extensions": [
				"mng"
			]
		},
		"video/x-ms-asf": {
			"source": "apache",
			"extensions": [
				"asf",
				"asx"
			]
		},
		"video/x-ms-vob": {
			"source": "apache",
			"extensions": [
				"vob"
			]
		},
		"video/x-ms-wm": {
			"source": "apache",
			"extensions": [
				"wm"
			]
		},
		"video/x-ms-wmv": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"wmv"
			]
		},
		"video/x-ms-wmx": {
			"source": "apache",
			"extensions": [
				"wmx"
			]
		},
		"video/x-ms-wvx": {
			"source": "apache",
			"extensions": [
				"wvx"
			]
		},
		"video/x-msvideo": {
			"source": "apache",
			"extensions": [
				"avi"
			]
		},
		"video/x-sgi-movie": {
			"source": "apache",
			"extensions": [
				"movie"
			]
		},
		"video/x-smv": {
			"source": "apache",
			"extensions": [
				"smv"
			]
		},
		"x-conference/x-cooltalk": {
			"source": "apache",
			"extensions": [
				"ice"
			]
		},
		"x-shader/x-fragment": {
			"compressible": true
		},
		"x-shader/x-vertex": {
			"compressible": true
		}
	};

/***/ },
/* 11 */
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ function(module, exports) {

	module.exports = require("path");

/***/ },
/* 12 */
/*!**************************!*\
  !*** ./~/bytes/index.js ***!
  \**************************/
/***/ function(module, exports) {

	/*!
	 * bytes
	 * Copyright(c) 2012-2014 TJ Holowaychuk
	 * Copyright(c) 2015 Jed Watson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = bytes;
	module.exports.format = format;
	module.exports.parse = parse;

	/**
	 * Module variables.
	 * @private
	 */

	var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;

	var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;

	var map = {
	  b:  1,
	  kb: 1 << 10,
	  mb: 1 << 20,
	  gb: 1 << 30,
	  tb: ((1 << 30) * 1024)
	};

	// TODO: use is-finite module?
	var numberIsFinite = Number.isFinite || function (v) { return typeof v === 'number' && isFinite(v); };

	var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb)$/i;

	/**
	 * Convert the given value in bytes into a string or parse to string to an integer in bytes.
	 *
	 * @param {string|number} value
	 * @param {{
	 *  case: [string],
	 *  decimalPlaces: [number]
	 *  fixedDecimals: [boolean]
	 *  thousandsSeparator: [string]
	 *  }} [options] bytes options.
	 *
	 * @returns {string|number|null}
	 */

	function bytes(value, options) {
	  if (typeof value === 'string') {
	    return parse(value);
	  }

	  if (typeof value === 'number') {
	    return format(value, options);
	  }

	  return null;
	}

	/**
	 * Format the given value in bytes into a string.
	 *
	 * If the value is negative, it is kept as such. If it is a float,
	 * it is rounded.
	 *
	 * @param {number} value
	 * @param {object} [options]
	 * @param {number} [options.decimalPlaces=2]
	 * @param {number} [options.fixedDecimals=false]
	 * @param {string} [options.thousandsSeparator=]
	 *
	 * @returns {string|null}
	 * @public
	 */

	function format(value, options) {
	  if (!numberIsFinite(value)) {
	    return null;
	  }

	  var mag = Math.abs(value);
	  var thousandsSeparator = (options && options.thousandsSeparator) || '';
	  var decimalPlaces = (options && options.decimalPlaces !== undefined) ? options.decimalPlaces : 2;
	  var fixedDecimals = Boolean(options && options.fixedDecimals);
	  var unit = 'B';

	  if (mag >= map.tb) {
	    unit = 'TB';
	  } else if (mag >= map.gb) {
	    unit = 'GB';
	  } else if (mag >= map.mb) {
	    unit = 'MB';
	  } else if (mag >= map.kb) {
	    unit = 'kB';
	  }

	  var val = value / map[unit.toLowerCase()];
	  var str = val.toFixed(decimalPlaces);

	  if (!fixedDecimals) {
	    str = str.replace(formatDecimalsRegExp, '$1');
	  }

	  if (thousandsSeparator) {
	    str = str.replace(formatThousandsRegExp, thousandsSeparator);
	  }

	  return str + unit;
	}

	/**
	 * Parse the string value into an integer in bytes.
	 *
	 * If no unit is given, it is assumed the value is in bytes.
	 *
	 * @param {number|string} val
	 *
	 * @returns {number|null}
	 * @public
	 */

	function parse(val) {
	  if (typeof val === 'number' && !isNaN(val)) {
	    return val;
	  }

	  if (typeof val !== 'string') {
	    return null;
	  }

	  // Test if the string passed is valid
	  var results = parseRegExp.exec(val);
	  var floatValue;
	  var unit = 'b';

	  if (!results) {
	    // Nothing could be extracted from the given string
	    floatValue = parseInt(val, 10);
	    unit = 'b'
	  } else {
	    // Retrieve the value and the unit
	    floatValue = parseFloat(results[1]);
	    unit = results[4].toLowerCase();
	  }

	  return Math.floor(map[unit] * floatValue);
	}


/***/ },
/* 13 */
/*!*********************************!*\
  !*** ./~/compressible/index.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * compressible
	 * Copyright(c) 2013 Jonathan Ong
	 * Copyright(c) 2014 Jeremiah Senkpiel
	 * Copyright(c) 2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict'

	/**
	 * Module dependencies.
	 * @private
	 */

	var db = __webpack_require__(/*! mime-db */ 9)

	/**
	 * Module variables.
	 * @private
	 */

	var compressibleTypeRegExp = /^text\/|\+json$|\+text$|\+xml$/i
	var extractTypeRegExp = /^\s*([^;\s]*)(?:;|\s|$)/

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = compressible

	/**
	 * Checks if a type is compressible.
	 *
	 * @param {string} type
	 * @return {Boolean} compressible
	 * @public
	 */

	function compressible (type) {
	  if (!type || typeof type !== 'string') {
	    return false
	  }

	  // strip parameters
	  var match = extractTypeRegExp.exec(type)
	  var mime = match && match[1].toLowerCase()
	  var data = db[mime]

	  if ((data && data.compressible) || compressibleTypeRegExp.test(mime)) {
	    return true
	  }

	  return data
	    ? data.compressible
	    : undefined
	}


/***/ },
/* 14 */
/*!*************************!*\
  !*** ./~/debug/node.js ***!
  \*************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */

	var tty = __webpack_require__(/*! tty */ 15);
	var util = __webpack_require__(/*! util */ 16);

	/**
	 * This is the Node.js implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = __webpack_require__(/*! ./debug */ 17);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;

	/**
	 * Colors.
	 */

	exports.colors = [6, 2, 3, 4, 5, 1];

	/**
	 * The file descriptor to write the `debug()` calls to.
	 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
	 *
	 *   $ DEBUG_FD=3 node script.js 3>debug.log
	 */

	var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
	var stream = 1 === fd ? process.stdout :
	             2 === fd ? process.stderr :
	             createWritableStdioStream(fd);

	/**
	 * Is stdout a TTY? Colored output is enabled when `true`.
	 */

	function useColors() {
	  var debugColors = (process.env.DEBUG_COLORS || '').trim().toLowerCase();
	  if (0 === debugColors.length) {
	    return tty.isatty(fd);
	  } else {
	    return '0' !== debugColors
	        && 'no' !== debugColors
	        && 'false' !== debugColors
	        && 'disabled' !== debugColors;
	  }
	}

	/**
	 * Map %o to `util.inspect()`, since Node doesn't do that out of the box.
	 */

	var inspect = (4 === util.inspect.length ?
	  // node <= 0.8.x
	  function (v, colors) {
	    return util.inspect(v, void 0, void 0, colors);
	  } :
	  // node > 0.8.x
	  function (v, colors) {
	    return util.inspect(v, { colors: colors });
	  }
	);

	exports.formatters.o = function(v) {
	  return inspect(v, this.useColors)
	    .replace(/\s*\n\s*/g, ' ');
	};

	/**
	 * Adds ANSI color escape codes if enabled.
	 *
	 * @api public
	 */

	function formatArgs() {
	  var args = arguments;
	  var useColors = this.useColors;
	  var name = this.namespace;

	  if (useColors) {
	    var c = this.color;

	    args[0] = '  \u001b[3' + c + ';1m' + name + ' '
	      + '\u001b[0m'
	      + args[0] + '\u001b[3' + c + 'm'
	      + ' +' + exports.humanize(this.diff) + '\u001b[0m';
	  } else {
	    args[0] = new Date().toUTCString()
	      + ' ' + name + ' ' + args[0];
	  }
	  return args;
	}

	/**
	 * Invokes `console.error()` with the specified arguments.
	 */

	function log() {
	  return stream.write(util.format.apply(this, arguments) + '\n');
	}

	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */

	function save(namespaces) {
	  if (null == namespaces) {
	    // If you set a process.env field to null or undefined, it gets cast to the
	    // string 'null' or 'undefined'. Just delete instead.
	    delete process.env.DEBUG;
	  } else {
	    process.env.DEBUG = namespaces;
	  }
	}

	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */

	function load() {
	  return process.env.DEBUG;
	}

	/**
	 * Copied from `node/src/node.js`.
	 *
	 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
	 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
	 */

	function createWritableStdioStream (fd) {
	  var stream;
	  var tty_wrap = process.binding('tty_wrap');

	  // Note stream._type is used for test-module-load-list.js

	  switch (tty_wrap.guessHandleType(fd)) {
	    case 'TTY':
	      stream = new tty.WriteStream(fd);
	      stream._type = 'tty';

	      // Hack to have stream not keep the event loop alive.
	      // See https://github.com/joyent/node/issues/1726
	      if (stream._handle && stream._handle.unref) {
	        stream._handle.unref();
	      }
	      break;

	    case 'FILE':
	      var fs = __webpack_require__(/*! fs */ 19);
	      stream = new fs.SyncWriteStream(fd, { autoClose: false });
	      stream._type = 'fs';
	      break;

	    case 'PIPE':
	    case 'TCP':
	      var net = __webpack_require__(/*! net */ 20);
	      stream = new net.Socket({
	        fd: fd,
	        readable: false,
	        writable: true
	      });

	      // FIXME Should probably have an option in net.Socket to create a
	      // stream from an existing fd which is writable only. But for now
	      // we'll just add this hack and set the `readable` member to false.
	      // Test: ./node test/fixtures/echo.js < /etc/passwd
	      stream.readable = false;
	      stream.read = null;
	      stream._type = 'pipe';

	      // FIXME Hack to have stream not keep the event loop alive.
	      // See https://github.com/joyent/node/issues/1726
	      if (stream._handle && stream._handle.unref) {
	        stream._handle.unref();
	      }
	      break;

	    default:
	      // Probably an error on in uv_guess_handle()
	      throw new Error('Implement me. Unknown stream file type!');
	  }

	  // For supporting legacy API we put the FD here.
	  stream.fd = fd;

	  stream._isStdio = true;

	  return stream;
	}

	/**
	 * Enable namespaces listed in `process.env.DEBUG` initially.
	 */

	exports.enable(load());


/***/ },
/* 15 */
/*!**********************!*\
  !*** external "tty" ***!
  \**********************/
/***/ function(module, exports) {

	module.exports = require("tty");

/***/ },
/* 16 */
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ function(module, exports) {

	module.exports = require("util");

/***/ },
/* 17 */
/*!**************************!*\
  !*** ./~/debug/debug.js ***!
  \**************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = debug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(/*! ms */ 18);

	/**
	 * The currently active debug mode names, and names to skip.
	 */

	exports.names = [];
	exports.skips = [];

	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lowercased letter, i.e. "n".
	 */

	exports.formatters = {};

	/**
	 * Previously assigned color.
	 */

	var prevColor = 0;

	/**
	 * Previous log timestamp.
	 */

	var prevTime;

	/**
	 * Select a color.
	 *
	 * @return {Number}
	 * @api private
	 */

	function selectColor() {
	  return exports.colors[prevColor++ % exports.colors.length];
	}

	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */

	function debug(namespace) {

	  // define the `disabled` version
	  function disabled() {
	  }
	  disabled.enabled = false;

	  // define the `enabled` version
	  function enabled() {

	    var self = enabled;

	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;

	    // add the `color` if not set
	    if (null == self.useColors) self.useColors = exports.useColors();
	    if (null == self.color && self.useColors) self.color = selectColor();

	    var args = Array.prototype.slice.call(arguments);

	    args[0] = exports.coerce(args[0]);

	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %o
	      args = ['%o'].concat(args);
	    }

	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);

	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });

	    if ('function' === typeof exports.formatArgs) {
	      args = exports.formatArgs.apply(self, args);
	    }
	    var logFn = enabled.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	  enabled.enabled = true;

	  var fn = exports.enabled(namespace) ? enabled : disabled;

	  fn.namespace = namespace;

	  return fn;
	}

	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */

	function enable(namespaces) {
	  exports.save(namespaces);

	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;

	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}

	/**
	 * Disable debug output.
	 *
	 * @api public
	 */

	function disable() {
	  exports.enable('');
	}

	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */

	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */

	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ },
/* 18 */
/*!***********************!*\
  !*** ./~/ms/index.js ***!
  \***********************/
/***/ function(module, exports) {

	/**
	 * Helpers.
	 */

	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @return {String|Number}
	 * @api public
	 */

	module.exports = function(val, options){
	  options = options || {};
	  if ('string' == typeof val) return parse(val);
	  return options.long
	    ? long(val)
	    : short(val);
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = '' + str;
	  if (str.length > 10000) return;
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) return;
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function short(ms) {
	  if (ms >= d) return Math.round(ms / d) + 'd';
	  if (ms >= h) return Math.round(ms / h) + 'h';
	  if (ms >= m) return Math.round(ms / m) + 'm';
	  if (ms >= s) return Math.round(ms / s) + 's';
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function long(ms) {
	  return plural(ms, d, 'day')
	    || plural(ms, h, 'hour')
	    || plural(ms, m, 'minute')
	    || plural(ms, s, 'second')
	    || ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, n, name) {
	  if (ms < n) return;
	  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}


/***/ },
/* 19 */
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ function(module, exports) {

	module.exports = require("fs");

/***/ },
/* 20 */
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ function(module, exports) {

	module.exports = require("net");

/***/ },
/* 21 */
/*!*******************************!*\
  !*** ./~/on-headers/index.js ***!
  \*******************************/
/***/ function(module, exports) {

	/*!
	 * on-headers
	 * Copyright(c) 2014 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict'

	/**
	 * Reference to Array slice.
	 */

	var slice = Array.prototype.slice

	/**
	 * Execute a listener when a response is about to write headers.
	 *
	 * @param {Object} res
	 * @return {Function} listener
	 * @api public
	 */

	module.exports = function onHeaders(res, listener) {
	  if (!res) {
	    throw new TypeError('argument res is required')
	  }

	  if (typeof listener !== 'function') {
	    throw new TypeError('argument listener must be a function')
	  }

	  res.writeHead = createWriteHead(res.writeHead, listener)
	}

	function createWriteHead(prevWriteHead, listener) {
	  var fired = false;

	  // return function with core name and argument list
	  return function writeHead(statusCode) {
	    // set headers from arguments
	    var args = setWriteHeadHeaders.apply(this, arguments);

	    // fire listener
	    if (!fired) {
	      fired = true
	      listener.call(this)

	      // pass-along an updated status code
	      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {
	        args[0] = this.statusCode
	        args.length = 1
	      }
	    }

	    prevWriteHead.apply(this, args);
	  }
	}

	function setWriteHeadHeaders(statusCode) {
	  var length = arguments.length
	  var headerIndex = length > 1 && typeof arguments[1] === 'string'
	    ? 2
	    : 1

	  var headers = length >= headerIndex + 1
	    ? arguments[headerIndex]
	    : undefined

	  this.statusCode = statusCode

	  // the following block is from node.js core
	  if (Array.isArray(headers)) {
	    // handle array case
	    for (var i = 0, len = headers.length; i < len; ++i) {
	      this.setHeader(headers[i][0], headers[i][1])
	    }
	  } else if (headers) {
	    // handle object case
	    var keys = Object.keys(headers)
	    for (var i = 0; i < keys.length; i++) {
	      var k = keys[i]
	      if (k) this.setHeader(k, headers[k])
	    }
	  }

	  // copy leading arguments
	  var args = new Array(Math.min(length, headerIndex))
	  for (var i = 0; i < args.length; i++) {
	    args[i] = arguments[i]
	  }

	  return args
	}


/***/ },
/* 22 */
/*!*************************!*\
  !*** ./~/vary/index.js ***!
  \*************************/
/***/ function(module, exports) {

	/*!
	 * vary
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module exports.
	 */

	module.exports = vary;
	module.exports.append = append;

	/**
	 * RegExp to match field-name in RFC 7230 sec 3.2
	 *
	 * field-name    = token
	 * token         = 1*tchar
	 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
	 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
	 *               / DIGIT / ALPHA
	 *               ; any VCHAR, except delimiters
	 */

	var fieldNameRegExp = /^[!#$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+$/

	/**
	 * Append a field to a vary header.
	 *
	 * @param {String} header
	 * @param {String|Array} field
	 * @return {String}
	 * @api public
	 */

	function append(header, field) {
	  if (typeof header !== 'string') {
	    throw new TypeError('header argument is required');
	  }

	  if (!field) {
	    throw new TypeError('field argument is required');
	  }

	  // get fields array
	  var fields = !Array.isArray(field)
	    ? parse(String(field))
	    : field;

	  // assert on invalid field names
	  for (var i = 0; i < fields.length; i++) {
	    if (!fieldNameRegExp.test(fields[i])) {
	      throw new TypeError('field argument contains an invalid header name');
	    }
	  }

	  // existing, unspecified vary
	  if (header === '*') {
	    return header;
	  }

	  // enumerate current values
	  var val = header;
	  var vals = parse(header.toLowerCase());

	  // unspecified vary
	  if (fields.indexOf('*') !== -1 || vals.indexOf('*') !== -1) {
	    return '*';
	  }

	  for (var i = 0; i < fields.length; i++) {
	    var fld = fields[i].toLowerCase();

	    // append value (case-preserving)
	    if (vals.indexOf(fld) === -1) {
	      vals.push(fld);
	      val = val
	        ? val + ', ' + fields[i]
	        : fields[i];
	    }
	  }

	  return val;
	}

	/**
	 * Parse a vary header into an array.
	 *
	 * @param {String} header
	 * @return {Array}
	 * @api private
	 */

	function parse(header) {
	  return header.trim().split(/ *, */);
	}

	/**
	 * Mark that a request is varied on a header field.
	 *
	 * @param {Object} res
	 * @param {String|Array} field
	 * @api public
	 */

	function vary(res, field) {
	  if (!res || !res.getHeader || !res.setHeader) {
	    // quack quack
	    throw new TypeError('res argument is required');
	  }

	  // get existing header
	  var val = res.getHeader('Vary') || ''
	  var header = Array.isArray(val)
	    ? val.join(', ')
	    : String(val);

	  // set new header
	  if ((val = append(header, field))) {
	    res.setHeader('Vary', val);
	  }
	}


/***/ },
/* 23 */
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ function(module, exports) {

	module.exports = require("zlib");

/***/ },
/* 24 */
/*!****************************!*\
  !*** ./~/express/index.js ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2013 Roman Shtylman
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	module.exports = __webpack_require__(/*! ./lib/express */ 25);


/***/ },
/* 25 */
/*!**********************************!*\
  !*** ./~/express/lib/express.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2013 Roman Shtylman
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 */

	var EventEmitter = __webpack_require__(/*! events */ 26).EventEmitter;
	var mixin = __webpack_require__(/*! merge-descriptors */ 27);
	var proto = __webpack_require__(/*! ./application */ 28);
	var Route = __webpack_require__(/*! ./router/route */ 37);
	var Router = __webpack_require__(/*! ./router */ 36);
	var req = __webpack_require__(/*! ./request */ 81);
	var res = __webpack_require__(/*! ./response */ 84);

	/**
	 * Expose `createApplication()`.
	 */

	exports = module.exports = createApplication;

	/**
	 * Create an express application.
	 *
	 * @return {Function}
	 * @api public
	 */

	function createApplication() {
	  var app = function(req, res, next) {
	    app.handle(req, res, next);
	  };

	  mixin(app, EventEmitter.prototype, false);
	  mixin(app, proto, false);

	  app.request = { __proto__: req, app: app };
	  app.response = { __proto__: res, app: app };
	  app.init();
	  return app;
	}

	/**
	 * Expose the prototypes.
	 */

	exports.application = proto;
	exports.request = req;
	exports.response = res;

	/**
	 * Expose constructors.
	 */

	exports.Route = Route;
	exports.Router = Router;

	/**
	 * Expose middleware
	 */

	exports.query = __webpack_require__(/*! ./middleware/query */ 53);
	exports.static = __webpack_require__(/*! serve-static */ 87);

	/**
	 * Replace removed middleware with an appropriate error message.
	 */

	[
	  'json',
	  'urlencoded',
	  'bodyParser',
	  'compress',
	  'cookieSession',
	  'session',
	  'logger',
	  'cookieParser',
	  'favicon',
	  'responseTime',
	  'errorHandler',
	  'timeout',
	  'methodOverride',
	  'vhost',
	  'csrf',
	  'directory',
	  'limit',
	  'multipart',
	  'staticCache',
	].forEach(function (name) {
	  Object.defineProperty(exports, name, {
	    get: function () {
	      throw new Error('Most middleware (like ' + name + ') is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.');
	    },
	    configurable: true
	  });
	});


/***/ },
/* 26 */
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ function(module, exports) {

	module.exports = require("events");

/***/ },
/* 27 */
/*!**************************************!*\
  !*** ./~/merge-descriptors/index.js ***!
  \**************************************/
/***/ function(module, exports) {

	/*!
	 * merge-descriptors
	 * Copyright(c) 2014 Jonathan Ong
	 * Copyright(c) 2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict'

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = merge

	/**
	 * Module variables.
	 * @private
	 */

	var hasOwnProperty = Object.prototype.hasOwnProperty

	/**
	 * Merge the property descriptors of `src` into `dest`
	 *
	 * @param {object} dest Object to add descriptors to
	 * @param {object} src Object to clone descriptors from
	 * @param {boolean} [redefine=true] Redefine `dest` properties with `src` properties
	 * @returns {object} Reference to dest
	 * @public
	 */

	function merge(dest, src, redefine) {
	  if (!dest) {
	    throw new TypeError('argument dest is required')
	  }

	  if (!src) {
	    throw new TypeError('argument src is required')
	  }

	  if (redefine === undefined) {
	    // Default to true
	    redefine = true
	  }

	  Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName(name) {
	    if (!redefine && hasOwnProperty.call(dest, name)) {
	      // Skip desriptor
	      return
	    }

	    // Copy descriptor
	    var descriptor = Object.getOwnPropertyDescriptor(src, name)
	    Object.defineProperty(dest, name, descriptor)
	  })

	  return dest
	}


/***/ },
/* 28 */
/*!**************************************!*\
  !*** ./~/express/lib/application.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2013 Roman Shtylman
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @private
	 */

	var finalhandler = __webpack_require__(/*! finalhandler */ 29);
	var Router = __webpack_require__(/*! ./router */ 36);
	var methods = __webpack_require__(/*! methods */ 41);
	var middleware = __webpack_require__(/*! ./middleware/init */ 52);
	var query = __webpack_require__(/*! ./middleware/query */ 53);
	var debug = __webpack_require__(/*! debug */ 14)('express:application');
	var View = __webpack_require__(/*! ./view */ 58);
	var http = __webpack_require__(/*! http */ 42);
	var compileETag = __webpack_require__(/*! ./utils */ 59).compileETag;
	var compileQueryParser = __webpack_require__(/*! ./utils */ 59).compileQueryParser;
	var compileTrust = __webpack_require__(/*! ./utils */ 59).compileTrust;
	var deprecate = __webpack_require__(/*! depd */ 44)('express');
	var flatten = __webpack_require__(/*! array-flatten */ 38);
	var merge = __webpack_require__(/*! utils-merge */ 43);
	var resolve = __webpack_require__(/*! path */ 11).resolve;
	var slice = Array.prototype.slice;

	/**
	 * Application prototype.
	 */

	var app = exports = module.exports = {};

	/**
	 * Variable for trust proxy inheritance back-compat
	 * @private
	 */

	var trustProxyDefaultSymbol = '@@symbol:trust_proxy_default';

	/**
	 * Initialize the server.
	 *
	 *   - setup default configuration
	 *   - setup default middleware
	 *   - setup route reflection methods
	 *
	 * @private
	 */

	app.init = function init() {
	  this.cache = {};
	  this.engines = {};
	  this.settings = {};

	  this.defaultConfiguration();
	};

	/**
	 * Initialize application configuration.
	 * @private
	 */

	app.defaultConfiguration = function defaultConfiguration() {
	  var env = process.env.NODE_ENV || 'development';

	  // default settings
	  this.enable('x-powered-by');
	  this.set('etag', 'weak');
	  this.set('env', env);
	  this.set('query parser', 'extended');
	  this.set('subdomain offset', 2);
	  this.set('trust proxy', false);

	  // trust proxy inherit back-compat
	  Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
	    configurable: true,
	    value: true
	  });

	  debug('booting in %s mode', env);

	  this.on('mount', function onmount(parent) {
	    // inherit trust proxy
	    if (this.settings[trustProxyDefaultSymbol] === true
	      && typeof parent.settings['trust proxy fn'] === 'function') {
	      delete this.settings['trust proxy'];
	      delete this.settings['trust proxy fn'];
	    }

	    // inherit protos
	    this.request.__proto__ = parent.request;
	    this.response.__proto__ = parent.response;
	    this.engines.__proto__ = parent.engines;
	    this.settings.__proto__ = parent.settings;
	  });

	  // setup locals
	  this.locals = Object.create(null);

	  // top-most app is mounted at /
	  this.mountpath = '/';

	  // default locals
	  this.locals.settings = this.settings;

	  // default configuration
	  this.set('view', View);
	  this.set('views', resolve('views'));
	  this.set('jsonp callback name', 'callback');

	  if (env === 'production') {
	    this.enable('view cache');
	  }

	  Object.defineProperty(this, 'router', {
	    get: function() {
	      throw new Error('\'app.router\' is deprecated!\nPlease see the 3.x to 4.x migration guide for details on how to update your app.');
	    }
	  });
	};

	/**
	 * lazily adds the base router if it has not yet been added.
	 *
	 * We cannot add the base router in the defaultConfiguration because
	 * it reads app settings which might be set after that has run.
	 *
	 * @private
	 */
	app.lazyrouter = function lazyrouter() {
	  if (!this._router) {
	    this._router = new Router({
	      caseSensitive: this.enabled('case sensitive routing'),
	      strict: this.enabled('strict routing')
	    });

	    this._router.use(query(this.get('query parser fn')));
	    this._router.use(middleware.init(this));
	  }
	};

	/**
	 * Dispatch a req, res pair into the application. Starts pipeline processing.
	 *
	 * If no callback is provided, then default error handlers will respond
	 * in the event of an error bubbling through the stack.
	 *
	 * @private
	 */

	app.handle = function handle(req, res, callback) {
	  var router = this._router;

	  // final handler
	  var done = callback || finalhandler(req, res, {
	    env: this.get('env'),
	    onerror: logerror.bind(this)
	  });

	  // no routes
	  if (!router) {
	    debug('no routes defined on app');
	    done();
	    return;
	  }

	  router.handle(req, res, done);
	};

	/**
	 * Proxy `Router#use()` to add middleware to the app router.
	 * See Router#use() documentation for details.
	 *
	 * If the _fn_ parameter is an express app, then it will be
	 * mounted at the _route_ specified.
	 *
	 * @public
	 */

	app.use = function use(fn) {
	  var offset = 0;
	  var path = '/';

	  // default path to '/'
	  // disambiguate app.use([fn])
	  if (typeof fn !== 'function') {
	    var arg = fn;

	    while (Array.isArray(arg) && arg.length !== 0) {
	      arg = arg[0];
	    }

	    // first arg is the path
	    if (typeof arg !== 'function') {
	      offset = 1;
	      path = fn;
	    }
	  }

	  var fns = flatten(slice.call(arguments, offset));

	  if (fns.length === 0) {
	    throw new TypeError('app.use() requires middleware functions');
	  }

	  // setup router
	  this.lazyrouter();
	  var router = this._router;

	  fns.forEach(function (fn) {
	    // non-express app
	    if (!fn || !fn.handle || !fn.set) {
	      return router.use(path, fn);
	    }

	    debug('.use app under %s', path);
	    fn.mountpath = path;
	    fn.parent = this;

	    // restore .app property on req and res
	    router.use(path, function mounted_app(req, res, next) {
	      var orig = req.app;
	      fn.handle(req, res, function (err) {
	        req.__proto__ = orig.request;
	        res.__proto__ = orig.response;
	        next(err);
	      });
	    });

	    // mounted an app
	    fn.emit('mount', this);
	  }, this);

	  return this;
	};

	/**
	 * Proxy to the app `Router#route()`
	 * Returns a new `Route` instance for the _path_.
	 *
	 * Routes are isolated middleware stacks for specific paths.
	 * See the Route api docs for details.
	 *
	 * @public
	 */

	app.route = function route(path) {
	  this.lazyrouter();
	  return this._router.route(path);
	};

	/**
	 * Register the given template engine callback `fn`
	 * as `ext`.
	 *
	 * By default will `require()` the engine based on the
	 * file extension. For example if you try to render
	 * a "foo.jade" file Express will invoke the following internally:
	 *
	 *     app.engine('jade', require('jade').__express);
	 *
	 * For engines that do not provide `.__express` out of the box,
	 * or if you wish to "map" a different extension to the template engine
	 * you may use this method. For example mapping the EJS template engine to
	 * ".html" files:
	 *
	 *     app.engine('html', require('ejs').renderFile);
	 *
	 * In this case EJS provides a `.renderFile()` method with
	 * the same signature that Express expects: `(path, options, callback)`,
	 * though note that it aliases this method as `ejs.__express` internally
	 * so if you're using ".ejs" extensions you dont need to do anything.
	 *
	 * Some template engines do not follow this convention, the
	 * [Consolidate.js](https://github.com/tj/consolidate.js)
	 * library was created to map all of node's popular template
	 * engines to follow this convention, thus allowing them to
	 * work seamlessly within Express.
	 *
	 * @param {String} ext
	 * @param {Function} fn
	 * @return {app} for chaining
	 * @public
	 */

	app.engine = function engine(ext, fn) {
	  if (typeof fn !== 'function') {
	    throw new Error('callback function required');
	  }

	  // get file extension
	  var extension = ext[0] !== '.'
	    ? '.' + ext
	    : ext;

	  // store engine
	  this.engines[extension] = fn;

	  return this;
	};

	/**
	 * Proxy to `Router#param()` with one added api feature. The _name_ parameter
	 * can be an array of names.
	 *
	 * See the Router#param() docs for more details.
	 *
	 * @param {String|Array} name
	 * @param {Function} fn
	 * @return {app} for chaining
	 * @public
	 */

	app.param = function param(name, fn) {
	  this.lazyrouter();

	  if (Array.isArray(name)) {
	    for (var i = 0; i < name.length; i++) {
	      this.param(name[i], fn);
	    }

	    return this;
	  }

	  this._router.param(name, fn);

	  return this;
	};

	/**
	 * Assign `setting` to `val`, or return `setting`'s value.
	 *
	 *    app.set('foo', 'bar');
	 *    app.get('foo');
	 *    // => "bar"
	 *
	 * Mounted servers inherit their parent server's settings.
	 *
	 * @param {String} setting
	 * @param {*} [val]
	 * @return {Server} for chaining
	 * @public
	 */

	app.set = function set(setting, val) {
	  if (arguments.length === 1) {
	    // app.get(setting)
	    return this.settings[setting];
	  }

	  debug('set "%s" to %o', setting, val);

	  // set value
	  this.settings[setting] = val;

	  // trigger matched settings
	  switch (setting) {
	    case 'etag':
	      this.set('etag fn', compileETag(val));
	      break;
	    case 'query parser':
	      this.set('query parser fn', compileQueryParser(val));
	      break;
	    case 'trust proxy':
	      this.set('trust proxy fn', compileTrust(val));

	      // trust proxy inherit back-compat
	      Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
	        configurable: true,
	        value: false
	      });

	      break;
	  }

	  return this;
	};

	/**
	 * Return the app's absolute pathname
	 * based on the parent(s) that have
	 * mounted it.
	 *
	 * For example if the application was
	 * mounted as "/admin", which itself
	 * was mounted as "/blog" then the
	 * return value would be "/blog/admin".
	 *
	 * @return {String}
	 * @private
	 */

	app.path = function path() {
	  return this.parent
	    ? this.parent.path() + this.mountpath
	    : '';
	};

	/**
	 * Check if `setting` is enabled (truthy).
	 *
	 *    app.enabled('foo')
	 *    // => false
	 *
	 *    app.enable('foo')
	 *    app.enabled('foo')
	 *    // => true
	 *
	 * @param {String} setting
	 * @return {Boolean}
	 * @public
	 */

	app.enabled = function enabled(setting) {
	  return Boolean(this.set(setting));
	};

	/**
	 * Check if `setting` is disabled.
	 *
	 *    app.disabled('foo')
	 *    // => true
	 *
	 *    app.enable('foo')
	 *    app.disabled('foo')
	 *    // => false
	 *
	 * @param {String} setting
	 * @return {Boolean}
	 * @public
	 */

	app.disabled = function disabled(setting) {
	  return !this.set(setting);
	};

	/**
	 * Enable `setting`.
	 *
	 * @param {String} setting
	 * @return {app} for chaining
	 * @public
	 */

	app.enable = function enable(setting) {
	  return this.set(setting, true);
	};

	/**
	 * Disable `setting`.
	 *
	 * @param {String} setting
	 * @return {app} for chaining
	 * @public
	 */

	app.disable = function disable(setting) {
	  return this.set(setting, false);
	};

	/**
	 * Delegate `.VERB(...)` calls to `router.VERB(...)`.
	 */

	methods.forEach(function(method){
	  app[method] = function(path){
	    if (method === 'get' && arguments.length === 1) {
	      // app.get(setting)
	      return this.set(path);
	    }

	    this.lazyrouter();

	    var route = this._router.route(path);
	    route[method].apply(route, slice.call(arguments, 1));
	    return this;
	  };
	});

	/**
	 * Special-cased "all" method, applying the given route `path`,
	 * middleware, and callback to _every_ HTTP method.
	 *
	 * @param {String} path
	 * @param {Function} ...
	 * @return {app} for chaining
	 * @public
	 */

	app.all = function all(path) {
	  this.lazyrouter();

	  var route = this._router.route(path);
	  var args = slice.call(arguments, 1);

	  for (var i = 0; i < methods.length; i++) {
	    route[methods[i]].apply(route, args);
	  }

	  return this;
	};

	// del -> delete alias

	app.del = deprecate.function(app.delete, 'app.del: Use app.delete instead');

	/**
	 * Render the given view `name` name with `options`
	 * and a callback accepting an error and the
	 * rendered template string.
	 *
	 * Example:
	 *
	 *    app.render('email', { name: 'Tobi' }, function(err, html){
	 *      // ...
	 *    })
	 *
	 * @param {String} name
	 * @param {Object|Function} options or fn
	 * @param {Function} callback
	 * @public
	 */

	app.render = function render(name, options, callback) {
	  var cache = this.cache;
	  var done = callback;
	  var engines = this.engines;
	  var opts = options;
	  var renderOptions = {};
	  var view;

	  // support callback function as second arg
	  if (typeof options === 'function') {
	    done = options;
	    opts = {};
	  }

	  // merge app.locals
	  merge(renderOptions, this.locals);

	  // merge options._locals
	  if (opts._locals) {
	    merge(renderOptions, opts._locals);
	  }

	  // merge options
	  merge(renderOptions, opts);

	  // set .cache unless explicitly provided
	  if (renderOptions.cache == null) {
	    renderOptions.cache = this.enabled('view cache');
	  }

	  // primed cache
	  if (renderOptions.cache) {
	    view = cache[name];
	  }

	  // view
	  if (!view) {
	    var View = this.get('view');

	    view = new View(name, {
	      defaultEngine: this.get('view engine'),
	      root: this.get('views'),
	      engines: engines
	    });

	    if (!view.path) {
	      var dirs = Array.isArray(view.root) && view.root.length > 1
	        ? 'directories "' + view.root.slice(0, -1).join('", "') + '" or "' + view.root[view.root.length - 1] + '"'
	        : 'directory "' + view.root + '"'
	      var err = new Error('Failed to lookup view "' + name + '" in views ' + dirs);
	      err.view = view;
	      return done(err);
	    }

	    // prime the cache
	    if (renderOptions.cache) {
	      cache[name] = view;
	    }
	  }

	  // render
	  tryRender(view, renderOptions, done);
	};

	/**
	 * Listen for connections.
	 *
	 * A node `http.Server` is returned, with this
	 * application (which is a `Function`) as its
	 * callback. If you wish to create both an HTTP
	 * and HTTPS server you may do so with the "http"
	 * and "https" modules as shown here:
	 *
	 *    var http = require('http')
	 *      , https = require('https')
	 *      , express = require('express')
	 *      , app = express();
	 *
	 *    http.createServer(app).listen(80);
	 *    https.createServer({ ... }, app).listen(443);
	 *
	 * @return {http.Server}
	 * @public
	 */

	app.listen = function listen() {
	  var server = http.createServer(this);
	  return server.listen.apply(server, arguments);
	};

	/**
	 * Log error using console.error.
	 *
	 * @param {Error} err
	 * @private
	 */

	function logerror(err) {
	  /* istanbul ignore next */
	  if (this.get('env') !== 'test') console.error(err.stack || err.toString());
	}

	/**
	 * Try rendering a view.
	 * @private
	 */

	function tryRender(view, options, callback) {
	  try {
	    view.render(options, callback);
	  } catch (err) {
	    callback(err);
	  }
	}


/***/ },
/* 29 */
/*!*********************************!*\
  !*** ./~/finalhandler/index.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * finalhandler
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict'

	/**
	 * Module dependencies.
	 * @private
	 */

	var debug = __webpack_require__(/*! debug */ 14)('finalhandler')
	var escapeHtml = __webpack_require__(/*! escape-html */ 30)
	var onFinished = __webpack_require__(/*! on-finished */ 31)
	var statuses = __webpack_require__(/*! statuses */ 33)
	var unpipe = __webpack_require__(/*! unpipe */ 35)

	/**
	 * Module variables.
	 * @private
	 */

	/* istanbul ignore next */
	var defer = typeof setImmediate === 'function'
	  ? setImmediate
	  : function (fn) { process.nextTick(fn.bind.apply(fn, arguments)) }
	var isFinished = onFinished.isFinished

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = finalhandler

	/**
	 * Create a function to handle the final response.
	 *
	 * @param {Request} req
	 * @param {Response} res
	 * @param {Object} [options]
	 * @return {Function}
	 * @public
	 */

	function finalhandler (req, res, options) {
	  var opts = options || {}

	  // get environment
	  var env = opts.env || process.env.NODE_ENV || 'development'

	  // get error callback
	  var onerror = opts.onerror

	  return function (err) {
	    var headers = Object.create(null)
	    var status

	    // ignore 404 on in-flight response
	    if (!err && res._header) {
	      debug('cannot 404 after headers sent')
	      return
	    }

	    // unhandled error
	    if (err) {
	      // respect status code from error
	      status = getErrorStatusCode(err) || res.statusCode

	      // default status code to 500 if outside valid range
	      if (typeof status !== 'number' || status < 400 || status > 599) {
	        status = 500
	      }

	      // respect err.headers
	      if (err.headers && (err.status === status || err.statusCode === status)) {
	        var keys = Object.keys(err.headers)
	        for (var i = 0; i < keys.length; i++) {
	          var key = keys[i]
	          headers[key] = err.headers[key]
	        }
	      }

	      // production gets a basic error message
	      var msg = env === 'production'
	        ? statuses[status]
	        : err.stack || err.toString()
	      msg = escapeHtml(msg)
	        .replace(/\n/g, '<br>')
	        .replace(/\x20{2}/g, ' &nbsp;') + '\n'
	    } else {
	      status = 404
	      msg = 'Cannot ' + escapeHtml(req.method) + ' ' + escapeHtml(req.originalUrl || req.url) + '\n'
	    }

	    debug('default %s', status)

	    // schedule onerror callback
	    if (err && onerror) {
	      defer(onerror, err, req, res)
	    }

	    // cannot actually respond
	    if (res._header) {
	      debug('cannot %d after headers sent', status)
	      req.socket.destroy()
	      return
	    }

	    // send response
	    send(req, res, status, headers, msg)
	  }
	}

	/**
	 * Get status code from Error object.
	 *
	 * @param {Error} err
	 * @return {number}
	 * @private
	 */

	function getErrorStatusCode (err) {
	  // check err.status
	  if (typeof err.status === 'number' && err.status >= 400 && err.status < 600) {
	    return err.status
	  }

	  // check err.statusCode
	  if (typeof err.statusCode === 'number' && err.statusCode >= 400 && err.statusCode < 600) {
	    return err.statusCode
	  }

	  return undefined
	}

	/**
	 * Send response.
	 *
	 * @param {IncomingMessage} req
	 * @param {OutgoingMessage} res
	 * @param {number} status
	 * @param {object} headers
	 * @param {string} body
	 * @private
	 */

	function send (req, res, status, headers, body) {
	  function write () {
	    // response status
	    res.statusCode = status
	    res.statusMessage = statuses[status]

	    // response headers
	    var keys = Object.keys(headers)
	    for (var i = 0; i < keys.length; i++) {
	      var key = keys[i]
	      res.setHeader(key, headers[key])
	    }

	    // security header for content sniffing
	    res.setHeader('X-Content-Type-Options', 'nosniff')

	    // standard headers
	    res.setHeader('Content-Type', 'text/html; charset=utf-8')
	    res.setHeader('Content-Length', Buffer.byteLength(body, 'utf8'))

	    if (req.method === 'HEAD') {
	      res.end()
	      return
	    }

	    res.end(body, 'utf8')
	  }

	  if (isFinished(req)) {
	    write()
	    return
	  }

	  // unpipe everything from the request
	  unpipe(req)

	  // flush the request
	  onFinished(req, write)
	  req.resume()
	}


/***/ },
/* 30 */
/*!********************************!*\
  !*** ./~/escape-html/index.js ***!
  \********************************/
/***/ function(module, exports) {

	/*!
	 * escape-html
	 * Copyright(c) 2012-2013 TJ Holowaychuk
	 * Copyright(c) 2015 Andreas Lubbe
	 * Copyright(c) 2015 Tiancheng "Timothy" Gu
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module variables.
	 * @private
	 */

	var matchHtmlRegExp = /["'&<>]/;

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = escapeHtml;

	/**
	 * Escape special characters in the given string of html.
	 *
	 * @param  {string} string The string to escape for inserting into HTML
	 * @return {string}
	 * @public
	 */

	function escapeHtml(string) {
	  var str = '' + string;
	  var match = matchHtmlRegExp.exec(str);

	  if (!match) {
	    return str;
	  }

	  var escape;
	  var html = '';
	  var index = 0;
	  var lastIndex = 0;

	  for (index = match.index; index < str.length; index++) {
	    switch (str.charCodeAt(index)) {
	      case 34: // "
	        escape = '&quot;';
	        break;
	      case 38: // &
	        escape = '&amp;';
	        break;
	      case 39: // '
	        escape = '&#39;';
	        break;
	      case 60: // <
	        escape = '&lt;';
	        break;
	      case 62: // >
	        escape = '&gt;';
	        break;
	      default:
	        continue;
	    }

	    if (lastIndex !== index) {
	      html += str.substring(lastIndex, index);
	    }

	    lastIndex = index + 1;
	    html += escape;
	  }

	  return lastIndex !== index
	    ? html + str.substring(lastIndex, index)
	    : html;
	}


/***/ },
/* 31 */
/*!********************************!*\
  !*** ./~/on-finished/index.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * on-finished
	 * Copyright(c) 2013 Jonathan Ong
	 * Copyright(c) 2014 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict'

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = onFinished
	module.exports.isFinished = isFinished

	/**
	 * Module dependencies.
	 * @private
	 */

	var first = __webpack_require__(/*! ee-first */ 32)

	/**
	 * Variables.
	 * @private
	 */

	/* istanbul ignore next */
	var defer = typeof setImmediate === 'function'
	  ? setImmediate
	  : function(fn){ process.nextTick(fn.bind.apply(fn, arguments)) }

	/**
	 * Invoke callback when the response has finished, useful for
	 * cleaning up resources afterwards.
	 *
	 * @param {object} msg
	 * @param {function} listener
	 * @return {object}
	 * @public
	 */

	function onFinished(msg, listener) {
	  if (isFinished(msg) !== false) {
	    defer(listener, null, msg)
	    return msg
	  }

	  // attach the listener to the message
	  attachListener(msg, listener)

	  return msg
	}

	/**
	 * Determine if message is already finished.
	 *
	 * @param {object} msg
	 * @return {boolean}
	 * @public
	 */

	function isFinished(msg) {
	  var socket = msg.socket

	  if (typeof msg.finished === 'boolean') {
	    // OutgoingMessage
	    return Boolean(msg.finished || (socket && !socket.writable))
	  }

	  if (typeof msg.complete === 'boolean') {
	    // IncomingMessage
	    return Boolean(msg.upgrade || !socket || !socket.readable || (msg.complete && !msg.readable))
	  }

	  // don't know
	  return undefined
	}

	/**
	 * Attach a finished listener to the message.
	 *
	 * @param {object} msg
	 * @param {function} callback
	 * @private
	 */

	function attachFinishedListener(msg, callback) {
	  var eeMsg
	  var eeSocket
	  var finished = false

	  function onFinish(error) {
	    eeMsg.cancel()
	    eeSocket.cancel()

	    finished = true
	    callback(error)
	  }

	  // finished on first message event
	  eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish)

	  function onSocket(socket) {
	    // remove listener
	    msg.removeListener('socket', onSocket)

	    if (finished) return
	    if (eeMsg !== eeSocket) return

	    // finished on first socket event
	    eeSocket = first([[socket, 'error', 'close']], onFinish)
	  }

	  if (msg.socket) {
	    // socket already assigned
	    onSocket(msg.socket)
	    return
	  }

	  // wait for socket to be assigned
	  msg.on('socket', onSocket)

	  if (msg.socket === undefined) {
	    // node.js 0.8 patch
	    patchAssignSocket(msg, onSocket)
	  }
	}

	/**
	 * Attach the listener to the message.
	 *
	 * @param {object} msg
	 * @return {function}
	 * @private
	 */

	function attachListener(msg, listener) {
	  var attached = msg.__onFinished

	  // create a private single listener with queue
	  if (!attached || !attached.queue) {
	    attached = msg.__onFinished = createListener(msg)
	    attachFinishedListener(msg, attached)
	  }

	  attached.queue.push(listener)
	}

	/**
	 * Create listener on message.
	 *
	 * @param {object} msg
	 * @return {function}
	 * @private
	 */

	function createListener(msg) {
	  function listener(err) {
	    if (msg.__onFinished === listener) msg.__onFinished = null
	    if (!listener.queue) return

	    var queue = listener.queue
	    listener.queue = null

	    for (var i = 0; i < queue.length; i++) {
	      queue[i](err, msg)
	    }
	  }

	  listener.queue = []

	  return listener
	}

	/**
	 * Patch ServerResponse.prototype.assignSocket for node.js 0.8.
	 *
	 * @param {ServerResponse} res
	 * @param {function} callback
	 * @private
	 */

	function patchAssignSocket(res, callback) {
	  var assignSocket = res.assignSocket

	  if (typeof assignSocket !== 'function') return

	  // res.on('socket', callback) is broken in 0.8
	  res.assignSocket = function _assignSocket(socket) {
	    assignSocket.call(this, socket)
	    callback(socket)
	  }
	}


/***/ },
/* 32 */
/*!*****************************!*\
  !*** ./~/ee-first/index.js ***!
  \*****************************/
/***/ function(module, exports) {

	/*!
	 * ee-first
	 * Copyright(c) 2014 Jonathan Ong
	 * MIT Licensed
	 */

	'use strict'

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = first

	/**
	 * Get the first event in a set of event emitters and event pairs.
	 *
	 * @param {array} stuff
	 * @param {function} done
	 * @public
	 */

	function first(stuff, done) {
	  if (!Array.isArray(stuff))
	    throw new TypeError('arg must be an array of [ee, events...] arrays')

	  var cleanups = []

	  for (var i = 0; i < stuff.length; i++) {
	    var arr = stuff[i]

	    if (!Array.isArray(arr) || arr.length < 2)
	      throw new TypeError('each array member must be [ee, events...]')

	    var ee = arr[0]

	    for (var j = 1; j < arr.length; j++) {
	      var event = arr[j]
	      var fn = listener(event, callback)

	      // listen to the event
	      ee.on(event, fn)
	      // push this listener to the list of cleanups
	      cleanups.push({
	        ee: ee,
	        event: event,
	        fn: fn,
	      })
	    }
	  }

	  function callback() {
	    cleanup()
	    done.apply(null, arguments)
	  }

	  function cleanup() {
	    var x
	    for (var i = 0; i < cleanups.length; i++) {
	      x = cleanups[i]
	      x.ee.removeListener(x.event, x.fn)
	    }
	  }

	  function thunk(fn) {
	    done = fn
	  }

	  thunk.cancel = cleanup

	  return thunk
	}

	/**
	 * Create the event listener.
	 * @private
	 */

	function listener(event, done) {
	  return function onevent(arg1) {
	    var args = new Array(arguments.length)
	    var ee = this
	    var err = event === 'error'
	      ? arg1
	      : null

	    // copy args to prevent arguments escaping scope
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i]
	    }

	    done(err, ee, event, args)
	  }
	}


/***/ },
/* 33 */
/*!*****************************!*\
  !*** ./~/statuses/index.js ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * statuses
	 * Copyright(c) 2014 Jonathan Ong
	 * Copyright(c) 2016 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict'

	/**
	 * Module dependencies.
	 * @private
	 */

	var codes = __webpack_require__(/*! ./codes.json */ 34)

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = status

	// array of status codes
	status.codes = populateStatusesMap(status, codes)

	// status codes for redirects
	status.redirect = {
	  300: true,
	  301: true,
	  302: true,
	  303: true,
	  305: true,
	  307: true,
	  308: true
	}

	// status codes for empty bodies
	status.empty = {
	  204: true,
	  205: true,
	  304: true
	}

	// status codes for when you should retry the request
	status.retry = {
	  502: true,
	  503: true,
	  504: true
	}

	/**
	 * Populate the statuses map for given codes.
	 * @private
	 */

	function populateStatusesMap (statuses, codes) {
	  var arr = []

	  Object.keys(codes).forEach(function forEachCode (code) {
	    var message = codes[code]
	    var status = Number(code)

	    // Populate properties
	    statuses[status] = message
	    statuses[message] = status
	    statuses[message.toLowerCase()] = status

	    // Add to array
	    arr.push(status)
	  })

	  return arr
	}

	/**
	 * Get the status code.
	 *
	 * Given a number, this will throw if it is not a known status
	 * code, otherwise the code will be returned. Given a string,
	 * the string will be parsed for a number and return the code
	 * if valid, otherwise will lookup the code assuming this is
	 * the status message.
	 *
	 * @param {string|number} code
	 * @returns {string}
	 * @public
	 */

	function status (code) {
	  if (typeof code === 'number') {
	    if (!status[code]) throw new Error('invalid status code: ' + code)
	    return code
	  }

	  if (typeof code !== 'string') {
	    throw new TypeError('code must be a number or string')
	  }

	  // '403'
	  var n = parseInt(code, 10)
	  if (!isNaN(n)) {
	    if (!status[n]) throw new Error('invalid status code: ' + n)
	    return n
	  }

	  n = status[code.toLowerCase()]
	  if (!n) throw new Error('invalid status message: "' + code + '"')
	  return n
	}


/***/ },
/* 34 */
/*!*******************************!*\
  !*** ./~/statuses/codes.json ***!
  \*******************************/
/***/ function(module, exports) {

	module.exports = {
		"100": "Continue",
		"101": "Switching Protocols",
		"102": "Processing",
		"200": "OK",
		"201": "Created",
		"202": "Accepted",
		"203": "Non-Authoritative Information",
		"204": "No Content",
		"205": "Reset Content",
		"206": "Partial Content",
		"207": "Multi-Status",
		"208": "Already Reported",
		"226": "IM Used",
		"300": "Multiple Choices",
		"301": "Moved Permanently",
		"302": "Found",
		"303": "See Other",
		"304": "Not Modified",
		"305": "Use Proxy",
		"306": "(Unused)",
		"307": "Temporary Redirect",
		"308": "Permanent Redirect",
		"400": "Bad Request",
		"401": "Unauthorized",
		"402": "Payment Required",
		"403": "Forbidden",
		"404": "Not Found",
		"405": "Method Not Allowed",
		"406": "Not Acceptable",
		"407": "Proxy Authentication Required",
		"408": "Request Timeout",
		"409": "Conflict",
		"410": "Gone",
		"411": "Length Required",
		"412": "Precondition Failed",
		"413": "Payload Too Large",
		"414": "URI Too Long",
		"415": "Unsupported Media Type",
		"416": "Range Not Satisfiable",
		"417": "Expectation Failed",
		"418": "I'm a teapot",
		"421": "Misdirected Request",
		"422": "Unprocessable Entity",
		"423": "Locked",
		"424": "Failed Dependency",
		"425": "Unordered Collection",
		"426": "Upgrade Required",
		"428": "Precondition Required",
		"429": "Too Many Requests",
		"431": "Request Header Fields Too Large",
		"451": "Unavailable For Legal Reasons",
		"500": "Internal Server Error",
		"501": "Not Implemented",
		"502": "Bad Gateway",
		"503": "Service Unavailable",
		"504": "Gateway Timeout",
		"505": "HTTP Version Not Supported",
		"506": "Variant Also Negotiates",
		"507": "Insufficient Storage",
		"508": "Loop Detected",
		"509": "Bandwidth Limit Exceeded",
		"510": "Not Extended",
		"511": "Network Authentication Required"
	};

/***/ },
/* 35 */
/*!***************************!*\
  !*** ./~/unpipe/index.js ***!
  \***************************/
/***/ function(module, exports) {

	/*!
	 * unpipe
	 * Copyright(c) 2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict'

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = unpipe

	/**
	 * Determine if there are Node.js pipe-like data listeners.
	 * @private
	 */

	function hasPipeDataListeners(stream) {
	  var listeners = stream.listeners('data')

	  for (var i = 0; i < listeners.length; i++) {
	    if (listeners[i].name === 'ondata') {
	      return true
	    }
	  }

	  return false
	}

	/**
	 * Unpipe a stream from all destinations.
	 *
	 * @param {object} stream
	 * @public
	 */

	function unpipe(stream) {
	  if (!stream) {
	    throw new TypeError('argument stream is required')
	  }

	  if (typeof stream.unpipe === 'function') {
	    // new-style
	    stream.unpipe()
	    return
	  }

	  // Node.js 0.8 hack
	  if (!hasPipeDataListeners(stream)) {
	    return
	  }

	  var listener
	  var listeners = stream.listeners('close')

	  for (var i = 0; i < listeners.length; i++) {
	    listener = listeners[i]

	    if (listener.name !== 'cleanup' && listener.name !== 'onclose') {
	      continue
	    }

	    // invoke the listener
	    listener.call(stream)
	  }
	}


/***/ },
/* 36 */
/*!***************************************!*\
  !*** ./~/express/lib/router/index.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2013 Roman Shtylman
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @private
	 */

	var Route = __webpack_require__(/*! ./route */ 37);
	var Layer = __webpack_require__(/*! ./layer */ 39);
	var methods = __webpack_require__(/*! methods */ 41);
	var mixin = __webpack_require__(/*! utils-merge */ 43);
	var debug = __webpack_require__(/*! debug */ 14)('express:router');
	var deprecate = __webpack_require__(/*! depd */ 44)('express');
	var flatten = __webpack_require__(/*! array-flatten */ 38);
	var parseUrl = __webpack_require__(/*! parseurl */ 50);

	/**
	 * Module variables.
	 * @private
	 */

	var objectRegExp = /^\[object (\S+)\]$/;
	var slice = Array.prototype.slice;
	var toString = Object.prototype.toString;

	/**
	 * Initialize a new `Router` with the given `options`.
	 *
	 * @param {Object} options
	 * @return {Router} which is an callable function
	 * @public
	 */

	var proto = module.exports = function(options) {
	  var opts = options || {};

	  function router(req, res, next) {
	    router.handle(req, res, next);
	  }

	  // mixin Router class functions
	  router.__proto__ = proto;

	  router.params = {};
	  router._params = [];
	  router.caseSensitive = opts.caseSensitive;
	  router.mergeParams = opts.mergeParams;
	  router.strict = opts.strict;
	  router.stack = [];

	  return router;
	};

	/**
	 * Map the given param placeholder `name`(s) to the given callback.
	 *
	 * Parameter mapping is used to provide pre-conditions to routes
	 * which use normalized placeholders. For example a _:user_id_ parameter
	 * could automatically load a user's information from the database without
	 * any additional code,
	 *
	 * The callback uses the same signature as middleware, the only difference
	 * being that the value of the placeholder is passed, in this case the _id_
	 * of the user. Once the `next()` function is invoked, just like middleware
	 * it will continue on to execute the route, or subsequent parameter functions.
	 *
	 * Just like in middleware, you must either respond to the request or call next
	 * to avoid stalling the request.
	 *
	 *  app.param('user_id', function(req, res, next, id){
	 *    User.find(id, function(err, user){
	 *      if (err) {
	 *        return next(err);
	 *      } else if (!user) {
	 *        return next(new Error('failed to load user'));
	 *      }
	 *      req.user = user;
	 *      next();
	 *    });
	 *  });
	 *
	 * @param {String} name
	 * @param {Function} fn
	 * @return {app} for chaining
	 * @public
	 */

	proto.param = function param(name, fn) {
	  // param logic
	  if (typeof name === 'function') {
	    deprecate('router.param(fn): Refactor to use path params');
	    this._params.push(name);
	    return;
	  }

	  // apply param functions
	  var params = this._params;
	  var len = params.length;
	  var ret;

	  if (name[0] === ':') {
	    deprecate('router.param(' + JSON.stringify(name) + ', fn): Use router.param(' + JSON.stringify(name.substr(1)) + ', fn) instead');
	    name = name.substr(1);
	  }

	  for (var i = 0; i < len; ++i) {
	    if (ret = params[i](name, fn)) {
	      fn = ret;
	    }
	  }

	  // ensure we end up with a
	  // middleware function
	  if ('function' !== typeof fn) {
	    throw new Error('invalid param() call for ' + name + ', got ' + fn);
	  }

	  (this.params[name] = this.params[name] || []).push(fn);
	  return this;
	};

	/**
	 * Dispatch a req, res into the router.
	 * @private
	 */

	proto.handle = function handle(req, res, out) {
	  var self = this;

	  debug('dispatching %s %s', req.method, req.url);

	  var search = 1 + req.url.indexOf('?');
	  var pathlength = search ? search - 1 : req.url.length;
	  var fqdn = req.url[0] !== '/' && 1 + req.url.substr(0, pathlength).indexOf('://');
	  var protohost = fqdn ? req.url.substr(0, req.url.indexOf('/', 2 + fqdn)) : '';
	  var idx = 0;
	  var removed = '';
	  var slashAdded = false;
	  var paramcalled = {};

	  // store options for OPTIONS request
	  // only used if OPTIONS request
	  var options = [];

	  // middleware and routes
	  var stack = self.stack;

	  // manage inter-router variables
	  var parentParams = req.params;
	  var parentUrl = req.baseUrl || '';
	  var done = restore(out, req, 'baseUrl', 'next', 'params');

	  // setup next layer
	  req.next = next;

	  // for options requests, respond with a default if nothing else responds
	  if (req.method === 'OPTIONS') {
	    done = wrap(done, function(old, err) {
	      if (err || options.length === 0) return old(err);
	      sendOptionsResponse(res, options, old);
	    });
	  }

	  // setup basic req values
	  req.baseUrl = parentUrl;
	  req.originalUrl = req.originalUrl || req.url;

	  next();

	  function next(err) {
	    var layerError = err === 'route'
	      ? null
	      : err;

	    // remove added slash
	    if (slashAdded) {
	      req.url = req.url.substr(1);
	      slashAdded = false;
	    }

	    // restore altered req.url
	    if (removed.length !== 0) {
	      req.baseUrl = parentUrl;
	      req.url = protohost + removed + req.url.substr(protohost.length);
	      removed = '';
	    }

	    // no more matching layers
	    if (idx >= stack.length) {
	      setImmediate(done, layerError);
	      return;
	    }

	    // get pathname of request
	    var path = getPathname(req);

	    if (path == null) {
	      return done(layerError);
	    }

	    // find next matching layer
	    var layer;
	    var match;
	    var route;

	    while (match !== true && idx < stack.length) {
	      layer = stack[idx++];
	      match = matchLayer(layer, path);
	      route = layer.route;

	      if (typeof match !== 'boolean') {
	        // hold on to layerError
	        layerError = layerError || match;
	      }

	      if (match !== true) {
	        continue;
	      }

	      if (!route) {
	        // process non-route handlers normally
	        continue;
	      }

	      if (layerError) {
	        // routes do not match with a pending error
	        match = false;
	        continue;
	      }

	      var method = req.method;
	      var has_method = route._handles_method(method);

	      // build up automatic options response
	      if (!has_method && method === 'OPTIONS') {
	        appendMethods(options, route._options());
	      }

	      // don't even bother matching route
	      if (!has_method && method !== 'HEAD') {
	        match = false;
	        continue;
	      }
	    }

	    // no match
	    if (match !== true) {
	      return done(layerError);
	    }

	    // store route for dispatch on change
	    if (route) {
	      req.route = route;
	    }

	    // Capture one-time layer values
	    req.params = self.mergeParams
	      ? mergeParams(layer.params, parentParams)
	      : layer.params;
	    var layerPath = layer.path;

	    // this should be done for the layer
	    self.process_params(layer, paramcalled, req, res, function (err) {
	      if (err) {
	        return next(layerError || err);
	      }

	      if (route) {
	        return layer.handle_request(req, res, next);
	      }

	      trim_prefix(layer, layerError, layerPath, path);
	    });
	  }

	  function trim_prefix(layer, layerError, layerPath, path) {
	    var c = path[layerPath.length];
	    if (c && '/' !== c && '.' !== c) return next(layerError);

	     // Trim off the part of the url that matches the route
	     // middleware (.use stuff) needs to have the path stripped
	    if (layerPath.length !== 0) {
	      debug('trim prefix (%s) from url %s', layerPath, req.url);
	      removed = layerPath;
	      req.url = protohost + req.url.substr(protohost.length + removed.length);

	      // Ensure leading slash
	      if (!fqdn && req.url[0] !== '/') {
	        req.url = '/' + req.url;
	        slashAdded = true;
	      }

	      // Setup base URL (no trailing slash)
	      req.baseUrl = parentUrl + (removed[removed.length - 1] === '/'
	        ? removed.substring(0, removed.length - 1)
	        : removed);
	    }

	    debug('%s %s : %s', layer.name, layerPath, req.originalUrl);

	    if (layerError) {
	      layer.handle_error(layerError, req, res, next);
	    } else {
	      layer.handle_request(req, res, next);
	    }
	  }
	};

	/**
	 * Process any parameters for the layer.
	 * @private
	 */

	proto.process_params = function process_params(layer, called, req, res, done) {
	  var params = this.params;

	  // captured parameters from the layer, keys and values
	  var keys = layer.keys;

	  // fast track
	  if (!keys || keys.length === 0) {
	    return done();
	  }

	  var i = 0;
	  var name;
	  var paramIndex = 0;
	  var key;
	  var paramVal;
	  var paramCallbacks;
	  var paramCalled;

	  // process params in order
	  // param callbacks can be async
	  function param(err) {
	    if (err) {
	      return done(err);
	    }

	    if (i >= keys.length ) {
	      return done();
	    }

	    paramIndex = 0;
	    key = keys[i++];

	    if (!key) {
	      return done();
	    }

	    name = key.name;
	    paramVal = req.params[name];
	    paramCallbacks = params[name];
	    paramCalled = called[name];

	    if (paramVal === undefined || !paramCallbacks) {
	      return param();
	    }

	    // param previously called with same value or error occurred
	    if (paramCalled && (paramCalled.match === paramVal
	      || (paramCalled.error && paramCalled.error !== 'route'))) {
	      // restore value
	      req.params[name] = paramCalled.value;

	      // next param
	      return param(paramCalled.error);
	    }

	    called[name] = paramCalled = {
	      error: null,
	      match: paramVal,
	      value: paramVal
	    };

	    paramCallback();
	  }

	  // single param callbacks
	  function paramCallback(err) {
	    var fn = paramCallbacks[paramIndex++];

	    // store updated value
	    paramCalled.value = req.params[key.name];

	    if (err) {
	      // store error
	      paramCalled.error = err;
	      param(err);
	      return;
	    }

	    if (!fn) return param();

	    try {
	      fn(req, res, paramCallback, paramVal, key.name);
	    } catch (e) {
	      paramCallback(e);
	    }
	  }

	  param();
	};

	/**
	 * Use the given middleware function, with optional path, defaulting to "/".
	 *
	 * Use (like `.all`) will run for any http METHOD, but it will not add
	 * handlers for those methods so OPTIONS requests will not consider `.use`
	 * functions even if they could respond.
	 *
	 * The other difference is that _route_ path is stripped and not visible
	 * to the handler function. The main effect of this feature is that mounted
	 * handlers can operate without any code changes regardless of the "prefix"
	 * pathname.
	 *
	 * @public
	 */

	proto.use = function use(fn) {
	  var offset = 0;
	  var path = '/';

	  // default path to '/'
	  // disambiguate router.use([fn])
	  if (typeof fn !== 'function') {
	    var arg = fn;

	    while (Array.isArray(arg) && arg.length !== 0) {
	      arg = arg[0];
	    }

	    // first arg is the path
	    if (typeof arg !== 'function') {
	      offset = 1;
	      path = fn;
	    }
	  }

	  var callbacks = flatten(slice.call(arguments, offset));

	  if (callbacks.length === 0) {
	    throw new TypeError('Router.use() requires middleware functions');
	  }

	  for (var i = 0; i < callbacks.length; i++) {
	    var fn = callbacks[i];

	    if (typeof fn !== 'function') {
	      throw new TypeError('Router.use() requires middleware function but got a ' + gettype(fn));
	    }

	    // add the middleware
	    debug('use %s %s', path, fn.name || '<anonymous>');

	    var layer = new Layer(path, {
	      sensitive: this.caseSensitive,
	      strict: false,
	      end: false
	    }, fn);

	    layer.route = undefined;

	    this.stack.push(layer);
	  }

	  return this;
	};

	/**
	 * Create a new Route for the given path.
	 *
	 * Each route contains a separate middleware stack and VERB handlers.
	 *
	 * See the Route api documentation for details on adding handlers
	 * and middleware to routes.
	 *
	 * @param {String} path
	 * @return {Route}
	 * @public
	 */

	proto.route = function route(path) {
	  var route = new Route(path);

	  var layer = new Layer(path, {
	    sensitive: this.caseSensitive,
	    strict: this.strict,
	    end: true
	  }, route.dispatch.bind(route));

	  layer.route = route;

	  this.stack.push(layer);
	  return route;
	};

	// create Router#VERB functions
	methods.concat('all').forEach(function(method){
	  proto[method] = function(path){
	    var route = this.route(path)
	    route[method].apply(route, slice.call(arguments, 1));
	    return this;
	  };
	});

	// append methods to a list of methods
	function appendMethods(list, addition) {
	  for (var i = 0; i < addition.length; i++) {
	    var method = addition[i];
	    if (list.indexOf(method) === -1) {
	      list.push(method);
	    }
	  }
	}

	// get pathname of request
	function getPathname(req) {
	  try {
	    return parseUrl(req).pathname;
	  } catch (err) {
	    return undefined;
	  }
	}

	// get type for error message
	function gettype(obj) {
	  var type = typeof obj;

	  if (type !== 'object') {
	    return type;
	  }

	  // inspect [[Class]] for objects
	  return toString.call(obj)
	    .replace(objectRegExp, '$1');
	}

	/**
	 * Match path to a layer.
	 *
	 * @param {Layer} layer
	 * @param {string} path
	 * @private
	 */

	function matchLayer(layer, path) {
	  try {
	    return layer.match(path);
	  } catch (err) {
	    return err;
	  }
	}

	// merge params with parent params
	function mergeParams(params, parent) {
	  if (typeof parent !== 'object' || !parent) {
	    return params;
	  }

	  // make copy of parent for base
	  var obj = mixin({}, parent);

	  // simple non-numeric merging
	  if (!(0 in params) || !(0 in parent)) {
	    return mixin(obj, params);
	  }

	  var i = 0;
	  var o = 0;

	  // determine numeric gaps
	  while (i in params) {
	    i++;
	  }

	  while (o in parent) {
	    o++;
	  }

	  // offset numeric indices in params before merge
	  for (i--; i >= 0; i--) {
	    params[i + o] = params[i];

	    // create holes for the merge when necessary
	    if (i < o) {
	      delete params[i];
	    }
	  }

	  return mixin(obj, params);
	}

	// restore obj props after function
	function restore(fn, obj) {
	  var props = new Array(arguments.length - 2);
	  var vals = new Array(arguments.length - 2);

	  for (var i = 0; i < props.length; i++) {
	    props[i] = arguments[i + 2];
	    vals[i] = obj[props[i]];
	  }

	  return function(err){
	    // restore vals
	    for (var i = 0; i < props.length; i++) {
	      obj[props[i]] = vals[i];
	    }

	    return fn.apply(this, arguments);
	  };
	}

	// send an OPTIONS response
	function sendOptionsResponse(res, options, next) {
	  try {
	    var body = options.join(',');
	    res.set('Allow', body);
	    res.send(body);
	  } catch (err) {
	    next(err);
	  }
	}

	// wrap a function
	function wrap(old, fn) {
	  return function proxy() {
	    var args = new Array(arguments.length + 1);

	    args[0] = old;
	    for (var i = 0, len = arguments.length; i < len; i++) {
	      args[i + 1] = arguments[i];
	    }

	    fn.apply(this, args);
	  };
	}


/***/ },
/* 37 */
/*!***************************************!*\
  !*** ./~/express/lib/router/route.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2013 Roman Shtylman
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @private
	 */

	var debug = __webpack_require__(/*! debug */ 14)('express:router:route');
	var flatten = __webpack_require__(/*! array-flatten */ 38);
	var Layer = __webpack_require__(/*! ./layer */ 39);
	var methods = __webpack_require__(/*! methods */ 41);

	/**
	 * Module variables.
	 * @private
	 */

	var slice = Array.prototype.slice;
	var toString = Object.prototype.toString;

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = Route;

	/**
	 * Initialize `Route` with the given `path`,
	 *
	 * @param {String} path
	 * @public
	 */

	function Route(path) {
	  this.path = path;
	  this.stack = [];

	  debug('new %s', path);

	  // route handlers for various http methods
	  this.methods = {};
	}

	/**
	 * Determine if the route handles a given method.
	 * @private
	 */

	Route.prototype._handles_method = function _handles_method(method) {
	  if (this.methods._all) {
	    return true;
	  }

	  var name = method.toLowerCase();

	  if (name === 'head' && !this.methods['head']) {
	    name = 'get';
	  }

	  return Boolean(this.methods[name]);
	};

	/**
	 * @return {Array} supported HTTP methods
	 * @private
	 */

	Route.prototype._options = function _options() {
	  var methods = Object.keys(this.methods);

	  // append automatic head
	  if (this.methods.get && !this.methods.head) {
	    methods.push('head');
	  }

	  for (var i = 0; i < methods.length; i++) {
	    // make upper case
	    methods[i] = methods[i].toUpperCase();
	  }

	  return methods;
	};

	/**
	 * dispatch req, res into this route
	 * @private
	 */

	Route.prototype.dispatch = function dispatch(req, res, done) {
	  var idx = 0;
	  var stack = this.stack;
	  if (stack.length === 0) {
	    return done();
	  }

	  var method = req.method.toLowerCase();
	  if (method === 'head' && !this.methods['head']) {
	    method = 'get';
	  }

	  req.route = this;

	  next();

	  function next(err) {
	    if (err && err === 'route') {
	      return done();
	    }

	    var layer = stack[idx++];
	    if (!layer) {
	      return done(err);
	    }

	    if (layer.method && layer.method !== method) {
	      return next(err);
	    }

	    if (err) {
	      layer.handle_error(err, req, res, next);
	    } else {
	      layer.handle_request(req, res, next);
	    }
	  }
	};

	/**
	 * Add a handler for all HTTP verbs to this route.
	 *
	 * Behaves just like middleware and can respond or call `next`
	 * to continue processing.
	 *
	 * You can use multiple `.all` call to add multiple handlers.
	 *
	 *   function check_something(req, res, next){
	 *     next();
	 *   };
	 *
	 *   function validate_user(req, res, next){
	 *     next();
	 *   };
	 *
	 *   route
	 *   .all(validate_user)
	 *   .all(check_something)
	 *   .get(function(req, res, next){
	 *     res.send('hello world');
	 *   });
	 *
	 * @param {function} handler
	 * @return {Route} for chaining
	 * @api public
	 */

	Route.prototype.all = function all() {
	  var handles = flatten(slice.call(arguments));

	  for (var i = 0; i < handles.length; i++) {
	    var handle = handles[i];

	    if (typeof handle !== 'function') {
	      var type = toString.call(handle);
	      var msg = 'Route.all() requires callback functions but got a ' + type;
	      throw new TypeError(msg);
	    }

	    var layer = Layer('/', {}, handle);
	    layer.method = undefined;

	    this.methods._all = true;
	    this.stack.push(layer);
	  }

	  return this;
	};

	methods.forEach(function(method){
	  Route.prototype[method] = function(){
	    var handles = flatten(slice.call(arguments));

	    for (var i = 0; i < handles.length; i++) {
	      var handle = handles[i];

	      if (typeof handle !== 'function') {
	        var type = toString.call(handle);
	        var msg = 'Route.' + method + '() requires callback functions but got a ' + type;
	        throw new Error(msg);
	      }

	      debug('%s %s', method, this.path);

	      var layer = Layer('/', {}, handle);
	      layer.method = method;

	      this.methods[method] = true;
	      this.stack.push(layer);
	    }

	    return this;
	  };
	});


/***/ },
/* 38 */
/*!******************************************!*\
  !*** ./~/array-flatten/array-flatten.js ***!
  \******************************************/
/***/ function(module, exports) {

	'use strict'

	/**
	 * Expose `arrayFlatten`.
	 */
	module.exports = arrayFlatten

	/**
	 * Recursive flatten function with depth.
	 *
	 * @param  {Array}  array
	 * @param  {Array}  result
	 * @param  {Number} depth
	 * @return {Array}
	 */
	function flattenWithDepth (array, result, depth) {
	  for (var i = 0; i < array.length; i++) {
	    var value = array[i]

	    if (depth > 0 && Array.isArray(value)) {
	      flattenWithDepth(value, result, depth - 1)
	    } else {
	      result.push(value)
	    }
	  }

	  return result
	}

	/**
	 * Recursive flatten function. Omitting depth is slightly faster.
	 *
	 * @param  {Array} array
	 * @param  {Array} result
	 * @return {Array}
	 */
	function flattenForever (array, result) {
	  for (var i = 0; i < array.length; i++) {
	    var value = array[i]

	    if (Array.isArray(value)) {
	      flattenForever(value, result)
	    } else {
	      result.push(value)
	    }
	  }

	  return result
	}

	/**
	 * Flatten an array, with the ability to define a depth.
	 *
	 * @param  {Array}  array
	 * @param  {Number} depth
	 * @return {Array}
	 */
	function arrayFlatten (array, depth) {
	  if (depth == null) {
	    return flattenForever(array, [])
	  }

	  return flattenWithDepth(array, [], depth)
	}


/***/ },
/* 39 */
/*!***************************************!*\
  !*** ./~/express/lib/router/layer.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2013 Roman Shtylman
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @private
	 */

	var pathRegexp = __webpack_require__(/*! path-to-regexp */ 40);
	var debug = __webpack_require__(/*! debug */ 14)('express:router:layer');

	/**
	 * Module variables.
	 * @private
	 */

	var hasOwnProperty = Object.prototype.hasOwnProperty;

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = Layer;

	function Layer(path, options, fn) {
	  if (!(this instanceof Layer)) {
	    return new Layer(path, options, fn);
	  }

	  debug('new %s', path);
	  var opts = options || {};

	  this.handle = fn;
	  this.name = fn.name || '<anonymous>';
	  this.params = undefined;
	  this.path = undefined;
	  this.regexp = pathRegexp(path, this.keys = [], opts);

	  if (path === '/' && opts.end === false) {
	    this.regexp.fast_slash = true;
	  }
	}

	/**
	 * Handle the error for the layer.
	 *
	 * @param {Error} error
	 * @param {Request} req
	 * @param {Response} res
	 * @param {function} next
	 * @api private
	 */

	Layer.prototype.handle_error = function handle_error(error, req, res, next) {
	  var fn = this.handle;

	  if (fn.length !== 4) {
	    // not a standard error handler
	    return next(error);
	  }

	  try {
	    fn(error, req, res, next);
	  } catch (err) {
	    next(err);
	  }
	};

	/**
	 * Handle the request for the layer.
	 *
	 * @param {Request} req
	 * @param {Response} res
	 * @param {function} next
	 * @api private
	 */

	Layer.prototype.handle_request = function handle(req, res, next) {
	  var fn = this.handle;

	  if (fn.length > 3) {
	    // not a standard request handler
	    return next();
	  }

	  try {
	    fn(req, res, next);
	  } catch (err) {
	    next(err);
	  }
	};

	/**
	 * Check if this route matches `path`, if so
	 * populate `.params`.
	 *
	 * @param {String} path
	 * @return {Boolean}
	 * @api private
	 */

	Layer.prototype.match = function match(path) {
	  if (path == null) {
	    // no path, nothing matches
	    this.params = undefined;
	    this.path = undefined;
	    return false;
	  }

	  if (this.regexp.fast_slash) {
	    // fast path non-ending match for / (everything matches)
	    this.params = {};
	    this.path = '';
	    return true;
	  }

	  var m = this.regexp.exec(path);

	  if (!m) {
	    this.params = undefined;
	    this.path = undefined;
	    return false;
	  }

	  // store values
	  this.params = {};
	  this.path = m[0];

	  var keys = this.keys;
	  var params = this.params;

	  for (var i = 1; i < m.length; i++) {
	    var key = keys[i - 1];
	    var prop = key.name;
	    var val = decode_param(m[i]);

	    if (val !== undefined || !(hasOwnProperty.call(params, prop))) {
	      params[prop] = val;
	    }
	  }

	  return true;
	};

	/**
	 * Decode param value.
	 *
	 * @param {string} val
	 * @return {string}
	 * @private
	 */

	function decode_param(val) {
	  if (typeof val !== 'string' || val.length === 0) {
	    return val;
	  }

	  try {
	    return decodeURIComponent(val);
	  } catch (err) {
	    if (err instanceof URIError) {
	      err.message = 'Failed to decode param \'' + val + '\'';
	      err.status = err.statusCode = 400;
	    }

	    throw err;
	  }
	}


/***/ },
/* 40 */
/*!***********************************!*\
  !*** ./~/path-to-regexp/index.js ***!
  \***********************************/
/***/ function(module, exports) {

	/**
	 * Expose `pathtoRegexp`.
	 */

	module.exports = pathtoRegexp;

	/**
	 * Match matching groups in a regular expression.
	 */
	var MATCHING_GROUP_REGEXP = /\((?!\?)/g;

	/**
	 * Normalize the given path string,
	 * returning a regular expression.
	 *
	 * An empty array should be passed,
	 * which will contain the placeholder
	 * key names. For example "/user/:id" will
	 * then contain ["id"].
	 *
	 * @param  {String|RegExp|Array} path
	 * @param  {Array} keys
	 * @param  {Object} options
	 * @return {RegExp}
	 * @api private
	 */

	function pathtoRegexp(path, keys, options) {
	  options = options || {};
	  keys = keys || [];
	  var strict = options.strict;
	  var end = options.end !== false;
	  var flags = options.sensitive ? '' : 'i';
	  var extraOffset = 0;
	  var keysOffset = keys.length;
	  var i = 0;
	  var name = 0;
	  var m;

	  if (path instanceof RegExp) {
	    while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {
	      keys.push({
	        name: name++,
	        optional: false,
	        offset: m.index
	      });
	    }

	    return path;
	  }

	  if (Array.isArray(path)) {
	    // Map array parts into regexps and return their source. We also pass
	    // the same keys and options instance into every generation to get
	    // consistent matching groups before we join the sources together.
	    path = path.map(function (value) {
	      return pathtoRegexp(value, keys, options).source;
	    });

	    return new RegExp('(?:' + path.join('|') + ')', flags);
	  }

	  path = ('^' + path + (strict ? '' : path[path.length - 1] === '/' ? '?' : '/?'))
	    .replace(/\/\(/g, '/(?:')
	    .replace(/([\/\.])/g, '\\$1')
	    .replace(/(\\\/)?(\\\.)?:(\w+)(\(.*?\))?(\*)?(\?)?/g, function (match, slash, format, key, capture, star, optional, offset) {
	      slash = slash || '';
	      format = format || '';
	      capture = capture || '([^\\/' + format + ']+?)';
	      optional = optional || '';

	      keys.push({
	        name: key,
	        optional: !!optional,
	        offset: offset + extraOffset
	      });

	      var result = ''
	        + (optional ? '' : slash)
	        + '(?:'
	        + format + (optional ? slash : '') + capture
	        + (star ? '((?:[\\/' + format + '].+?)?)' : '')
	        + ')'
	        + optional;

	      extraOffset += result.length - match.length;

	      return result;
	    })
	    .replace(/\*/g, function (star, index) {
	      var len = keys.length

	      while (len-- > keysOffset && keys[len].offset > index) {
	        keys[len].offset += 3; // Replacement length minus asterisk length.
	      }

	      return '(.*)';
	    });

	  // This is a workaround for handling unnamed matching groups.
	  while (m = MATCHING_GROUP_REGEXP.exec(path)) {
	    var escapeCount = 0;
	    var index = m.index;

	    while (path.charAt(--index) === '\\') {
	      escapeCount++;
	    }

	    // It's possible to escape the bracket.
	    if (escapeCount % 2 === 1) {
	      continue;
	    }

	    if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {
	      keys.splice(keysOffset + i, 0, {
	        name: name++, // Unnamed matching groups must be consistently linear.
	        optional: false,
	        offset: m.index
	      });
	    }

	    i++;
	  }

	  // If the path is non-ending, match until the end or a slash.
	  path += (end ? '$' : (path[path.length - 1] === '/' ? '' : '(?=\\/|$)'));

	  return new RegExp(path, flags);
	};


/***/ },
/* 41 */
/*!****************************!*\
  !*** ./~/methods/index.js ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * methods
	 * Copyright(c) 2013-2014 TJ Holowaychuk
	 * Copyright(c) 2015-2016 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @private
	 */

	var http = __webpack_require__(/*! http */ 42);

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = getCurrentNodeMethods() || getBasicNodeMethods();

	/**
	 * Get the current Node.js methods.
	 * @private
	 */

	function getCurrentNodeMethods() {
	  return http.METHODS && http.METHODS.map(function lowerCaseMethod(method) {
	    return method.toLowerCase();
	  });
	}

	/**
	 * Get the "basic" Node.js methods, a snapshot from Node.js 0.10.
	 * @private
	 */

	function getBasicNodeMethods() {
	  return [
	    'get',
	    'post',
	    'put',
	    'head',
	    'delete',
	    'options',
	    'trace',
	    'copy',
	    'lock',
	    'mkcol',
	    'move',
	    'purge',
	    'propfind',
	    'proppatch',
	    'unlock',
	    'report',
	    'mkactivity',
	    'checkout',
	    'merge',
	    'm-search',
	    'notify',
	    'subscribe',
	    'unsubscribe',
	    'patch',
	    'search',
	    'connect'
	  ];
	}


/***/ },
/* 42 */
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ function(module, exports) {

	module.exports = require("http");

/***/ },
/* 43 */
/*!********************************!*\
  !*** ./~/utils-merge/index.js ***!
  \********************************/
/***/ function(module, exports) {

	/**
	 * Merge object b with object a.
	 *
	 *     var a = { foo: 'bar' }
	 *       , b = { bar: 'baz' };
	 *
	 *     merge(a, b);
	 *     // => { foo: 'bar', bar: 'baz' }
	 *
	 * @param {Object} a
	 * @param {Object} b
	 * @return {Object}
	 * @api public
	 */

	exports = module.exports = function(a, b){
	  if (a && b) {
	    for (var key in b) {
	      a[key] = b[key];
	    }
	  }
	  return a;
	};


/***/ },
/* 44 */
/*!*************************!*\
  !*** ./~/depd/index.js ***!
  \*************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * depd
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	/**
	 * Module dependencies.
	 */

	var callSiteToString = __webpack_require__(/*! ./lib/compat */ 45).callSiteToString
	var eventListenerCount = __webpack_require__(/*! ./lib/compat */ 45).eventListenerCount
	var relative = __webpack_require__(/*! path */ 11).relative

	/**
	 * Module exports.
	 */

	module.exports = depd

	/**
	 * Get the path to base files on.
	 */

	var basePath = process.cwd()

	/**
	 * Determine if namespace is contained in the string.
	 */

	function containsNamespace(str, namespace) {
	  var val = str.split(/[ ,]+/)

	  namespace = String(namespace).toLowerCase()

	  for (var i = 0 ; i < val.length; i++) {
	    if (!(str = val[i])) continue;

	    // namespace contained
	    if (str === '*' || str.toLowerCase() === namespace) {
	      return true
	    }
	  }

	  return false
	}

	/**
	 * Convert a data descriptor to accessor descriptor.
	 */

	function convertDataDescriptorToAccessor(obj, prop, message) {
	  var descriptor = Object.getOwnPropertyDescriptor(obj, prop)
	  var value = descriptor.value

	  descriptor.get = function getter() { return value }

	  if (descriptor.writable) {
	    descriptor.set = function setter(val) { return value = val }
	  }

	  delete descriptor.value
	  delete descriptor.writable

	  Object.defineProperty(obj, prop, descriptor)

	  return descriptor
	}

	/**
	 * Create arguments string to keep arity.
	 */

	function createArgumentsString(arity) {
	  var str = ''

	  for (var i = 0; i < arity; i++) {
	    str += ', arg' + i
	  }

	  return str.substr(2)
	}

	/**
	 * Create stack string from stack.
	 */

	function createStackString(stack) {
	  var str = this.name + ': ' + this.namespace

	  if (this.message) {
	    str += ' deprecated ' + this.message
	  }

	  for (var i = 0; i < stack.length; i++) {
	    str += '\n    at ' + callSiteToString(stack[i])
	  }

	  return str
	}

	/**
	 * Create deprecate for namespace in caller.
	 */

	function depd(namespace) {
	  if (!namespace) {
	    throw new TypeError('argument namespace is required')
	  }

	  var stack = getStack()
	  var site = callSiteLocation(stack[1])
	  var file = site[0]

	  function deprecate(message) {
	    // call to self as log
	    log.call(deprecate, message)
	  }

	  deprecate._file = file
	  deprecate._ignored = isignored(namespace)
	  deprecate._namespace = namespace
	  deprecate._traced = istraced(namespace)
	  deprecate._warned = Object.create(null)

	  deprecate.function = wrapfunction
	  deprecate.property = wrapproperty

	  return deprecate
	}

	/**
	 * Determine if namespace is ignored.
	 */

	function isignored(namespace) {
	  /* istanbul ignore next: tested in a child processs */
	  if (process.noDeprecation) {
	    // --no-deprecation support
	    return true
	  }

	  var str = process.env.NO_DEPRECATION || ''

	  // namespace ignored
	  return containsNamespace(str, namespace)
	}

	/**
	 * Determine if namespace is traced.
	 */

	function istraced(namespace) {
	  /* istanbul ignore next: tested in a child processs */
	  if (process.traceDeprecation) {
	    // --trace-deprecation support
	    return true
	  }

	  var str = process.env.TRACE_DEPRECATION || ''

	  // namespace traced
	  return containsNamespace(str, namespace)
	}

	/**
	 * Display deprecation message.
	 */

	function log(message, site) {
	  var haslisteners = eventListenerCount(process, 'deprecation') !== 0

	  // abort early if no destination
	  if (!haslisteners && this._ignored) {
	    return
	  }

	  var caller
	  var callFile
	  var callSite
	  var i = 0
	  var seen = false
	  var stack = getStack()
	  var file = this._file

	  if (site) {
	    // provided site
	    callSite = callSiteLocation(stack[1])
	    callSite.name = site.name
	    file = callSite[0]
	  } else {
	    // get call site
	    i = 2
	    site = callSiteLocation(stack[i])
	    callSite = site
	  }

	  // get caller of deprecated thing in relation to file
	  for (; i < stack.length; i++) {
	    caller = callSiteLocation(stack[i])
	    callFile = caller[0]

	    if (callFile === file) {
	      seen = true
	    } else if (callFile === this._file) {
	      file = this._file
	    } else if (seen) {
	      break
	    }
	  }

	  var key = caller
	    ? site.join(':') + '__' + caller.join(':')
	    : undefined

	  if (key !== undefined && key in this._warned) {
	    // already warned
	    return
	  }

	  this._warned[key] = true

	  // generate automatic message from call site
	  if (!message) {
	    message = callSite === site || !callSite.name
	      ? defaultMessage(site)
	      : defaultMessage(callSite)
	  }

	  // emit deprecation if listeners exist
	  if (haslisteners) {
	    var err = DeprecationError(this._namespace, message, stack.slice(i))
	    process.emit('deprecation', err)
	    return
	  }

	  // format and write message
	  var format = process.stderr.isTTY
	    ? formatColor
	    : formatPlain
	  var msg = format.call(this, message, caller, stack.slice(i))
	  process.stderr.write(msg + '\n', 'utf8')

	  return
	}

	/**
	 * Get call site location as array.
	 */

	function callSiteLocation(callSite) {
	  var file = callSite.getFileName() || '<anonymous>'
	  var line = callSite.getLineNumber()
	  var colm = callSite.getColumnNumber()

	  if (callSite.isEval()) {
	    file = callSite.getEvalOrigin() + ', ' + file
	  }

	  var site = [file, line, colm]

	  site.callSite = callSite
	  site.name = callSite.getFunctionName()

	  return site
	}

	/**
	 * Generate a default message from the site.
	 */

	function defaultMessage(site) {
	  var callSite = site.callSite
	  var funcName = site.name

	  // make useful anonymous name
	  if (!funcName) {
	    funcName = '<anonymous@' + formatLocation(site) + '>'
	  }

	  var context = callSite.getThis()
	  var typeName = context && callSite.getTypeName()

	  // ignore useless type name
	  if (typeName === 'Object') {
	    typeName = undefined
	  }

	  // make useful type name
	  if (typeName === 'Function') {
	    typeName = context.name || typeName
	  }

	  return typeName && callSite.getMethodName()
	    ? typeName + '.' + funcName
	    : funcName
	}

	/**
	 * Format deprecation message without color.
	 */

	function formatPlain(msg, caller, stack) {
	  var timestamp = new Date().toUTCString()

	  var formatted = timestamp
	    + ' ' + this._namespace
	    + ' deprecated ' + msg

	  // add stack trace
	  if (this._traced) {
	    for (var i = 0; i < stack.length; i++) {
	      formatted += '\n    at ' + callSiteToString(stack[i])
	    }

	    return formatted
	  }

	  if (caller) {
	    formatted += ' at ' + formatLocation(caller)
	  }

	  return formatted
	}

	/**
	 * Format deprecation message with color.
	 */

	function formatColor(msg, caller, stack) {
	  var formatted = '\x1b[36;1m' + this._namespace + '\x1b[22;39m' // bold cyan
	    + ' \x1b[33;1mdeprecated\x1b[22;39m' // bold yellow
	    + ' \x1b[0m' + msg + '\x1b[39m' // reset

	  // add stack trace
	  if (this._traced) {
	    for (var i = 0; i < stack.length; i++) {
	      formatted += '\n    \x1b[36mat ' + callSiteToString(stack[i]) + '\x1b[39m' // cyan
	    }

	    return formatted
	  }

	  if (caller) {
	    formatted += ' \x1b[36m' + formatLocation(caller) + '\x1b[39m' // cyan
	  }

	  return formatted
	}

	/**
	 * Format call site location.
	 */

	function formatLocation(callSite) {
	  return relative(basePath, callSite[0])
	    + ':' + callSite[1]
	    + ':' + callSite[2]
	}

	/**
	 * Get the stack as array of call sites.
	 */

	function getStack() {
	  var limit = Error.stackTraceLimit
	  var obj = {}
	  var prep = Error.prepareStackTrace

	  Error.prepareStackTrace = prepareObjectStackTrace
	  Error.stackTraceLimit = Math.max(10, limit)

	  // capture the stack
	  Error.captureStackTrace(obj)

	  // slice this function off the top
	  var stack = obj.stack.slice(1)

	  Error.prepareStackTrace = prep
	  Error.stackTraceLimit = limit

	  return stack
	}

	/**
	 * Capture call site stack from v8.
	 */

	function prepareObjectStackTrace(obj, stack) {
	  return stack
	}

	/**
	 * Return a wrapped function in a deprecation message.
	 */

	function wrapfunction(fn, message) {
	  if (typeof fn !== 'function') {
	    throw new TypeError('argument fn must be a function')
	  }

	  var args = createArgumentsString(fn.length)
	  var deprecate = this
	  var stack = getStack()
	  var site = callSiteLocation(stack[1])

	  site.name = fn.name

	  var deprecatedfn = eval('(function (' + args + ') {\n'
	    + '"use strict"\n'
	    + 'log.call(deprecate, message, site)\n'
	    + 'return fn.apply(this, arguments)\n'
	    + '})')

	  return deprecatedfn
	}

	/**
	 * Wrap property in a deprecation message.
	 */

	function wrapproperty(obj, prop, message) {
	  if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
	    throw new TypeError('argument obj must be object')
	  }

	  var descriptor = Object.getOwnPropertyDescriptor(obj, prop)

	  if (!descriptor) {
	    throw new TypeError('must call property on owner object')
	  }

	  if (!descriptor.configurable) {
	    throw new TypeError('property must be configurable')
	  }

	  var deprecate = this
	  var stack = getStack()
	  var site = callSiteLocation(stack[1])

	  // set site name
	  site.name = prop

	  // convert data descriptor
	  if ('value' in descriptor) {
	    descriptor = convertDataDescriptorToAccessor(obj, prop, message)
	  }

	  var get = descriptor.get
	  var set = descriptor.set

	  // wrap getter
	  if (typeof get === 'function') {
	    descriptor.get = function getter() {
	      log.call(deprecate, message, site)
	      return get.apply(this, arguments)
	    }
	  }

	  // wrap setter
	  if (typeof set === 'function') {
	    descriptor.set = function setter() {
	      log.call(deprecate, message, site)
	      return set.apply(this, arguments)
	    }
	  }

	  Object.defineProperty(obj, prop, descriptor)
	}

	/**
	 * Create DeprecationError for deprecation
	 */

	function DeprecationError(namespace, message, stack) {
	  var error = new Error()
	  var stackString

	  Object.defineProperty(error, 'constructor', {
	    value: DeprecationError
	  })

	  Object.defineProperty(error, 'message', {
	    configurable: true,
	    enumerable: false,
	    value: message,
	    writable: true
	  })

	  Object.defineProperty(error, 'name', {
	    enumerable: false,
	    configurable: true,
	    value: 'DeprecationError',
	    writable: true
	  })

	  Object.defineProperty(error, 'namespace', {
	    configurable: true,
	    enumerable: false,
	    value: namespace,
	    writable: true
	  })

	  Object.defineProperty(error, 'stack', {
	    configurable: true,
	    enumerable: false,
	    get: function () {
	      if (stackString !== undefined) {
	        return stackString
	      }

	      // prepare stack trace
	      return stackString = createStackString.call(this, stack)
	    },
	    set: function setter(val) {
	      stackString = val
	    }
	  })

	  return error
	}


/***/ },
/* 45 */
/*!************************************!*\
  !*** ./~/depd/lib/compat/index.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * depd
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict'

	/**
	 * Module dependencies.
	 * @private
	 */

	var Buffer = __webpack_require__(/*! buffer */ 46)
	var EventEmitter = __webpack_require__(/*! events */ 26).EventEmitter

	/**
	 * Module exports.
	 * @public
	 */

	lazyProperty(module.exports, 'bufferConcat', function bufferConcat() {
	  return Buffer.concat || __webpack_require__(/*! ./buffer-concat */ 47)
	})

	lazyProperty(module.exports, 'callSiteToString', function callSiteToString() {
	  var limit = Error.stackTraceLimit
	  var obj = {}
	  var prep = Error.prepareStackTrace

	  function prepareObjectStackTrace(obj, stack) {
	    return stack
	  }

	  Error.prepareStackTrace = prepareObjectStackTrace
	  Error.stackTraceLimit = 2

	  // capture the stack
	  Error.captureStackTrace(obj)

	  // slice the stack
	  var stack = obj.stack.slice()

	  Error.prepareStackTrace = prep
	  Error.stackTraceLimit = limit

	  return stack[0].toString ? toString : __webpack_require__(/*! ./callsite-tostring */ 48)
	})

	lazyProperty(module.exports, 'eventListenerCount', function eventListenerCount() {
	  return EventEmitter.listenerCount || __webpack_require__(/*! ./event-listener-count */ 49)
	})

	/**
	 * Define a lazy property.
	 */

	function lazyProperty(obj, prop, getter) {
	  function get() {
	    var val = getter()

	    Object.defineProperty(obj, prop, {
	      configurable: true,
	      enumerable: true,
	      value: val
	    })

	    return val
	  }

	  Object.defineProperty(obj, prop, {
	    configurable: true,
	    enumerable: true,
	    get: get
	  })
	}

	/**
	 * Call toString() on the obj
	 */

	function toString(obj) {
	  return obj.toString()
	}


/***/ },
/* 46 */
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ function(module, exports) {

	module.exports = require("buffer");

/***/ },
/* 47 */
/*!********************************************!*\
  !*** ./~/depd/lib/compat/buffer-concat.js ***!
  \********************************************/
/***/ function(module, exports) {

	/*!
	 * depd
	 * Copyright(c) 2014 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict'

	/**
	 * Module exports.
	 */

	module.exports = bufferConcat

	/**
	 * Concatenate an array of Buffers.
	 */

	function bufferConcat(bufs) {
	  var length = 0

	  for (var i = 0, len = bufs.length; i < len; i++) {
	    length += bufs[i].length
	  }

	  var buf = new Buffer(length)
	  var pos = 0

	  for (var i = 0, len = bufs.length; i < len; i++) {
	    bufs[i].copy(buf, pos)
	    pos += bufs[i].length
	  }

	  return buf
	}


/***/ },
/* 48 */
/*!************************************************!*\
  !*** ./~/depd/lib/compat/callsite-tostring.js ***!
  \************************************************/
/***/ function(module, exports) {

	/*!
	 * depd
	 * Copyright(c) 2014 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict'

	/**
	 * Module exports.
	 */

	module.exports = callSiteToString

	/**
	 * Format a CallSite file location to a string.
	 */

	function callSiteFileLocation(callSite) {
	  var fileName
	  var fileLocation = ''

	  if (callSite.isNative()) {
	    fileLocation = 'native'
	  } else if (callSite.isEval()) {
	    fileName = callSite.getScriptNameOrSourceURL()
	    if (!fileName) {
	      fileLocation = callSite.getEvalOrigin()
	    }
	  } else {
	    fileName = callSite.getFileName()
	  }

	  if (fileName) {
	    fileLocation += fileName

	    var lineNumber = callSite.getLineNumber()
	    if (lineNumber != null) {
	      fileLocation += ':' + lineNumber

	      var columnNumber = callSite.getColumnNumber()
	      if (columnNumber) {
	        fileLocation += ':' + columnNumber
	      }
	    }
	  }

	  return fileLocation || 'unknown source'
	}

	/**
	 * Format a CallSite to a string.
	 */

	function callSiteToString(callSite) {
	  var addSuffix = true
	  var fileLocation = callSiteFileLocation(callSite)
	  var functionName = callSite.getFunctionName()
	  var isConstructor = callSite.isConstructor()
	  var isMethodCall = !(callSite.isToplevel() || isConstructor)
	  var line = ''

	  if (isMethodCall) {
	    var methodName = callSite.getMethodName()
	    var typeName = getConstructorName(callSite)

	    if (functionName) {
	      if (typeName && functionName.indexOf(typeName) !== 0) {
	        line += typeName + '.'
	      }

	      line += functionName

	      if (methodName && functionName.lastIndexOf('.' + methodName) !== functionName.length - methodName.length - 1) {
	        line += ' [as ' + methodName + ']'
	      }
	    } else {
	      line += typeName + '.' + (methodName || '<anonymous>')
	    }
	  } else if (isConstructor) {
	    line += 'new ' + (functionName || '<anonymous>')
	  } else if (functionName) {
	    line += functionName
	  } else {
	    addSuffix = false
	    line += fileLocation
	  }

	  if (addSuffix) {
	    line += ' (' + fileLocation + ')'
	  }

	  return line
	}

	/**
	 * Get constructor name of reviver.
	 */

	function getConstructorName(obj) {
	  var receiver = obj.receiver
	  return (receiver.constructor && receiver.constructor.name) || null
	}


/***/ },
/* 49 */
/*!***************************************************!*\
  !*** ./~/depd/lib/compat/event-listener-count.js ***!
  \***************************************************/
/***/ function(module, exports) {

	/*!
	 * depd
	 * Copyright(c) 2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict'

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = eventListenerCount

	/**
	 * Get the count of listeners on an event emitter of a specific type.
	 */

	function eventListenerCount(emitter, type) {
	  return emitter.listeners(type).length
	}


/***/ },
/* 50 */
/*!*****************************!*\
  !*** ./~/parseurl/index.js ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * parseurl
	 * Copyright(c) 2014 Jonathan Ong
	 * Copyright(c) 2014 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict'

	/**
	 * Module dependencies.
	 */

	var url = __webpack_require__(/*! url */ 51)
	var parse = url.parse
	var Url = url.Url

	/**
	 * Pattern for a simple path case.
	 * See: https://github.com/joyent/node/pull/7878
	 */

	var simplePathRegExp = /^(\/\/?(?!\/)[^\?#\s]*)(\?[^#\s]*)?$/

	/**
	 * Exports.
	 */

	module.exports = parseurl
	module.exports.original = originalurl

	/**
	 * Parse the `req` url with memoization.
	 *
	 * @param {ServerRequest} req
	 * @return {Object}
	 * @api public
	 */

	function parseurl(req) {
	  var url = req.url

	  if (url === undefined) {
	    // URL is undefined
	    return undefined
	  }

	  var parsed = req._parsedUrl

	  if (fresh(url, parsed)) {
	    // Return cached URL parse
	    return parsed
	  }

	  // Parse the URL
	  parsed = fastparse(url)
	  parsed._raw = url

	  return req._parsedUrl = parsed
	};

	/**
	 * Parse the `req` original url with fallback and memoization.
	 *
	 * @param {ServerRequest} req
	 * @return {Object}
	 * @api public
	 */

	function originalurl(req) {
	  var url = req.originalUrl

	  if (typeof url !== 'string') {
	    // Fallback
	    return parseurl(req)
	  }

	  var parsed = req._parsedOriginalUrl

	  if (fresh(url, parsed)) {
	    // Return cached URL parse
	    return parsed
	  }

	  // Parse the URL
	  parsed = fastparse(url)
	  parsed._raw = url

	  return req._parsedOriginalUrl = parsed
	};

	/**
	 * Parse the `str` url with fast-path short-cut.
	 *
	 * @param {string} str
	 * @return {Object}
	 * @api private
	 */

	function fastparse(str) {
	  // Try fast path regexp
	  // See: https://github.com/joyent/node/pull/7878
	  var simplePath = typeof str === 'string' && simplePathRegExp.exec(str)

	  // Construct simple URL
	  if (simplePath) {
	    var pathname = simplePath[1]
	    var search = simplePath[2] || null
	    var url = Url !== undefined
	      ? new Url()
	      : {}
	    url.path = str
	    url.href = str
	    url.pathname = pathname
	    url.search = search
	    url.query = search && search.substr(1)

	    return url
	  }

	  return parse(str)
	}

	/**
	 * Determine if parsed is still fresh for url.
	 *
	 * @param {string} url
	 * @param {object} parsedUrl
	 * @return {boolean}
	 * @api private
	 */

	function fresh(url, parsedUrl) {
	  return typeof parsedUrl === 'object'
	    && parsedUrl !== null
	    && (Url === undefined || parsedUrl instanceof Url)
	    && parsedUrl._raw === url
	}


/***/ },
/* 51 */
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ function(module, exports) {

	module.exports = require("url");

/***/ },
/* 52 */
/*!******************************************!*\
  !*** ./~/express/lib/middleware/init.js ***!
  \******************************************/
/***/ function(module, exports) {

	/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2013 Roman Shtylman
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Initialization middleware, exposing the
	 * request and response to each other, as well
	 * as defaulting the X-Powered-By header field.
	 *
	 * @param {Function} app
	 * @return {Function}
	 * @api private
	 */

	exports.init = function(app){
	  return function expressInit(req, res, next){
	    if (app.enabled('x-powered-by')) res.setHeader('X-Powered-By', 'Express');
	    req.res = res;
	    res.req = req;
	    req.next = next;

	    req.__proto__ = app.request;
	    res.__proto__ = app.response;

	    res.locals = res.locals || Object.create(null);

	    next();
	  };
	};



/***/ },
/* 53 */
/*!*******************************************!*\
  !*** ./~/express/lib/middleware/query.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2013 Roman Shtylman
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 */

	var parseUrl = __webpack_require__(/*! parseurl */ 50);
	var qs = __webpack_require__(/*! qs */ 54);

	/**
	 * @param {Object} options
	 * @return {Function}
	 * @api public
	 */

	module.exports = function query(options) {
	  var opts = Object.create(options || null);
	  var queryparse = qs.parse;

	  if (typeof options === 'function') {
	    queryparse = options;
	    opts = undefined;
	  }

	  if (opts !== undefined && opts.allowPrototypes === undefined) {
	    // back-compat for qs module
	    opts.allowPrototypes = true;
	  }

	  return function query(req, res, next){
	    if (!req.query) {
	      var val = parseUrl(req).query;
	      req.query = queryparse(val, opts);
	    }

	    next();
	  };
	};


/***/ },
/* 54 */
/*!***************************!*\
  !*** ./~/qs/lib/index.js ***!
  \***************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Stringify = __webpack_require__(/*! ./stringify */ 55);
	var Parse = __webpack_require__(/*! ./parse */ 57);

	module.exports = {
	    stringify: Stringify,
	    parse: Parse
	};


/***/ },
/* 55 */
/*!*******************************!*\
  !*** ./~/qs/lib/stringify.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Utils = __webpack_require__(/*! ./utils */ 56);

	var arrayPrefixGenerators = {
	    brackets: function brackets(prefix) {
	        return prefix + '[]';
	    },
	    indices: function indices(prefix, key) {
	        return prefix + '[' + key + ']';
	    },
	    repeat: function repeat(prefix) {
	        return prefix;
	    }
	};

	var defaults = {
	    delimiter: '&',
	    strictNullHandling: false,
	    skipNulls: false,
	    encode: true,
	    encoder: Utils.encode
	};

	var stringify = function stringify(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots) {
	    var obj = object;
	    if (typeof filter === 'function') {
	        obj = filter(prefix, obj);
	    } else if (obj instanceof Date) {
	        obj = obj.toISOString();
	    } else if (obj === null) {
	        if (strictNullHandling) {
	            return encoder ? encoder(prefix) : prefix;
	        }

	        obj = '';
	    }

	    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || Utils.isBuffer(obj)) {
	        if (encoder) {
	            return [encoder(prefix) + '=' + encoder(obj)];
	        }
	        return [prefix + '=' + String(obj)];
	    }

	    var values = [];

	    if (typeof obj === 'undefined') {
	        return values;
	    }

	    var objKeys;
	    if (Array.isArray(filter)) {
	        objKeys = filter;
	    } else {
	        var keys = Object.keys(obj);
	        objKeys = sort ? keys.sort(sort) : keys;
	    }

	    for (var i = 0; i < objKeys.length; ++i) {
	        var key = objKeys[i];

	        if (skipNulls && obj[key] === null) {
	            continue;
	        }

	        if (Array.isArray(obj)) {
	            values = values.concat(stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));
	        } else {
	            values = values.concat(stringify(obj[key], prefix + (allowDots ? '.' + key : '[' + key + ']'), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));
	        }
	    }

	    return values;
	};

	module.exports = function (object, opts) {
	    var obj = object;
	    var options = opts || {};
	    var delimiter = typeof options.delimiter === 'undefined' ? defaults.delimiter : options.delimiter;
	    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;
	    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults.skipNulls;
	    var encode = typeof options.encode === 'boolean' ? options.encode : defaults.encode;
	    var encoder = encode ? (typeof options.encoder === 'function' ? options.encoder : defaults.encoder) : null;
	    var sort = typeof options.sort === 'function' ? options.sort : null;
	    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;
	    var objKeys;
	    var filter;

	    if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== 'function') {
	        throw new TypeError('Encoder has to be a function.');
	    }

	    if (typeof options.filter === 'function') {
	        filter = options.filter;
	        obj = filter('', obj);
	    } else if (Array.isArray(options.filter)) {
	        objKeys = filter = options.filter;
	    }

	    var keys = [];

	    if (typeof obj !== 'object' || obj === null) {
	        return '';
	    }

	    var arrayFormat;
	    if (options.arrayFormat in arrayPrefixGenerators) {
	        arrayFormat = options.arrayFormat;
	    } else if ('indices' in options) {
	        arrayFormat = options.indices ? 'indices' : 'repeat';
	    } else {
	        arrayFormat = 'indices';
	    }

	    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

	    if (!objKeys) {
	        objKeys = Object.keys(obj);
	    }

	    if (sort) {
	        objKeys.sort(sort);
	    }

	    for (var i = 0; i < objKeys.length; ++i) {
	        var key = objKeys[i];

	        if (skipNulls && obj[key] === null) {
	            continue;
	        }

	        keys = keys.concat(stringify(obj[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));
	    }

	    return keys.join(delimiter);
	};


/***/ },
/* 56 */
/*!***************************!*\
  !*** ./~/qs/lib/utils.js ***!
  \***************************/
/***/ function(module, exports) {

	'use strict';

	var hexTable = (function () {
	    var array = new Array(256);
	    for (var i = 0; i < 256; ++i) {
	        array[i] = '%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase();
	    }

	    return array;
	}());

	exports.arrayToObject = function (source, options) {
	    var obj = options.plainObjects ? Object.create(null) : {};
	    for (var i = 0; i < source.length; ++i) {
	        if (typeof source[i] !== 'undefined') {
	            obj[i] = source[i];
	        }
	    }

	    return obj;
	};

	exports.merge = function (target, source, options) {
	    if (!source) {
	        return target;
	    }

	    if (typeof source !== 'object') {
	        if (Array.isArray(target)) {
	            target.push(source);
	        } else if (typeof target === 'object') {
	            target[source] = true;
	        } else {
	            return [target, source];
	        }

	        return target;
	    }

	    if (typeof target !== 'object') {
	        return [target].concat(source);
	    }

	    var mergeTarget = target;
	    if (Array.isArray(target) && !Array.isArray(source)) {
	        mergeTarget = exports.arrayToObject(target, options);
	    }

	    return Object.keys(source).reduce(function (acc, key) {
	        var value = source[key];

	        if (Object.prototype.hasOwnProperty.call(acc, key)) {
	            acc[key] = exports.merge(acc[key], value, options);
	        } else {
	            acc[key] = value;
	        }
	        return acc;
	    }, mergeTarget);
	};

	exports.decode = function (str) {
	    try {
	        return decodeURIComponent(str.replace(/\+/g, ' '));
	    } catch (e) {
	        return str;
	    }
	};

	exports.encode = function (str) {
	    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
	    // It has been adapted here for stricter adherence to RFC 3986
	    if (str.length === 0) {
	        return str;
	    }

	    var string = typeof str === 'string' ? str : String(str);

	    var out = '';
	    for (var i = 0; i < string.length; ++i) {
	        var c = string.charCodeAt(i);

	        if (
	            c === 0x2D || // -
	            c === 0x2E || // .
	            c === 0x5F || // _
	            c === 0x7E || // ~
	            (c >= 0x30 && c <= 0x39) || // 0-9
	            (c >= 0x41 && c <= 0x5A) || // a-z
	            (c >= 0x61 && c <= 0x7A) // A-Z
	        ) {
	            out += string.charAt(i);
	            continue;
	        }

	        if (c < 0x80) {
	            out = out + hexTable[c];
	            continue;
	        }

	        if (c < 0x800) {
	            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
	            continue;
	        }

	        if (c < 0xD800 || c >= 0xE000) {
	            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
	            continue;
	        }

	        i += 1;
	        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
	        out += hexTable[0xF0 | (c >> 18)] + hexTable[0x80 | ((c >> 12) & 0x3F)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)];
	    }

	    return out;
	};

	exports.compact = function (obj, references) {
	    if (typeof obj !== 'object' || obj === null) {
	        return obj;
	    }

	    var refs = references || [];
	    var lookup = refs.indexOf(obj);
	    if (lookup !== -1) {
	        return refs[lookup];
	    }

	    refs.push(obj);

	    if (Array.isArray(obj)) {
	        var compacted = [];

	        for (var i = 0; i < obj.length; ++i) {
	            if (obj[i] && typeof obj[i] === 'object') {
	                compacted.push(exports.compact(obj[i], refs));
	            } else if (typeof obj[i] !== 'undefined') {
	                compacted.push(obj[i]);
	            }
	        }

	        return compacted;
	    }

	    var keys = Object.keys(obj);
	    for (var j = 0; j < keys.length; ++j) {
	        var key = keys[j];
	        obj[key] = exports.compact(obj[key], refs);
	    }

	    return obj;
	};

	exports.isRegExp = function (obj) {
	    return Object.prototype.toString.call(obj) === '[object RegExp]';
	};

	exports.isBuffer = function (obj) {
	    if (obj === null || typeof obj === 'undefined') {
	        return false;
	    }

	    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
	};


/***/ },
/* 57 */
/*!***************************!*\
  !*** ./~/qs/lib/parse.js ***!
  \***************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Utils = __webpack_require__(/*! ./utils */ 56);

	var defaults = {
	    delimiter: '&',
	    depth: 5,
	    arrayLimit: 20,
	    parameterLimit: 1000,
	    strictNullHandling: false,
	    plainObjects: false,
	    allowPrototypes: false,
	    allowDots: false,
	    decoder: Utils.decode
	};

	var parseValues = function parseValues(str, options) {
	    var obj = {};
	    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);

	    for (var i = 0; i < parts.length; ++i) {
	        var part = parts[i];
	        var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;

	        if (pos === -1) {
	            obj[options.decoder(part)] = '';

	            if (options.strictNullHandling) {
	                obj[options.decoder(part)] = null;
	            }
	        } else {
	            var key = options.decoder(part.slice(0, pos));
	            var val = options.decoder(part.slice(pos + 1));

	            if (Object.prototype.hasOwnProperty.call(obj, key)) {
	                obj[key] = [].concat(obj[key]).concat(val);
	            } else {
	                obj[key] = val;
	            }
	        }
	    }

	    return obj;
	};

	var parseObject = function parseObject(chain, val, options) {
	    if (!chain.length) {
	        return val;
	    }

	    var root = chain.shift();

	    var obj;
	    if (root === '[]') {
	        obj = [];
	        obj = obj.concat(parseObject(chain, val, options));
	    } else {
	        obj = options.plainObjects ? Object.create(null) : {};
	        var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;
	        var index = parseInt(cleanRoot, 10);
	        if (
	            !isNaN(index) &&
	            root !== cleanRoot &&
	            String(index) === cleanRoot &&
	            index >= 0 &&
	            (options.parseArrays && index <= options.arrayLimit)
	        ) {
	            obj = [];
	            obj[index] = parseObject(chain, val, options);
	        } else {
	            obj[cleanRoot] = parseObject(chain, val, options);
	        }
	    }

	    return obj;
	};

	var parseKeys = function parseKeys(givenKey, val, options) {
	    if (!givenKey) {
	        return;
	    }

	    // Transform dot notation to bracket notation
	    var key = options.allowDots ? givenKey.replace(/\.([^\.\[]+)/g, '[$1]') : givenKey;

	    // The regex chunks

	    var parent = /^([^\[\]]*)/;
	    var child = /(\[[^\[\]]*\])/g;

	    // Get the parent

	    var segment = parent.exec(key);

	    // Stash the parent if it exists

	    var keys = [];
	    if (segment[1]) {
	        // If we aren't using plain objects, optionally prefix keys
	        // that would overwrite object prototype properties
	        if (!options.plainObjects && Object.prototype.hasOwnProperty(segment[1])) {
	            if (!options.allowPrototypes) {
	                return;
	            }
	        }

	        keys.push(segment[1]);
	    }

	    // Loop through children appending to the array until we hit depth

	    var i = 0;
	    while ((segment = child.exec(key)) !== null && i < options.depth) {
	        i += 1;
	        if (!options.plainObjects && Object.prototype.hasOwnProperty(segment[1].replace(/\[|\]/g, ''))) {
	            if (!options.allowPrototypes) {
	                continue;
	            }
	        }
	        keys.push(segment[1]);
	    }

	    // If there's a remainder, just add whatever is left

	    if (segment) {
	        keys.push('[' + key.slice(segment.index) + ']');
	    }

	    return parseObject(keys, val, options);
	};

	module.exports = function (str, opts) {
	    var options = opts || {};

	    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {
	        throw new TypeError('Decoder has to be a function.');
	    }

	    options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;
	    options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;
	    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;
	    options.parseArrays = options.parseArrays !== false;
	    options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;
	    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;
	    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;
	    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;
	    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;
	    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;

	    if (str === '' || str === null || typeof str === 'undefined') {
	        return options.plainObjects ? Object.create(null) : {};
	    }

	    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
	    var obj = options.plainObjects ? Object.create(null) : {};

	    // Iterate over the keys and setup the new object

	    var keys = Object.keys(tempObj);
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        var newObj = parseKeys(key, tempObj[key], options);
	        obj = Utils.merge(obj, newObj, options);
	    }

	    return Utils.compact(obj);
	};


/***/ },
/* 58 */
/*!*******************************!*\
  !*** ./~/express/lib/view.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2013 Roman Shtylman
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @private
	 */

	var debug = __webpack_require__(/*! debug */ 14)('express:view');
	var path = __webpack_require__(/*! path */ 11);
	var fs = __webpack_require__(/*! fs */ 19);
	var utils = __webpack_require__(/*! ./utils */ 59);

	/**
	 * Module variables.
	 * @private
	 */

	var dirname = path.dirname;
	var basename = path.basename;
	var extname = path.extname;
	var join = path.join;
	var resolve = path.resolve;

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = View;

	/**
	 * Initialize a new `View` with the given `name`.
	 *
	 * Options:
	 *
	 *   - `defaultEngine` the default template engine name
	 *   - `engines` template engine require() cache
	 *   - `root` root path for view lookup
	 *
	 * @param {string} name
	 * @param {object} options
	 * @public
	 */

	function View(name, options) {
	  var opts = options || {};

	  this.defaultEngine = opts.defaultEngine;
	  this.ext = extname(name);
	  this.name = name;
	  this.root = opts.root;

	  if (!this.ext && !this.defaultEngine) {
	    throw new Error('No default engine was specified and no extension was provided.');
	  }

	  var fileName = name;

	  if (!this.ext) {
	    // get extension from default engine name
	    this.ext = this.defaultEngine[0] !== '.'
	      ? '.' + this.defaultEngine
	      : this.defaultEngine;

	    fileName += this.ext;
	  }

	  if (!opts.engines[this.ext]) {
	    // load engine
	    opts.engines[this.ext] = __webpack_require__(/*! . */ 80)(this.ext.substr(1)).__express;
	  }

	  // store loaded engine
	  this.engine = opts.engines[this.ext];

	  // lookup path
	  this.path = this.lookup(fileName);
	}

	/**
	 * Lookup view by the given `name`
	 *
	 * @param {string} name
	 * @private
	 */

	View.prototype.lookup = function lookup(name) {
	  var path;
	  var roots = [].concat(this.root);

	  debug('lookup "%s"', name);

	  for (var i = 0; i < roots.length && !path; i++) {
	    var root = roots[i];

	    // resolve the path
	    var loc = resolve(root, name);
	    var dir = dirname(loc);
	    var file = basename(loc);

	    // resolve the file
	    path = this.resolve(dir, file);
	  }

	  return path;
	};

	/**
	 * Render with the given options.
	 *
	 * @param {object} options
	 * @param {function} callback
	 * @private
	 */

	View.prototype.render = function render(options, callback) {
	  debug('render "%s"', this.path);
	  this.engine(this.path, options, callback);
	};

	/**
	 * Resolve the file within the given directory.
	 *
	 * @param {string} dir
	 * @param {string} file
	 * @private
	 */

	View.prototype.resolve = function resolve(dir, file) {
	  var ext = this.ext;

	  // <path>.<ext>
	  var path = join(dir, file);
	  var stat = tryStat(path);

	  if (stat && stat.isFile()) {
	    return path;
	  }

	  // <path>/index.<ext>
	  path = join(dir, basename(file, ext), 'index' + ext);
	  stat = tryStat(path);

	  if (stat && stat.isFile()) {
	    return path;
	  }
	};

	/**
	 * Return a stat, maybe.
	 *
	 * @param {string} path
	 * @return {fs.Stats}
	 * @private
	 */

	function tryStat(path) {
	  debug('stat "%s"', path);

	  try {
	    return fs.statSync(path);
	  } catch (e) {
	    return undefined;
	  }
	}


/***/ },
/* 59 */
/*!********************************!*\
  !*** ./~/express/lib/utils.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @api private
	 */

	var contentDisposition = __webpack_require__(/*! content-disposition */ 60);
	var contentType = __webpack_require__(/*! content-type */ 61);
	var deprecate = __webpack_require__(/*! depd */ 44)('express');
	var flatten = __webpack_require__(/*! array-flatten */ 38);
	var mime = __webpack_require__(/*! send */ 62).mime;
	var basename = __webpack_require__(/*! path */ 11).basename;
	var etag = __webpack_require__(/*! etag */ 69);
	var proxyaddr = __webpack_require__(/*! proxy-addr */ 75);
	var qs = __webpack_require__(/*! qs */ 54);
	var querystring = __webpack_require__(/*! querystring */ 79);

	/**
	 * Return strong ETag for `body`.
	 *
	 * @param {String|Buffer} body
	 * @param {String} [encoding]
	 * @return {String}
	 * @api private
	 */

	exports.etag = function (body, encoding) {
	  var buf = !Buffer.isBuffer(body)
	    ? new Buffer(body, encoding)
	    : body;

	  return etag(buf, {weak: false});
	};

	/**
	 * Return weak ETag for `body`.
	 *
	 * @param {String|Buffer} body
	 * @param {String} [encoding]
	 * @return {String}
	 * @api private
	 */

	exports.wetag = function wetag(body, encoding){
	  var buf = !Buffer.isBuffer(body)
	    ? new Buffer(body, encoding)
	    : body;

	  return etag(buf, {weak: true});
	};

	/**
	 * Check if `path` looks absolute.
	 *
	 * @param {String} path
	 * @return {Boolean}
	 * @api private
	 */

	exports.isAbsolute = function(path){
	  if ('/' === path[0]) return true;
	  if (':' === path[1] && ('\\' === path[2] || '/' === path[2])) return true; // Windows device path
	  if ('\\\\' === path.substring(0, 2)) return true; // Microsoft Azure absolute path
	};

	/**
	 * Flatten the given `arr`.
	 *
	 * @param {Array} arr
	 * @return {Array}
	 * @api private
	 */

	exports.flatten = deprecate.function(flatten,
	  'utils.flatten: use array-flatten npm module instead');

	/**
	 * Normalize the given `type`, for example "html" becomes "text/html".
	 *
	 * @param {String} type
	 * @return {Object}
	 * @api private
	 */

	exports.normalizeType = function(type){
	  return ~type.indexOf('/')
	    ? acceptParams(type)
	    : { value: mime.lookup(type), params: {} };
	};

	/**
	 * Normalize `types`, for example "html" becomes "text/html".
	 *
	 * @param {Array} types
	 * @return {Array}
	 * @api private
	 */

	exports.normalizeTypes = function(types){
	  var ret = [];

	  for (var i = 0; i < types.length; ++i) {
	    ret.push(exports.normalizeType(types[i]));
	  }

	  return ret;
	};

	/**
	 * Generate Content-Disposition header appropriate for the filename.
	 * non-ascii filenames are urlencoded and a filename* parameter is added
	 *
	 * @param {String} filename
	 * @return {String}
	 * @api private
	 */

	exports.contentDisposition = deprecate.function(contentDisposition,
	  'utils.contentDisposition: use content-disposition npm module instead');

	/**
	 * Parse accept params `str` returning an
	 * object with `.value`, `.quality` and `.params`.
	 * also includes `.originalIndex` for stable sorting
	 *
	 * @param {String} str
	 * @return {Object}
	 * @api private
	 */

	function acceptParams(str, index) {
	  var parts = str.split(/ *; */);
	  var ret = { value: parts[0], quality: 1, params: {}, originalIndex: index };

	  for (var i = 1; i < parts.length; ++i) {
	    var pms = parts[i].split(/ *= */);
	    if ('q' === pms[0]) {
	      ret.quality = parseFloat(pms[1]);
	    } else {
	      ret.params[pms[0]] = pms[1];
	    }
	  }

	  return ret;
	}

	/**
	 * Compile "etag" value to function.
	 *
	 * @param  {Boolean|String|Function} val
	 * @return {Function}
	 * @api private
	 */

	exports.compileETag = function(val) {
	  var fn;

	  if (typeof val === 'function') {
	    return val;
	  }

	  switch (val) {
	    case true:
	      fn = exports.wetag;
	      break;
	    case false:
	      break;
	    case 'strong':
	      fn = exports.etag;
	      break;
	    case 'weak':
	      fn = exports.wetag;
	      break;
	    default:
	      throw new TypeError('unknown value for etag function: ' + val);
	  }

	  return fn;
	}

	/**
	 * Compile "query parser" value to function.
	 *
	 * @param  {String|Function} val
	 * @return {Function}
	 * @api private
	 */

	exports.compileQueryParser = function compileQueryParser(val) {
	  var fn;

	  if (typeof val === 'function') {
	    return val;
	  }

	  switch (val) {
	    case true:
	      fn = querystring.parse;
	      break;
	    case false:
	      fn = newObject;
	      break;
	    case 'extended':
	      fn = parseExtendedQueryString;
	      break;
	    case 'simple':
	      fn = querystring.parse;
	      break;
	    default:
	      throw new TypeError('unknown value for query parser function: ' + val);
	  }

	  return fn;
	}

	/**
	 * Compile "proxy trust" value to function.
	 *
	 * @param  {Boolean|String|Number|Array|Function} val
	 * @return {Function}
	 * @api private
	 */

	exports.compileTrust = function(val) {
	  if (typeof val === 'function') return val;

	  if (val === true) {
	    // Support plain true/false
	    return function(){ return true };
	  }

	  if (typeof val === 'number') {
	    // Support trusting hop count
	    return function(a, i){ return i < val };
	  }

	  if (typeof val === 'string') {
	    // Support comma-separated values
	    val = val.split(/ *, */);
	  }

	  return proxyaddr.compile(val || []);
	}

	/**
	 * Set the charset in a given Content-Type string.
	 *
	 * @param {String} type
	 * @param {String} charset
	 * @return {String}
	 * @api private
	 */

	exports.setCharset = function setCharset(type, charset) {
	  if (!type || !charset) {
	    return type;
	  }

	  // parse type
	  var parsed = contentType.parse(type);

	  // set charset
	  parsed.parameters.charset = charset;

	  // format type
	  return contentType.format(parsed);
	};

	/**
	 * Parse an extended query string with qs.
	 *
	 * @return {Object}
	 * @private
	 */

	function parseExtendedQueryString(str) {
	  return qs.parse(str, {
	    allowPrototypes: true
	  });
	}

	/**
	 * Return new empty object.
	 *
	 * @return {Object}
	 * @api private
	 */

	function newObject() {
	  return {};
	}


/***/ },
/* 60 */
/*!****************************************!*\
  !*** ./~/content-disposition/index.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * content-disposition
	 * Copyright(c) 2014 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict'

	/**
	 * Module exports.
	 */

	module.exports = contentDisposition
	module.exports.parse = parse

	/**
	 * Module dependencies.
	 */

	var basename = __webpack_require__(/*! path */ 11).basename

	/**
	 * RegExp to match non attr-char, *after* encodeURIComponent (i.e. not including "%")
	 */

	var encodeUriAttrCharRegExp = /[\x00-\x20"'\(\)*,\/:;<=>?@\[\\\]\{\}\x7f]/g

	/**
	 * RegExp to match percent encoding escape.
	 */

	var hexEscapeRegExp = /%[0-9A-Fa-f]{2}/
	var hexEscapeReplaceRegExp = /%([0-9A-Fa-f]{2})/g

	/**
	 * RegExp to match non-latin1 characters.
	 */

	var nonLatin1RegExp = /[^\x20-\x7e\xa0-\xff]/g

	/**
	 * RegExp to match quoted-pair in RFC 2616
	 *
	 * quoted-pair = "\" CHAR
	 * CHAR        = <any US-ASCII character (octets 0 - 127)>
	 */

	var qescRegExp = /\\([\u0000-\u007f])/g;

	/**
	 * RegExp to match chars that must be quoted-pair in RFC 2616
	 */

	var quoteRegExp = /([\\"])/g

	/**
	 * RegExp for various RFC 2616 grammar
	 *
	 * parameter     = token "=" ( token | quoted-string )
	 * token         = 1*<any CHAR except CTLs or separators>
	 * separators    = "(" | ")" | "<" | ">" | "@"
	 *               | "," | ";" | ":" | "\" | <">
	 *               | "/" | "[" | "]" | "?" | "="
	 *               | "{" | "}" | SP | HT
	 * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
	 * qdtext        = <any TEXT except <">>
	 * quoted-pair   = "\" CHAR
	 * CHAR          = <any US-ASCII character (octets 0 - 127)>
	 * TEXT          = <any OCTET except CTLs, but including LWS>
	 * LWS           = [CRLF] 1*( SP | HT )
	 * CRLF          = CR LF
	 * CR            = <US-ASCII CR, carriage return (13)>
	 * LF            = <US-ASCII LF, linefeed (10)>
	 * SP            = <US-ASCII SP, space (32)>
	 * HT            = <US-ASCII HT, horizontal-tab (9)>
	 * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
	 * OCTET         = <any 8-bit sequence of data>
	 */

	var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g
	var textRegExp = /^[\x20-\x7e\x80-\xff]+$/
	var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/

	/**
	 * RegExp for various RFC 5987 grammar
	 *
	 * ext-value     = charset  "'" [ language ] "'" value-chars
	 * charset       = "UTF-8" / "ISO-8859-1" / mime-charset
	 * mime-charset  = 1*mime-charsetc
	 * mime-charsetc = ALPHA / DIGIT
	 *               / "!" / "#" / "$" / "%" / "&"
	 *               / "+" / "-" / "^" / "_" / "`"
	 *               / "{" / "}" / "~"
	 * language      = ( 2*3ALPHA [ extlang ] )
	 *               / 4ALPHA
	 *               / 5*8ALPHA
	 * extlang       = *3( "-" 3ALPHA )
	 * value-chars   = *( pct-encoded / attr-char )
	 * pct-encoded   = "%" HEXDIG HEXDIG
	 * attr-char     = ALPHA / DIGIT
	 *               / "!" / "#" / "$" / "&" / "+" / "-" / "."
	 *               / "^" / "_" / "`" / "|" / "~"
	 */

	var extValueRegExp = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+\-\.^_`|~])+)$/

	/**
	 * RegExp for various RFC 6266 grammar
	 *
	 * disposition-type = "inline" | "attachment" | disp-ext-type
	 * disp-ext-type    = token
	 * disposition-parm = filename-parm | disp-ext-parm
	 * filename-parm    = "filename" "=" value
	 *                  | "filename*" "=" ext-value
	 * disp-ext-parm    = token "=" value
	 *                  | ext-token "=" ext-value
	 * ext-token        = <the characters in token, followed by "*">
	 */

	var dispositionTypeRegExp = /^([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *(?:$|;)/

	/**
	 * Create an attachment Content-Disposition header.
	 *
	 * @param {string} [filename]
	 * @param {object} [options]
	 * @param {string} [options.type=attachment]
	 * @param {string|boolean} [options.fallback=true]
	 * @return {string}
	 * @api public
	 */

	function contentDisposition(filename, options) {
	  var opts = options || {}

	  // get type
	  var type = opts.type || 'attachment'

	  // get parameters
	  var params = createparams(filename, opts.fallback)

	  // format into string
	  return format(new ContentDisposition(type, params))
	}

	/**
	 * Create parameters object from filename and fallback.
	 *
	 * @param {string} [filename]
	 * @param {string|boolean} [fallback=true]
	 * @return {object}
	 * @api private
	 */

	function createparams(filename, fallback) {
	  if (filename === undefined) {
	    return
	  }

	  var params = {}

	  if (typeof filename !== 'string') {
	    throw new TypeError('filename must be a string')
	  }

	  // fallback defaults to true
	  if (fallback === undefined) {
	    fallback = true
	  }

	  if (typeof fallback !== 'string' && typeof fallback !== 'boolean') {
	    throw new TypeError('fallback must be a string or boolean')
	  }

	  if (typeof fallback === 'string' && nonLatin1RegExp.test(fallback)) {
	    throw new TypeError('fallback must be ISO-8859-1 string')
	  }

	  // restrict to file base name
	  var name = basename(filename)

	  // determine if name is suitable for quoted string
	  var isQuotedString = textRegExp.test(name)

	  // generate fallback name
	  var fallbackName = typeof fallback !== 'string'
	    ? fallback && getlatin1(name)
	    : basename(fallback)
	  var hasFallback = typeof fallbackName === 'string' && fallbackName !== name

	  // set extended filename parameter
	  if (hasFallback || !isQuotedString || hexEscapeRegExp.test(name)) {
	    params['filename*'] = name
	  }

	  // set filename parameter
	  if (isQuotedString || hasFallback) {
	    params.filename = hasFallback
	      ? fallbackName
	      : name
	  }

	  return params
	}

	/**
	 * Format object to Content-Disposition header.
	 *
	 * @param {object} obj
	 * @param {string} obj.type
	 * @param {object} [obj.parameters]
	 * @return {string}
	 * @api private
	 */

	function format(obj) {
	  var parameters = obj.parameters
	  var type = obj.type

	  if (!type || typeof type !== 'string' || !tokenRegExp.test(type)) {
	    throw new TypeError('invalid type')
	  }

	  // start with normalized type
	  var string = String(type).toLowerCase()

	  // append parameters
	  if (parameters && typeof parameters === 'object') {
	    var param
	    var params = Object.keys(parameters).sort()

	    for (var i = 0; i < params.length; i++) {
	      param = params[i]

	      var val = param.substr(-1) === '*'
	        ? ustring(parameters[param])
	        : qstring(parameters[param])

	      string += '; ' + param + '=' + val
	    }
	  }

	  return string
	}

	/**
	 * Decode a RFC 6987 field value (gracefully).
	 *
	 * @param {string} str
	 * @return {string}
	 * @api private
	 */

	function decodefield(str) {
	  var match = extValueRegExp.exec(str)

	  if (!match) {
	    throw new TypeError('invalid extended field value')
	  }

	  var charset = match[1].toLowerCase()
	  var encoded = match[2]
	  var value

	  // to binary string
	  var binary = encoded.replace(hexEscapeReplaceRegExp, pdecode)

	  switch (charset) {
	    case 'iso-8859-1':
	      value = getlatin1(binary)
	      break
	    case 'utf-8':
	      value = new Buffer(binary, 'binary').toString('utf8')
	      break
	    default:
	      throw new TypeError('unsupported charset in extended field')
	  }

	  return value
	}

	/**
	 * Get ISO-8859-1 version of string.
	 *
	 * @param {string} val
	 * @return {string}
	 * @api private
	 */

	function getlatin1(val) {
	  // simple Unicode -> ISO-8859-1 transformation
	  return String(val).replace(nonLatin1RegExp, '?')
	}

	/**
	 * Parse Content-Disposition header string.
	 *
	 * @param {string} string
	 * @return {object}
	 * @api private
	 */

	function parse(string) {
	  if (!string || typeof string !== 'string') {
	    throw new TypeError('argument string is required')
	  }

	  var match = dispositionTypeRegExp.exec(string)

	  if (!match) {
	    throw new TypeError('invalid type format')
	  }

	  // normalize type
	  var index = match[0].length
	  var type = match[1].toLowerCase()

	  var key
	  var names = []
	  var params = {}
	  var value

	  // calculate index to start at
	  index = paramRegExp.lastIndex = match[0].substr(-1) === ';'
	    ? index - 1
	    : index

	  // match parameters
	  while (match = paramRegExp.exec(string)) {
	    if (match.index !== index) {
	      throw new TypeError('invalid parameter format')
	    }

	    index += match[0].length
	    key = match[1].toLowerCase()
	    value = match[2]

	    if (names.indexOf(key) !== -1) {
	      throw new TypeError('invalid duplicate parameter')
	    }

	    names.push(key)

	    if (key.indexOf('*') + 1 === key.length) {
	      // decode extended value
	      key = key.slice(0, -1)
	      value = decodefield(value)

	      // overwrite existing value
	      params[key] = value
	      continue
	    }

	    if (typeof params[key] === 'string') {
	      continue
	    }

	    if (value[0] === '"') {
	      // remove quotes and escapes
	      value = value
	        .substr(1, value.length - 2)
	        .replace(qescRegExp, '$1')
	    }

	    params[key] = value
	  }

	  if (index !== -1 && index !== string.length) {
	    throw new TypeError('invalid parameter format')
	  }

	  return new ContentDisposition(type, params)
	}

	/**
	 * Percent decode a single character.
	 *
	 * @param {string} str
	 * @param {string} hex
	 * @return {string}
	 * @api private
	 */

	function pdecode(str, hex) {
	  return String.fromCharCode(parseInt(hex, 16))
	}

	/**
	 * Percent encode a single character.
	 *
	 * @param {string} char
	 * @return {string}
	 * @api private
	 */

	function pencode(char) {
	  var hex = String(char)
	    .charCodeAt(0)
	    .toString(16)
	    .toUpperCase()
	  return hex.length === 1
	    ? '%0' + hex
	    : '%' + hex
	}

	/**
	 * Quote a string for HTTP.
	 *
	 * @param {string} val
	 * @return {string}
	 * @api private
	 */

	function qstring(val) {
	  var str = String(val)

	  return '"' + str.replace(quoteRegExp, '\\$1') + '"'
	}

	/**
	 * Encode a Unicode string for HTTP (RFC 5987).
	 *
	 * @param {string} val
	 * @return {string}
	 * @api private
	 */

	function ustring(val) {
	  var str = String(val)

	  // percent encode as UTF-8
	  var encoded = encodeURIComponent(str)
	    .replace(encodeUriAttrCharRegExp, pencode)

	  return 'UTF-8\'\'' + encoded
	}

	/**
	 * Class for parsed Content-Disposition header for v8 optimization
	 */

	function ContentDisposition(type, parameters) {
	  this.type = type
	  this.parameters = parameters
	}


/***/ },
/* 61 */
/*!*********************************!*\
  !*** ./~/content-type/index.js ***!
  \*********************************/
/***/ function(module, exports) {

	/*!
	 * content-type
	 * Copyright(c) 2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict'

	/**
	 * RegExp to match *( ";" parameter ) in RFC 7231 sec 3.1.1.1
	 *
	 * parameter     = token "=" ( token / quoted-string )
	 * token         = 1*tchar
	 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
	 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
	 *               / DIGIT / ALPHA
	 *               ; any VCHAR, except delimiters
	 * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
	 * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
	 * obs-text      = %x80-FF
	 * quoted-pair   = "\" ( HTAB / SP / VCHAR / obs-text )
	 */
	var paramRegExp = /; *([!#$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+) */g
	var textRegExp = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/
	var tokenRegExp = /^[!#$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+$/

	/**
	 * RegExp to match quoted-pair in RFC 7230 sec 3.2.6
	 *
	 * quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
	 * obs-text    = %x80-FF
	 */
	var qescRegExp = /\\([\u000b\u0020-\u00ff])/g

	/**
	 * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6
	 */
	var quoteRegExp = /([\\"])/g

	/**
	 * RegExp to match type in RFC 6838
	 *
	 * media-type = type "/" subtype
	 * type       = token
	 * subtype    = token
	 */
	var typeRegExp = /^[!#$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+\/[!#$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+$/

	/**
	 * Module exports.
	 * @public
	 */

	exports.format = format
	exports.parse = parse

	/**
	 * Format object to media type.
	 *
	 * @param {object} obj
	 * @return {string}
	 * @public
	 */

	function format(obj) {
	  if (!obj || typeof obj !== 'object') {
	    throw new TypeError('argument obj is required')
	  }

	  var parameters = obj.parameters
	  var type = obj.type

	  if (!type || !typeRegExp.test(type)) {
	    throw new TypeError('invalid type')
	  }

	  var string = type

	  // append parameters
	  if (parameters && typeof parameters === 'object') {
	    var param
	    var params = Object.keys(parameters).sort()

	    for (var i = 0; i < params.length; i++) {
	      param = params[i]

	      if (!tokenRegExp.test(param)) {
	        throw new TypeError('invalid parameter name')
	      }

	      string += '; ' + param + '=' + qstring(parameters[param])
	    }
	  }

	  return string
	}

	/**
	 * Parse media type to object.
	 *
	 * @param {string|object} string
	 * @return {Object}
	 * @public
	 */

	function parse(string) {
	  if (!string) {
	    throw new TypeError('argument string is required')
	  }

	  if (typeof string === 'object') {
	    // support req/res-like objects as argument
	    string = getcontenttype(string)

	    if (typeof string !== 'string') {
	      throw new TypeError('content-type header is missing from object');
	    }
	  }

	  if (typeof string !== 'string') {
	    throw new TypeError('argument string is required to be a string')
	  }

	  var index = string.indexOf(';')
	  var type = index !== -1
	    ? string.substr(0, index).trim()
	    : string.trim()

	  if (!typeRegExp.test(type)) {
	    throw new TypeError('invalid media type')
	  }

	  var key
	  var match
	  var obj = new ContentType(type.toLowerCase())
	  var value

	  paramRegExp.lastIndex = index

	  while (match = paramRegExp.exec(string)) {
	    if (match.index !== index) {
	      throw new TypeError('invalid parameter format')
	    }

	    index += match[0].length
	    key = match[1].toLowerCase()
	    value = match[2]

	    if (value[0] === '"') {
	      // remove quotes and escapes
	      value = value
	        .substr(1, value.length - 2)
	        .replace(qescRegExp, '$1')
	    }

	    obj.parameters[key] = value
	  }

	  if (index !== -1 && index !== string.length) {
	    throw new TypeError('invalid parameter format')
	  }

	  return obj
	}

	/**
	 * Get content-type from req/res objects.
	 *
	 * @param {object}
	 * @return {Object}
	 * @private
	 */

	function getcontenttype(obj) {
	  if (typeof obj.getHeader === 'function') {
	    // res-like
	    return obj.getHeader('content-type')
	  }

	  if (typeof obj.headers === 'object') {
	    // req-like
	    return obj.headers && obj.headers['content-type']
	  }
	}

	/**
	 * Quote a string if necessary.
	 *
	 * @param {string} val
	 * @return {string}
	 * @private
	 */

	function qstring(val) {
	  var str = String(val)

	  // no need to quote tokens
	  if (tokenRegExp.test(str)) {
	    return str
	  }

	  if (str.length > 0 && !textRegExp.test(str)) {
	    throw new TypeError('invalid parameter value')
	  }

	  return '"' + str.replace(quoteRegExp, '\\$1') + '"'
	}

	/**
	 * Class to represent a content type.
	 * @private
	 */
	function ContentType(type) {
	  this.parameters = Object.create(null)
	  this.type = type
	}


/***/ },
/* 62 */
/*!*************************!*\
  !*** ./~/send/index.js ***!
  \*************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * send
	 * Copyright(c) 2012 TJ Holowaychuk
	 * Copyright(c) 2014-2016 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict'

	/**
	 * Module dependencies.
	 * @private
	 */

	var createError = __webpack_require__(/*! http-errors */ 63)
	var debug = __webpack_require__(/*! debug */ 14)('send')
	var deprecate = __webpack_require__(/*! depd */ 44)('send')
	var destroy = __webpack_require__(/*! destroy */ 66)
	var encodeUrl = __webpack_require__(/*! encodeurl */ 68)
	var escapeHtml = __webpack_require__(/*! escape-html */ 30)
	var etag = __webpack_require__(/*! etag */ 69)
	var EventEmitter = __webpack_require__(/*! events */ 26).EventEmitter
	var fresh = __webpack_require__(/*! fresh */ 71)
	var fs = __webpack_require__(/*! fs */ 19)
	var mime = __webpack_require__(/*! mime */ 72)
	var ms = __webpack_require__(/*! ms */ 18)
	var onFinished = __webpack_require__(/*! on-finished */ 31)
	var parseRange = __webpack_require__(/*! range-parser */ 74)
	var path = __webpack_require__(/*! path */ 11)
	var statuses = __webpack_require__(/*! statuses */ 33)
	var Stream = __webpack_require__(/*! stream */ 67)
	var util = __webpack_require__(/*! util */ 16)

	/**
	 * Path function references.
	 * @private
	 */

	var extname = path.extname
	var join = path.join
	var normalize = path.normalize
	var resolve = path.resolve
	var sep = path.sep

	/**
	 * Regular expression for identifying a bytes Range header.
	 * @private
	 */

	var BYTES_RANGE_REGEXP = /^ *bytes=/

	/**
	 * Maximum value allowed for the max age.
	 * @private
	 */

	var MAX_MAXAGE = 60 * 60 * 24 * 365 * 1000 // 1 year

	/**
	 * Regular expression to match a path with a directory up component.
	 * @private
	 */

	var UP_PATH_REGEXP = /(?:^|[\\\/])\.\.(?:[\\\/]|$)/

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = send
	module.exports.mime = mime

	/**
	 * Shim EventEmitter.listenerCount for node.js < 0.10
	 */

	/* istanbul ignore next */
	var listenerCount = EventEmitter.listenerCount ||
	  function (emitter, type) { return emitter.listeners(type).length }

	/**
	 * Return a `SendStream` for `req` and `path`.
	 *
	 * @param {object} req
	 * @param {string} path
	 * @param {object} [options]
	 * @return {SendStream}
	 * @public
	 */

	function send (req, path, options) {
	  return new SendStream(req, path, options)
	}

	/**
	 * Initialize a `SendStream` with the given `path`.
	 *
	 * @param {Request} req
	 * @param {String} path
	 * @param {object} [options]
	 * @private
	 */

	function SendStream (req, path, options) {
	  Stream.call(this)

	  var opts = options || {}

	  this.options = opts
	  this.path = path
	  this.req = req

	  this._acceptRanges = opts.acceptRanges !== undefined
	    ? Boolean(opts.acceptRanges)
	    : true

	  this._cacheControl = opts.cacheControl !== undefined
	    ? Boolean(opts.cacheControl)
	    : true

	  this._etag = opts.etag !== undefined
	    ? Boolean(opts.etag)
	    : true

	  this._dotfiles = opts.dotfiles !== undefined
	    ? opts.dotfiles
	    : 'ignore'

	  if (this._dotfiles !== 'ignore' && this._dotfiles !== 'allow' && this._dotfiles !== 'deny') {
	    throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"')
	  }

	  this._hidden = Boolean(opts.hidden)

	  if (opts.hidden !== undefined) {
	    deprecate('hidden: use dotfiles: \'' + (this._hidden ? 'allow' : 'ignore') + '\' instead')
	  }

	  // legacy support
	  if (opts.dotfiles === undefined) {
	    this._dotfiles = undefined
	  }

	  this._extensions = opts.extensions !== undefined
	    ? normalizeList(opts.extensions, 'extensions option')
	    : []

	  this._index = opts.index !== undefined
	    ? normalizeList(opts.index, 'index option')
	    : ['index.html']

	  this._lastModified = opts.lastModified !== undefined
	    ? Boolean(opts.lastModified)
	    : true

	  this._maxage = opts.maxAge || opts.maxage
	  this._maxage = typeof this._maxage === 'string'
	    ? ms(this._maxage)
	    : Number(this._maxage)
	  this._maxage = !isNaN(this._maxage)
	    ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE)
	    : 0

	  this._root = opts.root
	    ? resolve(opts.root)
	    : null

	  if (!this._root && opts.from) {
	    this.from(opts.from)
	  }
	}

	/**
	 * Inherits from `Stream`.
	 */

	util.inherits(SendStream, Stream)

	/**
	 * Enable or disable etag generation.
	 *
	 * @param {Boolean} val
	 * @return {SendStream}
	 * @api public
	 */

	SendStream.prototype.etag = deprecate.function(function etag (val) {
	  this._etag = Boolean(val)
	  debug('etag %s', this._etag)
	  return this
	}, 'send.etag: pass etag as option')

	/**
	 * Enable or disable "hidden" (dot) files.
	 *
	 * @param {Boolean} path
	 * @return {SendStream}
	 * @api public
	 */

	SendStream.prototype.hidden = deprecate.function(function hidden (val) {
	  this._hidden = Boolean(val)
	  this._dotfiles = undefined
	  debug('hidden %s', this._hidden)
	  return this
	}, 'send.hidden: use dotfiles option')

	/**
	 * Set index `paths`, set to a falsy
	 * value to disable index support.
	 *
	 * @param {String|Boolean|Array} paths
	 * @return {SendStream}
	 * @api public
	 */

	SendStream.prototype.index = deprecate.function(function index (paths) {
	  var index = !paths ? [] : normalizeList(paths, 'paths argument')
	  debug('index %o', paths)
	  this._index = index
	  return this
	}, 'send.index: pass index as option')

	/**
	 * Set root `path`.
	 *
	 * @param {String} path
	 * @return {SendStream}
	 * @api public
	 */

	SendStream.prototype.root = function root (path) {
	  this._root = resolve(String(path))
	  debug('root %s', this._root)
	  return this
	}

	SendStream.prototype.from = deprecate.function(SendStream.prototype.root,
	  'send.from: pass root as option')

	SendStream.prototype.root = deprecate.function(SendStream.prototype.root,
	  'send.root: pass root as option')

	/**
	 * Set max-age to `maxAge`.
	 *
	 * @param {Number} maxAge
	 * @return {SendStream}
	 * @api public
	 */

	SendStream.prototype.maxage = deprecate.function(function maxage (maxAge) {
	  this._maxage = typeof maxAge === 'string'
	    ? ms(maxAge)
	    : Number(maxAge)
	  this._maxage = !isNaN(this._maxage)
	    ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE)
	    : 0
	  debug('max-age %d', this._maxage)
	  return this
	}, 'send.maxage: pass maxAge as option')

	/**
	 * Emit error with `status`.
	 *
	 * @param {number} status
	 * @param {Error} [error]
	 * @private
	 */

	SendStream.prototype.error = function error (status, error) {
	  // emit if listeners instead of responding
	  if (listenerCount(this, 'error') !== 0) {
	    return this.emit('error', createError(error, status, {
	      expose: false
	    }))
	  }

	  var res = this.res
	  var msg = statuses[status]

	  // clear existing headers
	  clearHeaders(res)

	  // add error headers
	  if (error && error.headers) {
	    setHeaders(res, error.headers)
	  }

	  // send basic response
	  res.statusCode = status
	  res.setHeader('Content-Type', 'text/plain; charset=UTF-8')
	  res.setHeader('Content-Length', Buffer.byteLength(msg))
	  res.setHeader('X-Content-Type-Options', 'nosniff')
	  res.end(msg)
	}

	/**
	 * Check if the pathname ends with "/".
	 *
	 * @return {Boolean}
	 * @api private
	 */

	SendStream.prototype.hasTrailingSlash = function hasTrailingSlash () {
	  return this.path[this.path.length - 1] === '/'
	}

	/**
	 * Check if this is a conditional GET request.
	 *
	 * @return {Boolean}
	 * @api private
	 */

	SendStream.prototype.isConditionalGET = function isConditionalGET () {
	  return this.req.headers['if-none-match'] ||
	    this.req.headers['if-modified-since']
	}

	/**
	 * Strip content-* header fields.
	 *
	 * @private
	 */

	SendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields () {
	  var res = this.res
	  var headers = Object.keys(res._headers || {})

	  for (var i = 0; i < headers.length; i++) {
	    var header = headers[i]
	    if (header.substr(0, 8) === 'content-' && header !== 'content-location') {
	      res.removeHeader(header)
	    }
	  }
	}

	/**
	 * Respond with 304 not modified.
	 *
	 * @api private
	 */

	SendStream.prototype.notModified = function notModified () {
	  var res = this.res
	  debug('not modified')
	  this.removeContentHeaderFields()
	  res.statusCode = 304
	  res.end()
	}

	/**
	 * Raise error that headers already sent.
	 *
	 * @api private
	 */

	SendStream.prototype.headersAlreadySent = function headersAlreadySent () {
	  var err = new Error('Can\'t set headers after they are sent.')
	  debug('headers already sent')
	  this.error(500, err)
	}

	/**
	 * Check if the request is cacheable, aka
	 * responded with 2xx or 304 (see RFC 2616 section 14.2{5,6}).
	 *
	 * @return {Boolean}
	 * @api private
	 */

	SendStream.prototype.isCachable = function isCachable () {
	  var statusCode = this.res.statusCode
	  return (statusCode >= 200 && statusCode < 300) ||
	    statusCode === 304
	}

	/**
	 * Handle stat() error.
	 *
	 * @param {Error} error
	 * @private
	 */

	SendStream.prototype.onStatError = function onStatError (error) {
	  switch (error.code) {
	    case 'ENAMETOOLONG':
	    case 'ENOENT':
	    case 'ENOTDIR':
	      this.error(404, error)
	      break
	    default:
	      this.error(500, error)
	      break
	  }
	}

	/**
	 * Check if the cache is fresh.
	 *
	 * @return {Boolean}
	 * @api private
	 */

	SendStream.prototype.isFresh = function isFresh () {
	  return fresh(this.req.headers, this.res._headers)
	}

	/**
	 * Check if the range is fresh.
	 *
	 * @return {Boolean}
	 * @api private
	 */

	SendStream.prototype.isRangeFresh = function isRangeFresh () {
	  var ifRange = this.req.headers['if-range']

	  if (!ifRange) {
	    return true
	  }

	  return ~ifRange.indexOf('"')
	    ? ~ifRange.indexOf(this.res._headers['etag'])
	    : Date.parse(this.res._headers['last-modified']) <= Date.parse(ifRange)
	}

	/**
	 * Redirect to path.
	 *
	 * @param {string} path
	 * @private
	 */

	SendStream.prototype.redirect = function redirect (path) {
	  if (listenerCount(this, 'directory') !== 0) {
	    this.emit('directory')
	    return
	  }

	  if (this.hasTrailingSlash()) {
	    this.error(403)
	    return
	  }

	  var loc = encodeUrl(collapseLeadingSlashes(path + '/'))
	  var msg = 'Redirecting to <a href="' + escapeHtml(loc) + '">' + escapeHtml(loc) + '</a>\n'
	  var res = this.res

	  // redirect
	  res.statusCode = 301
	  res.setHeader('Content-Type', 'text/html; charset=UTF-8')
	  res.setHeader('Content-Length', Buffer.byteLength(msg))
	  res.setHeader('X-Content-Type-Options', 'nosniff')
	  res.setHeader('Location', loc)
	  res.end(msg)
	}

	/**
	 * Pipe to `res.
	 *
	 * @param {Stream} res
	 * @return {Stream} res
	 * @api public
	 */

	SendStream.prototype.pipe = function pipe (res) {
	  // root path
	  var root = this._root

	  // references
	  this.res = res

	  // decode the path
	  var path = decode(this.path)
	  if (path === -1) {
	    this.error(400)
	    return res
	  }

	  // null byte(s)
	  if (~path.indexOf('\0')) {
	    this.error(400)
	    return res
	  }

	  var parts
	  if (root !== null) {
	    // malicious path
	    if (UP_PATH_REGEXP.test(normalize('.' + sep + path))) {
	      debug('malicious path "%s"', path)
	      this.error(403)
	      return res
	    }

	    // join / normalize from optional root dir
	    path = normalize(join(root, path))
	    root = normalize(root + sep)

	    // explode path parts
	    parts = path.substr(root.length).split(sep)
	  } else {
	    // ".." is malicious without "root"
	    if (UP_PATH_REGEXP.test(path)) {
	      debug('malicious path "%s"', path)
	      this.error(403)
	      return res
	    }

	    // explode path parts
	    parts = normalize(path).split(sep)

	    // resolve the path
	    path = resolve(path)
	  }

	  // dotfile handling
	  if (containsDotFile(parts)) {
	    var access = this._dotfiles

	    // legacy support
	    if (access === undefined) {
	      access = parts[parts.length - 1][0] === '.'
	        ? (this._hidden ? 'allow' : 'ignore')
	        : 'allow'
	    }

	    debug('%s dotfile "%s"', access, path)
	    switch (access) {
	      case 'allow':
	        break
	      case 'deny':
	        this.error(403)
	        return res
	      case 'ignore':
	      default:
	        this.error(404)
	        return res
	    }
	  }

	  // index file support
	  if (this._index.length && this.path[this.path.length - 1] === '/') {
	    this.sendIndex(path)
	    return res
	  }

	  this.sendFile(path)
	  return res
	}

	/**
	 * Transfer `path`.
	 *
	 * @param {String} path
	 * @api public
	 */

	SendStream.prototype.send = function send (path, stat) {
	  var len = stat.size
	  var options = this.options
	  var opts = {}
	  var res = this.res
	  var req = this.req
	  var ranges = req.headers.range
	  var offset = options.start || 0

	  if (res._header) {
	    // impossible to send now
	    this.headersAlreadySent()
	    return
	  }

	  debug('pipe "%s"', path)

	  // set header fields
	  this.setHeader(path, stat)

	  // set content-type
	  this.type(path)

	  // conditional GET support
	  if (this.isConditionalGET() && this.isCachable() && this.isFresh()) {
	    this.notModified()
	    return
	  }

	  // adjust len to start/end options
	  len = Math.max(0, len - offset)
	  if (options.end !== undefined) {
	    var bytes = options.end - offset + 1
	    if (len > bytes) len = bytes
	  }

	  // Range support
	  if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {
	    // parse
	    ranges = parseRange(len, ranges, {
	      combine: true
	    })

	    // If-Range support
	    if (!this.isRangeFresh()) {
	      debug('range stale')
	      ranges = -2
	    }

	    // unsatisfiable
	    if (ranges === -1) {
	      debug('range unsatisfiable')

	      // Content-Range
	      res.setHeader('Content-Range', contentRange('bytes', len))

	      // 416 Requested Range Not Satisfiable
	      return this.error(416, {
	        headers: {'Content-Range': res.getHeader('Content-Range')}
	      })
	    }

	    // valid (syntactically invalid/multiple ranges are treated as a regular response)
	    if (ranges !== -2 && ranges.length === 1) {
	      debug('range %j', ranges)

	      // Content-Range
	      res.statusCode = 206
	      res.setHeader('Content-Range', contentRange('bytes', len, ranges[0]))

	      // adjust for requested range
	      offset += ranges[0].start
	      len = ranges[0].end - ranges[0].start + 1
	    }
	  }

	  // clone options
	  for (var prop in options) {
	    opts[prop] = options[prop]
	  }

	  // set read options
	  opts.start = offset
	  opts.end = Math.max(offset, offset + len - 1)

	  // content-length
	  res.setHeader('Content-Length', len)

	  // HEAD support
	  if (req.method === 'HEAD') {
	    res.end()
	    return
	  }

	  this.stream(path, opts)
	}

	/**
	 * Transfer file for `path`.
	 *
	 * @param {String} path
	 * @api private
	 */
	SendStream.prototype.sendFile = function sendFile (path) {
	  var i = 0
	  var self = this

	  debug('stat "%s"', path)
	  fs.stat(path, function onstat (err, stat) {
	    if (err && err.code === 'ENOENT' && !extname(path) && path[path.length - 1] !== sep) {
	      // not found, check extensions
	      return next(err)
	    }
	    if (err) return self.onStatError(err)
	    if (stat.isDirectory()) return self.redirect(self.path)
	    self.emit('file', path, stat)
	    self.send(path, stat)
	  })

	  function next (err) {
	    if (self._extensions.length <= i) {
	      return err
	        ? self.onStatError(err)
	        : self.error(404)
	    }

	    var p = path + '.' + self._extensions[i++]

	    debug('stat "%s"', p)
	    fs.stat(p, function (err, stat) {
	      if (err) return next(err)
	      if (stat.isDirectory()) return next()
	      self.emit('file', p, stat)
	      self.send(p, stat)
	    })
	  }
	}

	/**
	 * Transfer index for `path`.
	 *
	 * @param {String} path
	 * @api private
	 */
	SendStream.prototype.sendIndex = function sendIndex (path) {
	  var i = -1
	  var self = this

	  function next (err) {
	    if (++i >= self._index.length) {
	      if (err) return self.onStatError(err)
	      return self.error(404)
	    }

	    var p = join(path, self._index[i])

	    debug('stat "%s"', p)
	    fs.stat(p, function (err, stat) {
	      if (err) return next(err)
	      if (stat.isDirectory()) return next()
	      self.emit('file', p, stat)
	      self.send(p, stat)
	    })
	  }

	  next()
	}

	/**
	 * Stream `path` to the response.
	 *
	 * @param {String} path
	 * @param {Object} options
	 * @api private
	 */

	SendStream.prototype.stream = function stream (path, options) {
	  // TODO: this is all lame, refactor meeee
	  var finished = false
	  var self = this
	  var res = this.res

	  // pipe
	  var stream = fs.createReadStream(path, options)
	  this.emit('stream', stream)
	  stream.pipe(res)

	  // response finished, done with the fd
	  onFinished(res, function onfinished () {
	    finished = true
	    destroy(stream)
	  })

	  // error handling code-smell
	  stream.on('error', function onerror (err) {
	    // request already finished
	    if (finished) return

	    // clean up stream
	    finished = true
	    destroy(stream)

	    // error
	    self.onStatError(err)
	  })

	  // end
	  stream.on('end', function onend () {
	    self.emit('end')
	  })
	}

	/**
	 * Set content-type based on `path`
	 * if it hasn't been explicitly set.
	 *
	 * @param {String} path
	 * @api private
	 */

	SendStream.prototype.type = function type (path) {
	  var res = this.res

	  if (res.getHeader('Content-Type')) return

	  var type = mime.lookup(path)

	  if (!type) {
	    debug('no content-type')
	    return
	  }

	  var charset = mime.charsets.lookup(type)

	  debug('content-type %s', type)
	  res.setHeader('Content-Type', type + (charset ? '; charset=' + charset : ''))
	}

	/**
	 * Set response header fields, most
	 * fields may be pre-defined.
	 *
	 * @param {String} path
	 * @param {Object} stat
	 * @api private
	 */

	SendStream.prototype.setHeader = function setHeader (path, stat) {
	  var res = this.res

	  this.emit('headers', res, path, stat)

	  if (this._acceptRanges && !res.getHeader('Accept-Ranges')) {
	    debug('accept ranges')
	    res.setHeader('Accept-Ranges', 'bytes')
	  }

	  if (this._cacheControl && !res.getHeader('Cache-Control')) {
	    var cacheControl = 'public, max-age=' + Math.floor(this._maxage / 1000)
	    debug('cache-control %s', cacheControl)
	    res.setHeader('Cache-Control', cacheControl)
	  }

	  if (this._lastModified && !res.getHeader('Last-Modified')) {
	    var modified = stat.mtime.toUTCString()
	    debug('modified %s', modified)
	    res.setHeader('Last-Modified', modified)
	  }

	  if (this._etag && !res.getHeader('ETag')) {
	    var val = etag(stat)
	    debug('etag %s', val)
	    res.setHeader('ETag', val)
	  }
	}

	/**
	 * Clear all headers from a response.
	 *
	 * @param {object} res
	 * @private
	 */

	function clearHeaders (res) {
	  res._headers = {}
	  res._headerNames = {}
	}

	/**
	 * Collapse all leading slashes into a single slash
	 *
	 * @param {string} str
	 * @private
	 */
	function collapseLeadingSlashes (str) {
	  for (var i = 0; i < str.length; i++) {
	    if (str[i] !== '/') {
	      break
	    }
	  }

	  return i > 1
	    ? '/' + str.substr(i)
	    : str
	}

	/**
	 * Determine if path parts contain a dotfile.
	 *
	 * @api private
	 */

	function containsDotFile (parts) {
	  for (var i = 0; i < parts.length; i++) {
	    if (parts[i][0] === '.') {
	      return true
	    }
	  }

	  return false
	}

	/**
	 * Create a Content-Range header.
	 *
	 * @param {string} type
	 * @param {number} size
	 * @param {array} [range]
	 */

	function contentRange (type, size, range) {
	  return type + ' ' + (range ? range.start + '-' + range.end : '*') + '/' + size
	}

	/**
	 * decodeURIComponent.
	 *
	 * Allows V8 to only deoptimize this fn instead of all
	 * of send().
	 *
	 * @param {String} path
	 * @api private
	 */

	function decode (path) {
	  try {
	    return decodeURIComponent(path)
	  } catch (err) {
	    return -1
	  }
	}

	/**
	 * Normalize the index option into an array.
	 *
	 * @param {boolean|string|array} val
	 * @param {string} name
	 * @private
	 */

	function normalizeList (val, name) {
	  var list = [].concat(val || [])

	  for (var i = 0; i < list.length; i++) {
	    if (typeof list[i] !== 'string') {
	      throw new TypeError(name + ' must be array of strings or false')
	    }
	  }

	  return list
	}

	/**
	 * Set an object of headers on a response.
	 *
	 * @param {object} res
	 * @param {object} headers
	 * @private
	 */

	function setHeaders (res, headers) {
	  var keys = Object.keys(headers)

	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i]
	    res.setHeader(key, headers[key])
	  }
	}


/***/ },
/* 63 */
/*!********************************!*\
  !*** ./~/http-errors/index.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * http-errors
	 * Copyright(c) 2014 Jonathan Ong
	 * Copyright(c) 2016 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict'

	/**
	 * Module dependencies.
	 * @private
	 */

	var setPrototypeOf = __webpack_require__(/*! setprototypeof */ 64)
	var statuses = __webpack_require__(/*! statuses */ 33)
	var inherits = __webpack_require__(/*! inherits */ 65)

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = createError
	module.exports.HttpError = createHttpErrorConstructor()

	// Populate exports for all constructors
	populateConstructorExports(module.exports, statuses.codes, module.exports.HttpError)

	/**
	 * Create a new HTTP Error.
	 *
	 * @returns {Error}
	 * @public
	 */

	function createError () {
	  // so much arity going on ~_~
	  var err
	  var msg
	  var status = 500
	  var props = {}
	  for (var i = 0; i < arguments.length; i++) {
	    var arg = arguments[i]
	    if (arg instanceof Error) {
	      err = arg
	      status = err.status || err.statusCode || status
	      continue
	    }
	    switch (typeof arg) {
	      case 'string':
	        msg = arg
	        break
	      case 'number':
	        status = arg
	        break
	      case 'object':
	        props = arg
	        break
	    }
	  }

	  if (typeof status !== 'number' || !statuses[status]) {
	    status = 500
	  }

	  // constructor
	  var HttpError = createError[status]

	  if (!err) {
	    // create error
	    err = HttpError
	      ? new HttpError(msg)
	      : new Error(msg || statuses[status])
	    Error.captureStackTrace(err, createError)
	  }

	  if (!HttpError || !(err instanceof HttpError)) {
	    // add properties to generic error
	    err.expose = status < 500
	    err.status = err.statusCode = status
	  }

	  for (var key in props) {
	    if (key !== 'status' && key !== 'statusCode') {
	      err[key] = props[key]
	    }
	  }

	  return err
	}

	/**
	 * Create HTTP error abstract base class.
	 * @private
	 */

	function createHttpErrorConstructor () {
	  function HttpError () {
	    throw new TypeError('cannot construct abstract class')
	  }

	  inherits(HttpError, Error)

	  return HttpError
	}

	/**
	 * Create a constructor for a client error.
	 * @private
	 */

	function createClientErrorConstructor (HttpError, name, code) {
	  var className = name.match(/Error$/) ? name : name + 'Error'

	  function ClientError (message) {
	    // create the error object
	    var err = new Error(message != null ? message : statuses[code])

	    // capture a stack trace to the construction point
	    Error.captureStackTrace(err, ClientError)

	    // adjust the [[Prototype]]
	    setPrototypeOf(err, ClientError.prototype)

	    // redefine the error name
	    Object.defineProperty(err, 'name', {
	      enumerable: false,
	      configurable: true,
	      value: className,
	      writable: true
	    })

	    return err
	  }

	  inherits(ClientError, HttpError)

	  ClientError.prototype.status = code
	  ClientError.prototype.statusCode = code
	  ClientError.prototype.expose = true

	  return ClientError
	}

	/**
	 * Create a constructor for a server error.
	 * @private
	 */

	function createServerErrorConstructor (HttpError, name, code) {
	  var className = name.match(/Error$/) ? name : name + 'Error'

	  function ServerError (message) {
	    // create the error object
	    var err = new Error(message != null ? message : statuses[code])

	    // capture a stack trace to the construction point
	    Error.captureStackTrace(err, ServerError)

	    // adjust the [[Prototype]]
	    setPrototypeOf(err, ServerError.prototype)

	    // redefine the error name
	    Object.defineProperty(err, 'name', {
	      enumerable: false,
	      configurable: true,
	      value: className,
	      writable: true
	    })

	    return err
	  }

	  inherits(ServerError, HttpError)

	  ServerError.prototype.status = code
	  ServerError.prototype.statusCode = code
	  ServerError.prototype.expose = false

	  return ServerError
	}

	/**
	 * Populate the exports object with constructors for every error class.
	 * @private
	 */

	function populateConstructorExports (exports, codes, HttpError) {
	  codes.forEach(function forEachCode (code) {
	    var CodeError
	    var name = toIdentifier(statuses[code])

	    switch (String(code).charAt(0)) {
	      case '4':
	        CodeError = createClientErrorConstructor(HttpError, name, code)
	        break
	      case '5':
	        CodeError = createServerErrorConstructor(HttpError, name, code)
	        break
	    }

	    if (CodeError) {
	      // export the constructor
	      exports[code] = CodeError
	      exports[name] = CodeError
	    }
	  })

	  // backwards-compatibility
	  exports["I'mateapot"] = exports.ImATeapot
	}

	/**
	 * Convert a string of words to a JavaScript identifier.
	 * @private
	 */

	function toIdentifier (str) {
	  return str.split(' ').map(function (token) {
	    return token.slice(0, 1).toUpperCase() + token.slice(1)
	  }).join('').replace(/[^ _0-9a-z]/gi, '')
	}


/***/ },
/* 64 */
/*!***********************************!*\
  !*** ./~/setprototypeof/index.js ***!
  \***********************************/
/***/ function(module, exports) {

	module.exports = Object.setPrototypeOf || ({__proto__:[]} instanceof Array ? setProtoOf : mixinProperties);

	function setProtoOf(obj, proto) {
		obj.__proto__ = proto;
	}

	function mixinProperties(obj, proto) {
		for (var prop in proto) {
			obj[prop] = proto[prop];
		}
	}


/***/ },
/* 65 */
/*!**********************************************!*\
  !*** ./~/http-errors/~/inherits/inherits.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(/*! util */ 16).inherits


/***/ },
/* 66 */
/*!****************************!*\
  !*** ./~/destroy/index.js ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * destroy
	 * Copyright(c) 2014 Jonathan Ong
	 * MIT Licensed
	 */

	'use strict'

	/**
	 * Module dependencies.
	 * @private
	 */

	var ReadStream = __webpack_require__(/*! fs */ 19).ReadStream
	var Stream = __webpack_require__(/*! stream */ 67)

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = destroy

	/**
	 * Destroy a stream.
	 *
	 * @param {object} stream
	 * @public
	 */

	function destroy(stream) {
	  if (stream instanceof ReadStream) {
	    return destroyReadStream(stream)
	  }

	  if (!(stream instanceof Stream)) {
	    return stream
	  }

	  if (typeof stream.destroy === 'function') {
	    stream.destroy()
	  }

	  return stream
	}

	/**
	 * Destroy a ReadStream.
	 *
	 * @param {object} stream
	 * @private
	 */

	function destroyReadStream(stream) {
	  stream.destroy()

	  if (typeof stream.close === 'function') {
	    // node.js core bug work-around
	    stream.on('open', onOpenClose)
	  }

	  return stream
	}

	/**
	 * On open handler to close stream.
	 * @private
	 */

	function onOpenClose() {
	  if (typeof this.fd === 'number') {
	    // actually close down the fd
	    this.close()
	  }
	}


/***/ },
/* 67 */
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ function(module, exports) {

	module.exports = require("stream");

/***/ },
/* 68 */
/*!******************************!*\
  !*** ./~/encodeurl/index.js ***!
  \******************************/
/***/ function(module, exports) {

	/*!
	 * encodeurl
	 * Copyright(c) 2016 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict'

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = encodeUrl

	/**
	 * RegExp to match non-URL code points, *after* encoding (i.e. not including "%")
	 * and including invalid escape sequences.
	 * @private
	 */

	var ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]))+/g

	/**
	 * RegExp to match unmatched surrogate pair.
	 * @private
	 */

	var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g

	/**
	 * String to replace unmatched surrogate pair with.
	 * @private
	 */

	var UNMATCHED_SURROGATE_PAIR_REPLACE = '$1\uFFFD$2'

	/**
	 * Encode a URL to a percent-encoded form, excluding already-encoded sequences.
	 *
	 * This function will take an already-encoded URL and encode all the non-URL
	 * code points. This function will not encode the "%" character unless it is
	 * not part of a valid sequence (`%20` will be left as-is, but `%foo` will
	 * be encoded as `%25foo`).
	 *
	 * This encode is meant to be "safe" and does not throw errors. It will try as
	 * hard as it can to properly encode the given URL, including replacing any raw,
	 * unpaired surrogate pairs with the Unicode replacement character prior to
	 * encoding.
	 *
	 * @param {string} url
	 * @return {string}
	 * @public
	 */

	function encodeUrl (url) {
	  return String(url)
	    .replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE)
	    .replace(ENCODE_CHARS_REGEXP, encodeURI)
	}


/***/ },
/* 69 */
/*!*************************!*\
  !*** ./~/etag/index.js ***!
  \*************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * etag
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict'

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = etag

	/**
	 * Module dependencies.
	 * @private
	 */

	var crypto = __webpack_require__(/*! crypto */ 70)
	var Stats = __webpack_require__(/*! fs */ 19).Stats

	/**
	 * Module variables.
	 * @private
	 */

	var base64PadCharRegExp = /=+$/
	var toString = Object.prototype.toString

	/**
	 * Generate an entity tag.
	 *
	 * @param {Buffer|string} entity
	 * @return {string}
	 * @private
	 */

	function entitytag(entity) {
	  if (entity.length === 0) {
	    // fast-path empty
	    return '"0-1B2M2Y8AsgTpgAmY7PhCfg"'
	  }

	  // compute hash of entity
	  var hash = crypto
	    .createHash('md5')
	    .update(entity, 'utf8')
	    .digest('base64')
	    .replace(base64PadCharRegExp, '')

	  // compute length of entity
	  var len = typeof entity === 'string'
	    ? Buffer.byteLength(entity, 'utf8')
	    : entity.length

	  return '"' + len.toString(16) + '-' + hash + '"'
	}

	/**
	 * Create a simple ETag.
	 *
	 * @param {string|Buffer|Stats} entity
	 * @param {object} [options]
	 * @param {boolean} [options.weak]
	 * @return {String}
	 * @public
	 */

	function etag(entity, options) {
	  if (entity == null) {
	    throw new TypeError('argument entity is required')
	  }

	  // support fs.Stats object
	  var isStats = isstats(entity)
	  var weak = options && typeof options.weak === 'boolean'
	    ? options.weak
	    : isStats

	  // validate argument
	  if (!isStats && typeof entity !== 'string' && !Buffer.isBuffer(entity)) {
	    throw new TypeError('argument entity must be string, Buffer, or fs.Stats')
	  }

	  // generate entity tag
	  var tag = isStats
	    ? stattag(entity)
	    : entitytag(entity)

	  return weak
	    ? 'W/' + tag
	    : tag
	}

	/**
	 * Determine if object is a Stats object.
	 *
	 * @param {object} obj
	 * @return {boolean}
	 * @api private
	 */

	function isstats(obj) {
	  // genuine fs.Stats
	  if (typeof Stats === 'function' && obj instanceof Stats) {
	    return true
	  }

	  // quack quack
	  return obj && typeof obj === 'object'
	    && 'ctime' in obj && toString.call(obj.ctime) === '[object Date]'
	    && 'mtime' in obj && toString.call(obj.mtime) === '[object Date]'
	    && 'ino' in obj && typeof obj.ino === 'number'
	    && 'size' in obj && typeof obj.size === 'number'
	}

	/**
	 * Generate a tag for a stat.
	 *
	 * @param {object} stat
	 * @return {string}
	 * @private
	 */

	function stattag(stat) {
	  var mtime = stat.mtime.getTime().toString(16)
	  var size = stat.size.toString(16)

	  return '"' + size + '-' + mtime + '"'
	}


/***/ },
/* 70 */
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ function(module, exports) {

	module.exports = require("crypto");

/***/ },
/* 71 */
/*!**************************!*\
  !*** ./~/fresh/index.js ***!
  \**************************/
/***/ function(module, exports) {

	
	/**
	 * Expose `fresh()`.
	 */

	module.exports = fresh;

	/**
	 * Check freshness of `req` and `res` headers.
	 *
	 * When the cache is "fresh" __true__ is returned,
	 * otherwise __false__ is returned to indicate that
	 * the cache is now stale.
	 *
	 * @param {Object} req
	 * @param {Object} res
	 * @return {Boolean}
	 * @api public
	 */

	function fresh(req, res) {
	  // defaults
	  var etagMatches = true;
	  var notModified = true;

	  // fields
	  var modifiedSince = req['if-modified-since'];
	  var noneMatch = req['if-none-match'];
	  var lastModified = res['last-modified'];
	  var etag = res['etag'];
	  var cc = req['cache-control'];

	  // unconditional request
	  if (!modifiedSince && !noneMatch) return false;

	  // check for no-cache cache request directive
	  if (cc && cc.indexOf('no-cache') !== -1) return false;  

	  // parse if-none-match
	  if (noneMatch) noneMatch = noneMatch.split(/ *, */);

	  // if-none-match
	  if (noneMatch) {
	    etagMatches = noneMatch.some(function (match) {
	      return match === '*' || match === etag || match === 'W/' + etag;
	    });
	  }

	  // if-modified-since
	  if (modifiedSince) {
	    modifiedSince = new Date(modifiedSince);
	    lastModified = new Date(lastModified);
	    notModified = lastModified <= modifiedSince;
	  }

	  return !! (etagMatches && notModified);
	}


/***/ },
/* 72 */
/*!************************!*\
  !*** ./~/mime/mime.js ***!
  \************************/
/***/ function(module, exports, __webpack_require__) {

	var path = __webpack_require__(/*! path */ 11);
	var fs = __webpack_require__(/*! fs */ 19);

	function Mime() {
	  // Map of extension -> mime type
	  this.types = Object.create(null);

	  // Map of mime type -> extension
	  this.extensions = Object.create(null);
	}

	/**
	 * Define mimetype -> extension mappings.  Each key is a mime-type that maps
	 * to an array of extensions associated with the type.  The first extension is
	 * used as the default extension for the type.
	 *
	 * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
	 *
	 * @param map (Object) type definitions
	 */
	Mime.prototype.define = function (map) {
	  for (var type in map) {
	    var exts = map[type];
	    for (var i = 0; i < exts.length; i++) {
	      if (process.env.DEBUG_MIME && this.types[exts]) {
	        console.warn(this._loading.replace(/.*\//, ''), 'changes "' + exts[i] + '" extension type from ' +
	          this.types[exts] + ' to ' + type);
	      }

	      this.types[exts[i]] = type;
	    }

	    // Default extension is the first one we encounter
	    if (!this.extensions[type]) {
	      this.extensions[type] = exts[0];
	    }
	  }
	};

	/**
	 * Load an Apache2-style ".types" file
	 *
	 * This may be called multiple times (it's expected).  Where files declare
	 * overlapping types/extensions, the last file wins.
	 *
	 * @param file (String) path of file to load.
	 */
	Mime.prototype.load = function(file) {
	  this._loading = file;
	  // Read file and split into lines
	  var map = {},
	      content = fs.readFileSync(file, 'ascii'),
	      lines = content.split(/[\r\n]+/);

	  lines.forEach(function(line) {
	    // Clean up whitespace/comments, and split into fields
	    var fields = line.replace(/\s*#.*|^\s*|\s*$/g, '').split(/\s+/);
	    map[fields.shift()] = fields;
	  });

	  this.define(map);

	  this._loading = null;
	};

	/**
	 * Lookup a mime type based on extension
	 */
	Mime.prototype.lookup = function(path, fallback) {
	  var ext = path.replace(/.*[\.\/\\]/, '').toLowerCase();

	  return this.types[ext] || fallback || this.default_type;
	};

	/**
	 * Return file extension associated with a mime type
	 */
	Mime.prototype.extension = function(mimeType) {
	  var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
	  return this.extensions[type];
	};

	// Default instance
	var mime = new Mime();

	// Define built-in types
	mime.define(__webpack_require__(/*! ./types.json */ 73));

	// Default type
	mime.default_type = mime.lookup('bin');

	//
	// Additional API specific to the default instance
	//

	mime.Mime = Mime;

	/**
	 * Lookup a charset based on mime type.
	 */
	mime.charsets = {
	  lookup: function(mimeType, fallback) {
	    // Assume text types are utf8
	    return (/^text\//).test(mimeType) ? 'UTF-8' : fallback;
	  }
	};

	module.exports = mime;


/***/ },
/* 73 */
/*!***************************!*\
  !*** ./~/mime/types.json ***!
  \***************************/
/***/ function(module, exports) {

	module.exports = {
		"application/andrew-inset": [
			"ez"
		],
		"application/applixware": [
			"aw"
		],
		"application/atom+xml": [
			"atom"
		],
		"application/atomcat+xml": [
			"atomcat"
		],
		"application/atomsvc+xml": [
			"atomsvc"
		],
		"application/ccxml+xml": [
			"ccxml"
		],
		"application/cdmi-capability": [
			"cdmia"
		],
		"application/cdmi-container": [
			"cdmic"
		],
		"application/cdmi-domain": [
			"cdmid"
		],
		"application/cdmi-object": [
			"cdmio"
		],
		"application/cdmi-queue": [
			"cdmiq"
		],
		"application/cu-seeme": [
			"cu"
		],
		"application/dash+xml": [
			"mdp"
		],
		"application/davmount+xml": [
			"davmount"
		],
		"application/docbook+xml": [
			"dbk"
		],
		"application/dssc+der": [
			"dssc"
		],
		"application/dssc+xml": [
			"xdssc"
		],
		"application/ecmascript": [
			"ecma"
		],
		"application/emma+xml": [
			"emma"
		],
		"application/epub+zip": [
			"epub"
		],
		"application/exi": [
			"exi"
		],
		"application/font-tdpfr": [
			"pfr"
		],
		"application/font-woff": [
			"woff"
		],
		"application/font-woff2": [
			"woff2"
		],
		"application/gml+xml": [
			"gml"
		],
		"application/gpx+xml": [
			"gpx"
		],
		"application/gxf": [
			"gxf"
		],
		"application/hyperstudio": [
			"stk"
		],
		"application/inkml+xml": [
			"ink",
			"inkml"
		],
		"application/ipfix": [
			"ipfix"
		],
		"application/java-archive": [
			"jar"
		],
		"application/java-serialized-object": [
			"ser"
		],
		"application/java-vm": [
			"class"
		],
		"application/javascript": [
			"js"
		],
		"application/json": [
			"json",
			"map"
		],
		"application/json5": [
			"json5"
		],
		"application/jsonml+json": [
			"jsonml"
		],
		"application/lost+xml": [
			"lostxml"
		],
		"application/mac-binhex40": [
			"hqx"
		],
		"application/mac-compactpro": [
			"cpt"
		],
		"application/mads+xml": [
			"mads"
		],
		"application/marc": [
			"mrc"
		],
		"application/marcxml+xml": [
			"mrcx"
		],
		"application/mathematica": [
			"ma",
			"nb",
			"mb"
		],
		"application/mathml+xml": [
			"mathml"
		],
		"application/mbox": [
			"mbox"
		],
		"application/mediaservercontrol+xml": [
			"mscml"
		],
		"application/metalink+xml": [
			"metalink"
		],
		"application/metalink4+xml": [
			"meta4"
		],
		"application/mets+xml": [
			"mets"
		],
		"application/mods+xml": [
			"mods"
		],
		"application/mp21": [
			"m21",
			"mp21"
		],
		"application/mp4": [
			"mp4s",
			"m4p"
		],
		"application/msword": [
			"doc",
			"dot"
		],
		"application/mxf": [
			"mxf"
		],
		"application/octet-stream": [
			"bin",
			"dms",
			"lrf",
			"mar",
			"so",
			"dist",
			"distz",
			"pkg",
			"bpk",
			"dump",
			"elc",
			"deploy",
			"buffer"
		],
		"application/oda": [
			"oda"
		],
		"application/oebps-package+xml": [
			"opf"
		],
		"application/ogg": [
			"ogx"
		],
		"application/omdoc+xml": [
			"omdoc"
		],
		"application/onenote": [
			"onetoc",
			"onetoc2",
			"onetmp",
			"onepkg"
		],
		"application/oxps": [
			"oxps"
		],
		"application/patch-ops-error+xml": [
			"xer"
		],
		"application/pdf": [
			"pdf"
		],
		"application/pgp-encrypted": [
			"pgp"
		],
		"application/pgp-signature": [
			"asc",
			"sig"
		],
		"application/pics-rules": [
			"prf"
		],
		"application/pkcs10": [
			"p10"
		],
		"application/pkcs7-mime": [
			"p7m",
			"p7c"
		],
		"application/pkcs7-signature": [
			"p7s"
		],
		"application/pkcs8": [
			"p8"
		],
		"application/pkix-attr-cert": [
			"ac"
		],
		"application/pkix-cert": [
			"cer"
		],
		"application/pkix-crl": [
			"crl"
		],
		"application/pkix-pkipath": [
			"pkipath"
		],
		"application/pkixcmp": [
			"pki"
		],
		"application/pls+xml": [
			"pls"
		],
		"application/postscript": [
			"ai",
			"eps",
			"ps"
		],
		"application/prs.cww": [
			"cww"
		],
		"application/pskc+xml": [
			"pskcxml"
		],
		"application/rdf+xml": [
			"rdf"
		],
		"application/reginfo+xml": [
			"rif"
		],
		"application/relax-ng-compact-syntax": [
			"rnc"
		],
		"application/resource-lists+xml": [
			"rl"
		],
		"application/resource-lists-diff+xml": [
			"rld"
		],
		"application/rls-services+xml": [
			"rs"
		],
		"application/rpki-ghostbusters": [
			"gbr"
		],
		"application/rpki-manifest": [
			"mft"
		],
		"application/rpki-roa": [
			"roa"
		],
		"application/rsd+xml": [
			"rsd"
		],
		"application/rss+xml": [
			"rss"
		],
		"application/rtf": [
			"rtf"
		],
		"application/sbml+xml": [
			"sbml"
		],
		"application/scvp-cv-request": [
			"scq"
		],
		"application/scvp-cv-response": [
			"scs"
		],
		"application/scvp-vp-request": [
			"spq"
		],
		"application/scvp-vp-response": [
			"spp"
		],
		"application/sdp": [
			"sdp"
		],
		"application/set-payment-initiation": [
			"setpay"
		],
		"application/set-registration-initiation": [
			"setreg"
		],
		"application/shf+xml": [
			"shf"
		],
		"application/smil+xml": [
			"smi",
			"smil"
		],
		"application/sparql-query": [
			"rq"
		],
		"application/sparql-results+xml": [
			"srx"
		],
		"application/srgs": [
			"gram"
		],
		"application/srgs+xml": [
			"grxml"
		],
		"application/sru+xml": [
			"sru"
		],
		"application/ssdl+xml": [
			"ssdl"
		],
		"application/ssml+xml": [
			"ssml"
		],
		"application/tei+xml": [
			"tei",
			"teicorpus"
		],
		"application/thraud+xml": [
			"tfi"
		],
		"application/timestamped-data": [
			"tsd"
		],
		"application/vnd.3gpp.pic-bw-large": [
			"plb"
		],
		"application/vnd.3gpp.pic-bw-small": [
			"psb"
		],
		"application/vnd.3gpp.pic-bw-var": [
			"pvb"
		],
		"application/vnd.3gpp2.tcap": [
			"tcap"
		],
		"application/vnd.3m.post-it-notes": [
			"pwn"
		],
		"application/vnd.accpac.simply.aso": [
			"aso"
		],
		"application/vnd.accpac.simply.imp": [
			"imp"
		],
		"application/vnd.acucobol": [
			"acu"
		],
		"application/vnd.acucorp": [
			"atc",
			"acutc"
		],
		"application/vnd.adobe.air-application-installer-package+zip": [
			"air"
		],
		"application/vnd.adobe.formscentral.fcdt": [
			"fcdt"
		],
		"application/vnd.adobe.fxp": [
			"fxp",
			"fxpl"
		],
		"application/vnd.adobe.xdp+xml": [
			"xdp"
		],
		"application/vnd.adobe.xfdf": [
			"xfdf"
		],
		"application/vnd.ahead.space": [
			"ahead"
		],
		"application/vnd.airzip.filesecure.azf": [
			"azf"
		],
		"application/vnd.airzip.filesecure.azs": [
			"azs"
		],
		"application/vnd.amazon.ebook": [
			"azw"
		],
		"application/vnd.americandynamics.acc": [
			"acc"
		],
		"application/vnd.amiga.ami": [
			"ami"
		],
		"application/vnd.android.package-archive": [
			"apk"
		],
		"application/vnd.anser-web-certificate-issue-initiation": [
			"cii"
		],
		"application/vnd.anser-web-funds-transfer-initiation": [
			"fti"
		],
		"application/vnd.antix.game-component": [
			"atx"
		],
		"application/vnd.apple.installer+xml": [
			"mpkg"
		],
		"application/vnd.apple.mpegurl": [
			"m3u8"
		],
		"application/vnd.aristanetworks.swi": [
			"swi"
		],
		"application/vnd.astraea-software.iota": [
			"iota"
		],
		"application/vnd.audiograph": [
			"aep"
		],
		"application/vnd.blueice.multipass": [
			"mpm"
		],
		"application/vnd.bmi": [
			"bmi"
		],
		"application/vnd.businessobjects": [
			"rep"
		],
		"application/vnd.chemdraw+xml": [
			"cdxml"
		],
		"application/vnd.chipnuts.karaoke-mmd": [
			"mmd"
		],
		"application/vnd.cinderella": [
			"cdy"
		],
		"application/vnd.claymore": [
			"cla"
		],
		"application/vnd.cloanto.rp9": [
			"rp9"
		],
		"application/vnd.clonk.c4group": [
			"c4g",
			"c4d",
			"c4f",
			"c4p",
			"c4u"
		],
		"application/vnd.cluetrust.cartomobile-config": [
			"c11amc"
		],
		"application/vnd.cluetrust.cartomobile-config-pkg": [
			"c11amz"
		],
		"application/vnd.commonspace": [
			"csp"
		],
		"application/vnd.contact.cmsg": [
			"cdbcmsg"
		],
		"application/vnd.cosmocaller": [
			"cmc"
		],
		"application/vnd.crick.clicker": [
			"clkx"
		],
		"application/vnd.crick.clicker.keyboard": [
			"clkk"
		],
		"application/vnd.crick.clicker.palette": [
			"clkp"
		],
		"application/vnd.crick.clicker.template": [
			"clkt"
		],
		"application/vnd.crick.clicker.wordbank": [
			"clkw"
		],
		"application/vnd.criticaltools.wbs+xml": [
			"wbs"
		],
		"application/vnd.ctc-posml": [
			"pml"
		],
		"application/vnd.cups-ppd": [
			"ppd"
		],
		"application/vnd.curl.car": [
			"car"
		],
		"application/vnd.curl.pcurl": [
			"pcurl"
		],
		"application/vnd.dart": [
			"dart"
		],
		"application/vnd.data-vision.rdz": [
			"rdz"
		],
		"application/vnd.dece.data": [
			"uvf",
			"uvvf",
			"uvd",
			"uvvd"
		],
		"application/vnd.dece.ttml+xml": [
			"uvt",
			"uvvt"
		],
		"application/vnd.dece.unspecified": [
			"uvx",
			"uvvx"
		],
		"application/vnd.dece.zip": [
			"uvz",
			"uvvz"
		],
		"application/vnd.denovo.fcselayout-link": [
			"fe_launch"
		],
		"application/vnd.dna": [
			"dna"
		],
		"application/vnd.dolby.mlp": [
			"mlp"
		],
		"application/vnd.dpgraph": [
			"dpg"
		],
		"application/vnd.dreamfactory": [
			"dfac"
		],
		"application/vnd.ds-keypoint": [
			"kpxx"
		],
		"application/vnd.dvb.ait": [
			"ait"
		],
		"application/vnd.dvb.service": [
			"svc"
		],
		"application/vnd.dynageo": [
			"geo"
		],
		"application/vnd.ecowin.chart": [
			"mag"
		],
		"application/vnd.enliven": [
			"nml"
		],
		"application/vnd.epson.esf": [
			"esf"
		],
		"application/vnd.epson.msf": [
			"msf"
		],
		"application/vnd.epson.quickanime": [
			"qam"
		],
		"application/vnd.epson.salt": [
			"slt"
		],
		"application/vnd.epson.ssf": [
			"ssf"
		],
		"application/vnd.eszigno3+xml": [
			"es3",
			"et3"
		],
		"application/vnd.ezpix-album": [
			"ez2"
		],
		"application/vnd.ezpix-package": [
			"ez3"
		],
		"application/vnd.fdf": [
			"fdf"
		],
		"application/vnd.fdsn.mseed": [
			"mseed"
		],
		"application/vnd.fdsn.seed": [
			"seed",
			"dataless"
		],
		"application/vnd.flographit": [
			"gph"
		],
		"application/vnd.fluxtime.clip": [
			"ftc"
		],
		"application/vnd.framemaker": [
			"fm",
			"frame",
			"maker",
			"book"
		],
		"application/vnd.frogans.fnc": [
			"fnc"
		],
		"application/vnd.frogans.ltf": [
			"ltf"
		],
		"application/vnd.fsc.weblaunch": [
			"fsc"
		],
		"application/vnd.fujitsu.oasys": [
			"oas"
		],
		"application/vnd.fujitsu.oasys2": [
			"oa2"
		],
		"application/vnd.fujitsu.oasys3": [
			"oa3"
		],
		"application/vnd.fujitsu.oasysgp": [
			"fg5"
		],
		"application/vnd.fujitsu.oasysprs": [
			"bh2"
		],
		"application/vnd.fujixerox.ddd": [
			"ddd"
		],
		"application/vnd.fujixerox.docuworks": [
			"xdw"
		],
		"application/vnd.fujixerox.docuworks.binder": [
			"xbd"
		],
		"application/vnd.fuzzysheet": [
			"fzs"
		],
		"application/vnd.genomatix.tuxedo": [
			"txd"
		],
		"application/vnd.geogebra.file": [
			"ggb"
		],
		"application/vnd.geogebra.tool": [
			"ggt"
		],
		"application/vnd.geometry-explorer": [
			"gex",
			"gre"
		],
		"application/vnd.geonext": [
			"gxt"
		],
		"application/vnd.geoplan": [
			"g2w"
		],
		"application/vnd.geospace": [
			"g3w"
		],
		"application/vnd.gmx": [
			"gmx"
		],
		"application/vnd.google-earth.kml+xml": [
			"kml"
		],
		"application/vnd.google-earth.kmz": [
			"kmz"
		],
		"application/vnd.grafeq": [
			"gqf",
			"gqs"
		],
		"application/vnd.groove-account": [
			"gac"
		],
		"application/vnd.groove-help": [
			"ghf"
		],
		"application/vnd.groove-identity-message": [
			"gim"
		],
		"application/vnd.groove-injector": [
			"grv"
		],
		"application/vnd.groove-tool-message": [
			"gtm"
		],
		"application/vnd.groove-tool-template": [
			"tpl"
		],
		"application/vnd.groove-vcard": [
			"vcg"
		],
		"application/vnd.hal+xml": [
			"hal"
		],
		"application/vnd.handheld-entertainment+xml": [
			"zmm"
		],
		"application/vnd.hbci": [
			"hbci"
		],
		"application/vnd.hhe.lesson-player": [
			"les"
		],
		"application/vnd.hp-hpgl": [
			"hpgl"
		],
		"application/vnd.hp-hpid": [
			"hpid"
		],
		"application/vnd.hp-hps": [
			"hps"
		],
		"application/vnd.hp-jlyt": [
			"jlt"
		],
		"application/vnd.hp-pcl": [
			"pcl"
		],
		"application/vnd.hp-pclxl": [
			"pclxl"
		],
		"application/vnd.ibm.minipay": [
			"mpy"
		],
		"application/vnd.ibm.modcap": [
			"afp",
			"listafp",
			"list3820"
		],
		"application/vnd.ibm.rights-management": [
			"irm"
		],
		"application/vnd.ibm.secure-container": [
			"sc"
		],
		"application/vnd.iccprofile": [
			"icc",
			"icm"
		],
		"application/vnd.igloader": [
			"igl"
		],
		"application/vnd.immervision-ivp": [
			"ivp"
		],
		"application/vnd.immervision-ivu": [
			"ivu"
		],
		"application/vnd.insors.igm": [
			"igm"
		],
		"application/vnd.intercon.formnet": [
			"xpw",
			"xpx"
		],
		"application/vnd.intergeo": [
			"i2g"
		],
		"application/vnd.intu.qbo": [
			"qbo"
		],
		"application/vnd.intu.qfx": [
			"qfx"
		],
		"application/vnd.ipunplugged.rcprofile": [
			"rcprofile"
		],
		"application/vnd.irepository.package+xml": [
			"irp"
		],
		"application/vnd.is-xpr": [
			"xpr"
		],
		"application/vnd.isac.fcs": [
			"fcs"
		],
		"application/vnd.jam": [
			"jam"
		],
		"application/vnd.jcp.javame.midlet-rms": [
			"rms"
		],
		"application/vnd.jisp": [
			"jisp"
		],
		"application/vnd.joost.joda-archive": [
			"joda"
		],
		"application/vnd.kahootz": [
			"ktz",
			"ktr"
		],
		"application/vnd.kde.karbon": [
			"karbon"
		],
		"application/vnd.kde.kchart": [
			"chrt"
		],
		"application/vnd.kde.kformula": [
			"kfo"
		],
		"application/vnd.kde.kivio": [
			"flw"
		],
		"application/vnd.kde.kontour": [
			"kon"
		],
		"application/vnd.kde.kpresenter": [
			"kpr",
			"kpt"
		],
		"application/vnd.kde.kspread": [
			"ksp"
		],
		"application/vnd.kde.kword": [
			"kwd",
			"kwt"
		],
		"application/vnd.kenameaapp": [
			"htke"
		],
		"application/vnd.kidspiration": [
			"kia"
		],
		"application/vnd.kinar": [
			"kne",
			"knp"
		],
		"application/vnd.koan": [
			"skp",
			"skd",
			"skt",
			"skm"
		],
		"application/vnd.kodak-descriptor": [
			"sse"
		],
		"application/vnd.las.las+xml": [
			"lasxml"
		],
		"application/vnd.llamagraphics.life-balance.desktop": [
			"lbd"
		],
		"application/vnd.llamagraphics.life-balance.exchange+xml": [
			"lbe"
		],
		"application/vnd.lotus-1-2-3": [
			"123"
		],
		"application/vnd.lotus-approach": [
			"apr"
		],
		"application/vnd.lotus-freelance": [
			"pre"
		],
		"application/vnd.lotus-notes": [
			"nsf"
		],
		"application/vnd.lotus-organizer": [
			"org"
		],
		"application/vnd.lotus-screencam": [
			"scm"
		],
		"application/vnd.lotus-wordpro": [
			"lwp"
		],
		"application/vnd.macports.portpkg": [
			"portpkg"
		],
		"application/vnd.mcd": [
			"mcd"
		],
		"application/vnd.medcalcdata": [
			"mc1"
		],
		"application/vnd.mediastation.cdkey": [
			"cdkey"
		],
		"application/vnd.mfer": [
			"mwf"
		],
		"application/vnd.mfmp": [
			"mfm"
		],
		"application/vnd.micrografx.flo": [
			"flo"
		],
		"application/vnd.micrografx.igx": [
			"igx"
		],
		"application/vnd.mif": [
			"mif"
		],
		"application/vnd.mobius.daf": [
			"daf"
		],
		"application/vnd.mobius.dis": [
			"dis"
		],
		"application/vnd.mobius.mbk": [
			"mbk"
		],
		"application/vnd.mobius.mqy": [
			"mqy"
		],
		"application/vnd.mobius.msl": [
			"msl"
		],
		"application/vnd.mobius.plc": [
			"plc"
		],
		"application/vnd.mobius.txf": [
			"txf"
		],
		"application/vnd.mophun.application": [
			"mpn"
		],
		"application/vnd.mophun.certificate": [
			"mpc"
		],
		"application/vnd.mozilla.xul+xml": [
			"xul"
		],
		"application/vnd.ms-artgalry": [
			"cil"
		],
		"application/vnd.ms-cab-compressed": [
			"cab"
		],
		"application/vnd.ms-excel": [
			"xls",
			"xlm",
			"xla",
			"xlc",
			"xlt",
			"xlw"
		],
		"application/vnd.ms-excel.addin.macroenabled.12": [
			"xlam"
		],
		"application/vnd.ms-excel.sheet.binary.macroenabled.12": [
			"xlsb"
		],
		"application/vnd.ms-excel.sheet.macroenabled.12": [
			"xlsm"
		],
		"application/vnd.ms-excel.template.macroenabled.12": [
			"xltm"
		],
		"application/vnd.ms-fontobject": [
			"eot"
		],
		"application/vnd.ms-htmlhelp": [
			"chm"
		],
		"application/vnd.ms-ims": [
			"ims"
		],
		"application/vnd.ms-lrm": [
			"lrm"
		],
		"application/vnd.ms-officetheme": [
			"thmx"
		],
		"application/vnd.ms-pki.seccat": [
			"cat"
		],
		"application/vnd.ms-pki.stl": [
			"stl"
		],
		"application/vnd.ms-powerpoint": [
			"ppt",
			"pps",
			"pot"
		],
		"application/vnd.ms-powerpoint.addin.macroenabled.12": [
			"ppam"
		],
		"application/vnd.ms-powerpoint.presentation.macroenabled.12": [
			"pptm"
		],
		"application/vnd.ms-powerpoint.slide.macroenabled.12": [
			"sldm"
		],
		"application/vnd.ms-powerpoint.slideshow.macroenabled.12": [
			"ppsm"
		],
		"application/vnd.ms-powerpoint.template.macroenabled.12": [
			"potm"
		],
		"application/vnd.ms-project": [
			"mpp",
			"mpt"
		],
		"application/vnd.ms-word.document.macroenabled.12": [
			"docm"
		],
		"application/vnd.ms-word.template.macroenabled.12": [
			"dotm"
		],
		"application/vnd.ms-works": [
			"wps",
			"wks",
			"wcm",
			"wdb"
		],
		"application/vnd.ms-wpl": [
			"wpl"
		],
		"application/vnd.ms-xpsdocument": [
			"xps"
		],
		"application/vnd.mseq": [
			"mseq"
		],
		"application/vnd.musician": [
			"mus"
		],
		"application/vnd.muvee.style": [
			"msty"
		],
		"application/vnd.mynfc": [
			"taglet"
		],
		"application/vnd.neurolanguage.nlu": [
			"nlu"
		],
		"application/vnd.nitf": [
			"ntf",
			"nitf"
		],
		"application/vnd.noblenet-directory": [
			"nnd"
		],
		"application/vnd.noblenet-sealer": [
			"nns"
		],
		"application/vnd.noblenet-web": [
			"nnw"
		],
		"application/vnd.nokia.n-gage.data": [
			"ngdat"
		],
		"application/vnd.nokia.radio-preset": [
			"rpst"
		],
		"application/vnd.nokia.radio-presets": [
			"rpss"
		],
		"application/vnd.novadigm.edm": [
			"edm"
		],
		"application/vnd.novadigm.edx": [
			"edx"
		],
		"application/vnd.novadigm.ext": [
			"ext"
		],
		"application/vnd.oasis.opendocument.chart": [
			"odc"
		],
		"application/vnd.oasis.opendocument.chart-template": [
			"otc"
		],
		"application/vnd.oasis.opendocument.database": [
			"odb"
		],
		"application/vnd.oasis.opendocument.formula": [
			"odf"
		],
		"application/vnd.oasis.opendocument.formula-template": [
			"odft"
		],
		"application/vnd.oasis.opendocument.graphics": [
			"odg"
		],
		"application/vnd.oasis.opendocument.graphics-template": [
			"otg"
		],
		"application/vnd.oasis.opendocument.image": [
			"odi"
		],
		"application/vnd.oasis.opendocument.image-template": [
			"oti"
		],
		"application/vnd.oasis.opendocument.presentation": [
			"odp"
		],
		"application/vnd.oasis.opendocument.presentation-template": [
			"otp"
		],
		"application/vnd.oasis.opendocument.spreadsheet": [
			"ods"
		],
		"application/vnd.oasis.opendocument.spreadsheet-template": [
			"ots"
		],
		"application/vnd.oasis.opendocument.text": [
			"odt"
		],
		"application/vnd.oasis.opendocument.text-master": [
			"odm"
		],
		"application/vnd.oasis.opendocument.text-template": [
			"ott"
		],
		"application/vnd.oasis.opendocument.text-web": [
			"oth"
		],
		"application/vnd.olpc-sugar": [
			"xo"
		],
		"application/vnd.oma.dd2+xml": [
			"dd2"
		],
		"application/vnd.openofficeorg.extension": [
			"oxt"
		],
		"application/vnd.openxmlformats-officedocument.presentationml.presentation": [
			"pptx"
		],
		"application/vnd.openxmlformats-officedocument.presentationml.slide": [
			"sldx"
		],
		"application/vnd.openxmlformats-officedocument.presentationml.slideshow": [
			"ppsx"
		],
		"application/vnd.openxmlformats-officedocument.presentationml.template": [
			"potx"
		],
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": [
			"xlsx"
		],
		"application/vnd.openxmlformats-officedocument.spreadsheetml.template": [
			"xltx"
		],
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document": [
			"docx"
		],
		"application/vnd.openxmlformats-officedocument.wordprocessingml.template": [
			"dotx"
		],
		"application/vnd.osgeo.mapguide.package": [
			"mgp"
		],
		"application/vnd.osgi.dp": [
			"dp"
		],
		"application/vnd.osgi.subsystem": [
			"esa"
		],
		"application/vnd.palm": [
			"pdb",
			"pqa",
			"oprc"
		],
		"application/vnd.pawaafile": [
			"paw"
		],
		"application/vnd.pg.format": [
			"str"
		],
		"application/vnd.pg.osasli": [
			"ei6"
		],
		"application/vnd.picsel": [
			"efif"
		],
		"application/vnd.pmi.widget": [
			"wg"
		],
		"application/vnd.pocketlearn": [
			"plf"
		],
		"application/vnd.powerbuilder6": [
			"pbd"
		],
		"application/vnd.previewsystems.box": [
			"box"
		],
		"application/vnd.proteus.magazine": [
			"mgz"
		],
		"application/vnd.publishare-delta-tree": [
			"qps"
		],
		"application/vnd.pvi.ptid1": [
			"ptid"
		],
		"application/vnd.quark.quarkxpress": [
			"qxd",
			"qxt",
			"qwd",
			"qwt",
			"qxl",
			"qxb"
		],
		"application/vnd.realvnc.bed": [
			"bed"
		],
		"application/vnd.recordare.musicxml": [
			"mxl"
		],
		"application/vnd.recordare.musicxml+xml": [
			"musicxml"
		],
		"application/vnd.rig.cryptonote": [
			"cryptonote"
		],
		"application/vnd.rim.cod": [
			"cod"
		],
		"application/vnd.rn-realmedia": [
			"rm"
		],
		"application/vnd.rn-realmedia-vbr": [
			"rmvb"
		],
		"application/vnd.route66.link66+xml": [
			"link66"
		],
		"application/vnd.sailingtracker.track": [
			"st"
		],
		"application/vnd.seemail": [
			"see"
		],
		"application/vnd.sema": [
			"sema"
		],
		"application/vnd.semd": [
			"semd"
		],
		"application/vnd.semf": [
			"semf"
		],
		"application/vnd.shana.informed.formdata": [
			"ifm"
		],
		"application/vnd.shana.informed.formtemplate": [
			"itp"
		],
		"application/vnd.shana.informed.interchange": [
			"iif"
		],
		"application/vnd.shana.informed.package": [
			"ipk"
		],
		"application/vnd.simtech-mindmapper": [
			"twd",
			"twds"
		],
		"application/vnd.smaf": [
			"mmf"
		],
		"application/vnd.smart.teacher": [
			"teacher"
		],
		"application/vnd.solent.sdkm+xml": [
			"sdkm",
			"sdkd"
		],
		"application/vnd.spotfire.dxp": [
			"dxp"
		],
		"application/vnd.spotfire.sfs": [
			"sfs"
		],
		"application/vnd.stardivision.calc": [
			"sdc"
		],
		"application/vnd.stardivision.draw": [
			"sda"
		],
		"application/vnd.stardivision.impress": [
			"sdd"
		],
		"application/vnd.stardivision.math": [
			"smf"
		],
		"application/vnd.stardivision.writer": [
			"sdw",
			"vor"
		],
		"application/vnd.stardivision.writer-global": [
			"sgl"
		],
		"application/vnd.stepmania.package": [
			"smzip"
		],
		"application/vnd.stepmania.stepchart": [
			"sm"
		],
		"application/vnd.sun.xml.calc": [
			"sxc"
		],
		"application/vnd.sun.xml.calc.template": [
			"stc"
		],
		"application/vnd.sun.xml.draw": [
			"sxd"
		],
		"application/vnd.sun.xml.draw.template": [
			"std"
		],
		"application/vnd.sun.xml.impress": [
			"sxi"
		],
		"application/vnd.sun.xml.impress.template": [
			"sti"
		],
		"application/vnd.sun.xml.math": [
			"sxm"
		],
		"application/vnd.sun.xml.writer": [
			"sxw"
		],
		"application/vnd.sun.xml.writer.global": [
			"sxg"
		],
		"application/vnd.sun.xml.writer.template": [
			"stw"
		],
		"application/vnd.sus-calendar": [
			"sus",
			"susp"
		],
		"application/vnd.svd": [
			"svd"
		],
		"application/vnd.symbian.install": [
			"sis",
			"sisx"
		],
		"application/vnd.syncml+xml": [
			"xsm"
		],
		"application/vnd.syncml.dm+wbxml": [
			"bdm"
		],
		"application/vnd.syncml.dm+xml": [
			"xdm"
		],
		"application/vnd.tao.intent-module-archive": [
			"tao"
		],
		"application/vnd.tcpdump.pcap": [
			"pcap",
			"cap",
			"dmp"
		],
		"application/vnd.tmobile-livetv": [
			"tmo"
		],
		"application/vnd.trid.tpt": [
			"tpt"
		],
		"application/vnd.triscape.mxs": [
			"mxs"
		],
		"application/vnd.trueapp": [
			"tra"
		],
		"application/vnd.ufdl": [
			"ufd",
			"ufdl"
		],
		"application/vnd.uiq.theme": [
			"utz"
		],
		"application/vnd.umajin": [
			"umj"
		],
		"application/vnd.unity": [
			"unityweb"
		],
		"application/vnd.uoml+xml": [
			"uoml"
		],
		"application/vnd.vcx": [
			"vcx"
		],
		"application/vnd.visio": [
			"vsd",
			"vst",
			"vss",
			"vsw"
		],
		"application/vnd.visionary": [
			"vis"
		],
		"application/vnd.vsf": [
			"vsf"
		],
		"application/vnd.wap.wbxml": [
			"wbxml"
		],
		"application/vnd.wap.wmlc": [
			"wmlc"
		],
		"application/vnd.wap.wmlscriptc": [
			"wmlsc"
		],
		"application/vnd.webturbo": [
			"wtb"
		],
		"application/vnd.wolfram.player": [
			"nbp"
		],
		"application/vnd.wordperfect": [
			"wpd"
		],
		"application/vnd.wqd": [
			"wqd"
		],
		"application/vnd.wt.stf": [
			"stf"
		],
		"application/vnd.xara": [
			"xar"
		],
		"application/vnd.xfdl": [
			"xfdl"
		],
		"application/vnd.yamaha.hv-dic": [
			"hvd"
		],
		"application/vnd.yamaha.hv-script": [
			"hvs"
		],
		"application/vnd.yamaha.hv-voice": [
			"hvp"
		],
		"application/vnd.yamaha.openscoreformat": [
			"osf"
		],
		"application/vnd.yamaha.openscoreformat.osfpvg+xml": [
			"osfpvg"
		],
		"application/vnd.yamaha.smaf-audio": [
			"saf"
		],
		"application/vnd.yamaha.smaf-phrase": [
			"spf"
		],
		"application/vnd.yellowriver-custom-menu": [
			"cmp"
		],
		"application/vnd.zul": [
			"zir",
			"zirz"
		],
		"application/vnd.zzazz.deck+xml": [
			"zaz"
		],
		"application/voicexml+xml": [
			"vxml"
		],
		"application/widget": [
			"wgt"
		],
		"application/winhlp": [
			"hlp"
		],
		"application/wsdl+xml": [
			"wsdl"
		],
		"application/wspolicy+xml": [
			"wspolicy"
		],
		"application/x-7z-compressed": [
			"7z"
		],
		"application/x-abiword": [
			"abw"
		],
		"application/x-ace-compressed": [
			"ace"
		],
		"application/x-apple-diskimage": [
			"dmg"
		],
		"application/x-authorware-bin": [
			"aab",
			"x32",
			"u32",
			"vox"
		],
		"application/x-authorware-map": [
			"aam"
		],
		"application/x-authorware-seg": [
			"aas"
		],
		"application/x-bcpio": [
			"bcpio"
		],
		"application/x-bittorrent": [
			"torrent"
		],
		"application/x-blorb": [
			"blb",
			"blorb"
		],
		"application/x-bzip": [
			"bz"
		],
		"application/x-bzip2": [
			"bz2",
			"boz"
		],
		"application/x-cbr": [
			"cbr",
			"cba",
			"cbt",
			"cbz",
			"cb7"
		],
		"application/x-cdlink": [
			"vcd"
		],
		"application/x-cfs-compressed": [
			"cfs"
		],
		"application/x-chat": [
			"chat"
		],
		"application/x-chess-pgn": [
			"pgn"
		],
		"application/x-chrome-extension": [
			"crx"
		],
		"application/x-conference": [
			"nsc"
		],
		"application/x-cpio": [
			"cpio"
		],
		"application/x-csh": [
			"csh"
		],
		"application/x-debian-package": [
			"deb",
			"udeb"
		],
		"application/x-dgc-compressed": [
			"dgc"
		],
		"application/x-director": [
			"dir",
			"dcr",
			"dxr",
			"cst",
			"cct",
			"cxt",
			"w3d",
			"fgd",
			"swa"
		],
		"application/x-doom": [
			"wad"
		],
		"application/x-dtbncx+xml": [
			"ncx"
		],
		"application/x-dtbook+xml": [
			"dtb"
		],
		"application/x-dtbresource+xml": [
			"res"
		],
		"application/x-dvi": [
			"dvi"
		],
		"application/x-envoy": [
			"evy"
		],
		"application/x-eva": [
			"eva"
		],
		"application/x-font-bdf": [
			"bdf"
		],
		"application/x-font-ghostscript": [
			"gsf"
		],
		"application/x-font-linux-psf": [
			"psf"
		],
		"application/x-font-otf": [
			"otf"
		],
		"application/x-font-pcf": [
			"pcf"
		],
		"application/x-font-snf": [
			"snf"
		],
		"application/x-font-ttf": [
			"ttf",
			"ttc"
		],
		"application/x-font-type1": [
			"pfa",
			"pfb",
			"pfm",
			"afm"
		],
		"application/x-freearc": [
			"arc"
		],
		"application/x-futuresplash": [
			"spl"
		],
		"application/x-gca-compressed": [
			"gca"
		],
		"application/x-glulx": [
			"ulx"
		],
		"application/x-gnumeric": [
			"gnumeric"
		],
		"application/x-gramps-xml": [
			"gramps"
		],
		"application/x-gtar": [
			"gtar"
		],
		"application/x-hdf": [
			"hdf"
		],
		"application/x-install-instructions": [
			"install"
		],
		"application/x-iso9660-image": [
			"iso"
		],
		"application/x-java-jnlp-file": [
			"jnlp"
		],
		"application/x-latex": [
			"latex"
		],
		"application/x-lua-bytecode": [
			"luac"
		],
		"application/x-lzh-compressed": [
			"lzh",
			"lha"
		],
		"application/x-mie": [
			"mie"
		],
		"application/x-mobipocket-ebook": [
			"prc",
			"mobi"
		],
		"application/x-ms-application": [
			"application"
		],
		"application/x-ms-shortcut": [
			"lnk"
		],
		"application/x-ms-wmd": [
			"wmd"
		],
		"application/x-ms-wmz": [
			"wmz"
		],
		"application/x-ms-xbap": [
			"xbap"
		],
		"application/x-msaccess": [
			"mdb"
		],
		"application/x-msbinder": [
			"obd"
		],
		"application/x-mscardfile": [
			"crd"
		],
		"application/x-msclip": [
			"clp"
		],
		"application/x-msdownload": [
			"exe",
			"dll",
			"com",
			"bat",
			"msi"
		],
		"application/x-msmediaview": [
			"mvb",
			"m13",
			"m14"
		],
		"application/x-msmetafile": [
			"wmf",
			"wmz",
			"emf",
			"emz"
		],
		"application/x-msmoney": [
			"mny"
		],
		"application/x-mspublisher": [
			"pub"
		],
		"application/x-msschedule": [
			"scd"
		],
		"application/x-msterminal": [
			"trm"
		],
		"application/x-mswrite": [
			"wri"
		],
		"application/x-netcdf": [
			"nc",
			"cdf"
		],
		"application/x-nzb": [
			"nzb"
		],
		"application/x-pkcs12": [
			"p12",
			"pfx"
		],
		"application/x-pkcs7-certificates": [
			"p7b",
			"spc"
		],
		"application/x-pkcs7-certreqresp": [
			"p7r"
		],
		"application/x-rar-compressed": [
			"rar"
		],
		"application/x-research-info-systems": [
			"ris"
		],
		"application/x-sh": [
			"sh"
		],
		"application/x-shar": [
			"shar"
		],
		"application/x-shockwave-flash": [
			"swf"
		],
		"application/x-silverlight-app": [
			"xap"
		],
		"application/x-sql": [
			"sql"
		],
		"application/x-stuffit": [
			"sit"
		],
		"application/x-stuffitx": [
			"sitx"
		],
		"application/x-subrip": [
			"srt"
		],
		"application/x-sv4cpio": [
			"sv4cpio"
		],
		"application/x-sv4crc": [
			"sv4crc"
		],
		"application/x-t3vm-image": [
			"t3"
		],
		"application/x-tads": [
			"gam"
		],
		"application/x-tar": [
			"tar"
		],
		"application/x-tcl": [
			"tcl"
		],
		"application/x-tex": [
			"tex"
		],
		"application/x-tex-tfm": [
			"tfm"
		],
		"application/x-texinfo": [
			"texinfo",
			"texi"
		],
		"application/x-tgif": [
			"obj"
		],
		"application/x-ustar": [
			"ustar"
		],
		"application/x-wais-source": [
			"src"
		],
		"application/x-web-app-manifest+json": [
			"webapp"
		],
		"application/x-x509-ca-cert": [
			"der",
			"crt"
		],
		"application/x-xfig": [
			"fig"
		],
		"application/x-xliff+xml": [
			"xlf"
		],
		"application/x-xpinstall": [
			"xpi"
		],
		"application/x-xz": [
			"xz"
		],
		"application/x-zmachine": [
			"z1",
			"z2",
			"z3",
			"z4",
			"z5",
			"z6",
			"z7",
			"z8"
		],
		"application/xaml+xml": [
			"xaml"
		],
		"application/xcap-diff+xml": [
			"xdf"
		],
		"application/xenc+xml": [
			"xenc"
		],
		"application/xhtml+xml": [
			"xhtml",
			"xht"
		],
		"application/xml": [
			"xml",
			"xsl",
			"xsd"
		],
		"application/xml-dtd": [
			"dtd"
		],
		"application/xop+xml": [
			"xop"
		],
		"application/xproc+xml": [
			"xpl"
		],
		"application/xslt+xml": [
			"xslt"
		],
		"application/xspf+xml": [
			"xspf"
		],
		"application/xv+xml": [
			"mxml",
			"xhvml",
			"xvml",
			"xvm"
		],
		"application/yang": [
			"yang"
		],
		"application/yin+xml": [
			"yin"
		],
		"application/zip": [
			"zip"
		],
		"audio/adpcm": [
			"adp"
		],
		"audio/basic": [
			"au",
			"snd"
		],
		"audio/midi": [
			"mid",
			"midi",
			"kar",
			"rmi"
		],
		"audio/mp4": [
			"mp4a",
			"m4a"
		],
		"audio/mpeg": [
			"mpga",
			"mp2",
			"mp2a",
			"mp3",
			"m2a",
			"m3a"
		],
		"audio/ogg": [
			"oga",
			"ogg",
			"spx"
		],
		"audio/s3m": [
			"s3m"
		],
		"audio/silk": [
			"sil"
		],
		"audio/vnd.dece.audio": [
			"uva",
			"uvva"
		],
		"audio/vnd.digital-winds": [
			"eol"
		],
		"audio/vnd.dra": [
			"dra"
		],
		"audio/vnd.dts": [
			"dts"
		],
		"audio/vnd.dts.hd": [
			"dtshd"
		],
		"audio/vnd.lucent.voice": [
			"lvp"
		],
		"audio/vnd.ms-playready.media.pya": [
			"pya"
		],
		"audio/vnd.nuera.ecelp4800": [
			"ecelp4800"
		],
		"audio/vnd.nuera.ecelp7470": [
			"ecelp7470"
		],
		"audio/vnd.nuera.ecelp9600": [
			"ecelp9600"
		],
		"audio/vnd.rip": [
			"rip"
		],
		"audio/webm": [
			"weba"
		],
		"audio/x-aac": [
			"aac"
		],
		"audio/x-aiff": [
			"aif",
			"aiff",
			"aifc"
		],
		"audio/x-caf": [
			"caf"
		],
		"audio/x-flac": [
			"flac"
		],
		"audio/x-matroska": [
			"mka"
		],
		"audio/x-mpegurl": [
			"m3u"
		],
		"audio/x-ms-wax": [
			"wax"
		],
		"audio/x-ms-wma": [
			"wma"
		],
		"audio/x-pn-realaudio": [
			"ram",
			"ra"
		],
		"audio/x-pn-realaudio-plugin": [
			"rmp"
		],
		"audio/x-wav": [
			"wav"
		],
		"audio/xm": [
			"xm"
		],
		"chemical/x-cdx": [
			"cdx"
		],
		"chemical/x-cif": [
			"cif"
		],
		"chemical/x-cmdf": [
			"cmdf"
		],
		"chemical/x-cml": [
			"cml"
		],
		"chemical/x-csml": [
			"csml"
		],
		"chemical/x-xyz": [
			"xyz"
		],
		"font/opentype": [
			"otf"
		],
		"image/bmp": [
			"bmp"
		],
		"image/cgm": [
			"cgm"
		],
		"image/g3fax": [
			"g3"
		],
		"image/gif": [
			"gif"
		],
		"image/ief": [
			"ief"
		],
		"image/jpeg": [
			"jpeg",
			"jpg",
			"jpe"
		],
		"image/ktx": [
			"ktx"
		],
		"image/png": [
			"png"
		],
		"image/prs.btif": [
			"btif"
		],
		"image/sgi": [
			"sgi"
		],
		"image/svg+xml": [
			"svg",
			"svgz"
		],
		"image/tiff": [
			"tiff",
			"tif"
		],
		"image/vnd.adobe.photoshop": [
			"psd"
		],
		"image/vnd.dece.graphic": [
			"uvi",
			"uvvi",
			"uvg",
			"uvvg"
		],
		"image/vnd.djvu": [
			"djvu",
			"djv"
		],
		"image/vnd.dvb.subtitle": [
			"sub"
		],
		"image/vnd.dwg": [
			"dwg"
		],
		"image/vnd.dxf": [
			"dxf"
		],
		"image/vnd.fastbidsheet": [
			"fbs"
		],
		"image/vnd.fpx": [
			"fpx"
		],
		"image/vnd.fst": [
			"fst"
		],
		"image/vnd.fujixerox.edmics-mmr": [
			"mmr"
		],
		"image/vnd.fujixerox.edmics-rlc": [
			"rlc"
		],
		"image/vnd.ms-modi": [
			"mdi"
		],
		"image/vnd.ms-photo": [
			"wdp"
		],
		"image/vnd.net-fpx": [
			"npx"
		],
		"image/vnd.wap.wbmp": [
			"wbmp"
		],
		"image/vnd.xiff": [
			"xif"
		],
		"image/webp": [
			"webp"
		],
		"image/x-3ds": [
			"3ds"
		],
		"image/x-cmu-raster": [
			"ras"
		],
		"image/x-cmx": [
			"cmx"
		],
		"image/x-freehand": [
			"fh",
			"fhc",
			"fh4",
			"fh5",
			"fh7"
		],
		"image/x-icon": [
			"ico"
		],
		"image/x-mrsid-image": [
			"sid"
		],
		"image/x-pcx": [
			"pcx"
		],
		"image/x-pict": [
			"pic",
			"pct"
		],
		"image/x-portable-anymap": [
			"pnm"
		],
		"image/x-portable-bitmap": [
			"pbm"
		],
		"image/x-portable-graymap": [
			"pgm"
		],
		"image/x-portable-pixmap": [
			"ppm"
		],
		"image/x-rgb": [
			"rgb"
		],
		"image/x-tga": [
			"tga"
		],
		"image/x-xbitmap": [
			"xbm"
		],
		"image/x-xpixmap": [
			"xpm"
		],
		"image/x-xwindowdump": [
			"xwd"
		],
		"message/rfc822": [
			"eml",
			"mime"
		],
		"model/iges": [
			"igs",
			"iges"
		],
		"model/mesh": [
			"msh",
			"mesh",
			"silo"
		],
		"model/vnd.collada+xml": [
			"dae"
		],
		"model/vnd.dwf": [
			"dwf"
		],
		"model/vnd.gdl": [
			"gdl"
		],
		"model/vnd.gtw": [
			"gtw"
		],
		"model/vnd.mts": [
			"mts"
		],
		"model/vnd.vtu": [
			"vtu"
		],
		"model/vrml": [
			"wrl",
			"vrml"
		],
		"model/x3d+binary": [
			"x3db",
			"x3dbz"
		],
		"model/x3d+vrml": [
			"x3dv",
			"x3dvz"
		],
		"model/x3d+xml": [
			"x3d",
			"x3dz"
		],
		"text/cache-manifest": [
			"appcache",
			"manifest"
		],
		"text/calendar": [
			"ics",
			"ifb"
		],
		"text/coffeescript": [
			"coffee"
		],
		"text/css": [
			"css"
		],
		"text/csv": [
			"csv"
		],
		"text/hjson": [
			"hjson"
		],
		"text/html": [
			"html",
			"htm"
		],
		"text/jade": [
			"jade"
		],
		"text/jsx": [
			"jsx"
		],
		"text/less": [
			"less"
		],
		"text/n3": [
			"n3"
		],
		"text/plain": [
			"txt",
			"text",
			"conf",
			"def",
			"list",
			"log",
			"in",
			"ini"
		],
		"text/prs.lines.tag": [
			"dsc"
		],
		"text/richtext": [
			"rtx"
		],
		"text/sgml": [
			"sgml",
			"sgm"
		],
		"text/stylus": [
			"stylus",
			"styl"
		],
		"text/tab-separated-values": [
			"tsv"
		],
		"text/troff": [
			"t",
			"tr",
			"roff",
			"man",
			"me",
			"ms"
		],
		"text/turtle": [
			"ttl"
		],
		"text/uri-list": [
			"uri",
			"uris",
			"urls"
		],
		"text/vcard": [
			"vcard"
		],
		"text/vnd.curl": [
			"curl"
		],
		"text/vnd.curl.dcurl": [
			"dcurl"
		],
		"text/vnd.curl.mcurl": [
			"mcurl"
		],
		"text/vnd.curl.scurl": [
			"scurl"
		],
		"text/vnd.dvb.subtitle": [
			"sub"
		],
		"text/vnd.fly": [
			"fly"
		],
		"text/vnd.fmi.flexstor": [
			"flx"
		],
		"text/vnd.graphviz": [
			"gv"
		],
		"text/vnd.in3d.3dml": [
			"3dml"
		],
		"text/vnd.in3d.spot": [
			"spot"
		],
		"text/vnd.sun.j2me.app-descriptor": [
			"jad"
		],
		"text/vnd.wap.wml": [
			"wml"
		],
		"text/vnd.wap.wmlscript": [
			"wmls"
		],
		"text/vtt": [
			"vtt"
		],
		"text/x-asm": [
			"s",
			"asm"
		],
		"text/x-c": [
			"c",
			"cc",
			"cxx",
			"cpp",
			"h",
			"hh",
			"dic"
		],
		"text/x-component": [
			"htc"
		],
		"text/x-fortran": [
			"f",
			"for",
			"f77",
			"f90"
		],
		"text/x-handlebars-template": [
			"hbs"
		],
		"text/x-java-source": [
			"java"
		],
		"text/x-lua": [
			"lua"
		],
		"text/x-markdown": [
			"markdown",
			"md",
			"mkd"
		],
		"text/x-nfo": [
			"nfo"
		],
		"text/x-opml": [
			"opml"
		],
		"text/x-pascal": [
			"p",
			"pas"
		],
		"text/x-sass": [
			"sass"
		],
		"text/x-scss": [
			"scss"
		],
		"text/x-setext": [
			"etx"
		],
		"text/x-sfv": [
			"sfv"
		],
		"text/x-uuencode": [
			"uu"
		],
		"text/x-vcalendar": [
			"vcs"
		],
		"text/x-vcard": [
			"vcf"
		],
		"text/yaml": [
			"yaml",
			"yml"
		],
		"video/3gpp": [
			"3gp"
		],
		"video/3gpp2": [
			"3g2"
		],
		"video/h261": [
			"h261"
		],
		"video/h263": [
			"h263"
		],
		"video/h264": [
			"h264"
		],
		"video/jpeg": [
			"jpgv"
		],
		"video/jpm": [
			"jpm",
			"jpgm"
		],
		"video/mj2": [
			"mj2",
			"mjp2"
		],
		"video/mp2t": [
			"ts"
		],
		"video/mp4": [
			"mp4",
			"mp4v",
			"mpg4"
		],
		"video/mpeg": [
			"mpeg",
			"mpg",
			"mpe",
			"m1v",
			"m2v"
		],
		"video/ogg": [
			"ogv"
		],
		"video/quicktime": [
			"qt",
			"mov"
		],
		"video/vnd.dece.hd": [
			"uvh",
			"uvvh"
		],
		"video/vnd.dece.mobile": [
			"uvm",
			"uvvm"
		],
		"video/vnd.dece.pd": [
			"uvp",
			"uvvp"
		],
		"video/vnd.dece.sd": [
			"uvs",
			"uvvs"
		],
		"video/vnd.dece.video": [
			"uvv",
			"uvvv"
		],
		"video/vnd.dvb.file": [
			"dvb"
		],
		"video/vnd.fvt": [
			"fvt"
		],
		"video/vnd.mpegurl": [
			"mxu",
			"m4u"
		],
		"video/vnd.ms-playready.media.pyv": [
			"pyv"
		],
		"video/vnd.uvvu.mp4": [
			"uvu",
			"uvvu"
		],
		"video/vnd.vivo": [
			"viv"
		],
		"video/webm": [
			"webm"
		],
		"video/x-f4v": [
			"f4v"
		],
		"video/x-fli": [
			"fli"
		],
		"video/x-flv": [
			"flv"
		],
		"video/x-m4v": [
			"m4v"
		],
		"video/x-matroska": [
			"mkv",
			"mk3d",
			"mks"
		],
		"video/x-mng": [
			"mng"
		],
		"video/x-ms-asf": [
			"asf",
			"asx"
		],
		"video/x-ms-vob": [
			"vob"
		],
		"video/x-ms-wm": [
			"wm"
		],
		"video/x-ms-wmv": [
			"wmv"
		],
		"video/x-ms-wmx": [
			"wmx"
		],
		"video/x-ms-wvx": [
			"wvx"
		],
		"video/x-msvideo": [
			"avi"
		],
		"video/x-sgi-movie": [
			"movie"
		],
		"video/x-smv": [
			"smv"
		],
		"x-conference/x-cooltalk": [
			"ice"
		]
	};

/***/ },
/* 74 */
/*!*********************************!*\
  !*** ./~/range-parser/index.js ***!
  \*********************************/
/***/ function(module, exports) {

	/*!
	 * range-parser
	 * Copyright(c) 2012-2014 TJ Holowaychuk
	 * Copyright(c) 2015-2016 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict'

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = rangeParser

	/**
	 * Parse "Range" header `str` relative to the given file `size`.
	 *
	 * @param {Number} size
	 * @param {String} str
	 * @param {Object} [options]
	 * @return {Array}
	 * @public
	 */

	function rangeParser (size, str, options) {
	  var index = str.indexOf('=')

	  if (index === -1) {
	    return -2
	  }

	  // split the range string
	  var arr = str.slice(index + 1).split(',')
	  var ranges = []

	  // add ranges type
	  ranges.type = str.slice(0, index)

	  // parse all ranges
	  for (var i = 0; i < arr.length; i++) {
	    var range = arr[i].split('-')
	    var start = parseInt(range[0], 10)
	    var end = parseInt(range[1], 10)

	    // -nnn
	    if (isNaN(start)) {
	      start = size - end
	      end = size - 1
	    // nnn-
	    } else if (isNaN(end)) {
	      end = size - 1
	    }

	    // limit last-byte-pos to current length
	    if (end > size - 1) {
	      end = size - 1
	    }

	    // invalid or unsatisifiable
	    if (isNaN(start) || isNaN(end) || start > end || start < 0) {
	      continue
	    }

	    // add range
	    ranges.push({
	      start: start,
	      end: end
	    })
	  }

	  if (ranges.length < 1) {
	    // unsatisifiable
	    return -1
	  }

	  return options && options.combine
	    ? combineRanges(ranges)
	    : ranges
	}

	/**
	 * Combine overlapping & adjacent ranges.
	 * @private
	 */

	function combineRanges (ranges) {
	  var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart)

	  for (var j = 0, i = 1; i < ordered.length; i++) {
	    var range = ordered[i]
	    var current = ordered[j]

	    if (range.start > current.end + 1) {
	      // next range
	      ordered[++j] = range
	    } else if (range.end > current.end) {
	      // extend range
	      current.end = range.end
	      current.index = Math.min(current.index, range.index)
	    }
	  }

	  // trim ordered array
	  ordered.length = j + 1

	  // generate combined range
	  var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex)

	  // copy ranges type
	  combined.type = ranges.type

	  return combined
	}

	/**
	 * Map function to add index value to ranges.
	 * @private
	 */

	function mapWithIndex (range, index) {
	  return {
	    start: range.start,
	    end: range.end,
	    index: index
	  }
	}

	/**
	 * Map function to remove index value from ranges.
	 * @private
	 */

	function mapWithoutIndex (range) {
	  return {
	    start: range.start,
	    end: range.end
	  }
	}

	/**
	 * Sort function to sort ranges by index.
	 * @private
	 */

	function sortByRangeIndex (a, b) {
	  return a.index - b.index
	}

	/**
	 * Sort function to sort ranges by start position.
	 * @private
	 */

	function sortByRangeStart (a, b) {
	  return a.start - b.start
	}


/***/ },
/* 75 */
/*!*******************************!*\
  !*** ./~/proxy-addr/index.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * proxy-addr
	 * Copyright(c) 2014-2016 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict'

	/**
	 * Module exports.
	 */

	module.exports = proxyaddr;
	module.exports.all = alladdrs;
	module.exports.compile = compile;

	/**
	 * Module dependencies.
	 */

	var forwarded = __webpack_require__(/*! forwarded */ 76);
	var ipaddr = __webpack_require__(/*! ipaddr.js */ 77);

	/**
	 * Variables.
	 */

	var digitre = /^[0-9]+$/;
	var isip = ipaddr.isValid;
	var parseip = ipaddr.parse;

	/**
	 * Pre-defined IP ranges.
	 */

	var ipranges = {
	  linklocal: ['169.254.0.0/16', 'fe80::/10'],
	  loopback: ['127.0.0.1/8', '::1/128'],
	  uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']
	};

	/**
	 * Get all addresses in the request, optionally stopping
	 * at the first untrusted.
	 *
	 * @param {Object} request
	 * @param {Function|Array|String} [trust]
	 * @api public
	 */

	function alladdrs(req, trust) {
	  // get addresses
	  var addrs = forwarded(req);

	  if (!trust) {
	    // Return all addresses
	    return addrs;
	  }

	  if (typeof trust !== 'function') {
	    trust = compile(trust);
	  }

	  for (var i = 0; i < addrs.length - 1; i++) {
	    if (trust(addrs[i], i)) continue;

	    addrs.length = i + 1;
	  }

	  return addrs;
	}

	/**
	 * Compile argument into trust function.
	 *
	 * @param {Array|String} val
	 * @api private
	 */

	function compile(val) {
	  if (!val) {
	    throw new TypeError('argument is required');
	  }

	  var trust = typeof val === 'string'
	    ? [val]
	    : val;

	  if (!Array.isArray(trust)) {
	    throw new TypeError('unsupported trust argument');
	  }

	  for (var i = 0; i < trust.length; i++) {
	    val = trust[i];

	    if (!ipranges.hasOwnProperty(val)) {
	      continue;
	    }

	    // Splice in pre-defined range
	    val = ipranges[val];
	    trust.splice.apply(trust, [i, 1].concat(val));
	    i += val.length - 1;
	  }

	  return compileTrust(compileRangeSubnets(trust));
	}

	/**
	 * Compile `arr` elements into range subnets.
	 *
	 * @param {Array} arr
	 * @api private
	 */

	function compileRangeSubnets(arr) {
	  var rangeSubnets = new Array(arr.length);

	  for (var i = 0; i < arr.length; i++) {
	    rangeSubnets[i] = parseipNotation(arr[i]);
	  }

	  return rangeSubnets;
	}

	/**
	 * Compile range subnet array into trust function.
	 *
	 * @param {Array} rangeSubnets
	 * @api private
	 */

	function compileTrust(rangeSubnets) {
	  // Return optimized function based on length
	  var len = rangeSubnets.length;
	  return len === 0
	    ? trustNone
	    : len === 1
	    ? trustSingle(rangeSubnets[0])
	    : trustMulti(rangeSubnets);
	}

	/**
	 * Parse IP notation string into range subnet.
	 *
	 * @param {String} note
	 * @api private
	 */

	function parseipNotation(note) {
	  var pos = note.lastIndexOf('/');
	  var str = pos !== -1
	    ? note.substring(0, pos)
	    : note;

	  if (!isip(str)) {
	    throw new TypeError('invalid IP address: ' + str);
	  }

	  var ip = parseip(str);

	  if (pos === -1 && ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) {
	    // Store as IPv4
	    ip = ip.toIPv4Address();
	  }

	  var max = ip.kind() === 'ipv6'
	    ? 128
	    : 32;

	  var range = pos !== -1
	    ? note.substring(pos + 1, note.length)
	    : null;

	  if (range === null) {
	    range = max;
	  } else if (digitre.test(range)) {
	    range = parseInt(range, 10);
	  } else if (ip.kind() === 'ipv4' && isip(range)) {
	    range = parseNetmask(range);
	  } else {
	    range = null;
	  }

	  if (range <= 0 || range > max) {
	    throw new TypeError('invalid range on address: ' + note);
	  }

	  return [ip, range];
	}

	/**
	 * Parse netmask string into CIDR range.
	 *
	 * @param {String} netmask
	 * @api private
	 */

	function parseNetmask(netmask) {
	  var ip = parseip(netmask);
	  var kind = ip.kind();

	  return kind === 'ipv4'
	    ? ip.prefixLengthFromSubnetMask()
	    : null;
	}

	/**
	 * Determine address of proxied request.
	 *
	 * @param {Object} request
	 * @param {Function|Array|String} trust
	 * @api public
	 */

	function proxyaddr(req, trust) {
	  if (!req) {
	    throw new TypeError('req argument is required');
	  }

	  if (!trust) {
	    throw new TypeError('trust argument is required');
	  }

	  var addrs = alladdrs(req, trust);
	  var addr = addrs[addrs.length - 1];

	  return addr;
	}

	/**
	 * Static trust function to trust nothing.
	 *
	 * @api private
	 */

	function trustNone() {
	  return false;
	}

	/**
	 * Compile trust function for multiple subnets.
	 *
	 * @param {Array} subnets
	 * @api private
	 */

	function trustMulti(subnets) {
	  return function trust(addr) {
	    if (!isip(addr)) return false;

	    var ip = parseip(addr);
	    var ipconv;
	    var kind = ip.kind();

	    for (var i = 0; i < subnets.length; i++) {
	      var subnet = subnets[i];
	      var subnetip = subnet[0];
	      var subnetkind = subnetip.kind();
	      var subnetrange = subnet[1];
	      var trusted = ip;

	      if (kind !== subnetkind) {
	        if (subnetkind === 'ipv4' && !ip.isIPv4MappedAddress()) {
	          // Incompatible IP addresses
	          continue;
	        }

	        if (!ipconv) {
	          // Convert IP to match subnet IP kind
	          ipconv = subnetkind === 'ipv4'
	            ? ip.toIPv4Address()
	            : ip.toIPv4MappedAddress();
	        }

	        trusted = ipconv;
	      }

	      if (trusted.match(subnetip, subnetrange)) {
	        return true;
	      }
	    }

	    return false;
	  };
	}

	/**
	 * Compile trust function for single subnet.
	 *
	 * @param {Object} subnet
	 * @api private
	 */

	function trustSingle(subnet) {
	  var subnetip = subnet[0];
	  var subnetkind = subnetip.kind();
	  var subnetisipv4 = subnetkind === 'ipv4';
	  var subnetrange = subnet[1];

	  return function trust(addr) {
	    if (!isip(addr)) return false;

	    var ip = parseip(addr);
	    var kind = ip.kind();

	    if (kind !== subnetkind) {
	      if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
	        // Incompatible IP addresses
	        return false;
	      }

	      // Convert IP to match subnet IP kind
	      ip = subnetisipv4
	        ? ip.toIPv4Address()
	        : ip.toIPv4MappedAddress();
	    }

	    return ip.match(subnetip, subnetrange);
	  };
	}


/***/ },
/* 76 */
/*!******************************!*\
  !*** ./~/forwarded/index.js ***!
  \******************************/
/***/ function(module, exports) {

	/*!
	 * forwarded
	 * Copyright(c) 2014 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	/**
	 * Module exports.
	 */

	module.exports = forwarded

	/**
	 * Get all addresses in the request, using the `X-Forwarded-For` header.
	 *
	 * @param {Object} req
	 * @api public
	 */

	function forwarded(req) {
	  if (!req) {
	    throw new TypeError('argument req is required')
	  }

	  // simple header parsing
	  var proxyAddrs = (req.headers['x-forwarded-for'] || '')
	    .split(/ *, */)
	    .filter(Boolean)
	    .reverse()
	  var socketAddr = req.connection.remoteAddress
	  var addrs = [socketAddr].concat(proxyAddrs)

	  // return all addresses
	  return addrs
	}


/***/ },
/* 77 */
/*!***********************************!*\
  !*** ./~/ipaddr.js/lib/ipaddr.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {(function() {
	  var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root;

	  ipaddr = {};

	  root = this;

	  if ((typeof module !== "undefined" && module !== null) && module.exports) {
	    module.exports = ipaddr;
	  } else {
	    root['ipaddr'] = ipaddr;
	  }

	  matchCIDR = function(first, second, partSize, cidrBits) {
	    var part, shift;
	    if (first.length !== second.length) {
	      throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
	    }
	    part = 0;
	    while (cidrBits > 0) {
	      shift = partSize - cidrBits;
	      if (shift < 0) {
	        shift = 0;
	      }
	      if (first[part] >> shift !== second[part] >> shift) {
	        return false;
	      }
	      cidrBits -= partSize;
	      part += 1;
	    }
	    return true;
	  };

	  ipaddr.subnetMatch = function(address, rangeList, defaultName) {
	    var rangeName, rangeSubnets, subnet, _i, _len;
	    if (defaultName == null) {
	      defaultName = 'unicast';
	    }
	    for (rangeName in rangeList) {
	      rangeSubnets = rangeList[rangeName];
	      if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
	        rangeSubnets = [rangeSubnets];
	      }
	      for (_i = 0, _len = rangeSubnets.length; _i < _len; _i++) {
	        subnet = rangeSubnets[_i];
	        if (address.match.apply(address, subnet)) {
	          return rangeName;
	        }
	      }
	    }
	    return defaultName;
	  };

	  ipaddr.IPv4 = (function() {
	    function IPv4(octets) {
	      var octet, _i, _len;
	      if (octets.length !== 4) {
	        throw new Error("ipaddr: ipv4 octet count should be 4");
	      }
	      for (_i = 0, _len = octets.length; _i < _len; _i++) {
	        octet = octets[_i];
	        if (!((0 <= octet && octet <= 255))) {
	          throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
	        }
	      }
	      this.octets = octets;
	    }

	    IPv4.prototype.kind = function() {
	      return 'ipv4';
	    };

	    IPv4.prototype.toString = function() {
	      return this.octets.join(".");
	    };

	    IPv4.prototype.toByteArray = function() {
	      return this.octets.slice(0);
	    };

	    IPv4.prototype.match = function(other, cidrRange) {
	      var _ref;
	      if (cidrRange === void 0) {
	        _ref = other, other = _ref[0], cidrRange = _ref[1];
	      }
	      if (other.kind() !== 'ipv4') {
	        throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
	      }
	      return matchCIDR(this.octets, other.octets, 8, cidrRange);
	    };

	    IPv4.prototype.SpecialRanges = {
	      unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
	      broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
	      multicast: [[new IPv4([224, 0, 0, 0]), 4]],
	      linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
	      loopback: [[new IPv4([127, 0, 0, 0]), 8]],
	      "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
	      reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
	    };

	    IPv4.prototype.range = function() {
	      return ipaddr.subnetMatch(this, this.SpecialRanges);
	    };

	    IPv4.prototype.toIPv4MappedAddress = function() {
	      return ipaddr.IPv6.parse("::ffff:" + (this.toString()));
	    };

	    IPv4.prototype.prefixLengthFromSubnetMask = function() {
	      var cidr, i, octet, stop, zeros, zerotable, _i;
	      zerotable = {
	        0: 8,
	        128: 7,
	        192: 6,
	        224: 5,
	        240: 4,
	        248: 3,
	        252: 2,
	        254: 1,
	        255: 0
	      };
	      cidr = 0;
	      stop = false;
	      for (i = _i = 3; _i >= 0; i = _i += -1) {
	        octet = this.octets[i];
	        if (octet in zerotable) {
	          zeros = zerotable[octet];
	          if (stop && zeros !== 0) {
	            return null;
	          }
	          if (zeros !== 8) {
	            stop = true;
	          }
	          cidr += zeros;
	        } else {
	          return null;
	        }
	      }
	      return 32 - cidr;
	    };

	    return IPv4;

	  })();

	  ipv4Part = "(0?\\d+|0x[a-f0-9]+)";

	  ipv4Regexes = {
	    fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", 'i'),
	    longValue: new RegExp("^" + ipv4Part + "$", 'i')
	  };

	  ipaddr.IPv4.parser = function(string) {
	    var match, parseIntAuto, part, shift, value;
	    parseIntAuto = function(string) {
	      if (string[0] === "0" && string[1] !== "x") {
	        return parseInt(string, 8);
	      } else {
	        return parseInt(string);
	      }
	    };
	    if (match = string.match(ipv4Regexes.fourOctet)) {
	      return (function() {
	        var _i, _len, _ref, _results;
	        _ref = match.slice(1, 6);
	        _results = [];
	        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	          part = _ref[_i];
	          _results.push(parseIntAuto(part));
	        }
	        return _results;
	      })();
	    } else if (match = string.match(ipv4Regexes.longValue)) {
	      value = parseIntAuto(match[1]);
	      if (value > 0xffffffff || value < 0) {
	        throw new Error("ipaddr: address outside defined range");
	      }
	      return ((function() {
	        var _i, _results;
	        _results = [];
	        for (shift = _i = 0; _i <= 24; shift = _i += 8) {
	          _results.push((value >> shift) & 0xff);
	        }
	        return _results;
	      })()).reverse();
	    } else {
	      return null;
	    }
	  };

	  ipaddr.IPv6 = (function() {
	    function IPv6(parts) {
	      var i, part, _i, _j, _len, _ref;
	      if (parts.length === 16) {
	        this.parts = [];
	        for (i = _i = 0; _i <= 14; i = _i += 2) {
	          this.parts.push((parts[i] << 8) | parts[i + 1]);
	        }
	      } else if (parts.length === 8) {
	        this.parts = parts;
	      } else {
	        throw new Error("ipaddr: ipv6 part count should be 8 or 16");
	      }
	      _ref = this.parts;
	      for (_j = 0, _len = _ref.length; _j < _len; _j++) {
	        part = _ref[_j];
	        if (!((0 <= part && part <= 0xffff))) {
	          throw new Error("ipaddr: ipv6 part should fit in 16 bits");
	        }
	      }
	    }

	    IPv6.prototype.kind = function() {
	      return 'ipv6';
	    };

	    IPv6.prototype.toString = function() {
	      var compactStringParts, part, pushPart, state, stringParts, _i, _len;
	      stringParts = (function() {
	        var _i, _len, _ref, _results;
	        _ref = this.parts;
	        _results = [];
	        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	          part = _ref[_i];
	          _results.push(part.toString(16));
	        }
	        return _results;
	      }).call(this);
	      compactStringParts = [];
	      pushPart = function(part) {
	        return compactStringParts.push(part);
	      };
	      state = 0;
	      for (_i = 0, _len = stringParts.length; _i < _len; _i++) {
	        part = stringParts[_i];
	        switch (state) {
	          case 0:
	            if (part === '0') {
	              pushPart('');
	            } else {
	              pushPart(part);
	            }
	            state = 1;
	            break;
	          case 1:
	            if (part === '0') {
	              state = 2;
	            } else {
	              pushPart(part);
	            }
	            break;
	          case 2:
	            if (part !== '0') {
	              pushPart('');
	              pushPart(part);
	              state = 3;
	            }
	            break;
	          case 3:
	            pushPart(part);
	        }
	      }
	      if (state === 2) {
	        pushPart('');
	        pushPart('');
	      }
	      return compactStringParts.join(":");
	    };

	    IPv6.prototype.toByteArray = function() {
	      var bytes, part, _i, _len, _ref;
	      bytes = [];
	      _ref = this.parts;
	      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	        part = _ref[_i];
	        bytes.push(part >> 8);
	        bytes.push(part & 0xff);
	      }
	      return bytes;
	    };

	    IPv6.prototype.toNormalizedString = function() {
	      var part;
	      return ((function() {
	        var _i, _len, _ref, _results;
	        _ref = this.parts;
	        _results = [];
	        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	          part = _ref[_i];
	          _results.push(part.toString(16));
	        }
	        return _results;
	      }).call(this)).join(":");
	    };

	    IPv6.prototype.match = function(other, cidrRange) {
	      var _ref;
	      if (cidrRange === void 0) {
	        _ref = other, other = _ref[0], cidrRange = _ref[1];
	      }
	      if (other.kind() !== 'ipv6') {
	        throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
	      }
	      return matchCIDR(this.parts, other.parts, 16, cidrRange);
	    };

	    IPv6.prototype.SpecialRanges = {
	      unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
	      linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],
	      multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],
	      loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
	      uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],
	      ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],
	      rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],
	      rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],
	      '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],
	      teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],
	      reserved: [[new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32]]
	    };

	    IPv6.prototype.range = function() {
	      return ipaddr.subnetMatch(this, this.SpecialRanges);
	    };

	    IPv6.prototype.isIPv4MappedAddress = function() {
	      return this.range() === 'ipv4Mapped';
	    };

	    IPv6.prototype.toIPv4Address = function() {
	      var high, low, _ref;
	      if (!this.isIPv4MappedAddress()) {
	        throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
	      }
	      _ref = this.parts.slice(-2), high = _ref[0], low = _ref[1];
	      return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);
	    };

	    return IPv6;

	  })();

	  ipv6Part = "(?:[0-9a-f]+::?)+";

	  ipv6Regexes = {
	    "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?$", 'i'),
	    transitional: new RegExp(("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)") + ("" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$"), 'i')
	  };

	  expandIPv6 = function(string, parts) {
	    var colonCount, lastColon, part, replacement, replacementCount;
	    if (string.indexOf('::') !== string.lastIndexOf('::')) {
	      return null;
	    }
	    colonCount = 0;
	    lastColon = -1;
	    while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {
	      colonCount++;
	    }
	    if (string.substr(0, 2) === '::') {
	      colonCount--;
	    }
	    if (string.substr(-2, 2) === '::') {
	      colonCount--;
	    }
	    if (colonCount > parts) {
	      return null;
	    }
	    replacementCount = parts - colonCount;
	    replacement = ':';
	    while (replacementCount--) {
	      replacement += '0:';
	    }
	    string = string.replace('::', replacement);
	    if (string[0] === ':') {
	      string = string.slice(1);
	    }
	    if (string[string.length - 1] === ':') {
	      string = string.slice(0, -1);
	    }
	    return (function() {
	      var _i, _len, _ref, _results;
	      _ref = string.split(":");
	      _results = [];
	      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	        part = _ref[_i];
	        _results.push(parseInt(part, 16));
	      }
	      return _results;
	    })();
	  };

	  ipaddr.IPv6.parser = function(string) {
	    var match, octet, octets, parts, _i, _len;
	    if (string.match(ipv6Regexes['native'])) {
	      return expandIPv6(string, 8);
	    } else if (match = string.match(ipv6Regexes['transitional'])) {
	      parts = expandIPv6(match[1].slice(0, -1), 6);
	      if (parts) {
	        octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];
	        for (_i = 0, _len = octets.length; _i < _len; _i++) {
	          octet = octets[_i];
	          if (!((0 <= octet && octet <= 255))) {
	            return null;
	          }
	        }
	        parts.push(octets[0] << 8 | octets[1]);
	        parts.push(octets[2] << 8 | octets[3]);
	        return parts;
	      }
	    }
	    return null;
	  };

	  ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string) {
	    return this.parser(string) !== null;
	  };

	  ipaddr.IPv4.isValid = function(string) {
	    var e;
	    try {
	      new this(this.parser(string));
	      return true;
	    } catch (_error) {
	      e = _error;
	      return false;
	    }
	  };

	  ipaddr.IPv6.isValid = function(string) {
	    var e;
	    if (typeof string === "string" && string.indexOf(":") === -1) {
	      return false;
	    }
	    try {
	      new this(this.parser(string));
	      return true;
	    } catch (_error) {
	      e = _error;
	      return false;
	    }
	  };

	  ipaddr.IPv4.parse = ipaddr.IPv6.parse = function(string) {
	    var parts;
	    parts = this.parser(string);
	    if (parts === null) {
	      throw new Error("ipaddr: string is not formatted like ip address");
	    }
	    return new this(parts);
	  };

	  ipaddr.IPv4.parseCIDR = function(string) {
	    var maskLength, match;
	    if (match = string.match(/^(.+)\/(\d+)$/)) {
	      maskLength = parseInt(match[2]);
	      if (maskLength >= 0 && maskLength <= 32) {
	        return [this.parse(match[1]), maskLength];
	      }
	    }
	    throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
	  };

	  ipaddr.IPv6.parseCIDR = function(string) {
	    var maskLength, match;
	    if (match = string.match(/^(.+)\/(\d+)$/)) {
	      maskLength = parseInt(match[2]);
	      if (maskLength >= 0 && maskLength <= 128) {
	        return [this.parse(match[1]), maskLength];
	      }
	    }
	    throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
	  };

	  ipaddr.isValid = function(string) {
	    return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
	  };

	  ipaddr.parse = function(string) {
	    if (ipaddr.IPv6.isValid(string)) {
	      return ipaddr.IPv6.parse(string);
	    } else if (ipaddr.IPv4.isValid(string)) {
	      return ipaddr.IPv4.parse(string);
	    } else {
	      throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
	    }
	  };

	  ipaddr.parseCIDR = function(string) {
	    var e;
	    try {
	      return ipaddr.IPv6.parseCIDR(string);
	    } catch (_error) {
	      e = _error;
	      try {
	        return ipaddr.IPv4.parseCIDR(string);
	      } catch (_error) {
	        e = _error;
	        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
	      }
	    }
	  };

	  ipaddr.fromByteArray = function(bytes) {
	    var length;
	    length = bytes.length;
	    if (length === 4) {
	      return new ipaddr.IPv4(bytes);
	    } else if (length === 16) {
	      return new ipaddr.IPv6(bytes);
	    } else {
	      throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
	    }
	  };

	  ipaddr.process = function(string) {
	    var addr;
	    addr = this.parse(string);
	    if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {
	      return addr.toIPv4Address();
	    } else {
	      return addr;
	    }
	  };

	}).call(this);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../../webpack/buildin/module.js */ 78)(module)))

/***/ },
/* 78 */
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 79 */
/*!******************************!*\
  !*** external "querystring" ***!
  \******************************/
/***/ function(module, exports) {

	module.exports = require("querystring");

/***/ },
/* 80 */
/*!********************************!*\
  !*** ./~/express/lib ^\.\/.*$ ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./application": 28,
		"./application.js": 28,
		"./express": 25,
		"./express.js": 25,
		"./middleware/init": 52,
		"./middleware/init.js": 52,
		"./middleware/query": 53,
		"./middleware/query.js": 53,
		"./request": 81,
		"./request.js": 81,
		"./response": 84,
		"./response.js": 84,
		"./router/index": 36,
		"./router/index.js": 36,
		"./router/layer": 39,
		"./router/layer.js": 39,
		"./router/route": 37,
		"./router/route.js": 37,
		"./utils": 59,
		"./utils.js": 59,
		"./view": 58,
		"./view.js": 58
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 80;


/***/ },
/* 81 */
/*!**********************************!*\
  !*** ./~/express/lib/request.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2013 Roman Shtylman
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @private
	 */

	var accepts = __webpack_require__(/*! accepts */ 2);
	var deprecate = __webpack_require__(/*! depd */ 44)('express');
	var isIP = __webpack_require__(/*! net */ 20).isIP;
	var typeis = __webpack_require__(/*! type-is */ 82);
	var http = __webpack_require__(/*! http */ 42);
	var fresh = __webpack_require__(/*! fresh */ 71);
	var parseRange = __webpack_require__(/*! range-parser */ 74);
	var parse = __webpack_require__(/*! parseurl */ 50);
	var proxyaddr = __webpack_require__(/*! proxy-addr */ 75);

	/**
	 * Request prototype.
	 */

	var req = exports = module.exports = {
	  __proto__: http.IncomingMessage.prototype
	};

	/**
	 * Return request header.
	 *
	 * The `Referrer` header field is special-cased,
	 * both `Referrer` and `Referer` are interchangeable.
	 *
	 * Examples:
	 *
	 *     req.get('Content-Type');
	 *     // => "text/plain"
	 *
	 *     req.get('content-type');
	 *     // => "text/plain"
	 *
	 *     req.get('Something');
	 *     // => undefined
	 *
	 * Aliased as `req.header()`.
	 *
	 * @param {String} name
	 * @return {String}
	 * @public
	 */

	req.get =
	req.header = function header(name) {
	  if (!name) {
	    throw new TypeError('name argument is required to req.get');
	  }

	  if (typeof name !== 'string') {
	    throw new TypeError('name must be a string to req.get');
	  }

	  var lc = name.toLowerCase();

	  switch (lc) {
	    case 'referer':
	    case 'referrer':
	      return this.headers.referrer
	        || this.headers.referer;
	    default:
	      return this.headers[lc];
	  }
	};

	/**
	 * To do: update docs.
	 *
	 * Check if the given `type(s)` is acceptable, returning
	 * the best match when true, otherwise `undefined`, in which
	 * case you should respond with 406 "Not Acceptable".
	 *
	 * The `type` value may be a single MIME type string
	 * such as "application/json", an extension name
	 * such as "json", a comma-delimited list such as "json, html, text/plain",
	 * an argument list such as `"json", "html", "text/plain"`,
	 * or an array `["json", "html", "text/plain"]`. When a list
	 * or array is given, the _best_ match, if any is returned.
	 *
	 * Examples:
	 *
	 *     // Accept: text/html
	 *     req.accepts('html');
	 *     // => "html"
	 *
	 *     // Accept: text/*, application/json
	 *     req.accepts('html');
	 *     // => "html"
	 *     req.accepts('text/html');
	 *     // => "text/html"
	 *     req.accepts('json, text');
	 *     // => "json"
	 *     req.accepts('application/json');
	 *     // => "application/json"
	 *
	 *     // Accept: text/*, application/json
	 *     req.accepts('image/png');
	 *     req.accepts('png');
	 *     // => undefined
	 *
	 *     // Accept: text/*;q=.5, application/json
	 *     req.accepts(['html', 'json']);
	 *     req.accepts('html', 'json');
	 *     req.accepts('html, json');
	 *     // => "json"
	 *
	 * @param {String|Array} type(s)
	 * @return {String|Array|Boolean}
	 * @public
	 */

	req.accepts = function(){
	  var accept = accepts(this);
	  return accept.types.apply(accept, arguments);
	};

	/**
	 * Check if the given `encoding`s are accepted.
	 *
	 * @param {String} ...encoding
	 * @return {String|Array}
	 * @public
	 */

	req.acceptsEncodings = function(){
	  var accept = accepts(this);
	  return accept.encodings.apply(accept, arguments);
	};

	req.acceptsEncoding = deprecate.function(req.acceptsEncodings,
	  'req.acceptsEncoding: Use acceptsEncodings instead');

	/**
	 * Check if the given `charset`s are acceptable,
	 * otherwise you should respond with 406 "Not Acceptable".
	 *
	 * @param {String} ...charset
	 * @return {String|Array}
	 * @public
	 */

	req.acceptsCharsets = function(){
	  var accept = accepts(this);
	  return accept.charsets.apply(accept, arguments);
	};

	req.acceptsCharset = deprecate.function(req.acceptsCharsets,
	  'req.acceptsCharset: Use acceptsCharsets instead');

	/**
	 * Check if the given `lang`s are acceptable,
	 * otherwise you should respond with 406 "Not Acceptable".
	 *
	 * @param {String} ...lang
	 * @return {String|Array}
	 * @public
	 */

	req.acceptsLanguages = function(){
	  var accept = accepts(this);
	  return accept.languages.apply(accept, arguments);
	};

	req.acceptsLanguage = deprecate.function(req.acceptsLanguages,
	  'req.acceptsLanguage: Use acceptsLanguages instead');

	/**
	 * Parse Range header field, capping to the given `size`.
	 *
	 * Unspecified ranges such as "0-" require knowledge of your resource length. In
	 * the case of a byte range this is of course the total number of bytes. If the
	 * Range header field is not given `undefined` is returned, `-1` when unsatisfiable,
	 * and `-2` when syntactically invalid.
	 *
	 * When ranges are returned, the array has a "type" property which is the type of
	 * range that is required (most commonly, "bytes"). Each array element is an object
	 * with a "start" and "end" property for the portion of the range.
	 *
	 * The "combine" option can be set to `true` and overlapping & adjacent ranges
	 * will be combined into a single range.
	 *
	 * NOTE: remember that ranges are inclusive, so for example "Range: users=0-3"
	 * should respond with 4 users when available, not 3.
	 *
	 * @param {number} size
	 * @param {object} [options]
	 * @param {boolean} [options.combine=false]
	 * @return {number|array}
	 * @public
	 */

	req.range = function range(size, options) {
	  var range = this.get('Range');
	  if (!range) return;
	  return parseRange(size, range, options);
	};

	/**
	 * Return the value of param `name` when present or `defaultValue`.
	 *
	 *  - Checks route placeholders, ex: _/user/:id_
	 *  - Checks body params, ex: id=12, {"id":12}
	 *  - Checks query string params, ex: ?id=12
	 *
	 * To utilize request bodies, `req.body`
	 * should be an object. This can be done by using
	 * the `bodyParser()` middleware.
	 *
	 * @param {String} name
	 * @param {Mixed} [defaultValue]
	 * @return {String}
	 * @public
	 */

	req.param = function param(name, defaultValue) {
	  var params = this.params || {};
	  var body = this.body || {};
	  var query = this.query || {};

	  var args = arguments.length === 1
	    ? 'name'
	    : 'name, default';
	  deprecate('req.param(' + args + '): Use req.params, req.body, or req.query instead');

	  if (null != params[name] && params.hasOwnProperty(name)) return params[name];
	  if (null != body[name]) return body[name];
	  if (null != query[name]) return query[name];

	  return defaultValue;
	};

	/**
	 * Check if the incoming request contains the "Content-Type"
	 * header field, and it contains the give mime `type`.
	 *
	 * Examples:
	 *
	 *      // With Content-Type: text/html; charset=utf-8
	 *      req.is('html');
	 *      req.is('text/html');
	 *      req.is('text/*');
	 *      // => true
	 *
	 *      // When Content-Type is application/json
	 *      req.is('json');
	 *      req.is('application/json');
	 *      req.is('application/*');
	 *      // => true
	 *
	 *      req.is('html');
	 *      // => false
	 *
	 * @param {String|Array} types...
	 * @return {String|false|null}
	 * @public
	 */

	req.is = function is(types) {
	  var arr = types;

	  // support flattened arguments
	  if (!Array.isArray(types)) {
	    arr = new Array(arguments.length);
	    for (var i = 0; i < arr.length; i++) {
	      arr[i] = arguments[i];
	    }
	  }

	  return typeis(this, arr);
	};

	/**
	 * Return the protocol string "http" or "https"
	 * when requested with TLS. When the "trust proxy"
	 * setting trusts the socket address, the
	 * "X-Forwarded-Proto" header field will be trusted
	 * and used if present.
	 *
	 * If you're running behind a reverse proxy that
	 * supplies https for you this may be enabled.
	 *
	 * @return {String}
	 * @public
	 */

	defineGetter(req, 'protocol', function protocol(){
	  var proto = this.connection.encrypted
	    ? 'https'
	    : 'http';
	  var trust = this.app.get('trust proxy fn');

	  if (!trust(this.connection.remoteAddress, 0)) {
	    return proto;
	  }

	  // Note: X-Forwarded-Proto is normally only ever a
	  //       single value, but this is to be safe.
	  proto = this.get('X-Forwarded-Proto') || proto;
	  return proto.split(/\s*,\s*/)[0];
	});

	/**
	 * Short-hand for:
	 *
	 *    req.protocol === 'https'
	 *
	 * @return {Boolean}
	 * @public
	 */

	defineGetter(req, 'secure', function secure(){
	  return this.protocol === 'https';
	});

	/**
	 * Return the remote address from the trusted proxy.
	 *
	 * The is the remote address on the socket unless
	 * "trust proxy" is set.
	 *
	 * @return {String}
	 * @public
	 */

	defineGetter(req, 'ip', function ip(){
	  var trust = this.app.get('trust proxy fn');
	  return proxyaddr(this, trust);
	});

	/**
	 * When "trust proxy" is set, trusted proxy addresses + client.
	 *
	 * For example if the value were "client, proxy1, proxy2"
	 * you would receive the array `["client", "proxy1", "proxy2"]`
	 * where "proxy2" is the furthest down-stream and "proxy1" and
	 * "proxy2" were trusted.
	 *
	 * @return {Array}
	 * @public
	 */

	defineGetter(req, 'ips', function ips() {
	  var trust = this.app.get('trust proxy fn');
	  var addrs = proxyaddr.all(this, trust);
	  return addrs.slice(1).reverse();
	});

	/**
	 * Return subdomains as an array.
	 *
	 * Subdomains are the dot-separated parts of the host before the main domain of
	 * the app. By default, the domain of the app is assumed to be the last two
	 * parts of the host. This can be changed by setting "subdomain offset".
	 *
	 * For example, if the domain is "tobi.ferrets.example.com":
	 * If "subdomain offset" is not set, req.subdomains is `["ferrets", "tobi"]`.
	 * If "subdomain offset" is 3, req.subdomains is `["tobi"]`.
	 *
	 * @return {Array}
	 * @public
	 */

	defineGetter(req, 'subdomains', function subdomains() {
	  var hostname = this.hostname;

	  if (!hostname) return [];

	  var offset = this.app.get('subdomain offset');
	  var subdomains = !isIP(hostname)
	    ? hostname.split('.').reverse()
	    : [hostname];

	  return subdomains.slice(offset);
	});

	/**
	 * Short-hand for `url.parse(req.url).pathname`.
	 *
	 * @return {String}
	 * @public
	 */

	defineGetter(req, 'path', function path() {
	  return parse(this).pathname;
	});

	/**
	 * Parse the "Host" header field to a hostname.
	 *
	 * When the "trust proxy" setting trusts the socket
	 * address, the "X-Forwarded-Host" header field will
	 * be trusted.
	 *
	 * @return {String}
	 * @public
	 */

	defineGetter(req, 'hostname', function hostname(){
	  var trust = this.app.get('trust proxy fn');
	  var host = this.get('X-Forwarded-Host');

	  if (!host || !trust(this.connection.remoteAddress, 0)) {
	    host = this.get('Host');
	  }

	  if (!host) return;

	  // IPv6 literal support
	  var offset = host[0] === '['
	    ? host.indexOf(']') + 1
	    : 0;
	  var index = host.indexOf(':', offset);

	  return index !== -1
	    ? host.substring(0, index)
	    : host;
	});

	// TODO: change req.host to return host in next major

	defineGetter(req, 'host', deprecate.function(function host(){
	  return this.hostname;
	}, 'req.host: Use req.hostname instead'));

	/**
	 * Check if the request is fresh, aka
	 * Last-Modified and/or the ETag
	 * still match.
	 *
	 * @return {Boolean}
	 * @public
	 */

	defineGetter(req, 'fresh', function(){
	  var method = this.method;
	  var s = this.res.statusCode;

	  // GET or HEAD for weak freshness validation only
	  if ('GET' !== method && 'HEAD' !== method) return false;

	  // 2xx or 304 as per rfc2616 14.26
	  if ((s >= 200 && s < 300) || 304 === s) {
	    return fresh(this.headers, (this.res._headers || {}));
	  }

	  return false;
	});

	/**
	 * Check if the request is stale, aka
	 * "Last-Modified" and / or the "ETag" for the
	 * resource has changed.
	 *
	 * @return {Boolean}
	 * @public
	 */

	defineGetter(req, 'stale', function stale(){
	  return !this.fresh;
	});

	/**
	 * Check if the request was an _XMLHttpRequest_.
	 *
	 * @return {Boolean}
	 * @public
	 */

	defineGetter(req, 'xhr', function xhr(){
	  var val = this.get('X-Requested-With') || '';
	  return val.toLowerCase() === 'xmlhttprequest';
	});

	/**
	 * Helper function for creating a getter on an object.
	 *
	 * @param {Object} obj
	 * @param {String} name
	 * @param {Function} getter
	 * @private
	 */
	function defineGetter(obj, name, getter) {
	  Object.defineProperty(obj, name, {
	    configurable: true,
	    enumerable: true,
	    get: getter
	  });
	};


/***/ },
/* 82 */
/*!****************************!*\
  !*** ./~/type-is/index.js ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * type-is
	 * Copyright(c) 2014 Jonathan Ong
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict'

	/**
	 * Module dependencies.
	 * @private
	 */

	var typer = __webpack_require__(/*! media-typer */ 83)
	var mime = __webpack_require__(/*! mime-types */ 8)

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = typeofrequest
	module.exports.is = typeis
	module.exports.hasBody = hasbody
	module.exports.normalize = normalize
	module.exports.match = mimeMatch

	/**
	 * Compare a `value` content-type with `types`.
	 * Each `type` can be an extension like `html`,
	 * a special shortcut like `multipart` or `urlencoded`,
	 * or a mime type.
	 *
	 * If no types match, `false` is returned.
	 * Otherwise, the first `type` that matches is returned.
	 *
	 * @param {String} value
	 * @param {Array} types
	 * @public
	 */

	function typeis (value, types_) {
	  var i
	  var types = types_

	  // remove parameters and normalize
	  var val = tryNormalizeType(value)

	  // no type or invalid
	  if (!val) {
	    return false
	  }

	  // support flattened arguments
	  if (types && !Array.isArray(types)) {
	    types = new Array(arguments.length - 1)
	    for (i = 0; i < types.length; i++) {
	      types[i] = arguments[i + 1]
	    }
	  }

	  // no types, return the content type
	  if (!types || !types.length) {
	    return val
	  }

	  var type
	  for (i = 0; i < types.length; i++) {
	    if (mimeMatch(normalize(type = types[i]), val)) {
	      return type[0] === '+' || type.indexOf('*') !== -1
	        ? val
	        : type
	    }
	  }

	  // no matches
	  return false
	}

	/**
	 * Check if a request has a request body.
	 * A request with a body __must__ either have `transfer-encoding`
	 * or `content-length` headers set.
	 * http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3
	 *
	 * @param {Object} request
	 * @return {Boolean}
	 * @public
	 */

	function hasbody (req) {
	  return req.headers['transfer-encoding'] !== undefined ||
	    !isNaN(req.headers['content-length'])
	}

	/**
	 * Check if the incoming request contains the "Content-Type"
	 * header field, and it contains any of the give mime `type`s.
	 * If there is no request body, `null` is returned.
	 * If there is no content type, `false` is returned.
	 * Otherwise, it returns the first `type` that matches.
	 *
	 * Examples:
	 *
	 *     // With Content-Type: text/html; charset=utf-8
	 *     this.is('html'); // => 'html'
	 *     this.is('text/html'); // => 'text/html'
	 *     this.is('text/*', 'application/json'); // => 'text/html'
	 *
	 *     // When Content-Type is application/json
	 *     this.is('json', 'urlencoded'); // => 'json'
	 *     this.is('application/json'); // => 'application/json'
	 *     this.is('html', 'application/*'); // => 'application/json'
	 *
	 *     this.is('html'); // => false
	 *
	 * @param {String|Array} types...
	 * @return {String|false|null}
	 * @public
	 */

	function typeofrequest (req, types_) {
	  var types = types_

	  // no body
	  if (!hasbody(req)) {
	    return null
	  }

	  // support flattened arguments
	  if (arguments.length > 2) {
	    types = new Array(arguments.length - 1)
	    for (var i = 0; i < types.length; i++) {
	      types[i] = arguments[i + 1]
	    }
	  }

	  // request content type
	  var value = req.headers['content-type']

	  return typeis(value, types)
	}

	/**
	 * Normalize a mime type.
	 * If it's a shorthand, expand it to a valid mime type.
	 *
	 * In general, you probably want:
	 *
	 *   var type = is(req, ['urlencoded', 'json', 'multipart']);
	 *
	 * Then use the appropriate body parsers.
	 * These three are the most common request body types
	 * and are thus ensured to work.
	 *
	 * @param {String} type
	 * @private
	 */

	function normalize (type) {
	  if (typeof type !== 'string') {
	    // invalid type
	    return false
	  }

	  switch (type) {
	    case 'urlencoded':
	      return 'application/x-www-form-urlencoded'
	    case 'multipart':
	      return 'multipart/*'
	  }

	  if (type[0] === '+') {
	    // "+json" -> "*/*+json" expando
	    return '*/*' + type
	  }

	  return type.indexOf('/') === -1
	    ? mime.lookup(type)
	    : type
	}

	/**
	 * Check if `expected` mime type
	 * matches `actual` mime type with
	 * wildcard and +suffix support.
	 *
	 * @param {String} expected
	 * @param {String} actual
	 * @return {Boolean}
	 * @private
	 */

	function mimeMatch (expected, actual) {
	  // invalid type
	  if (expected === false) {
	    return false
	  }

	  // split types
	  var actualParts = actual.split('/')
	  var expectedParts = expected.split('/')

	  // invalid format
	  if (actualParts.length !== 2 || expectedParts.length !== 2) {
	    return false
	  }

	  // validate type
	  if (expectedParts[0] !== '*' && expectedParts[0] !== actualParts[0]) {
	    return false
	  }

	  // validate suffix wildcard
	  if (expectedParts[1].substr(0, 2) === '*+') {
	    return expectedParts[1].length <= actualParts[1].length + 1 &&
	      expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length)
	  }

	  // validate subtype
	  if (expectedParts[1] !== '*' && expectedParts[1] !== actualParts[1]) {
	    return false
	  }

	  return true
	}

	/**
	 * Normalize a type and remove parameters.
	 *
	 * @param {string} value
	 * @return {string}
	 * @private
	 */

	function normalizeType (value) {
	  // parse the type
	  var type = typer.parse(value)

	  // remove the parameters
	  type.parameters = undefined

	  // reformat it
	  return typer.format(type)
	}

	/**
	 * Try to normalize a type and remove parameters.
	 *
	 * @param {string} value
	 * @return {string}
	 * @private
	 */

	function tryNormalizeType (value) {
	  try {
	    return normalizeType(value)
	  } catch (err) {
	    return null
	  }
	}


/***/ },
/* 83 */
/*!********************************!*\
  !*** ./~/media-typer/index.js ***!
  \********************************/
/***/ function(module, exports) {

	/*!
	 * media-typer
	 * Copyright(c) 2014 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	/**
	 * RegExp to match *( ";" parameter ) in RFC 2616 sec 3.7
	 *
	 * parameter     = token "=" ( token | quoted-string )
	 * token         = 1*<any CHAR except CTLs or separators>
	 * separators    = "(" | ")" | "<" | ">" | "@"
	 *               | "," | ";" | ":" | "\" | <">
	 *               | "/" | "[" | "]" | "?" | "="
	 *               | "{" | "}" | SP | HT
	 * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
	 * qdtext        = <any TEXT except <">>
	 * quoted-pair   = "\" CHAR
	 * CHAR          = <any US-ASCII character (octets 0 - 127)>
	 * TEXT          = <any OCTET except CTLs, but including LWS>
	 * LWS           = [CRLF] 1*( SP | HT )
	 * CRLF          = CR LF
	 * CR            = <US-ASCII CR, carriage return (13)>
	 * LF            = <US-ASCII LF, linefeed (10)>
	 * SP            = <US-ASCII SP, space (32)>
	 * SHT           = <US-ASCII HT, horizontal-tab (9)>
	 * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
	 * OCTET         = <any 8-bit sequence of data>
	 */
	var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
	var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/
	var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/

	/**
	 * RegExp to match quoted-pair in RFC 2616
	 *
	 * quoted-pair = "\" CHAR
	 * CHAR        = <any US-ASCII character (octets 0 - 127)>
	 */
	var qescRegExp = /\\([\u0000-\u007f])/g;

	/**
	 * RegExp to match chars that must be quoted-pair in RFC 2616
	 */
	var quoteRegExp = /([\\"])/g;

	/**
	 * RegExp to match type in RFC 6838
	 *
	 * type-name = restricted-name
	 * subtype-name = restricted-name
	 * restricted-name = restricted-name-first *126restricted-name-chars
	 * restricted-name-first  = ALPHA / DIGIT
	 * restricted-name-chars  = ALPHA / DIGIT / "!" / "#" /
	 *                          "$" / "&" / "-" / "^" / "_"
	 * restricted-name-chars =/ "." ; Characters before first dot always
	 *                              ; specify a facet name
	 * restricted-name-chars =/ "+" ; Characters after last plus always
	 *                              ; specify a structured syntax suffix
	 * ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z
	 * DIGIT =  %x30-39             ; 0-9
	 */
	var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/
	var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/
	var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;

	/**
	 * Module exports.
	 */

	exports.format = format
	exports.parse = parse

	/**
	 * Format object to media type.
	 *
	 * @param {object} obj
	 * @return {string}
	 * @api public
	 */

	function format(obj) {
	  if (!obj || typeof obj !== 'object') {
	    throw new TypeError('argument obj is required')
	  }

	  var parameters = obj.parameters
	  var subtype = obj.subtype
	  var suffix = obj.suffix
	  var type = obj.type

	  if (!type || !typeNameRegExp.test(type)) {
	    throw new TypeError('invalid type')
	  }

	  if (!subtype || !subtypeNameRegExp.test(subtype)) {
	    throw new TypeError('invalid subtype')
	  }

	  // format as type/subtype
	  var string = type + '/' + subtype

	  // append +suffix
	  if (suffix) {
	    if (!typeNameRegExp.test(suffix)) {
	      throw new TypeError('invalid suffix')
	    }

	    string += '+' + suffix
	  }

	  // append parameters
	  if (parameters && typeof parameters === 'object') {
	    var param
	    var params = Object.keys(parameters).sort()

	    for (var i = 0; i < params.length; i++) {
	      param = params[i]

	      if (!tokenRegExp.test(param)) {
	        throw new TypeError('invalid parameter name')
	      }

	      string += '; ' + param + '=' + qstring(parameters[param])
	    }
	  }

	  return string
	}

	/**
	 * Parse media type to object.
	 *
	 * @param {string|object} string
	 * @return {Object}
	 * @api public
	 */

	function parse(string) {
	  if (!string) {
	    throw new TypeError('argument string is required')
	  }

	  // support req/res-like objects as argument
	  if (typeof string === 'object') {
	    string = getcontenttype(string)
	  }

	  if (typeof string !== 'string') {
	    throw new TypeError('argument string is required to be a string')
	  }

	  var index = string.indexOf(';')
	  var type = index !== -1
	    ? string.substr(0, index)
	    : string

	  var key
	  var match
	  var obj = splitType(type)
	  var params = {}
	  var value

	  paramRegExp.lastIndex = index

	  while (match = paramRegExp.exec(string)) {
	    if (match.index !== index) {
	      throw new TypeError('invalid parameter format')
	    }

	    index += match[0].length
	    key = match[1].toLowerCase()
	    value = match[2]

	    if (value[0] === '"') {
	      // remove quotes and escapes
	      value = value
	        .substr(1, value.length - 2)
	        .replace(qescRegExp, '$1')
	    }

	    params[key] = value
	  }

	  if (index !== -1 && index !== string.length) {
	    throw new TypeError('invalid parameter format')
	  }

	  obj.parameters = params

	  return obj
	}

	/**
	 * Get content-type from req/res objects.
	 *
	 * @param {object}
	 * @return {Object}
	 * @api private
	 */

	function getcontenttype(obj) {
	  if (typeof obj.getHeader === 'function') {
	    // res-like
	    return obj.getHeader('content-type')
	  }

	  if (typeof obj.headers === 'object') {
	    // req-like
	    return obj.headers && obj.headers['content-type']
	  }
	}

	/**
	 * Quote a string if necessary.
	 *
	 * @param {string} val
	 * @return {string}
	 * @api private
	 */

	function qstring(val) {
	  var str = String(val)

	  // no need to quote tokens
	  if (tokenRegExp.test(str)) {
	    return str
	  }

	  if (str.length > 0 && !textRegExp.test(str)) {
	    throw new TypeError('invalid parameter value')
	  }

	  return '"' + str.replace(quoteRegExp, '\\$1') + '"'
	}

	/**
	 * Simply "type/subtype+siffx" into parts.
	 *
	 * @param {string} string
	 * @return {Object}
	 * @api private
	 */

	function splitType(string) {
	  var match = typeRegExp.exec(string.toLowerCase())

	  if (!match) {
	    throw new TypeError('invalid media type')
	  }

	  var type = match[1]
	  var subtype = match[2]
	  var suffix

	  // suffix after last +
	  var index = subtype.lastIndexOf('+')
	  if (index !== -1) {
	    suffix = subtype.substr(index + 1)
	    subtype = subtype.substr(0, index)
	  }

	  var obj = {
	    type: type,
	    subtype: subtype,
	    suffix: suffix
	  }

	  return obj
	}


/***/ },
/* 84 */
/*!***********************************!*\
  !*** ./~/express/lib/response.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * express
	 * Copyright(c) 2009-2013 TJ Holowaychuk
	 * Copyright(c) 2014-2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module dependencies.
	 * @private
	 */

	var contentDisposition = __webpack_require__(/*! content-disposition */ 60);
	var deprecate = __webpack_require__(/*! depd */ 44)('express');
	var encodeUrl = __webpack_require__(/*! encodeurl */ 68);
	var escapeHtml = __webpack_require__(/*! escape-html */ 30);
	var http = __webpack_require__(/*! http */ 42);
	var isAbsolute = __webpack_require__(/*! ./utils */ 59).isAbsolute;
	var onFinished = __webpack_require__(/*! on-finished */ 31);
	var path = __webpack_require__(/*! path */ 11);
	var merge = __webpack_require__(/*! utils-merge */ 43);
	var sign = __webpack_require__(/*! cookie-signature */ 85).sign;
	var normalizeType = __webpack_require__(/*! ./utils */ 59).normalizeType;
	var normalizeTypes = __webpack_require__(/*! ./utils */ 59).normalizeTypes;
	var setCharset = __webpack_require__(/*! ./utils */ 59).setCharset;
	var statusCodes = http.STATUS_CODES;
	var cookie = __webpack_require__(/*! cookie */ 86);
	var send = __webpack_require__(/*! send */ 62);
	var extname = path.extname;
	var mime = send.mime;
	var resolve = path.resolve;
	var vary = __webpack_require__(/*! vary */ 22);

	/**
	 * Response prototype.
	 */

	var res = module.exports = {
	  __proto__: http.ServerResponse.prototype
	};

	/**
	 * Module variables.
	 * @private
	 */

	var charsetRegExp = /;\s*charset\s*=/;

	/**
	 * Set status `code`.
	 *
	 * @param {Number} code
	 * @return {ServerResponse}
	 * @public
	 */

	res.status = function status(code) {
	  this.statusCode = code;
	  return this;
	};

	/**
	 * Set Link header field with the given `links`.
	 *
	 * Examples:
	 *
	 *    res.links({
	 *      next: 'http://api.example.com/users?page=2',
	 *      last: 'http://api.example.com/users?page=5'
	 *    });
	 *
	 * @param {Object} links
	 * @return {ServerResponse}
	 * @public
	 */

	res.links = function(links){
	  var link = this.get('Link') || '';
	  if (link) link += ', ';
	  return this.set('Link', link + Object.keys(links).map(function(rel){
	    return '<' + links[rel] + '>; rel="' + rel + '"';
	  }).join(', '));
	};

	/**
	 * Send a response.
	 *
	 * Examples:
	 *
	 *     res.send(new Buffer('wahoo'));
	 *     res.send({ some: 'json' });
	 *     res.send('<p>some html</p>');
	 *
	 * @param {string|number|boolean|object|Buffer} body
	 * @public
	 */

	res.send = function send(body) {
	  var chunk = body;
	  var encoding;
	  var len;
	  var req = this.req;
	  var type;

	  // settings
	  var app = this.app;

	  // allow status / body
	  if (arguments.length === 2) {
	    // res.send(body, status) backwards compat
	    if (typeof arguments[0] !== 'number' && typeof arguments[1] === 'number') {
	      deprecate('res.send(body, status): Use res.status(status).send(body) instead');
	      this.statusCode = arguments[1];
	    } else {
	      deprecate('res.send(status, body): Use res.status(status).send(body) instead');
	      this.statusCode = arguments[0];
	      chunk = arguments[1];
	    }
	  }

	  // disambiguate res.send(status) and res.send(status, num)
	  if (typeof chunk === 'number' && arguments.length === 1) {
	    // res.send(status) will set status message as text string
	    if (!this.get('Content-Type')) {
	      this.type('txt');
	    }

	    deprecate('res.send(status): Use res.sendStatus(status) instead');
	    this.statusCode = chunk;
	    chunk = statusCodes[chunk];
	  }

	  switch (typeof chunk) {
	    // string defaulting to html
	    case 'string':
	      if (!this.get('Content-Type')) {
	        this.type('html');
	      }
	      break;
	    case 'boolean':
	    case 'number':
	    case 'object':
	      if (chunk === null) {
	        chunk = '';
	      } else if (Buffer.isBuffer(chunk)) {
	        if (!this.get('Content-Type')) {
	          this.type('bin');
	        }
	      } else {
	        return this.json(chunk);
	      }
	      break;
	  }

	  // write strings in utf-8
	  if (typeof chunk === 'string') {
	    encoding = 'utf8';
	    type = this.get('Content-Type');

	    // reflect this in content-type
	    if (typeof type === 'string') {
	      this.set('Content-Type', setCharset(type, 'utf-8'));
	    }
	  }

	  // populate Content-Length
	  if (chunk !== undefined) {
	    if (!Buffer.isBuffer(chunk)) {
	      // convert chunk to Buffer; saves later double conversions
	      chunk = new Buffer(chunk, encoding);
	      encoding = undefined;
	    }

	    len = chunk.length;
	    this.set('Content-Length', len);
	  }

	  // populate ETag
	  var etag;
	  var generateETag = len !== undefined && app.get('etag fn');
	  if (typeof generateETag === 'function' && !this.get('ETag')) {
	    if ((etag = generateETag(chunk, encoding))) {
	      this.set('ETag', etag);
	    }
	  }

	  // freshness
	  if (req.fresh) this.statusCode = 304;

	  // strip irrelevant headers
	  if (204 === this.statusCode || 304 === this.statusCode) {
	    this.removeHeader('Content-Type');
	    this.removeHeader('Content-Length');
	    this.removeHeader('Transfer-Encoding');
	    chunk = '';
	  }

	  if (req.method === 'HEAD') {
	    // skip body for HEAD
	    this.end();
	  } else {
	    // respond
	    this.end(chunk, encoding);
	  }

	  return this;
	};

	/**
	 * Send JSON response.
	 *
	 * Examples:
	 *
	 *     res.json(null);
	 *     res.json({ user: 'tj' });
	 *
	 * @param {string|number|boolean|object} obj
	 * @public
	 */

	res.json = function json(obj) {
	  var val = obj;

	  // allow status / body
	  if (arguments.length === 2) {
	    // res.json(body, status) backwards compat
	    if (typeof arguments[1] === 'number') {
	      deprecate('res.json(obj, status): Use res.status(status).json(obj) instead');
	      this.statusCode = arguments[1];
	    } else {
	      deprecate('res.json(status, obj): Use res.status(status).json(obj) instead');
	      this.statusCode = arguments[0];
	      val = arguments[1];
	    }
	  }

	  // settings
	  var app = this.app;
	  var replacer = app.get('json replacer');
	  var spaces = app.get('json spaces');
	  var body = stringify(val, replacer, spaces);

	  // content-type
	  if (!this.get('Content-Type')) {
	    this.set('Content-Type', 'application/json');
	  }

	  return this.send(body);
	};

	/**
	 * Send JSON response with JSONP callback support.
	 *
	 * Examples:
	 *
	 *     res.jsonp(null);
	 *     res.jsonp({ user: 'tj' });
	 *
	 * @param {string|number|boolean|object} obj
	 * @public
	 */

	res.jsonp = function jsonp(obj) {
	  var val = obj;

	  // allow status / body
	  if (arguments.length === 2) {
	    // res.json(body, status) backwards compat
	    if (typeof arguments[1] === 'number') {
	      deprecate('res.jsonp(obj, status): Use res.status(status).json(obj) instead');
	      this.statusCode = arguments[1];
	    } else {
	      deprecate('res.jsonp(status, obj): Use res.status(status).jsonp(obj) instead');
	      this.statusCode = arguments[0];
	      val = arguments[1];
	    }
	  }

	  // settings
	  var app = this.app;
	  var replacer = app.get('json replacer');
	  var spaces = app.get('json spaces');
	  var body = stringify(val, replacer, spaces);
	  var callback = this.req.query[app.get('jsonp callback name')];

	  // content-type
	  if (!this.get('Content-Type')) {
	    this.set('X-Content-Type-Options', 'nosniff');
	    this.set('Content-Type', 'application/json');
	  }

	  // fixup callback
	  if (Array.isArray(callback)) {
	    callback = callback[0];
	  }

	  // jsonp
	  if (typeof callback === 'string' && callback.length !== 0) {
	    this.charset = 'utf-8';
	    this.set('X-Content-Type-Options', 'nosniff');
	    this.set('Content-Type', 'text/javascript');

	    // restrict callback charset
	    callback = callback.replace(/[^\[\]\w$.]/g, '');

	    // replace chars not allowed in JavaScript that are in JSON
	    body = body
	      .replace(/\u2028/g, '\\u2028')
	      .replace(/\u2029/g, '\\u2029');

	    // the /**/ is a specific security mitigation for "Rosetta Flash JSONP abuse"
	    // the typeof check is just to reduce client error noise
	    body = '/**/ typeof ' + callback + ' === \'function\' && ' + callback + '(' + body + ');';
	  }

	  return this.send(body);
	};

	/**
	 * Send given HTTP status code.
	 *
	 * Sets the response status to `statusCode` and the body of the
	 * response to the standard description from node's http.STATUS_CODES
	 * or the statusCode number if no description.
	 *
	 * Examples:
	 *
	 *     res.sendStatus(200);
	 *
	 * @param {number} statusCode
	 * @public
	 */

	res.sendStatus = function sendStatus(statusCode) {
	  var body = statusCodes[statusCode] || String(statusCode);

	  this.statusCode = statusCode;
	  this.type('txt');

	  return this.send(body);
	};

	/**
	 * Transfer the file at the given `path`.
	 *
	 * Automatically sets the _Content-Type_ response header field.
	 * The callback `callback(err)` is invoked when the transfer is complete
	 * or when an error occurs. Be sure to check `res.sentHeader`
	 * if you wish to attempt responding, as the header and some data
	 * may have already been transferred.
	 *
	 * Options:
	 *
	 *   - `maxAge`   defaulting to 0 (can be string converted by `ms`)
	 *   - `root`     root directory for relative filenames
	 *   - `headers`  object of headers to serve with file
	 *   - `dotfiles` serve dotfiles, defaulting to false; can be `"allow"` to send them
	 *
	 * Other options are passed along to `send`.
	 *
	 * Examples:
	 *
	 *  The following example illustrates how `res.sendFile()` may
	 *  be used as an alternative for the `static()` middleware for
	 *  dynamic situations. The code backing `res.sendFile()` is actually
	 *  the same code, so HTTP cache support etc is identical.
	 *
	 *     app.get('/user/:uid/photos/:file', function(req, res){
	 *       var uid = req.params.uid
	 *         , file = req.params.file;
	 *
	 *       req.user.mayViewFilesFrom(uid, function(yes){
	 *         if (yes) {
	 *           res.sendFile('/uploads/' + uid + '/' + file);
	 *         } else {
	 *           res.send(403, 'Sorry! you cant see that.');
	 *         }
	 *       });
	 *     });
	 *
	 * @public
	 */

	res.sendFile = function sendFile(path, options, callback) {
	  var done = callback;
	  var req = this.req;
	  var res = this;
	  var next = req.next;
	  var opts = options || {};

	  if (!path) {
	    throw new TypeError('path argument is required to res.sendFile');
	  }

	  // support function as second arg
	  if (typeof options === 'function') {
	    done = options;
	    opts = {};
	  }

	  if (!opts.root && !isAbsolute(path)) {
	    throw new TypeError('path must be absolute or specify root to res.sendFile');
	  }

	  // create file stream
	  var pathname = encodeURI(path);
	  var file = send(req, pathname, opts);

	  // transfer
	  sendfile(res, file, opts, function (err) {
	    if (done) return done(err);
	    if (err && err.code === 'EISDIR') return next();

	    // next() all but write errors
	    if (err && err.code !== 'ECONNABORTED' && err.syscall !== 'write') {
	      next(err);
	    }
	  });
	};

	/**
	 * Transfer the file at the given `path`.
	 *
	 * Automatically sets the _Content-Type_ response header field.
	 * The callback `callback(err)` is invoked when the transfer is complete
	 * or when an error occurs. Be sure to check `res.sentHeader`
	 * if you wish to attempt responding, as the header and some data
	 * may have already been transferred.
	 *
	 * Options:
	 *
	 *   - `maxAge`   defaulting to 0 (can be string converted by `ms`)
	 *   - `root`     root directory for relative filenames
	 *   - `headers`  object of headers to serve with file
	 *   - `dotfiles` serve dotfiles, defaulting to false; can be `"allow"` to send them
	 *
	 * Other options are passed along to `send`.
	 *
	 * Examples:
	 *
	 *  The following example illustrates how `res.sendfile()` may
	 *  be used as an alternative for the `static()` middleware for
	 *  dynamic situations. The code backing `res.sendfile()` is actually
	 *  the same code, so HTTP cache support etc is identical.
	 *
	 *     app.get('/user/:uid/photos/:file', function(req, res){
	 *       var uid = req.params.uid
	 *         , file = req.params.file;
	 *
	 *       req.user.mayViewFilesFrom(uid, function(yes){
	 *         if (yes) {
	 *           res.sendfile('/uploads/' + uid + '/' + file);
	 *         } else {
	 *           res.send(403, 'Sorry! you cant see that.');
	 *         }
	 *       });
	 *     });
	 *
	 * @public
	 */

	res.sendfile = function (path, options, callback) {
	  var done = callback;
	  var req = this.req;
	  var res = this;
	  var next = req.next;
	  var opts = options || {};

	  // support function as second arg
	  if (typeof options === 'function') {
	    done = options;
	    opts = {};
	  }

	  // create file stream
	  var file = send(req, path, opts);

	  // transfer
	  sendfile(res, file, opts, function (err) {
	    if (done) return done(err);
	    if (err && err.code === 'EISDIR') return next();

	    // next() all but write errors
	    if (err && err.code !== 'ECONNABORT' && err.syscall !== 'write') {
	      next(err);
	    }
	  });
	};

	res.sendfile = deprecate.function(res.sendfile,
	  'res.sendfile: Use res.sendFile instead');

	/**
	 * Transfer the file at the given `path` as an attachment.
	 *
	 * Optionally providing an alternate attachment `filename`,
	 * and optional callback `callback(err)`. The callback is invoked
	 * when the data transfer is complete, or when an error has
	 * ocurred. Be sure to check `res.headersSent` if you plan to respond.
	 *
	 * This method uses `res.sendfile()`.
	 *
	 * @public
	 */

	res.download = function download(path, filename, callback) {
	  var done = callback;
	  var name = filename;

	  // support function as second arg
	  if (typeof filename === 'function') {
	    done = filename;
	    name = null;
	  }

	  // set Content-Disposition when file is sent
	  var headers = {
	    'Content-Disposition': contentDisposition(name || path)
	  };

	  // Resolve the full path for sendFile
	  var fullPath = resolve(path);

	  return this.sendFile(fullPath, { headers: headers }, done);
	};

	/**
	 * Set _Content-Type_ response header with `type` through `mime.lookup()`
	 * when it does not contain "/", or set the Content-Type to `type` otherwise.
	 *
	 * Examples:
	 *
	 *     res.type('.html');
	 *     res.type('html');
	 *     res.type('json');
	 *     res.type('application/json');
	 *     res.type('png');
	 *
	 * @param {String} type
	 * @return {ServerResponse} for chaining
	 * @public
	 */

	res.contentType =
	res.type = function contentType(type) {
	  var ct = type.indexOf('/') === -1
	    ? mime.lookup(type)
	    : type;

	  return this.set('Content-Type', ct);
	};

	/**
	 * Respond to the Acceptable formats using an `obj`
	 * of mime-type callbacks.
	 *
	 * This method uses `req.accepted`, an array of
	 * acceptable types ordered by their quality values.
	 * When "Accept" is not present the _first_ callback
	 * is invoked, otherwise the first match is used. When
	 * no match is performed the server responds with
	 * 406 "Not Acceptable".
	 *
	 * Content-Type is set for you, however if you choose
	 * you may alter this within the callback using `res.type()`
	 * or `res.set('Content-Type', ...)`.
	 *
	 *    res.format({
	 *      'text/plain': function(){
	 *        res.send('hey');
	 *      },
	 *
	 *      'text/html': function(){
	 *        res.send('<p>hey</p>');
	 *      },
	 *
	 *      'appliation/json': function(){
	 *        res.send({ message: 'hey' });
	 *      }
	 *    });
	 *
	 * In addition to canonicalized MIME types you may
	 * also use extnames mapped to these types:
	 *
	 *    res.format({
	 *      text: function(){
	 *        res.send('hey');
	 *      },
	 *
	 *      html: function(){
	 *        res.send('<p>hey</p>');
	 *      },
	 *
	 *      json: function(){
	 *        res.send({ message: 'hey' });
	 *      }
	 *    });
	 *
	 * By default Express passes an `Error`
	 * with a `.status` of 406 to `next(err)`
	 * if a match is not made. If you provide
	 * a `.default` callback it will be invoked
	 * instead.
	 *
	 * @param {Object} obj
	 * @return {ServerResponse} for chaining
	 * @public
	 */

	res.format = function(obj){
	  var req = this.req;
	  var next = req.next;

	  var fn = obj.default;
	  if (fn) delete obj.default;
	  var keys = Object.keys(obj);

	  var key = keys.length > 0
	    ? req.accepts(keys)
	    : false;

	  this.vary("Accept");

	  if (key) {
	    this.set('Content-Type', normalizeType(key).value);
	    obj[key](req, this, next);
	  } else if (fn) {
	    fn();
	  } else {
	    var err = new Error('Not Acceptable');
	    err.status = err.statusCode = 406;
	    err.types = normalizeTypes(keys).map(function(o){ return o.value });
	    next(err);
	  }

	  return this;
	};

	/**
	 * Set _Content-Disposition_ header to _attachment_ with optional `filename`.
	 *
	 * @param {String} filename
	 * @return {ServerResponse}
	 * @public
	 */

	res.attachment = function attachment(filename) {
	  if (filename) {
	    this.type(extname(filename));
	  }

	  this.set('Content-Disposition', contentDisposition(filename));

	  return this;
	};

	/**
	 * Append additional header `field` with value `val`.
	 *
	 * Example:
	 *
	 *    res.append('Link', ['<http://localhost/>', '<http://localhost:3000/>']);
	 *    res.append('Set-Cookie', 'foo=bar; Path=/; HttpOnly');
	 *    res.append('Warning', '199 Miscellaneous warning');
	 *
	 * @param {String} field
	 * @param {String|Array} val
	 * @return {ServerResponse} for chaining
	 * @public
	 */

	res.append = function append(field, val) {
	  var prev = this.get(field);
	  var value = val;

	  if (prev) {
	    // concat the new and prev vals
	    value = Array.isArray(prev) ? prev.concat(val)
	      : Array.isArray(val) ? [prev].concat(val)
	      : [prev, val];
	  }

	  return this.set(field, value);
	};

	/**
	 * Set header `field` to `val`, or pass
	 * an object of header fields.
	 *
	 * Examples:
	 *
	 *    res.set('Foo', ['bar', 'baz']);
	 *    res.set('Accept', 'application/json');
	 *    res.set({ Accept: 'text/plain', 'X-API-Key': 'tobi' });
	 *
	 * Aliased as `res.header()`.
	 *
	 * @param {String|Object} field
	 * @param {String|Array} val
	 * @return {ServerResponse} for chaining
	 * @public
	 */

	res.set =
	res.header = function header(field, val) {
	  if (arguments.length === 2) {
	    var value = Array.isArray(val)
	      ? val.map(String)
	      : String(val);

	    // add charset to content-type
	    if (field.toLowerCase() === 'content-type' && !charsetRegExp.test(value)) {
	      var charset = mime.charsets.lookup(value.split(';')[0]);
	      if (charset) value += '; charset=' + charset.toLowerCase();
	    }

	    this.setHeader(field, value);
	  } else {
	    for (var key in field) {
	      this.set(key, field[key]);
	    }
	  }
	  return this;
	};

	/**
	 * Get value for header `field`.
	 *
	 * @param {String} field
	 * @return {String}
	 * @public
	 */

	res.get = function(field){
	  return this.getHeader(field);
	};

	/**
	 * Clear cookie `name`.
	 *
	 * @param {String} name
	 * @param {Object} [options]
	 * @return {ServerResponse} for chaining
	 * @public
	 */

	res.clearCookie = function clearCookie(name, options) {
	  var opts = merge({ expires: new Date(1), path: '/' }, options);

	  return this.cookie(name, '', opts);
	};

	/**
	 * Set cookie `name` to `value`, with the given `options`.
	 *
	 * Options:
	 *
	 *    - `maxAge`   max-age in milliseconds, converted to `expires`
	 *    - `signed`   sign the cookie
	 *    - `path`     defaults to "/"
	 *
	 * Examples:
	 *
	 *    // "Remember Me" for 15 minutes
	 *    res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });
	 *
	 *    // save as above
	 *    res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })
	 *
	 * @param {String} name
	 * @param {String|Object} value
	 * @param {Options} options
	 * @return {ServerResponse} for chaining
	 * @public
	 */

	res.cookie = function (name, value, options) {
	  var opts = merge({}, options);
	  var secret = this.req.secret;
	  var signed = opts.signed;

	  if (signed && !secret) {
	    throw new Error('cookieParser("secret") required for signed cookies');
	  }

	  var val = typeof value === 'object'
	    ? 'j:' + JSON.stringify(value)
	    : String(value);

	  if (signed) {
	    val = 's:' + sign(val, secret);
	  }

	  if ('maxAge' in opts) {
	    opts.expires = new Date(Date.now() + opts.maxAge);
	    opts.maxAge /= 1000;
	  }

	  if (opts.path == null) {
	    opts.path = '/';
	  }

	  this.append('Set-Cookie', cookie.serialize(name, String(val), opts));

	  return this;
	};

	/**
	 * Set the location header to `url`.
	 *
	 * The given `url` can also be "back", which redirects
	 * to the _Referrer_ or _Referer_ headers or "/".
	 *
	 * Examples:
	 *
	 *    res.location('/foo/bar').;
	 *    res.location('http://example.com');
	 *    res.location('../login');
	 *
	 * @param {String} url
	 * @return {ServerResponse} for chaining
	 * @public
	 */

	res.location = function location(url) {
	  var loc = url;

	  // "back" is an alias for the referrer
	  if (url === 'back') {
	    loc = this.req.get('Referrer') || '/';
	  }

	  // set location
	  return this.set('Location', encodeUrl(loc));
	};

	/**
	 * Redirect to the given `url` with optional response `status`
	 * defaulting to 302.
	 *
	 * The resulting `url` is determined by `res.location()`, so
	 * it will play nicely with mounted apps, relative paths,
	 * `"back"` etc.
	 *
	 * Examples:
	 *
	 *    res.redirect('/foo/bar');
	 *    res.redirect('http://example.com');
	 *    res.redirect(301, 'http://example.com');
	 *    res.redirect('../login'); // /blog/post/1 -> /blog/login
	 *
	 * @public
	 */

	res.redirect = function redirect(url) {
	  var address = url;
	  var body;
	  var status = 302;

	  // allow status / url
	  if (arguments.length === 2) {
	    if (typeof arguments[0] === 'number') {
	      status = arguments[0];
	      address = arguments[1];
	    } else {
	      deprecate('res.redirect(url, status): Use res.redirect(status, url) instead');
	      status = arguments[1];
	    }
	  }

	  // Set location header
	  address = this.location(address).get('Location');

	  // Support text/{plain,html} by default
	  this.format({
	    text: function(){
	      body = statusCodes[status] + '. Redirecting to ' + address;
	    },

	    html: function(){
	      var u = escapeHtml(address);
	      body = '<p>' + statusCodes[status] + '. Redirecting to <a href="' + u + '">' + u + '</a></p>';
	    },

	    default: function(){
	      body = '';
	    }
	  });

	  // Respond
	  this.statusCode = status;
	  this.set('Content-Length', Buffer.byteLength(body));

	  if (this.req.method === 'HEAD') {
	    this.end();
	  } else {
	    this.end(body);
	  }
	};

	/**
	 * Add `field` to Vary. If already present in the Vary set, then
	 * this call is simply ignored.
	 *
	 * @param {Array|String} field
	 * @return {ServerResponse} for chaining
	 * @public
	 */

	res.vary = function(field){
	  // checks for back-compat
	  if (!field || (Array.isArray(field) && !field.length)) {
	    deprecate('res.vary(): Provide a field name');
	    return this;
	  }

	  vary(this, field);

	  return this;
	};

	/**
	 * Render `view` with the given `options` and optional callback `fn`.
	 * When a callback function is given a response will _not_ be made
	 * automatically, otherwise a response of _200_ and _text/html_ is given.
	 *
	 * Options:
	 *
	 *  - `cache`     boolean hinting to the engine it should cache
	 *  - `filename`  filename of the view being rendered
	 *
	 * @public
	 */

	res.render = function render(view, options, callback) {
	  var app = this.req.app;
	  var done = callback;
	  var opts = options || {};
	  var req = this.req;
	  var self = this;

	  // support callback function as second arg
	  if (typeof options === 'function') {
	    done = options;
	    opts = {};
	  }

	  // merge res.locals
	  opts._locals = self.locals;

	  // default callback to respond
	  done = done || function (err, str) {
	    if (err) return req.next(err);
	    self.send(str);
	  };

	  // render
	  app.render(view, opts, done);
	};

	// pipe the send file stream
	function sendfile(res, file, options, callback) {
	  var done = false;
	  var streaming;

	  // request aborted
	  function onaborted() {
	    if (done) return;
	    done = true;

	    var err = new Error('Request aborted');
	    err.code = 'ECONNABORTED';
	    callback(err);
	  }

	  // directory
	  function ondirectory() {
	    if (done) return;
	    done = true;

	    var err = new Error('EISDIR, read');
	    err.code = 'EISDIR';
	    callback(err);
	  }

	  // errors
	  function onerror(err) {
	    if (done) return;
	    done = true;
	    callback(err);
	  }

	  // ended
	  function onend() {
	    if (done) return;
	    done = true;
	    callback();
	  }

	  // file
	  function onfile() {
	    streaming = false;
	  }

	  // finished
	  function onfinish(err) {
	    if (err && err.code === 'ECONNRESET') return onaborted();
	    if (err) return onerror(err);
	    if (done) return;

	    setImmediate(function () {
	      if (streaming !== false && !done) {
	        onaborted();
	        return;
	      }

	      if (done) return;
	      done = true;
	      callback();
	    });
	  }

	  // streaming
	  function onstream() {
	    streaming = true;
	  }

	  file.on('directory', ondirectory);
	  file.on('end', onend);
	  file.on('error', onerror);
	  file.on('file', onfile);
	  file.on('stream', onstream);
	  onFinished(res, onfinish);

	  if (options.headers) {
	    // set headers on successful transfer
	    file.on('headers', function headers(res) {
	      var obj = options.headers;
	      var keys = Object.keys(obj);

	      for (var i = 0; i < keys.length; i++) {
	        var k = keys[i];
	        res.setHeader(k, obj[k]);
	      }
	    });
	  }

	  // pipe
	  file.pipe(res);
	}

	/**
	 * Stringify JSON, like JSON.stringify, but v8 optimized.
	 * @private
	 */

	function stringify(value, replacer, spaces) {
	  // v8 checks arguments.length for optimizing simple call
	  // https://bugs.chromium.org/p/v8/issues/detail?id=4730
	  return replacer || spaces
	    ? JSON.stringify(value, replacer, spaces)
	    : JSON.stringify(value);
	}


/***/ },
/* 85 */
/*!*************************************!*\
  !*** ./~/cookie-signature/index.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */

	var crypto = __webpack_require__(/*! crypto */ 70);

	/**
	 * Sign the given `val` with `secret`.
	 *
	 * @param {String} val
	 * @param {String} secret
	 * @return {String}
	 * @api private
	 */

	exports.sign = function(val, secret){
	  if ('string' != typeof val) throw new TypeError("Cookie value must be provided as a string.");
	  if ('string' != typeof secret) throw new TypeError("Secret string must be provided.");
	  return val + '.' + crypto
	    .createHmac('sha256', secret)
	    .update(val)
	    .digest('base64')
	    .replace(/\=+$/, '');
	};

	/**
	 * Unsign and decode the given `val` with `secret`,
	 * returning `false` if the signature is invalid.
	 *
	 * @param {String} val
	 * @param {String} secret
	 * @return {String|Boolean}
	 * @api private
	 */

	exports.unsign = function(val, secret){
	  if ('string' != typeof val) throw new TypeError("Signed cookie string must be provided.");
	  if ('string' != typeof secret) throw new TypeError("Secret string must be provided.");
	  var str = val.slice(0, val.lastIndexOf('.'))
	    , mac = exports.sign(str, secret);
	  
	  return sha1(mac) == sha1(val) ? str : false;
	};

	/**
	 * Private
	 */

	function sha1(str){
	  return crypto.createHash('sha1').update(str).digest('hex');
	}


/***/ },
/* 86 */
/*!***************************!*\
  !*** ./~/cookie/index.js ***!
  \***************************/
/***/ function(module, exports) {

	/*!
	 * cookie
	 * Copyright(c) 2012-2014 Roman Shtylman
	 * Copyright(c) 2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict';

	/**
	 * Module exports.
	 * @public
	 */

	exports.parse = parse;
	exports.serialize = serialize;

	/**
	 * Module variables.
	 * @private
	 */

	var decode = decodeURIComponent;
	var encode = encodeURIComponent;
	var pairSplitRegExp = /; */;

	/**
	 * RegExp to match field-content in RFC 7230 sec 3.2
	 *
	 * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
	 * field-vchar   = VCHAR / obs-text
	 * obs-text      = %x80-FF
	 */

	var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;

	/**
	 * Parse a cookie header.
	 *
	 * Parse the given cookie header string into an object
	 * The object has the various cookies as keys(names) => values
	 *
	 * @param {string} str
	 * @param {object} [options]
	 * @return {object}
	 * @public
	 */

	function parse(str, options) {
	  if (typeof str !== 'string') {
	    throw new TypeError('argument str must be a string');
	  }

	  var obj = {}
	  var opt = options || {};
	  var pairs = str.split(pairSplitRegExp);
	  var dec = opt.decode || decode;

	  for (var i = 0; i < pairs.length; i++) {
	    var pair = pairs[i];
	    var eq_idx = pair.indexOf('=');

	    // skip things that don't look like key=value
	    if (eq_idx < 0) {
	      continue;
	    }

	    var key = pair.substr(0, eq_idx).trim()
	    var val = pair.substr(++eq_idx, pair.length).trim();

	    // quoted values
	    if ('"' == val[0]) {
	      val = val.slice(1, -1);
	    }

	    // only assign once
	    if (undefined == obj[key]) {
	      obj[key] = tryDecode(val, dec);
	    }
	  }

	  return obj;
	}

	/**
	 * Serialize data into a cookie header.
	 *
	 * Serialize the a name value pair into a cookie string suitable for
	 * http headers. An optional options object specified cookie parameters.
	 *
	 * serialize('foo', 'bar', { httpOnly: true })
	 *   => "foo=bar; httpOnly"
	 *
	 * @param {string} name
	 * @param {string} val
	 * @param {object} [options]
	 * @return {string}
	 * @public
	 */

	function serialize(name, val, options) {
	  var opt = options || {};
	  var enc = opt.encode || encode;

	  if (typeof enc !== 'function') {
	    throw new TypeError('option encode is invalid');
	  }

	  if (!fieldContentRegExp.test(name)) {
	    throw new TypeError('argument name is invalid');
	  }

	  var value = enc(val);

	  if (value && !fieldContentRegExp.test(value)) {
	    throw new TypeError('argument val is invalid');
	  }

	  var str = name + '=' + value;

	  if (null != opt.maxAge) {
	    var maxAge = opt.maxAge - 0;
	    if (isNaN(maxAge)) throw new Error('maxAge should be a Number');
	    str += '; Max-Age=' + Math.floor(maxAge);
	  }

	  if (opt.domain) {
	    if (!fieldContentRegExp.test(opt.domain)) {
	      throw new TypeError('option domain is invalid');
	    }

	    str += '; Domain=' + opt.domain;
	  }

	  if (opt.path) {
	    if (!fieldContentRegExp.test(opt.path)) {
	      throw new TypeError('option path is invalid');
	    }

	    str += '; Path=' + opt.path;
	  }

	  if (opt.expires) {
	    if (typeof opt.expires.toUTCString !== 'function') {
	      throw new TypeError('option expires is invalid');
	    }

	    str += '; Expires=' + opt.expires.toUTCString();
	  }

	  if (opt.httpOnly) {
	    str += '; HttpOnly';
	  }

	  if (opt.secure) {
	    str += '; Secure';
	  }

	  if (opt.sameSite) {
	    var sameSite = typeof opt.sameSite === 'string'
	      ? opt.sameSite.toLowerCase() : opt.sameSite;

	    switch (sameSite) {
	      case true:
	        str += '; SameSite=Strict';
	        break;
	      case 'lax':
	        str += '; SameSite=Lax';
	        break;
	      case 'strict':
	        str += '; SameSite=Strict';
	        break;
	      default:
	        throw new TypeError('option sameSite is invalid');
	    }
	  }

	  return str;
	}

	/**
	 * Try decoding a string using a decoding function.
	 *
	 * @param {string} str
	 * @param {function} decode
	 * @private
	 */

	function tryDecode(str, decode) {
	  try {
	    return decode(str);
	  } catch (e) {
	    return str;
	  }
	}


/***/ },
/* 87 */
/*!*********************************!*\
  !*** ./~/serve-static/index.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * serve-static
	 * Copyright(c) 2010 Sencha Inc.
	 * Copyright(c) 2011 TJ Holowaychuk
	 * Copyright(c) 2014-2016 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	'use strict'

	/**
	 * Module dependencies.
	 * @private
	 */

	var encodeUrl = __webpack_require__(/*! encodeurl */ 68)
	var escapeHtml = __webpack_require__(/*! escape-html */ 30)
	var parseUrl = __webpack_require__(/*! parseurl */ 50)
	var resolve = __webpack_require__(/*! path */ 11).resolve
	var send = __webpack_require__(/*! send */ 62)
	var url = __webpack_require__(/*! url */ 51)

	/**
	 * Module exports.
	 * @public
	 */

	module.exports = serveStatic
	module.exports.mime = send.mime

	/**
	 * @param {string} root
	 * @param {object} [options]
	 * @return {function}
	 * @public
	 */

	function serveStatic (root, options) {
	  if (!root) {
	    throw new TypeError('root path required')
	  }

	  if (typeof root !== 'string') {
	    throw new TypeError('root path must be a string')
	  }

	  // copy options object
	  var opts = Object.create(options || null)

	  // fall-though
	  var fallthrough = opts.fallthrough !== false

	  // default redirect
	  var redirect = opts.redirect !== false

	  // headers listener
	  var setHeaders = opts.setHeaders

	  if (setHeaders && typeof setHeaders !== 'function') {
	    throw new TypeError('option setHeaders must be function')
	  }

	  // setup options for send
	  opts.maxage = opts.maxage || opts.maxAge || 0
	  opts.root = resolve(root)

	  // construct directory listener
	  var onDirectory = redirect
	    ? createRedirectDirectoryListener()
	    : createNotFoundDirectoryListener()

	  return function serveStatic (req, res, next) {
	    if (req.method !== 'GET' && req.method !== 'HEAD') {
	      if (fallthrough) {
	        return next()
	      }

	      // method not allowed
	      res.statusCode = 405
	      res.setHeader('Allow', 'GET, HEAD')
	      res.setHeader('Content-Length', '0')
	      res.end()
	      return
	    }

	    var forwardError = !fallthrough
	    var originalUrl = parseUrl.original(req)
	    var path = parseUrl(req).pathname

	    // make sure redirect occurs at mount
	    if (path === '/' && originalUrl.pathname.substr(-1) !== '/') {
	      path = ''
	    }

	    // create send stream
	    var stream = send(req, path, opts)

	    // add directory handler
	    stream.on('directory', onDirectory)

	    // add headers listener
	    if (setHeaders) {
	      stream.on('headers', setHeaders)
	    }

	    // add file listener for fallthrough
	    if (fallthrough) {
	      stream.on('file', function onFile () {
	        // once file is determined, always forward error
	        forwardError = true
	      })
	    }

	    // forward errors
	    stream.on('error', function error (err) {
	      if (forwardError || !(err.statusCode < 500)) {
	        next(err)
	        return
	      }

	      next()
	    })

	    // pipe
	    stream.pipe(res)
	  }
	}

	/**
	 * Collapse all leading slashes into a single slash
	 * @private
	 */
	function collapseLeadingSlashes (str) {
	  for (var i = 0; i < str.length; i++) {
	    if (str[i] !== '/') {
	      break
	    }
	  }

	  return i > 1
	    ? '/' + str.substr(i)
	    : str
	}

	/**
	 * Create a directory listener that just 404s.
	 * @private
	 */

	function createNotFoundDirectoryListener () {
	  return function notFound () {
	    this.error(404)
	  }
	}

	/**
	 * Create a directory listener that performs a redirect.
	 * @private
	 */

	function createRedirectDirectoryListener () {
	  return function redirect () {
	    if (this.hasTrailingSlash()) {
	      this.error(404)
	      return
	    }

	    // get original URL
	    var originalUrl = parseUrl.original(this.req)

	    // append trailing slash
	    originalUrl.path = null
	    originalUrl.pathname = collapseLeadingSlashes(originalUrl.pathname + '/')

	    // reformat the URL
	    var loc = encodeUrl(url.format(originalUrl))
	    var msg = 'Redirecting to <a href="' + escapeHtml(loc) + '">' + escapeHtml(loc) + '</a>\n'
	    var res = this.res

	    // send redirect response
	    res.statusCode = 301
	    res.setHeader('Content-Type', 'text/html; charset=UTF-8')
	    res.setHeader('Content-Length', Buffer.byteLength(msg))
	    res.setHeader('X-Content-Type-Options', 'nosniff')
	    res.setHeader('Location', loc)
	    res.end(msg)
	  }
	}


/***/ },
/* 88 */
/*!********************************!*\
  !*** ./src/server/init-api.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	//
	// TODO: figure out system for api routes
	//


	//---------//
	// Imports //
	//---------//

	var confs = __webpack_require__(/*! ../../utils/pg-confs */ 89)
	  , DALDataPoint = __webpack_require__(/*! ../../db/models/dal/data-point */ 365)
	  , DALLocation = __webpack_require__(/*! ../../db/models/dal/location */ 386)
	  , DALType = __webpack_require__(/*! ../../db/models/dal/type */ 383)
	  , DALymd = __webpack_require__(/*! ../../db/models/dal/ymd */ 385)
	  , DALMeasurementName = __webpack_require__(/*! ../../db/models/dal/measurement-name */ 387)
	  , DALSource = __webpack_require__(/*! ../../db/models/dal/source */ 384)
	  , YMD = __webpack_require__(/*! ../../db/models/extensions/ymd */ 378)
	  ;


	//------//
	// Main //
	//------//

	const initApi = app => {
	  var pgWrapperInst = confs[("prod")].GeneratePGWrapper()
	    , dalDataPointInst = new DALDataPoint(pgWrapperInst)
	    , dalLocationInst = new DALLocation(pgWrapperInst)
	    , dalTypeInst = new DALType(pgWrapperInst)
	    , dalYmdInst = new DALymd(pgWrapperInst)
	    , dalMeasurementNameInst = new DALMeasurementName(pgWrapperInst)
	    , dalSourceInst = new DALSource(pgWrapperInst);

	  app.get('/api/graph-data', (req, res) => {
	    // validation
	    if (!(req.query.dateFrom && req.query.dateTo)) {
	      throw new Error("Invalid Arguments: /graph-data requires two query strings dateFrom and dateTo");
	    }

	    YMD.ValidateValue(req.query.dateFrom, true);
	    YMD.ValidateValue(req.query.dateTo);

	    var momentFrom = YMD.getMoment(req.query.dateFrom)
	      , momentTo = YMD.getMoment(req.query.dateTo);

	    if (!momentFrom.isBefore(momentTo)) {
	      throw new Error("Invalid Arguments: /graph-data requires dateFrom to be before dateTo");
	    } else if (Math.abs(momentFrom.diff(momentTo, 'days')) > 31) {
	      throw new Error("Invalid Arguments: /graph-data requires the number of days between dateFrom and dateTo to be no longer than 31 days");
	    }

	    // query string is valid
	    dalDataPointInst.getDataPointsBetweenDates(req.query.dateFrom, req.query.dateTo)
	    .then(lazyDataPoints => {
	        var resDataPoints = lazyDataPoints.map(aDataPoint => aDataPoint.serialize())
	          .toArray();
	        res.send(resDataPoints);
	      });
	  });

	  app.get('/api/locations', (req, res) => {
	    dalLocationInst.getAllLocations()
	      .then(lazyLocations => {
	        var resLocations = lazyLocations.map(aLocation => aLocation.serialize())
	          .toArray();
	        res.send(resLocations);
	      });
	  });

	  app.get('/api/types', (req, res) => {
	    dalTypeInst.getClientOptionTypes()
	      .then(lazyTypes => {
	        var resTypes = lazyTypes.map(aType => aType.serialize()).toArray();
	        res.send(resTypes);
	      });
	  });

	  app.get('/api/measurement-names', (req, res) => {
	    dalMeasurementNameInst.getAllMeasurementNames()
	      .then(lazyMeasurementNames => {
	        var resMeasurementNames = lazyMeasurementNames
	          .map(aMeasurementName => aMeasurementName.serialize())
	          .toArray();
	        res.send(resMeasurementNames);
	      });
	  });

	  app.get('/api/ymd-range', (req, res) => {
	    dalYmdInst.getYmdRangeWithFullData()
	      .then(dateRange => {
	        var resYmds = {
	          min: dateRange.min.serialize()
	          , max: dateRange.max.serialize()
	        };

	        res.send(resYmds);
	      });
	  });

	  app.get('/api/sources', (req, res) => {
	    dalSourceInst.getAllSources()
	      .then(lazySources => {
	        var resSources = lazySources.map(aSource => aSource.serialize())
	          .toArray();

	        res.send(resSources);
	      });
	  });
	};


	//---------//
	// Exports //
	//---------//

	module.exports = initApi;


/***/ },
/* 89 */
/*!***************************!*\
  !*** ./utils/pg-confs.js ***!
  \***************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var nh = __webpack_require__(/*! node-helpers */ 90);
	var PGConf = nh.psqlWrapper.PGConf;
	var e = process.env;

	// if on heroku, then always use the DATABASE_URL environment variable
	if (e.DATABASE_URL) {
	  module.exports.prod = module.exports.test = module.exports.dev = new PGConf({
	    connString: e.DATABASE_URL
	  });
	} else {
	  module.exports.dev = new PGConf({
	    user: 'weather_accuracy_test'
	    , database: 'weather_accuracy_test'
	    , password: e.PGPASS_WEATHER_ACCURACY_TEST
	    , port: 5432
	    , host: 'localhost'
	    , ssl: false
	  });

	  module.exports.prod = module.exports.test = new PGConf({
	    user: 'weather_accuracy'
	    , database: 'weather_accuracy'
	    , password: e.PGPASS_WEATHER_ACCURACY
	    , port: 5432
	    , host: 'localhost'
	    , ssl: false
	  });
	}


/***/ },
/* 90 */
/*!*********************************!*\
  !*** ./~/node-helpers/index.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports.commonPgconfs = __webpack_require__(/*! ./common-pgconfs */ 91);
	module.exports.lazyExtensions = __webpack_require__(/*! ./lazy-extensions */ 173);
	module.exports.psqlWrapper = __webpack_require__(/*! ./psql-wrapper */ 92);
	module.exports.utils = __webpack_require__(/*! ./utils */ 131);
	module.exports.Environment = __webpack_require__(/*! ./environment */ 177);
	module.exports.bunyanStreams = __webpack_require__(/*! ./bunyan-streams */ 178);
	module.exports.gsapDefaults = __webpack_require__(/*! ./gsap-defaults */ 315);
	module.exports.config = __webpack_require__(/*! ./config */ 316);
	module.exports.LogProvider = __webpack_require__(/*! ./log-provider */ 359);


/***/ },
/* 91 */
/*!******************************************!*\
  !*** ./~/node-helpers/common-pgconfs.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var PGConf = __webpack_require__(/*! ./psql-wrapper */ 92).PGConf;
	var e = process.env;

	if (!e.DATABASE_URL) {
	  if (e.PGUSER && e.PGDATABASE && e.PGPASSWORD && e.PGPORT) {
	    module.exports.ptq = new PGConf({
	      user: e.PGUSER
	      , database: e.PGDATABASE
	      , password: e.PGPASSWORD
	      , port: e.PGPORT
	      , host: '/run/postgresql'
	      , ssl: false
	    });
	  }

	  if (e.PGTESTUSER && e.PGTESTPASS) {
	    module.exports.test = new PGConf({
	      user: e.PGTESTUSER
	      , database: e.PGTESTUSER
	      , password: e.PGTESTPASS
	      , port: 5432
	      , host: 'localhost'
	      , ssl: false
	    });
	  }

	  module.exports.ptq_test = new PGConf({
	    user: 'ptq_test'
	    , database: 'ptq_test'
	    , password: 'ptq_test'
	    , port: 5432
	    , host: 'localhost'
	    , ssl: false
	  });
	} else {
	  module.exports = {};
	}


/***/ },
/* 92 */
/*!****************************************!*\
  !*** ./~/node-helpers/psql-wrapper.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';


	//---------//
	// Imports //
	//---------//

	var bPromise = __webpack_require__(/*! bluebird */ 93)
	  , Utils = __webpack_require__(/*! ./utils */ 131)
	  , pg = __webpack_require__(/*! pg */ 133)
	  ;


	//------//
	// Init //
	//------//

	var using = bPromise.using;
	bPromise.promisifyAll(pg);


	//--------//
	// PGConf //
	//--------//

	function PGConf(argsObj) {
	  argsObj = argsObj || {};
	  var confObj = {};

	  if (typeof argsObj.user !== 'undefined') {
	    confObj.user = argsObj.user;
	  }
	  if (typeof argsObj.database !== 'undefined') {
	    confObj.database = argsObj.database;
	  }
	  if (typeof argsObj.password !== 'undefined') {
	    confObj.password = argsObj.password;
	  }
	  if (typeof argsObj.port !== 'undefined') {
	    confObj.port = argsObj.port;
	  }
	  if (typeof argsObj.host !== 'undefined') {
	    confObj.host = argsObj.host;
	  }
	  if (typeof argsObj.ssl !== 'undefined') {
	    confObj.ssl = argsObj.ssl;
	  }

	  this.confObj = confObj;
	  this.connString = argsObj.connString;

	  PGConf.validatePgConf(this);
	}

	PGConf.prototype.GetConnection = function GetConnection() {
	  return this.connString || this.confObj;
	};

	PGConf.prototype.GeneratePGWrapper = function GeneratePGWrapper() {
	  return (new PGWrapper(this));
	};


	//-------------//
	// Constructor //
	//-------------//

	function PGWrapper(curPgConf_) {
	  PGConf.validatePgConf(curPgConf_);
	  this.curPgConf = curPgConf_;
	}


	//-----------------------//
	// Prototyped Extensions //
	//-----------------------//

	PGWrapper.prototype.RunParameterizedQuery = function RunParameterizedQuery(queryText_, queryValues_) {
	  return using(getPostgresConnection(this.curPgConf.GetConnection()), function(conn_) {
	    var queryConf = {
	      text: queryText_
	    };
	    if (typeof queryValues_ !== 'undefined') {
	      queryConf.values = queryValues_;
	    }
	    return conn_.queryAsync(queryConf);
	  });
	};

	PGWrapper.prototype.RunQuery = function RunQuery(queryText_) {
	  return this.RunParameterizedQuery(queryText_);
	};

	PGWrapper.prototype.end = function end() {
	  return pg.end();
	};


	//-------------//
	// Helper Fxns //
	//-------------//

	// doesn't return anything - just throws an error if invalid
	PGConf.validatePgConf = function validatePgConf(pgConf_) {
	  if (!Utils.xor(Object.keys(pgConf_.confObj).length, pgConf_.connString)) {
	    throw new Error("Invalid Argument: PGConf requires _either_ connString _or_ separate configuration arguments to be passed");
	  }

	  // parsing the string is unreasonable for now.  Just assume it's correct
	  if (pgConf_.connString) {
	    return;
	  }

	  if (!(Utils.instance_of(pgConf_, PGConf))) {
	    throw new Error("validatePgConf requires a PGConf argument");
	  }
	  var errFields = [];
	  if (!pgConf_.confObj.user) {
	    errFields.push({
	      field: 'user', reason: 'falsy'
	    });
	  }
	  if (!pgConf_.confObj.database) {
	    errFields.push({
	      field: 'database', reason: 'falsy'
	    });
	  }
	  if (!pgConf_.confObj.password) {
	    errFields.push({
	      field: 'password', reason: 'falsy'
	    });
	  }
	  if (!pgConf_.confObj.port) {
	    errFields.push({
	      field: 'port', reason: 'falsy'
	    });
	  }
	  if (!pgConf_.confObj.host) {
	    errFields.push({
	      field: 'host', reason: 'falsy'
	    });
	  }
	  if (isNullOrUndefined(pgConf_.confObj.ssl)) {
	    errFields.push({
	      field: 'ssl', reason: 'null or undefined'
	    });
	  }
	  if (errFields.length) {
	    var fieldReasons = "";
	    errFields.forEach(function(e) {
	      fieldReasons += "\n  field: " + e.field + "\n  reason: " + e.reason;
	    });
	    throw new Error("Invalid Arguments: The following fields were invalid" + fieldReasons);
	  }
	};

	function isNullOrUndefined(prop_) {
	  return (typeof prop_ === 'undefined' || prop_ === null);
	}

	function getPostgresConnection(pgConf_) {
	  var close;
	  return pg.connectAsync(pgConf_).spread(function(client, done) {
	    close = done;
	    return client;
	  }).disposer(function() {
	    if (close) {
	      close();
	    }
	  });
	}


	//---------//
	// Exports //
	//---------//

	module.exports.PGConf = PGConf;
	module.exports.PGWrapper = PGWrapper;


/***/ },
/* 93 */
/*!****************************************!*\
  !*** ./~/bluebird/js/main/bluebird.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var old;
	if (typeof Promise !== "undefined") old = Promise;
	function noConflict() {
	    try { if (Promise === bluebird) Promise = old; }
	    catch (e) {}
	    return bluebird;
	}
	var bluebird = __webpack_require__(/*! ./promise.js */ 94)();
	bluebird.noConflict = noConflict;
	module.exports = bluebird;


/***/ },
/* 94 */
/*!***************************************!*\
  !*** ./~/bluebird/js/main/promise.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function() {
	var makeSelfResolutionError = function () {
	    return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/LhFpo0\u000a");
	};
	var reflect = function() {
	    return new Promise.PromiseInspection(this._target());
	};
	var apiRejection = function(msg) {
	    return Promise.reject(new TypeError(msg));
	};

	var util = __webpack_require__(/*! ./util.js */ 95);

	var getDomain;
	if (util.isNode) {
	    getDomain = function() {
	        var ret = process.domain;
	        if (ret === undefined) ret = null;
	        return ret;
	    };
	} else {
	    getDomain = function() {
	        return null;
	    };
	}
	util.notEnumerableProp(Promise, "_getDomain", getDomain);

	var UNDEFINED_BINDING = {};
	var async = __webpack_require__(/*! ./async.js */ 97);
	var errors = __webpack_require__(/*! ./errors.js */ 100);
	var TypeError = Promise.TypeError = errors.TypeError;
	Promise.RangeError = errors.RangeError;
	Promise.CancellationError = errors.CancellationError;
	Promise.TimeoutError = errors.TimeoutError;
	Promise.OperationalError = errors.OperationalError;
	Promise.RejectionError = errors.OperationalError;
	Promise.AggregateError = errors.AggregateError;
	var INTERNAL = function(){};
	var APPLY = {};
	var NEXT_FILTER = {e: null};
	var tryConvertToPromise = __webpack_require__(/*! ./thenables.js */ 101)(Promise, INTERNAL);
	var PromiseArray =
	    __webpack_require__(/*! ./promise_array.js */ 102)(Promise, INTERNAL,
	                                    tryConvertToPromise, apiRejection);
	var CapturedTrace = __webpack_require__(/*! ./captured_trace.js */ 103)();
	var isDebugging = __webpack_require__(/*! ./debuggability.js */ 104)(Promise, CapturedTrace);
	 /*jshint unused:false*/
	var createContext =
	    __webpack_require__(/*! ./context.js */ 105)(Promise, CapturedTrace, isDebugging);
	var CatchFilter = __webpack_require__(/*! ./catch_filter.js */ 106)(NEXT_FILTER);
	var PromiseResolver = __webpack_require__(/*! ./promise_resolver.js */ 107);
	var nodebackForPromise = PromiseResolver._nodebackForPromise;
	var errorObj = util.errorObj;
	var tryCatch = util.tryCatch;

	function Promise(resolver) {
	    if (typeof resolver !== "function") {
	        throw new TypeError("the promise constructor requires a resolver function\u000a\u000a    See http://goo.gl/EC22Yn\u000a");
	    }
	    if (this.constructor !== Promise) {
	        throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/KsIlge\u000a");
	    }
	    this._bitField = 0;
	    this._fulfillmentHandler0 = undefined;
	    this._rejectionHandler0 = undefined;
	    this._progressHandler0 = undefined;
	    this._promise0 = undefined;
	    this._receiver0 = undefined;
	    this._settledValue = undefined;
	    if (resolver !== INTERNAL) this._resolveFromResolver(resolver);
	}

	Promise.prototype.toString = function () {
	    return "[object Promise]";
	};

	Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
	    var len = arguments.length;
	    if (len > 1) {
	        var catchInstances = new Array(len - 1),
	            j = 0, i;
	        for (i = 0; i < len - 1; ++i) {
	            var item = arguments[i];
	            if (typeof item === "function") {
	                catchInstances[j++] = item;
	            } else {
	                return Promise.reject(
	                    new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a"));
	            }
	        }
	        catchInstances.length = j;
	        fn = arguments[i];
	        var catchFilter = new CatchFilter(catchInstances, fn, this);
	        return this._then(undefined, catchFilter.doFilter, undefined,
	            catchFilter, undefined);
	    }
	    return this._then(undefined, fn, undefined, undefined, undefined);
	};

	Promise.prototype.reflect = function () {
	    return this._then(reflect, reflect, undefined, this, undefined);
	};

	Promise.prototype.then = function (didFulfill, didReject, didProgress) {
	    if (isDebugging() && arguments.length > 0 &&
	        typeof didFulfill !== "function" &&
	        typeof didReject !== "function") {
	        var msg = ".then() only accepts functions but was passed: " +
	                util.classString(didFulfill);
	        if (arguments.length > 1) {
	            msg += ", " + util.classString(didReject);
	        }
	        this._warn(msg);
	    }
	    return this._then(didFulfill, didReject, didProgress,
	        undefined, undefined);
	};

	Promise.prototype.done = function (didFulfill, didReject, didProgress) {
	    var promise = this._then(didFulfill, didReject, didProgress,
	        undefined, undefined);
	    promise._setIsFinal();
	};

	Promise.prototype.spread = function (didFulfill, didReject) {
	    return this.all()._then(didFulfill, didReject, undefined, APPLY, undefined);
	};

	Promise.prototype.isCancellable = function () {
	    return !this.isResolved() &&
	        this._cancellable();
	};

	Promise.prototype.toJSON = function () {
	    var ret = {
	        isFulfilled: false,
	        isRejected: false,
	        fulfillmentValue: undefined,
	        rejectionReason: undefined
	    };
	    if (this.isFulfilled()) {
	        ret.fulfillmentValue = this.value();
	        ret.isFulfilled = true;
	    } else if (this.isRejected()) {
	        ret.rejectionReason = this.reason();
	        ret.isRejected = true;
	    }
	    return ret;
	};

	Promise.prototype.all = function () {
	    return new PromiseArray(this).promise();
	};

	Promise.prototype.error = function (fn) {
	    return this.caught(util.originatesFromRejection, fn);
	};

	Promise.getNewLibraryCopy = module.exports;

	Promise.is = function (val) {
	    return val instanceof Promise;
	};

	Promise.fromNode = function(fn) {
	    var ret = new Promise(INTERNAL);
	    var result = tryCatch(fn)(nodebackForPromise(ret));
	    if (result === errorObj) {
	        ret._rejectCallback(result.e, true, true);
	    }
	    return ret;
	};

	Promise.all = function (promises) {
	    return new PromiseArray(promises).promise();
	};

	Promise.defer = Promise.pending = function () {
	    var promise = new Promise(INTERNAL);
	    return new PromiseResolver(promise);
	};

	Promise.cast = function (obj) {
	    var ret = tryConvertToPromise(obj);
	    if (!(ret instanceof Promise)) {
	        var val = ret;
	        ret = new Promise(INTERNAL);
	        ret._fulfillUnchecked(val);
	    }
	    return ret;
	};

	Promise.resolve = Promise.fulfilled = Promise.cast;

	Promise.reject = Promise.rejected = function (reason) {
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    ret._rejectCallback(reason, true);
	    return ret;
	};

	Promise.setScheduler = function(fn) {
	    if (typeof fn !== "function") throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    var prev = async._schedule;
	    async._schedule = fn;
	    return prev;
	};

	Promise.prototype._then = function (
	    didFulfill,
	    didReject,
	    didProgress,
	    receiver,
	    internalData
	) {
	    var haveInternalData = internalData !== undefined;
	    var ret = haveInternalData ? internalData : new Promise(INTERNAL);

	    if (!haveInternalData) {
	        ret._propagateFrom(this, 4 | 1);
	        ret._captureStackTrace();
	    }

	    var target = this._target();
	    if (target !== this) {
	        if (receiver === undefined) receiver = this._boundTo;
	        if (!haveInternalData) ret._setIsMigrated();
	    }

	    var callbackIndex = target._addCallbacks(didFulfill,
	                                             didReject,
	                                             didProgress,
	                                             ret,
	                                             receiver,
	                                             getDomain());

	    if (target._isResolved() && !target._isSettlePromisesQueued()) {
	        async.invoke(
	            target._settlePromiseAtPostResolution, target, callbackIndex);
	    }

	    return ret;
	};

	Promise.prototype._settlePromiseAtPostResolution = function (index) {
	    if (this._isRejectionUnhandled()) this._unsetRejectionIsUnhandled();
	    this._settlePromiseAt(index);
	};

	Promise.prototype._length = function () {
	    return this._bitField & 131071;
	};

	Promise.prototype._isFollowingOrFulfilledOrRejected = function () {
	    return (this._bitField & 939524096) > 0;
	};

	Promise.prototype._isFollowing = function () {
	    return (this._bitField & 536870912) === 536870912;
	};

	Promise.prototype._setLength = function (len) {
	    this._bitField = (this._bitField & -131072) |
	        (len & 131071);
	};

	Promise.prototype._setFulfilled = function () {
	    this._bitField = this._bitField | 268435456;
	};

	Promise.prototype._setRejected = function () {
	    this._bitField = this._bitField | 134217728;
	};

	Promise.prototype._setFollowing = function () {
	    this._bitField = this._bitField | 536870912;
	};

	Promise.prototype._setIsFinal = function () {
	    this._bitField = this._bitField | 33554432;
	};

	Promise.prototype._isFinal = function () {
	    return (this._bitField & 33554432) > 0;
	};

	Promise.prototype._cancellable = function () {
	    return (this._bitField & 67108864) > 0;
	};

	Promise.prototype._setCancellable = function () {
	    this._bitField = this._bitField | 67108864;
	};

	Promise.prototype._unsetCancellable = function () {
	    this._bitField = this._bitField & (~67108864);
	};

	Promise.prototype._setIsMigrated = function () {
	    this._bitField = this._bitField | 4194304;
	};

	Promise.prototype._unsetIsMigrated = function () {
	    this._bitField = this._bitField & (~4194304);
	};

	Promise.prototype._isMigrated = function () {
	    return (this._bitField & 4194304) > 0;
	};

	Promise.prototype._receiverAt = function (index) {
	    var ret = index === 0
	        ? this._receiver0
	        : this[
	            index * 5 - 5 + 4];
	    if (ret === UNDEFINED_BINDING) {
	        return undefined;
	    } else if (ret === undefined && this._isBound()) {
	        return this._boundValue();
	    }
	    return ret;
	};

	Promise.prototype._promiseAt = function (index) {
	    return index === 0
	        ? this._promise0
	        : this[index * 5 - 5 + 3];
	};

	Promise.prototype._fulfillmentHandlerAt = function (index) {
	    return index === 0
	        ? this._fulfillmentHandler0
	        : this[index * 5 - 5 + 0];
	};

	Promise.prototype._rejectionHandlerAt = function (index) {
	    return index === 0
	        ? this._rejectionHandler0
	        : this[index * 5 - 5 + 1];
	};

	Promise.prototype._boundValue = function() {
	    var ret = this._boundTo;
	    if (ret !== undefined) {
	        if (ret instanceof Promise) {
	            if (ret.isFulfilled()) {
	                return ret.value();
	            } else {
	                return undefined;
	            }
	        }
	    }
	    return ret;
	};

	Promise.prototype._migrateCallbacks = function (follower, index) {
	    var fulfill = follower._fulfillmentHandlerAt(index);
	    var reject = follower._rejectionHandlerAt(index);
	    var progress = follower._progressHandlerAt(index);
	    var promise = follower._promiseAt(index);
	    var receiver = follower._receiverAt(index);
	    if (promise instanceof Promise) promise._setIsMigrated();
	    if (receiver === undefined) receiver = UNDEFINED_BINDING;
	    this._addCallbacks(fulfill, reject, progress, promise, receiver, null);
	};

	Promise.prototype._addCallbacks = function (
	    fulfill,
	    reject,
	    progress,
	    promise,
	    receiver,
	    domain
	) {
	    var index = this._length();

	    if (index >= 131071 - 5) {
	        index = 0;
	        this._setLength(0);
	    }

	    if (index === 0) {
	        this._promise0 = promise;
	        if (receiver !== undefined) this._receiver0 = receiver;
	        if (typeof fulfill === "function" && !this._isCarryingStackTrace()) {
	            this._fulfillmentHandler0 =
	                domain === null ? fulfill : domain.bind(fulfill);
	        }
	        if (typeof reject === "function") {
	            this._rejectionHandler0 =
	                domain === null ? reject : domain.bind(reject);
	        }
	        if (typeof progress === "function") {
	            this._progressHandler0 =
	                domain === null ? progress : domain.bind(progress);
	        }
	    } else {
	        var base = index * 5 - 5;
	        this[base + 3] = promise;
	        this[base + 4] = receiver;
	        if (typeof fulfill === "function") {
	            this[base + 0] =
	                domain === null ? fulfill : domain.bind(fulfill);
	        }
	        if (typeof reject === "function") {
	            this[base + 1] =
	                domain === null ? reject : domain.bind(reject);
	        }
	        if (typeof progress === "function") {
	            this[base + 2] =
	                domain === null ? progress : domain.bind(progress);
	        }
	    }
	    this._setLength(index + 1);
	    return index;
	};

	Promise.prototype._setProxyHandlers = function (receiver, promiseSlotValue) {
	    var index = this._length();

	    if (index >= 131071 - 5) {
	        index = 0;
	        this._setLength(0);
	    }
	    if (index === 0) {
	        this._promise0 = promiseSlotValue;
	        this._receiver0 = receiver;
	    } else {
	        var base = index * 5 - 5;
	        this[base + 3] = promiseSlotValue;
	        this[base + 4] = receiver;
	    }
	    this._setLength(index + 1);
	};

	Promise.prototype._proxyPromiseArray = function (promiseArray, index) {
	    this._setProxyHandlers(promiseArray, index);
	};

	Promise.prototype._resolveCallback = function(value, shouldBind) {
	    if (this._isFollowingOrFulfilledOrRejected()) return;
	    if (value === this)
	        return this._rejectCallback(makeSelfResolutionError(), false, true);
	    var maybePromise = tryConvertToPromise(value, this);
	    if (!(maybePromise instanceof Promise)) return this._fulfill(value);

	    var propagationFlags = 1 | (shouldBind ? 4 : 0);
	    this._propagateFrom(maybePromise, propagationFlags);
	    var promise = maybePromise._target();
	    if (promise._isPending()) {
	        var len = this._length();
	        for (var i = 0; i < len; ++i) {
	            promise._migrateCallbacks(this, i);
	        }
	        this._setFollowing();
	        this._setLength(0);
	        this._setFollowee(promise);
	    } else if (promise._isFulfilled()) {
	        this._fulfillUnchecked(promise._value());
	    } else {
	        this._rejectUnchecked(promise._reason(),
	            promise._getCarriedStackTrace());
	    }
	};

	Promise.prototype._rejectCallback =
	function(reason, synchronous, shouldNotMarkOriginatingFromRejection) {
	    if (!shouldNotMarkOriginatingFromRejection) {
	        util.markAsOriginatingFromRejection(reason);
	    }
	    var trace = util.ensureErrorObject(reason);
	    var hasStack = trace === reason;
	    this._attachExtraTrace(trace, synchronous ? hasStack : false);
	    this._reject(reason, hasStack ? undefined : trace);
	};

	Promise.prototype._resolveFromResolver = function (resolver) {
	    var promise = this;
	    this._captureStackTrace();
	    this._pushContext();
	    var synchronous = true;
	    var r = tryCatch(resolver)(function(value) {
	        if (promise === null) return;
	        promise._resolveCallback(value);
	        promise = null;
	    }, function (reason) {
	        if (promise === null) return;
	        promise._rejectCallback(reason, synchronous);
	        promise = null;
	    });
	    synchronous = false;
	    this._popContext();

	    if (r !== undefined && r === errorObj && promise !== null) {
	        promise._rejectCallback(r.e, true, true);
	        promise = null;
	    }
	};

	Promise.prototype._settlePromiseFromHandler = function (
	    handler, receiver, value, promise
	) {
	    if (promise._isRejected()) return;
	    promise._pushContext();
	    var x;
	    if (receiver === APPLY && !this._isRejected()) {
	        x = tryCatch(handler).apply(this._boundValue(), value);
	    } else {
	        x = tryCatch(handler).call(receiver, value);
	    }
	    promise._popContext();

	    if (x === errorObj || x === promise || x === NEXT_FILTER) {
	        var err = x === promise ? makeSelfResolutionError() : x.e;
	        promise._rejectCallback(err, false, true);
	    } else {
	        promise._resolveCallback(x);
	    }
	};

	Promise.prototype._target = function() {
	    var ret = this;
	    while (ret._isFollowing()) ret = ret._followee();
	    return ret;
	};

	Promise.prototype._followee = function() {
	    return this._rejectionHandler0;
	};

	Promise.prototype._setFollowee = function(promise) {
	    this._rejectionHandler0 = promise;
	};

	Promise.prototype._cleanValues = function () {
	    if (this._cancellable()) {
	        this._cancellationParent = undefined;
	    }
	};

	Promise.prototype._propagateFrom = function (parent, flags) {
	    if ((flags & 1) > 0 && parent._cancellable()) {
	        this._setCancellable();
	        this._cancellationParent = parent;
	    }
	    if ((flags & 4) > 0 && parent._isBound()) {
	        this._setBoundTo(parent._boundTo);
	    }
	};

	Promise.prototype._fulfill = function (value) {
	    if (this._isFollowingOrFulfilledOrRejected()) return;
	    this._fulfillUnchecked(value);
	};

	Promise.prototype._reject = function (reason, carriedStackTrace) {
	    if (this._isFollowingOrFulfilledOrRejected()) return;
	    this._rejectUnchecked(reason, carriedStackTrace);
	};

	Promise.prototype._settlePromiseAt = function (index) {
	    var promise = this._promiseAt(index);
	    var isPromise = promise instanceof Promise;

	    if (isPromise && promise._isMigrated()) {
	        promise._unsetIsMigrated();
	        return async.invoke(this._settlePromiseAt, this, index);
	    }
	    var handler = this._isFulfilled()
	        ? this._fulfillmentHandlerAt(index)
	        : this._rejectionHandlerAt(index);

	    var carriedStackTrace =
	        this._isCarryingStackTrace() ? this._getCarriedStackTrace() : undefined;
	    var value = this._settledValue;
	    var receiver = this._receiverAt(index);
	    this._clearCallbackDataAtIndex(index);

	    if (typeof handler === "function") {
	        if (!isPromise) {
	            handler.call(receiver, value, promise);
	        } else {
	            this._settlePromiseFromHandler(handler, receiver, value, promise);
	        }
	    } else if (receiver instanceof PromiseArray) {
	        if (!receiver._isResolved()) {
	            if (this._isFulfilled()) {
	                receiver._promiseFulfilled(value, promise);
	            }
	            else {
	                receiver._promiseRejected(value, promise);
	            }
	        }
	    } else if (isPromise) {
	        if (this._isFulfilled()) {
	            promise._fulfill(value);
	        } else {
	            promise._reject(value, carriedStackTrace);
	        }
	    }

	    if (index >= 4 && (index & 31) === 4)
	        async.invokeLater(this._setLength, this, 0);
	};

	Promise.prototype._clearCallbackDataAtIndex = function(index) {
	    if (index === 0) {
	        if (!this._isCarryingStackTrace()) {
	            this._fulfillmentHandler0 = undefined;
	        }
	        this._rejectionHandler0 =
	        this._progressHandler0 =
	        this._receiver0 =
	        this._promise0 = undefined;
	    } else {
	        var base = index * 5 - 5;
	        this[base + 3] =
	        this[base + 4] =
	        this[base + 0] =
	        this[base + 1] =
	        this[base + 2] = undefined;
	    }
	};

	Promise.prototype._isSettlePromisesQueued = function () {
	    return (this._bitField &
	            -1073741824) === -1073741824;
	};

	Promise.prototype._setSettlePromisesQueued = function () {
	    this._bitField = this._bitField | -1073741824;
	};

	Promise.prototype._unsetSettlePromisesQueued = function () {
	    this._bitField = this._bitField & (~-1073741824);
	};

	Promise.prototype._queueSettlePromises = function() {
	    async.settlePromises(this);
	    this._setSettlePromisesQueued();
	};

	Promise.prototype._fulfillUnchecked = function (value) {
	    if (value === this) {
	        var err = makeSelfResolutionError();
	        this._attachExtraTrace(err);
	        return this._rejectUnchecked(err, undefined);
	    }
	    this._setFulfilled();
	    this._settledValue = value;
	    this._cleanValues();

	    if (this._length() > 0) {
	        this._queueSettlePromises();
	    }
	};

	Promise.prototype._rejectUncheckedCheckError = function (reason) {
	    var trace = util.ensureErrorObject(reason);
	    this._rejectUnchecked(reason, trace === reason ? undefined : trace);
	};

	Promise.prototype._rejectUnchecked = function (reason, trace) {
	    if (reason === this) {
	        var err = makeSelfResolutionError();
	        this._attachExtraTrace(err);
	        return this._rejectUnchecked(err);
	    }
	    this._setRejected();
	    this._settledValue = reason;
	    this._cleanValues();

	    if (this._isFinal()) {
	        async.throwLater(function(e) {
	            if ("stack" in e) {
	                async.invokeFirst(
	                    CapturedTrace.unhandledRejection, undefined, e);
	            }
	            throw e;
	        }, trace === undefined ? reason : trace);
	        return;
	    }

	    if (trace !== undefined && trace !== reason) {
	        this._setCarriedStackTrace(trace);
	    }

	    if (this._length() > 0) {
	        this._queueSettlePromises();
	    } else {
	        this._ensurePossibleRejectionHandled();
	    }
	};

	Promise.prototype._settlePromises = function () {
	    this._unsetSettlePromisesQueued();
	    var len = this._length();
	    for (var i = 0; i < len; i++) {
	        this._settlePromiseAt(i);
	    }
	};


	util.notEnumerableProp(Promise,
	                       "_makeSelfResolutionError",
	                       makeSelfResolutionError);

	__webpack_require__(/*! ./progress.js */ 108)(Promise, PromiseArray);
	__webpack_require__(/*! ./method.js */ 109)(Promise, INTERNAL, tryConvertToPromise, apiRejection);
	__webpack_require__(/*! ./bind.js */ 110)(Promise, INTERNAL, tryConvertToPromise);
	__webpack_require__(/*! ./finally.js */ 111)(Promise, NEXT_FILTER, tryConvertToPromise);
	__webpack_require__(/*! ./direct_resolve.js */ 112)(Promise);
	__webpack_require__(/*! ./synchronous_inspection.js */ 113)(Promise);
	__webpack_require__(/*! ./join.js */ 114)(Promise, PromiseArray, tryConvertToPromise, INTERNAL);
	Promise.version = "2.11.0";
	Promise.Promise = Promise;
	__webpack_require__(/*! ./map.js */ 115)(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
	__webpack_require__(/*! ./cancel.js */ 116)(Promise);
	__webpack_require__(/*! ./using.js */ 117)(Promise, apiRejection, tryConvertToPromise, createContext);
	__webpack_require__(/*! ./generators.js */ 118)(Promise, apiRejection, INTERNAL, tryConvertToPromise);
	__webpack_require__(/*! ./nodeify.js */ 119)(Promise);
	__webpack_require__(/*! ./call_get.js */ 120)(Promise);
	__webpack_require__(/*! ./props.js */ 121)(Promise, PromiseArray, tryConvertToPromise, apiRejection);
	__webpack_require__(/*! ./race.js */ 122)(Promise, INTERNAL, tryConvertToPromise, apiRejection);
	__webpack_require__(/*! ./reduce.js */ 123)(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
	__webpack_require__(/*! ./settle.js */ 124)(Promise, PromiseArray);
	__webpack_require__(/*! ./some.js */ 125)(Promise, PromiseArray, apiRejection);
	__webpack_require__(/*! ./promisify.js */ 126)(Promise, INTERNAL);
	__webpack_require__(/*! ./any.js */ 127)(Promise);
	__webpack_require__(/*! ./each.js */ 128)(Promise, INTERNAL);
	__webpack_require__(/*! ./timers.js */ 129)(Promise, INTERNAL);
	__webpack_require__(/*! ./filter.js */ 130)(Promise, INTERNAL);
	                                                         
	    util.toFastProperties(Promise);                                          
	    util.toFastProperties(Promise.prototype);                                
	    function fillTypes(value) {                                              
	        var p = new Promise(INTERNAL);                                       
	        p._fulfillmentHandler0 = value;                                      
	        p._rejectionHandler0 = value;                                        
	        p._progressHandler0 = value;                                         
	        p._promise0 = value;                                                 
	        p._receiver0 = value;                                                
	        p._settledValue = value;                                             
	    }                                                                        
	    // Complete slack tracking, opt out of field-type tracking and           
	    // stabilize map                                                         
	    fillTypes({a: 1});                                                       
	    fillTypes({b: 2});                                                       
	    fillTypes({c: 3});                                                       
	    fillTypes(1);                                                            
	    fillTypes(function(){});                                                 
	    fillTypes(undefined);                                                    
	    fillTypes(false);                                                        
	    fillTypes(new Promise(INTERNAL));                                        
	    CapturedTrace.setBounds(async.firstLineError, util.lastLineError);       
	    return Promise;                                                          

	};


/***/ },
/* 95 */
/*!************************************!*\
  !*** ./~/bluebird/js/main/util.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var es5 = __webpack_require__(/*! ./es5.js */ 96);
	var canEvaluate = typeof navigator == "undefined";
	var haveGetters = (function(){
	    try {
	        var o = {};
	        es5.defineProperty(o, "f", {
	            get: function () {
	                return 3;
	            }
	        });
	        return o.f === 3;
	    }
	    catch (e) {
	        return false;
	    }

	})();

	var errorObj = {e: {}};
	var tryCatchTarget;
	function tryCatcher() {
	    try {
	        var target = tryCatchTarget;
	        tryCatchTarget = null;
	        return target.apply(this, arguments);
	    } catch (e) {
	        errorObj.e = e;
	        return errorObj;
	    }
	}
	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}

	var inherits = function(Child, Parent) {
	    var hasProp = {}.hasOwnProperty;

	    function T() {
	        this.constructor = Child;
	        this.constructor$ = Parent;
	        for (var propertyName in Parent.prototype) {
	            if (hasProp.call(Parent.prototype, propertyName) &&
	                propertyName.charAt(propertyName.length-1) !== "$"
	           ) {
	                this[propertyName + "$"] = Parent.prototype[propertyName];
	            }
	        }
	    }
	    T.prototype = Parent.prototype;
	    Child.prototype = new T();
	    return Child.prototype;
	};


	function isPrimitive(val) {
	    return val == null || val === true || val === false ||
	        typeof val === "string" || typeof val === "number";

	}

	function isObject(value) {
	    return !isPrimitive(value);
	}

	function maybeWrapAsError(maybeError) {
	    if (!isPrimitive(maybeError)) return maybeError;

	    return new Error(safeToString(maybeError));
	}

	function withAppended(target, appendee) {
	    var len = target.length;
	    var ret = new Array(len + 1);
	    var i;
	    for (i = 0; i < len; ++i) {
	        ret[i] = target[i];
	    }
	    ret[i] = appendee;
	    return ret;
	}

	function getDataPropertyOrDefault(obj, key, defaultValue) {
	    if (es5.isES5) {
	        var desc = Object.getOwnPropertyDescriptor(obj, key);

	        if (desc != null) {
	            return desc.get == null && desc.set == null
	                    ? desc.value
	                    : defaultValue;
	        }
	    } else {
	        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
	    }
	}

	function notEnumerableProp(obj, name, value) {
	    if (isPrimitive(obj)) return obj;
	    var descriptor = {
	        value: value,
	        configurable: true,
	        enumerable: false,
	        writable: true
	    };
	    es5.defineProperty(obj, name, descriptor);
	    return obj;
	}

	function thrower(r) {
	    throw r;
	}

	var inheritedDataKeys = (function() {
	    var excludedPrototypes = [
	        Array.prototype,
	        Object.prototype,
	        Function.prototype
	    ];

	    var isExcludedProto = function(val) {
	        for (var i = 0; i < excludedPrototypes.length; ++i) {
	            if (excludedPrototypes[i] === val) {
	                return true;
	            }
	        }
	        return false;
	    };

	    if (es5.isES5) {
	        var getKeys = Object.getOwnPropertyNames;
	        return function(obj) {
	            var ret = [];
	            var visitedKeys = Object.create(null);
	            while (obj != null && !isExcludedProto(obj)) {
	                var keys;
	                try {
	                    keys = getKeys(obj);
	                } catch (e) {
	                    return ret;
	                }
	                for (var i = 0; i < keys.length; ++i) {
	                    var key = keys[i];
	                    if (visitedKeys[key]) continue;
	                    visitedKeys[key] = true;
	                    var desc = Object.getOwnPropertyDescriptor(obj, key);
	                    if (desc != null && desc.get == null && desc.set == null) {
	                        ret.push(key);
	                    }
	                }
	                obj = es5.getPrototypeOf(obj);
	            }
	            return ret;
	        };
	    } else {
	        var hasProp = {}.hasOwnProperty;
	        return function(obj) {
	            if (isExcludedProto(obj)) return [];
	            var ret = [];

	            /*jshint forin:false */
	            enumeration: for (var key in obj) {
	                if (hasProp.call(obj, key)) {
	                    ret.push(key);
	                } else {
	                    for (var i = 0; i < excludedPrototypes.length; ++i) {
	                        if (hasProp.call(excludedPrototypes[i], key)) {
	                            continue enumeration;
	                        }
	                    }
	                    ret.push(key);
	                }
	            }
	            return ret;
	        };
	    }

	})();

	var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
	function isClass(fn) {
	    try {
	        if (typeof fn === "function") {
	            var keys = es5.names(fn.prototype);

	            var hasMethods = es5.isES5 && keys.length > 1;
	            var hasMethodsOtherThanConstructor = keys.length > 0 &&
	                !(keys.length === 1 && keys[0] === "constructor");
	            var hasThisAssignmentAndStaticMethods =
	                thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;

	            if (hasMethods || hasMethodsOtherThanConstructor ||
	                hasThisAssignmentAndStaticMethods) {
	                return true;
	            }
	        }
	        return false;
	    } catch (e) {
	        return false;
	    }
	}

	function toFastProperties(obj) {
	    /*jshint -W027,-W055,-W031*/
	    function f() {}
	    f.prototype = obj;
	    var l = 8;
	    while (l--) new f();
	    return obj;
	    eval(obj);
	}

	var rident = /^[a-z$_][a-z$_0-9]*$/i;
	function isIdentifier(str) {
	    return rident.test(str);
	}

	function filledRange(count, prefix, suffix) {
	    var ret = new Array(count);
	    for(var i = 0; i < count; ++i) {
	        ret[i] = prefix + i + suffix;
	    }
	    return ret;
	}

	function safeToString(obj) {
	    try {
	        return obj + "";
	    } catch (e) {
	        return "[no string representation]";
	    }
	}

	function markAsOriginatingFromRejection(e) {
	    try {
	        notEnumerableProp(e, "isOperational", true);
	    }
	    catch(ignore) {}
	}

	function originatesFromRejection(e) {
	    if (e == null) return false;
	    return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
	        e["isOperational"] === true);
	}

	function canAttachTrace(obj) {
	    return obj instanceof Error && es5.propertyIsWritable(obj, "stack");
	}

	var ensureErrorObject = (function() {
	    if (!("stack" in new Error())) {
	        return function(value) {
	            if (canAttachTrace(value)) return value;
	            try {throw new Error(safeToString(value));}
	            catch(err) {return err;}
	        };
	    } else {
	        return function(value) {
	            if (canAttachTrace(value)) return value;
	            return new Error(safeToString(value));
	        };
	    }
	})();

	function classString(obj) {
	    return {}.toString.call(obj);
	}

	function copyDescriptors(from, to, filter) {
	    var keys = es5.names(from);
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        if (filter(key)) {
	            try {
	                es5.defineProperty(to, key, es5.getDescriptor(from, key));
	            } catch (ignore) {}
	        }
	    }
	}

	var ret = {
	    isClass: isClass,
	    isIdentifier: isIdentifier,
	    inheritedDataKeys: inheritedDataKeys,
	    getDataPropertyOrDefault: getDataPropertyOrDefault,
	    thrower: thrower,
	    isArray: es5.isArray,
	    haveGetters: haveGetters,
	    notEnumerableProp: notEnumerableProp,
	    isPrimitive: isPrimitive,
	    isObject: isObject,
	    canEvaluate: canEvaluate,
	    errorObj: errorObj,
	    tryCatch: tryCatch,
	    inherits: inherits,
	    withAppended: withAppended,
	    maybeWrapAsError: maybeWrapAsError,
	    toFastProperties: toFastProperties,
	    filledRange: filledRange,
	    toString: safeToString,
	    canAttachTrace: canAttachTrace,
	    ensureErrorObject: ensureErrorObject,
	    originatesFromRejection: originatesFromRejection,
	    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
	    classString: classString,
	    copyDescriptors: copyDescriptors,
	    hasDevTools: typeof chrome !== "undefined" && chrome &&
	                 typeof chrome.loadTimes === "function",
	    isNode: typeof process !== "undefined" &&
	        classString(process).toLowerCase() === "[object process]"
	};
	ret.isRecentNode = ret.isNode && (function() {
	    var version = process.versions.node.split(".").map(Number);
	    return (version[0] === 0 && version[1] > 10) || (version[0] > 0);
	})();

	if (ret.isNode) ret.toFastProperties(process);

	try {throw new Error(); } catch (e) {ret.lastLineError = e;}
	module.exports = ret;


/***/ },
/* 96 */
/*!***********************************!*\
  !*** ./~/bluebird/js/main/es5.js ***!
  \***********************************/
/***/ function(module, exports) {

	var isES5 = (function(){
	    "use strict";
	    return this === undefined;
	})();

	if (isES5) {
	    module.exports = {
	        freeze: Object.freeze,
	        defineProperty: Object.defineProperty,
	        getDescriptor: Object.getOwnPropertyDescriptor,
	        keys: Object.keys,
	        names: Object.getOwnPropertyNames,
	        getPrototypeOf: Object.getPrototypeOf,
	        isArray: Array.isArray,
	        isES5: isES5,
	        propertyIsWritable: function(obj, prop) {
	            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
	            return !!(!descriptor || descriptor.writable || descriptor.set);
	        }
	    };
	} else {
	    var has = {}.hasOwnProperty;
	    var str = {}.toString;
	    var proto = {}.constructor.prototype;

	    var ObjectKeys = function (o) {
	        var ret = [];
	        for (var key in o) {
	            if (has.call(o, key)) {
	                ret.push(key);
	            }
	        }
	        return ret;
	    };

	    var ObjectGetDescriptor = function(o, key) {
	        return {value: o[key]};
	    };

	    var ObjectDefineProperty = function (o, key, desc) {
	        o[key] = desc.value;
	        return o;
	    };

	    var ObjectFreeze = function (obj) {
	        return obj;
	    };

	    var ObjectGetPrototypeOf = function (obj) {
	        try {
	            return Object(obj).constructor.prototype;
	        }
	        catch (e) {
	            return proto;
	        }
	    };

	    var ArrayIsArray = function (obj) {
	        try {
	            return str.call(obj) === "[object Array]";
	        }
	        catch(e) {
	            return false;
	        }
	    };

	    module.exports = {
	        isArray: ArrayIsArray,
	        keys: ObjectKeys,
	        names: ObjectKeys,
	        defineProperty: ObjectDefineProperty,
	        getDescriptor: ObjectGetDescriptor,
	        freeze: ObjectFreeze,
	        getPrototypeOf: ObjectGetPrototypeOf,
	        isES5: isES5,
	        propertyIsWritable: function() {
	            return true;
	        }
	    };
	}


/***/ },
/* 97 */
/*!*************************************!*\
  !*** ./~/bluebird/js/main/async.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var firstLineError;
	try {throw new Error(); } catch (e) {firstLineError = e;}
	var schedule = __webpack_require__(/*! ./schedule.js */ 98);
	var Queue = __webpack_require__(/*! ./queue.js */ 99);
	var util = __webpack_require__(/*! ./util.js */ 95);

	function Async() {
	    this._isTickUsed = false;
	    this._lateQueue = new Queue(16);
	    this._normalQueue = new Queue(16);
	    this._trampolineEnabled = true;
	    var self = this;
	    this.drainQueues = function () {
	        self._drainQueues();
	    };
	    this._schedule =
	        schedule.isStatic ? schedule(this.drainQueues) : schedule;
	}

	Async.prototype.disableTrampolineIfNecessary = function() {
	    if (util.hasDevTools) {
	        this._trampolineEnabled = false;
	    }
	};

	Async.prototype.enableTrampoline = function() {
	    if (!this._trampolineEnabled) {
	        this._trampolineEnabled = true;
	        this._schedule = function(fn) {
	            setTimeout(fn, 0);
	        };
	    }
	};

	Async.prototype.haveItemsQueued = function () {
	    return this._normalQueue.length() > 0;
	};

	Async.prototype.throwLater = function(fn, arg) {
	    if (arguments.length === 1) {
	        arg = fn;
	        fn = function () { throw arg; };
	    }
	    if (typeof setTimeout !== "undefined") {
	        setTimeout(function() {
	            fn(arg);
	        }, 0);
	    } else try {
	        this._schedule(function() {
	            fn(arg);
	        });
	    } catch (e) {
	        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
	    }
	};

	function AsyncInvokeLater(fn, receiver, arg) {
	    this._lateQueue.push(fn, receiver, arg);
	    this._queueTick();
	}

	function AsyncInvoke(fn, receiver, arg) {
	    this._normalQueue.push(fn, receiver, arg);
	    this._queueTick();
	}

	function AsyncSettlePromises(promise) {
	    this._normalQueue._pushOne(promise);
	    this._queueTick();
	}

	if (!util.hasDevTools) {
	    Async.prototype.invokeLater = AsyncInvokeLater;
	    Async.prototype.invoke = AsyncInvoke;
	    Async.prototype.settlePromises = AsyncSettlePromises;
	} else {
	    if (schedule.isStatic) {
	        schedule = function(fn) { setTimeout(fn, 0); };
	    }
	    Async.prototype.invokeLater = function (fn, receiver, arg) {
	        if (this._trampolineEnabled) {
	            AsyncInvokeLater.call(this, fn, receiver, arg);
	        } else {
	            this._schedule(function() {
	                setTimeout(function() {
	                    fn.call(receiver, arg);
	                }, 100);
	            });
	        }
	    };

	    Async.prototype.invoke = function (fn, receiver, arg) {
	        if (this._trampolineEnabled) {
	            AsyncInvoke.call(this, fn, receiver, arg);
	        } else {
	            this._schedule(function() {
	                fn.call(receiver, arg);
	            });
	        }
	    };

	    Async.prototype.settlePromises = function(promise) {
	        if (this._trampolineEnabled) {
	            AsyncSettlePromises.call(this, promise);
	        } else {
	            this._schedule(function() {
	                promise._settlePromises();
	            });
	        }
	    };
	}

	Async.prototype.invokeFirst = function (fn, receiver, arg) {
	    this._normalQueue.unshift(fn, receiver, arg);
	    this._queueTick();
	};

	Async.prototype._drainQueue = function(queue) {
	    while (queue.length() > 0) {
	        var fn = queue.shift();
	        if (typeof fn !== "function") {
	            fn._settlePromises();
	            continue;
	        }
	        var receiver = queue.shift();
	        var arg = queue.shift();
	        fn.call(receiver, arg);
	    }
	};

	Async.prototype._drainQueues = function () {
	    this._drainQueue(this._normalQueue);
	    this._reset();
	    this._drainQueue(this._lateQueue);
	};

	Async.prototype._queueTick = function () {
	    if (!this._isTickUsed) {
	        this._isTickUsed = true;
	        this._schedule(this.drainQueues);
	    }
	};

	Async.prototype._reset = function () {
	    this._isTickUsed = false;
	};

	module.exports = new Async();
	module.exports.firstLineError = firstLineError;


/***/ },
/* 98 */
/*!****************************************!*\
  !*** ./~/bluebird/js/main/schedule.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var schedule;
	var util = __webpack_require__(/*! ./util */ 95);
	var noAsyncScheduler = function() {
	    throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
	};
	if (util.isNode && typeof MutationObserver === "undefined") {
	    var GlobalSetImmediate = global.setImmediate;
	    var ProcessNextTick = process.nextTick;
	    schedule = util.isRecentNode
	                ? function(fn) { GlobalSetImmediate.call(global, fn); }
	                : function(fn) { ProcessNextTick.call(process, fn); };
	} else if ((typeof MutationObserver !== "undefined") &&
	          !(typeof window !== "undefined" &&
	            window.navigator &&
	            window.navigator.standalone)) {
	    schedule = function(fn) {
	        var div = document.createElement("div");
	        var observer = new MutationObserver(fn);
	        observer.observe(div, {attributes: true});
	        return function() { div.classList.toggle("foo"); };
	    };
	    schedule.isStatic = true;
	} else if (typeof setImmediate !== "undefined") {
	    schedule = function (fn) {
	        setImmediate(fn);
	    };
	} else if (typeof setTimeout !== "undefined") {
	    schedule = function (fn) {
	        setTimeout(fn, 0);
	    };
	} else {
	    schedule = noAsyncScheduler;
	}
	module.exports = schedule;


/***/ },
/* 99 */
/*!*************************************!*\
  !*** ./~/bluebird/js/main/queue.js ***!
  \*************************************/
/***/ function(module, exports) {

	"use strict";
	function arrayMove(src, srcIndex, dst, dstIndex, len) {
	    for (var j = 0; j < len; ++j) {
	        dst[j + dstIndex] = src[j + srcIndex];
	        src[j + srcIndex] = void 0;
	    }
	}

	function Queue(capacity) {
	    this._capacity = capacity;
	    this._length = 0;
	    this._front = 0;
	}

	Queue.prototype._willBeOverCapacity = function (size) {
	    return this._capacity < size;
	};

	Queue.prototype._pushOne = function (arg) {
	    var length = this.length();
	    this._checkCapacity(length + 1);
	    var i = (this._front + length) & (this._capacity - 1);
	    this[i] = arg;
	    this._length = length + 1;
	};

	Queue.prototype._unshiftOne = function(value) {
	    var capacity = this._capacity;
	    this._checkCapacity(this.length() + 1);
	    var front = this._front;
	    var i = (((( front - 1 ) &
	                    ( capacity - 1) ) ^ capacity ) - capacity );
	    this[i] = value;
	    this._front = i;
	    this._length = this.length() + 1;
	};

	Queue.prototype.unshift = function(fn, receiver, arg) {
	    this._unshiftOne(arg);
	    this._unshiftOne(receiver);
	    this._unshiftOne(fn);
	};

	Queue.prototype.push = function (fn, receiver, arg) {
	    var length = this.length() + 3;
	    if (this._willBeOverCapacity(length)) {
	        this._pushOne(fn);
	        this._pushOne(receiver);
	        this._pushOne(arg);
	        return;
	    }
	    var j = this._front + length - 3;
	    this._checkCapacity(length);
	    var wrapMask = this._capacity - 1;
	    this[(j + 0) & wrapMask] = fn;
	    this[(j + 1) & wrapMask] = receiver;
	    this[(j + 2) & wrapMask] = arg;
	    this._length = length;
	};

	Queue.prototype.shift = function () {
	    var front = this._front,
	        ret = this[front];

	    this[front] = undefined;
	    this._front = (front + 1) & (this._capacity - 1);
	    this._length--;
	    return ret;
	};

	Queue.prototype.length = function () {
	    return this._length;
	};

	Queue.prototype._checkCapacity = function (size) {
	    if (this._capacity < size) {
	        this._resizeTo(this._capacity << 1);
	    }
	};

	Queue.prototype._resizeTo = function (capacity) {
	    var oldCapacity = this._capacity;
	    this._capacity = capacity;
	    var front = this._front;
	    var length = this._length;
	    var moveItemsCount = (front + length) & (oldCapacity - 1);
	    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
	};

	module.exports = Queue;


/***/ },
/* 100 */
/*!**************************************!*\
  !*** ./~/bluebird/js/main/errors.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var es5 = __webpack_require__(/*! ./es5.js */ 96);
	var Objectfreeze = es5.freeze;
	var util = __webpack_require__(/*! ./util.js */ 95);
	var inherits = util.inherits;
	var notEnumerableProp = util.notEnumerableProp;

	function subError(nameProperty, defaultMessage) {
	    function SubError(message) {
	        if (!(this instanceof SubError)) return new SubError(message);
	        notEnumerableProp(this, "message",
	            typeof message === "string" ? message : defaultMessage);
	        notEnumerableProp(this, "name", nameProperty);
	        if (Error.captureStackTrace) {
	            Error.captureStackTrace(this, this.constructor);
	        } else {
	            Error.call(this);
	        }
	    }
	    inherits(SubError, Error);
	    return SubError;
	}

	var _TypeError, _RangeError;
	var Warning = subError("Warning", "warning");
	var CancellationError = subError("CancellationError", "cancellation error");
	var TimeoutError = subError("TimeoutError", "timeout error");
	var AggregateError = subError("AggregateError", "aggregate error");
	try {
	    _TypeError = TypeError;
	    _RangeError = RangeError;
	} catch(e) {
	    _TypeError = subError("TypeError", "type error");
	    _RangeError = subError("RangeError", "range error");
	}

	var methods = ("join pop push shift unshift slice filter forEach some " +
	    "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");

	for (var i = 0; i < methods.length; ++i) {
	    if (typeof Array.prototype[methods[i]] === "function") {
	        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
	    }
	}

	es5.defineProperty(AggregateError.prototype, "length", {
	    value: 0,
	    configurable: false,
	    writable: true,
	    enumerable: true
	});
	AggregateError.prototype["isOperational"] = true;
	var level = 0;
	AggregateError.prototype.toString = function() {
	    var indent = Array(level * 4 + 1).join(" ");
	    var ret = "\n" + indent + "AggregateError of:" + "\n";
	    level++;
	    indent = Array(level * 4 + 1).join(" ");
	    for (var i = 0; i < this.length; ++i) {
	        var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
	        var lines = str.split("\n");
	        for (var j = 0; j < lines.length; ++j) {
	            lines[j] = indent + lines[j];
	        }
	        str = lines.join("\n");
	        ret += str + "\n";
	    }
	    level--;
	    return ret;
	};

	function OperationalError(message) {
	    if (!(this instanceof OperationalError))
	        return new OperationalError(message);
	    notEnumerableProp(this, "name", "OperationalError");
	    notEnumerableProp(this, "message", message);
	    this.cause = message;
	    this["isOperational"] = true;

	    if (message instanceof Error) {
	        notEnumerableProp(this, "message", message.message);
	        notEnumerableProp(this, "stack", message.stack);
	    } else if (Error.captureStackTrace) {
	        Error.captureStackTrace(this, this.constructor);
	    }

	}
	inherits(OperationalError, Error);

	var errorTypes = Error["__BluebirdErrorTypes__"];
	if (!errorTypes) {
	    errorTypes = Objectfreeze({
	        CancellationError: CancellationError,
	        TimeoutError: TimeoutError,
	        OperationalError: OperationalError,
	        RejectionError: OperationalError,
	        AggregateError: AggregateError
	    });
	    notEnumerableProp(Error, "__BluebirdErrorTypes__", errorTypes);
	}

	module.exports = {
	    Error: Error,
	    TypeError: _TypeError,
	    RangeError: _RangeError,
	    CancellationError: errorTypes.CancellationError,
	    OperationalError: errorTypes.OperationalError,
	    TimeoutError: errorTypes.TimeoutError,
	    AggregateError: errorTypes.AggregateError,
	    Warning: Warning
	};


/***/ },
/* 101 */
/*!*****************************************!*\
  !*** ./~/bluebird/js/main/thenables.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var util = __webpack_require__(/*! ./util.js */ 95);
	var errorObj = util.errorObj;
	var isObject = util.isObject;

	function tryConvertToPromise(obj, context) {
	    if (isObject(obj)) {
	        if (obj instanceof Promise) {
	            return obj;
	        }
	        else if (isAnyBluebirdPromise(obj)) {
	            var ret = new Promise(INTERNAL);
	            obj._then(
	                ret._fulfillUnchecked,
	                ret._rejectUncheckedCheckError,
	                ret._progressUnchecked,
	                ret,
	                null
	            );
	            return ret;
	        }
	        var then = util.tryCatch(getThen)(obj);
	        if (then === errorObj) {
	            if (context) context._pushContext();
	            var ret = Promise.reject(then.e);
	            if (context) context._popContext();
	            return ret;
	        } else if (typeof then === "function") {
	            return doThenable(obj, then, context);
	        }
	    }
	    return obj;
	}

	function getThen(obj) {
	    return obj.then;
	}

	var hasProp = {}.hasOwnProperty;
	function isAnyBluebirdPromise(obj) {
	    return hasProp.call(obj, "_promise0");
	}

	function doThenable(x, then, context) {
	    var promise = new Promise(INTERNAL);
	    var ret = promise;
	    if (context) context._pushContext();
	    promise._captureStackTrace();
	    if (context) context._popContext();
	    var synchronous = true;
	    var result = util.tryCatch(then).call(x,
	                                        resolveFromThenable,
	                                        rejectFromThenable,
	                                        progressFromThenable);
	    synchronous = false;
	    if (promise && result === errorObj) {
	        promise._rejectCallback(result.e, true, true);
	        promise = null;
	    }

	    function resolveFromThenable(value) {
	        if (!promise) return;
	        promise._resolveCallback(value);
	        promise = null;
	    }

	    function rejectFromThenable(reason) {
	        if (!promise) return;
	        promise._rejectCallback(reason, synchronous, true);
	        promise = null;
	    }

	    function progressFromThenable(value) {
	        if (!promise) return;
	        if (typeof promise._progress === "function") {
	            promise._progress(value);
	        }
	    }
	    return ret;
	}

	return tryConvertToPromise;
	};


/***/ },
/* 102 */
/*!*********************************************!*\
  !*** ./~/bluebird/js/main/promise_array.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(Promise, INTERNAL, tryConvertToPromise,
	    apiRejection) {
	var util = __webpack_require__(/*! ./util.js */ 95);
	var isArray = util.isArray;

	function toResolutionValue(val) {
	    switch(val) {
	    case -2: return [];
	    case -3: return {};
	    }
	}

	function PromiseArray(values) {
	    var promise = this._promise = new Promise(INTERNAL);
	    var parent;
	    if (values instanceof Promise) {
	        parent = values;
	        promise._propagateFrom(parent, 1 | 4);
	    }
	    this._values = values;
	    this._length = 0;
	    this._totalResolved = 0;
	    this._init(undefined, -2);
	}
	PromiseArray.prototype.length = function () {
	    return this._length;
	};

	PromiseArray.prototype.promise = function () {
	    return this._promise;
	};

	PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
	    var values = tryConvertToPromise(this._values, this._promise);
	    if (values instanceof Promise) {
	        values = values._target();
	        this._values = values;
	        if (values._isFulfilled()) {
	            values = values._value();
	            if (!isArray(values)) {
	                var err = new Promise.TypeError("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
	                this.__hardReject__(err);
	                return;
	            }
	        } else if (values._isPending()) {
	            values._then(
	                init,
	                this._reject,
	                undefined,
	                this,
	                resolveValueIfEmpty
	           );
	            return;
	        } else {
	            this._reject(values._reason());
	            return;
	        }
	    } else if (!isArray(values)) {
	        this._promise._reject(apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a")._reason());
	        return;
	    }

	    if (values.length === 0) {
	        if (resolveValueIfEmpty === -5) {
	            this._resolveEmptyArray();
	        }
	        else {
	            this._resolve(toResolutionValue(resolveValueIfEmpty));
	        }
	        return;
	    }
	    var len = this.getActualLength(values.length);
	    this._length = len;
	    this._values = this.shouldCopyValues() ? new Array(len) : this._values;
	    var promise = this._promise;
	    for (var i = 0; i < len; ++i) {
	        var isResolved = this._isResolved();
	        var maybePromise = tryConvertToPromise(values[i], promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            if (isResolved) {
	                maybePromise._ignoreRejections();
	            } else if (maybePromise._isPending()) {
	                maybePromise._proxyPromiseArray(this, i);
	            } else if (maybePromise._isFulfilled()) {
	                this._promiseFulfilled(maybePromise._value(), i);
	            } else {
	                this._promiseRejected(maybePromise._reason(), i);
	            }
	        } else if (!isResolved) {
	            this._promiseFulfilled(maybePromise, i);
	        }
	    }
	};

	PromiseArray.prototype._isResolved = function () {
	    return this._values === null;
	};

	PromiseArray.prototype._resolve = function (value) {
	    this._values = null;
	    this._promise._fulfill(value);
	};

	PromiseArray.prototype.__hardReject__ =
	PromiseArray.prototype._reject = function (reason) {
	    this._values = null;
	    this._promise._rejectCallback(reason, false, true);
	};

	PromiseArray.prototype._promiseProgressed = function (progressValue, index) {
	    this._promise._progress({
	        index: index,
	        value: progressValue
	    });
	};


	PromiseArray.prototype._promiseFulfilled = function (value, index) {
	    this._values[index] = value;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        this._resolve(this._values);
	    }
	};

	PromiseArray.prototype._promiseRejected = function (reason, index) {
	    this._totalResolved++;
	    this._reject(reason);
	};

	PromiseArray.prototype.shouldCopyValues = function () {
	    return true;
	};

	PromiseArray.prototype.getActualLength = function (len) {
	    return len;
	};

	return PromiseArray;
	};


/***/ },
/* 103 */
/*!**********************************************!*\
  !*** ./~/bluebird/js/main/captured_trace.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function() {
	var async = __webpack_require__(/*! ./async.js */ 97);
	var util = __webpack_require__(/*! ./util.js */ 95);
	var bluebirdFramePattern =
	    /[\\\/]bluebird[\\\/]js[\\\/](main|debug|zalgo|instrumented)/;
	var stackFramePattern = null;
	var formatStack = null;
	var indentStackFrames = false;
	var warn;

	function CapturedTrace(parent) {
	    this._parent = parent;
	    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
	    captureStackTrace(this, CapturedTrace);
	    if (length > 32) this.uncycle();
	}
	util.inherits(CapturedTrace, Error);

	CapturedTrace.prototype.uncycle = function() {
	    var length = this._length;
	    if (length < 2) return;
	    var nodes = [];
	    var stackToIndex = {};

	    for (var i = 0, node = this; node !== undefined; ++i) {
	        nodes.push(node);
	        node = node._parent;
	    }
	    length = this._length = i;
	    for (var i = length - 1; i >= 0; --i) {
	        var stack = nodes[i].stack;
	        if (stackToIndex[stack] === undefined) {
	            stackToIndex[stack] = i;
	        }
	    }
	    for (var i = 0; i < length; ++i) {
	        var currentStack = nodes[i].stack;
	        var index = stackToIndex[currentStack];
	        if (index !== undefined && index !== i) {
	            if (index > 0) {
	                nodes[index - 1]._parent = undefined;
	                nodes[index - 1]._length = 1;
	            }
	            nodes[i]._parent = undefined;
	            nodes[i]._length = 1;
	            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;

	            if (index < length - 1) {
	                cycleEdgeNode._parent = nodes[index + 1];
	                cycleEdgeNode._parent.uncycle();
	                cycleEdgeNode._length =
	                    cycleEdgeNode._parent._length + 1;
	            } else {
	                cycleEdgeNode._parent = undefined;
	                cycleEdgeNode._length = 1;
	            }
	            var currentChildLength = cycleEdgeNode._length + 1;
	            for (var j = i - 2; j >= 0; --j) {
	                nodes[j]._length = currentChildLength;
	                currentChildLength++;
	            }
	            return;
	        }
	    }
	};

	CapturedTrace.prototype.parent = function() {
	    return this._parent;
	};

	CapturedTrace.prototype.hasParent = function() {
	    return this._parent !== undefined;
	};

	CapturedTrace.prototype.attachExtraTrace = function(error) {
	    if (error.__stackCleaned__) return;
	    this.uncycle();
	    var parsed = CapturedTrace.parseStackAndMessage(error);
	    var message = parsed.message;
	    var stacks = [parsed.stack];

	    var trace = this;
	    while (trace !== undefined) {
	        stacks.push(cleanStack(trace.stack.split("\n")));
	        trace = trace._parent;
	    }
	    removeCommonRoots(stacks);
	    removeDuplicateOrEmptyJumps(stacks);
	    util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
	    util.notEnumerableProp(error, "__stackCleaned__", true);
	};

	function reconstructStack(message, stacks) {
	    for (var i = 0; i < stacks.length - 1; ++i) {
	        stacks[i].push("From previous event:");
	        stacks[i] = stacks[i].join("\n");
	    }
	    if (i < stacks.length) {
	        stacks[i] = stacks[i].join("\n");
	    }
	    return message + "\n" + stacks.join("\n");
	}

	function removeDuplicateOrEmptyJumps(stacks) {
	    for (var i = 0; i < stacks.length; ++i) {
	        if (stacks[i].length === 0 ||
	            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {
	            stacks.splice(i, 1);
	            i--;
	        }
	    }
	}

	function removeCommonRoots(stacks) {
	    var current = stacks[0];
	    for (var i = 1; i < stacks.length; ++i) {
	        var prev = stacks[i];
	        var currentLastIndex = current.length - 1;
	        var currentLastLine = current[currentLastIndex];
	        var commonRootMeetPoint = -1;

	        for (var j = prev.length - 1; j >= 0; --j) {
	            if (prev[j] === currentLastLine) {
	                commonRootMeetPoint = j;
	                break;
	            }
	        }

	        for (var j = commonRootMeetPoint; j >= 0; --j) {
	            var line = prev[j];
	            if (current[currentLastIndex] === line) {
	                current.pop();
	                currentLastIndex--;
	            } else {
	                break;
	            }
	        }
	        current = prev;
	    }
	}

	function cleanStack(stack) {
	    var ret = [];
	    for (var i = 0; i < stack.length; ++i) {
	        var line = stack[i];
	        var isTraceLine = stackFramePattern.test(line) ||
	            "    (No stack trace)" === line;
	        var isInternalFrame = isTraceLine && shouldIgnore(line);
	        if (isTraceLine && !isInternalFrame) {
	            if (indentStackFrames && line.charAt(0) !== " ") {
	                line = "    " + line;
	            }
	            ret.push(line);
	        }
	    }
	    return ret;
	}

	function stackFramesAsArray(error) {
	    var stack = error.stack.replace(/\s+$/g, "").split("\n");
	    for (var i = 0; i < stack.length; ++i) {
	        var line = stack[i];
	        if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
	            break;
	        }
	    }
	    if (i > 0) {
	        stack = stack.slice(i);
	    }
	    return stack;
	}

	CapturedTrace.parseStackAndMessage = function(error) {
	    var stack = error.stack;
	    var message = error.toString();
	    stack = typeof stack === "string" && stack.length > 0
	                ? stackFramesAsArray(error) : ["    (No stack trace)"];
	    return {
	        message: message,
	        stack: cleanStack(stack)
	    };
	};

	CapturedTrace.formatAndLogError = function(error, title) {
	    if (typeof console !== "undefined") {
	        var message;
	        if (typeof error === "object" || typeof error === "function") {
	            var stack = error.stack;
	            message = title + formatStack(stack, error);
	        } else {
	            message = title + String(error);
	        }
	        if (typeof warn === "function") {
	            warn(message);
	        } else if (typeof console.log === "function" ||
	            typeof console.log === "object") {
	            console.log(message);
	        }
	    }
	};

	CapturedTrace.unhandledRejection = function (reason) {
	    CapturedTrace.formatAndLogError(reason, "^--- With additional stack trace: ");
	};

	CapturedTrace.isSupported = function () {
	    return typeof captureStackTrace === "function";
	};

	CapturedTrace.fireRejectionEvent =
	function(name, localHandler, reason, promise) {
	    var localEventFired = false;
	    try {
	        if (typeof localHandler === "function") {
	            localEventFired = true;
	            if (name === "rejectionHandled") {
	                localHandler(promise);
	            } else {
	                localHandler(reason, promise);
	            }
	        }
	    } catch (e) {
	        async.throwLater(e);
	    }

	    var globalEventFired = false;
	    try {
	        globalEventFired = fireGlobalEvent(name, reason, promise);
	    } catch (e) {
	        globalEventFired = true;
	        async.throwLater(e);
	    }

	    var domEventFired = false;
	    if (fireDomEvent) {
	        try {
	            domEventFired = fireDomEvent(name.toLowerCase(), {
	                reason: reason,
	                promise: promise
	            });
	        } catch (e) {
	            domEventFired = true;
	            async.throwLater(e);
	        }
	    }

	    if (!globalEventFired && !localEventFired && !domEventFired &&
	        name === "unhandledRejection") {
	        CapturedTrace.formatAndLogError(reason, "Unhandled rejection ");
	    }
	};

	function formatNonError(obj) {
	    var str;
	    if (typeof obj === "function") {
	        str = "[function " +
	            (obj.name || "anonymous") +
	            "]";
	    } else {
	        str = obj.toString();
	        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
	        if (ruselessToString.test(str)) {
	            try {
	                var newStr = JSON.stringify(obj);
	                str = newStr;
	            }
	            catch(e) {

	            }
	        }
	        if (str.length === 0) {
	            str = "(empty array)";
	        }
	    }
	    return ("(<" + snip(str) + ">, no stack trace)");
	}

	function snip(str) {
	    var maxChars = 41;
	    if (str.length < maxChars) {
	        return str;
	    }
	    return str.substr(0, maxChars - 3) + "...";
	}

	var shouldIgnore = function() { return false; };
	var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
	function parseLineInfo(line) {
	    var matches = line.match(parseLineInfoRegex);
	    if (matches) {
	        return {
	            fileName: matches[1],
	            line: parseInt(matches[2], 10)
	        };
	    }
	}
	CapturedTrace.setBounds = function(firstLineError, lastLineError) {
	    if (!CapturedTrace.isSupported()) return;
	    var firstStackLines = firstLineError.stack.split("\n");
	    var lastStackLines = lastLineError.stack.split("\n");
	    var firstIndex = -1;
	    var lastIndex = -1;
	    var firstFileName;
	    var lastFileName;
	    for (var i = 0; i < firstStackLines.length; ++i) {
	        var result = parseLineInfo(firstStackLines[i]);
	        if (result) {
	            firstFileName = result.fileName;
	            firstIndex = result.line;
	            break;
	        }
	    }
	    for (var i = 0; i < lastStackLines.length; ++i) {
	        var result = parseLineInfo(lastStackLines[i]);
	        if (result) {
	            lastFileName = result.fileName;
	            lastIndex = result.line;
	            break;
	        }
	    }
	    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||
	        firstFileName !== lastFileName || firstIndex >= lastIndex) {
	        return;
	    }

	    shouldIgnore = function(line) {
	        if (bluebirdFramePattern.test(line)) return true;
	        var info = parseLineInfo(line);
	        if (info) {
	            if (info.fileName === firstFileName &&
	                (firstIndex <= info.line && info.line <= lastIndex)) {
	                return true;
	            }
	        }
	        return false;
	    };
	};

	var captureStackTrace = (function stackDetection() {
	    var v8stackFramePattern = /^\s*at\s*/;
	    var v8stackFormatter = function(stack, error) {
	        if (typeof stack === "string") return stack;

	        if (error.name !== undefined &&
	            error.message !== undefined) {
	            return error.toString();
	        }
	        return formatNonError(error);
	    };

	    if (typeof Error.stackTraceLimit === "number" &&
	        typeof Error.captureStackTrace === "function") {
	        Error.stackTraceLimit = Error.stackTraceLimit + 6;
	        stackFramePattern = v8stackFramePattern;
	        formatStack = v8stackFormatter;
	        var captureStackTrace = Error.captureStackTrace;

	        shouldIgnore = function(line) {
	            return bluebirdFramePattern.test(line);
	        };
	        return function(receiver, ignoreUntil) {
	            Error.stackTraceLimit = Error.stackTraceLimit + 6;
	            captureStackTrace(receiver, ignoreUntil);
	            Error.stackTraceLimit = Error.stackTraceLimit - 6;
	        };
	    }
	    var err = new Error();

	    if (typeof err.stack === "string" &&
	        err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
	        stackFramePattern = /@/;
	        formatStack = v8stackFormatter;
	        indentStackFrames = true;
	        return function captureStackTrace(o) {
	            o.stack = new Error().stack;
	        };
	    }

	    var hasStackAfterThrow;
	    try { throw new Error(); }
	    catch(e) {
	        hasStackAfterThrow = ("stack" in e);
	    }
	    if (!("stack" in err) && hasStackAfterThrow &&
	        typeof Error.stackTraceLimit === "number") {
	        stackFramePattern = v8stackFramePattern;
	        formatStack = v8stackFormatter;
	        return function captureStackTrace(o) {
	            Error.stackTraceLimit = Error.stackTraceLimit + 6;
	            try { throw new Error(); }
	            catch(e) { o.stack = e.stack; }
	            Error.stackTraceLimit = Error.stackTraceLimit - 6;
	        };
	    }

	    formatStack = function(stack, error) {
	        if (typeof stack === "string") return stack;

	        if ((typeof error === "object" ||
	            typeof error === "function") &&
	            error.name !== undefined &&
	            error.message !== undefined) {
	            return error.toString();
	        }
	        return formatNonError(error);
	    };

	    return null;

	})([]);

	var fireDomEvent;
	var fireGlobalEvent = (function() {
	    if (util.isNode) {
	        return function(name, reason, promise) {
	            if (name === "rejectionHandled") {
	                return process.emit(name, promise);
	            } else {
	                return process.emit(name, reason, promise);
	            }
	        };
	    } else {
	        var customEventWorks = false;
	        var anyEventWorks = true;
	        try {
	            var ev = new self.CustomEvent("test");
	            customEventWorks = ev instanceof CustomEvent;
	        } catch (e) {}
	        if (!customEventWorks) {
	            try {
	                var event = document.createEvent("CustomEvent");
	                event.initCustomEvent("testingtheevent", false, true, {});
	                self.dispatchEvent(event);
	            } catch (e) {
	                anyEventWorks = false;
	            }
	        }
	        if (anyEventWorks) {
	            fireDomEvent = function(type, detail) {
	                var event;
	                if (customEventWorks) {
	                    event = new self.CustomEvent(type, {
	                        detail: detail,
	                        bubbles: false,
	                        cancelable: true
	                    });
	                } else if (self.dispatchEvent) {
	                    event = document.createEvent("CustomEvent");
	                    event.initCustomEvent(type, false, true, detail);
	                }

	                return event ? !self.dispatchEvent(event) : false;
	            };
	        }

	        var toWindowMethodNameMap = {};
	        toWindowMethodNameMap["unhandledRejection"] = ("on" +
	            "unhandledRejection").toLowerCase();
	        toWindowMethodNameMap["rejectionHandled"] = ("on" +
	            "rejectionHandled").toLowerCase();

	        return function(name, reason, promise) {
	            var methodName = toWindowMethodNameMap[name];
	            var method = self[methodName];
	            if (!method) return false;
	            if (name === "rejectionHandled") {
	                method.call(self, promise);
	            } else {
	                method.call(self, reason, promise);
	            }
	            return true;
	        };
	    }
	})();

	if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
	    warn = function (message) {
	        console.warn(message);
	    };
	    if (util.isNode && process.stderr.isTTY) {
	        warn = function(message) {
	            process.stderr.write("\u001b[31m" + message + "\u001b[39m\n");
	        };
	    } else if (!util.isNode && typeof (new Error().stack) === "string") {
	        warn = function(message) {
	            console.warn("%c" + message, "color: red");
	        };
	    }
	}

	return CapturedTrace;
	};


/***/ },
/* 104 */
/*!*********************************************!*\
  !*** ./~/bluebird/js/main/debuggability.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(Promise, CapturedTrace) {
	var getDomain = Promise._getDomain;
	var async = __webpack_require__(/*! ./async.js */ 97);
	var Warning = __webpack_require__(/*! ./errors.js */ 100).Warning;
	var util = __webpack_require__(/*! ./util.js */ 95);
	var canAttachTrace = util.canAttachTrace;
	var unhandledRejectionHandled;
	var possiblyUnhandledRejection;
	var debugging = false || (util.isNode &&
	                    (!!process.env["BLUEBIRD_DEBUG"] ||
	                     process.env["NODE_ENV"] === "development"));

	if (util.isNode && process.env["BLUEBIRD_DEBUG"] == 0) debugging = false;

	if (debugging) {
	    async.disableTrampolineIfNecessary();
	}

	Promise.prototype._ignoreRejections = function() {
	    this._unsetRejectionIsUnhandled();
	    this._bitField = this._bitField | 16777216;
	};

	Promise.prototype._ensurePossibleRejectionHandled = function () {
	    if ((this._bitField & 16777216) !== 0) return;
	    this._setRejectionIsUnhandled();
	    async.invokeLater(this._notifyUnhandledRejection, this, undefined);
	};

	Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
	    CapturedTrace.fireRejectionEvent("rejectionHandled",
	                                  unhandledRejectionHandled, undefined, this);
	};

	Promise.prototype._notifyUnhandledRejection = function () {
	    if (this._isRejectionUnhandled()) {
	        var reason = this._getCarriedStackTrace() || this._settledValue;
	        this._setUnhandledRejectionIsNotified();
	        CapturedTrace.fireRejectionEvent("unhandledRejection",
	                                      possiblyUnhandledRejection, reason, this);
	    }
	};

	Promise.prototype._setUnhandledRejectionIsNotified = function () {
	    this._bitField = this._bitField | 524288;
	};

	Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
	    this._bitField = this._bitField & (~524288);
	};

	Promise.prototype._isUnhandledRejectionNotified = function () {
	    return (this._bitField & 524288) > 0;
	};

	Promise.prototype._setRejectionIsUnhandled = function () {
	    this._bitField = this._bitField | 2097152;
	};

	Promise.prototype._unsetRejectionIsUnhandled = function () {
	    this._bitField = this._bitField & (~2097152);
	    if (this._isUnhandledRejectionNotified()) {
	        this._unsetUnhandledRejectionIsNotified();
	        this._notifyUnhandledRejectionIsHandled();
	    }
	};

	Promise.prototype._isRejectionUnhandled = function () {
	    return (this._bitField & 2097152) > 0;
	};

	Promise.prototype._setCarriedStackTrace = function (capturedTrace) {
	    this._bitField = this._bitField | 1048576;
	    this._fulfillmentHandler0 = capturedTrace;
	};

	Promise.prototype._isCarryingStackTrace = function () {
	    return (this._bitField & 1048576) > 0;
	};

	Promise.prototype._getCarriedStackTrace = function () {
	    return this._isCarryingStackTrace()
	        ? this._fulfillmentHandler0
	        : undefined;
	};

	Promise.prototype._captureStackTrace = function () {
	    if (debugging) {
	        this._trace = new CapturedTrace(this._peekContext());
	    }
	    return this;
	};

	Promise.prototype._attachExtraTrace = function (error, ignoreSelf) {
	    if (debugging && canAttachTrace(error)) {
	        var trace = this._trace;
	        if (trace !== undefined) {
	            if (ignoreSelf) trace = trace._parent;
	        }
	        if (trace !== undefined) {
	            trace.attachExtraTrace(error);
	        } else if (!error.__stackCleaned__) {
	            var parsed = CapturedTrace.parseStackAndMessage(error);
	            util.notEnumerableProp(error, "stack",
	                parsed.message + "\n" + parsed.stack.join("\n"));
	            util.notEnumerableProp(error, "__stackCleaned__", true);
	        }
	    }
	};

	Promise.prototype._warn = function(message) {
	    var warning = new Warning(message);
	    var ctx = this._peekContext();
	    if (ctx) {
	        ctx.attachExtraTrace(warning);
	    } else {
	        var parsed = CapturedTrace.parseStackAndMessage(warning);
	        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
	    }
	    CapturedTrace.formatAndLogError(warning, "");
	};

	Promise.onPossiblyUnhandledRejection = function (fn) {
	    var domain = getDomain();
	    possiblyUnhandledRejection =
	        typeof fn === "function" ? (domain === null ? fn : domain.bind(fn))
	                                 : undefined;
	};

	Promise.onUnhandledRejectionHandled = function (fn) {
	    var domain = getDomain();
	    unhandledRejectionHandled =
	        typeof fn === "function" ? (domain === null ? fn : domain.bind(fn))
	                                 : undefined;
	};

	Promise.longStackTraces = function () {
	    if (async.haveItemsQueued() &&
	        debugging === false
	   ) {
	        throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/DT1qyG\u000a");
	    }
	    debugging = CapturedTrace.isSupported();
	    if (debugging) {
	        async.disableTrampolineIfNecessary();
	    }
	};

	Promise.hasLongStackTraces = function () {
	    return debugging && CapturedTrace.isSupported();
	};

	if (!CapturedTrace.isSupported()) {
	    Promise.longStackTraces = function(){};
	    debugging = false;
	}

	return function() {
	    return debugging;
	};
	};


/***/ },
/* 105 */
/*!***************************************!*\
  !*** ./~/bluebird/js/main/context.js ***!
  \***************************************/
/***/ function(module, exports) {

	"use strict";
	module.exports = function(Promise, CapturedTrace, isDebugging) {
	var contextStack = [];
	function Context() {
	    this._trace = new CapturedTrace(peekContext());
	}
	Context.prototype._pushContext = function () {
	    if (!isDebugging()) return;
	    if (this._trace !== undefined) {
	        contextStack.push(this._trace);
	    }
	};

	Context.prototype._popContext = function () {
	    if (!isDebugging()) return;
	    if (this._trace !== undefined) {
	        contextStack.pop();
	    }
	};

	function createContext() {
	    if (isDebugging()) return new Context();
	}

	function peekContext() {
	    var lastIndex = contextStack.length - 1;
	    if (lastIndex >= 0) {
	        return contextStack[lastIndex];
	    }
	    return undefined;
	}

	Promise.prototype._peekContext = peekContext;
	Promise.prototype._pushContext = Context.prototype._pushContext;
	Promise.prototype._popContext = Context.prototype._popContext;

	return createContext;
	};


/***/ },
/* 106 */
/*!********************************************!*\
  !*** ./~/bluebird/js/main/catch_filter.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(NEXT_FILTER) {
	var util = __webpack_require__(/*! ./util.js */ 95);
	var errors = __webpack_require__(/*! ./errors.js */ 100);
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var keys = __webpack_require__(/*! ./es5.js */ 96).keys;
	var TypeError = errors.TypeError;

	function CatchFilter(instances, callback, promise) {
	    this._instances = instances;
	    this._callback = callback;
	    this._promise = promise;
	}

	function safePredicate(predicate, e) {
	    var safeObject = {};
	    var retfilter = tryCatch(predicate).call(safeObject, e);

	    if (retfilter === errorObj) return retfilter;

	    var safeKeys = keys(safeObject);
	    if (safeKeys.length) {
	        errorObj.e = new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a");
	        return errorObj;
	    }
	    return retfilter;
	}

	CatchFilter.prototype.doFilter = function (e) {
	    var cb = this._callback;
	    var promise = this._promise;
	    var boundTo = promise._boundValue();
	    for (var i = 0, len = this._instances.length; i < len; ++i) {
	        var item = this._instances[i];
	        var itemIsErrorType = item === Error ||
	            (item != null && item.prototype instanceof Error);

	        if (itemIsErrorType && e instanceof item) {
	            var ret = tryCatch(cb).call(boundTo, e);
	            if (ret === errorObj) {
	                NEXT_FILTER.e = ret.e;
	                return NEXT_FILTER;
	            }
	            return ret;
	        } else if (typeof item === "function" && !itemIsErrorType) {
	            var shouldHandle = safePredicate(item, e);
	            if (shouldHandle === errorObj) {
	                e = errorObj.e;
	                break;
	            } else if (shouldHandle) {
	                var ret = tryCatch(cb).call(boundTo, e);
	                if (ret === errorObj) {
	                    NEXT_FILTER.e = ret.e;
	                    return NEXT_FILTER;
	                }
	                return ret;
	            }
	        }
	    }
	    NEXT_FILTER.e = e;
	    return NEXT_FILTER;
	};

	return CatchFilter;
	};


/***/ },
/* 107 */
/*!************************************************!*\
  !*** ./~/bluebird/js/main/promise_resolver.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var util = __webpack_require__(/*! ./util.js */ 95);
	var maybeWrapAsError = util.maybeWrapAsError;
	var errors = __webpack_require__(/*! ./errors.js */ 100);
	var TimeoutError = errors.TimeoutError;
	var OperationalError = errors.OperationalError;
	var haveGetters = util.haveGetters;
	var es5 = __webpack_require__(/*! ./es5.js */ 96);

	function isUntypedError(obj) {
	    return obj instanceof Error &&
	        es5.getPrototypeOf(obj) === Error.prototype;
	}

	var rErrorKey = /^(?:name|message|stack|cause)$/;
	function wrapAsOperationalError(obj) {
	    var ret;
	    if (isUntypedError(obj)) {
	        ret = new OperationalError(obj);
	        ret.name = obj.name;
	        ret.message = obj.message;
	        ret.stack = obj.stack;
	        var keys = es5.keys(obj);
	        for (var i = 0; i < keys.length; ++i) {
	            var key = keys[i];
	            if (!rErrorKey.test(key)) {
	                ret[key] = obj[key];
	            }
	        }
	        return ret;
	    }
	    util.markAsOriginatingFromRejection(obj);
	    return obj;
	}

	function nodebackForPromise(promise) {
	    return function(err, value) {
	        if (promise === null) return;

	        if (err) {
	            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
	            promise._attachExtraTrace(wrapped);
	            promise._reject(wrapped);
	        } else if (arguments.length > 2) {
	            var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
	            promise._fulfill(args);
	        } else {
	            promise._fulfill(value);
	        }

	        promise = null;
	    };
	}


	var PromiseResolver;
	if (!haveGetters) {
	    PromiseResolver = function (promise) {
	        this.promise = promise;
	        this.asCallback = nodebackForPromise(promise);
	        this.callback = this.asCallback;
	    };
	}
	else {
	    PromiseResolver = function (promise) {
	        this.promise = promise;
	    };
	}
	if (haveGetters) {
	    var prop = {
	        get: function() {
	            return nodebackForPromise(this.promise);
	        }
	    };
	    es5.defineProperty(PromiseResolver.prototype, "asCallback", prop);
	    es5.defineProperty(PromiseResolver.prototype, "callback", prop);
	}

	PromiseResolver._nodebackForPromise = nodebackForPromise;

	PromiseResolver.prototype.toString = function () {
	    return "[object PromiseResolver]";
	};

	PromiseResolver.prototype.resolve =
	PromiseResolver.prototype.fulfill = function (value) {
	    if (!(this instanceof PromiseResolver)) {
	        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
	    }
	    this.promise._resolveCallback(value);
	};

	PromiseResolver.prototype.reject = function (reason) {
	    if (!(this instanceof PromiseResolver)) {
	        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
	    }
	    this.promise._rejectCallback(reason);
	};

	PromiseResolver.prototype.progress = function (value) {
	    if (!(this instanceof PromiseResolver)) {
	        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
	    }
	    this.promise._progress(value);
	};

	PromiseResolver.prototype.cancel = function (err) {
	    this.promise.cancel(err);
	};

	PromiseResolver.prototype.timeout = function () {
	    this.reject(new TimeoutError("timeout"));
	};

	PromiseResolver.prototype.isResolved = function () {
	    return this.promise.isResolved();
	};

	PromiseResolver.prototype.toJSON = function () {
	    return this.promise.toJSON();
	};

	module.exports = PromiseResolver;


/***/ },
/* 108 */
/*!****************************************!*\
  !*** ./~/bluebird/js/main/progress.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(Promise, PromiseArray) {
	var util = __webpack_require__(/*! ./util.js */ 95);
	var async = __webpack_require__(/*! ./async.js */ 97);
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;

	Promise.prototype.progressed = function (handler) {
	    return this._then(undefined, undefined, handler, undefined, undefined);
	};

	Promise.prototype._progress = function (progressValue) {
	    if (this._isFollowingOrFulfilledOrRejected()) return;
	    this._target()._progressUnchecked(progressValue);

	};

	Promise.prototype._progressHandlerAt = function (index) {
	    return index === 0
	        ? this._progressHandler0
	        : this[(index << 2) + index - 5 + 2];
	};

	Promise.prototype._doProgressWith = function (progression) {
	    var progressValue = progression.value;
	    var handler = progression.handler;
	    var promise = progression.promise;
	    var receiver = progression.receiver;

	    var ret = tryCatch(handler).call(receiver, progressValue);
	    if (ret === errorObj) {
	        if (ret.e != null &&
	            ret.e.name !== "StopProgressPropagation") {
	            var trace = util.canAttachTrace(ret.e)
	                ? ret.e : new Error(util.toString(ret.e));
	            promise._attachExtraTrace(trace);
	            promise._progress(ret.e);
	        }
	    } else if (ret instanceof Promise) {
	        ret._then(promise._progress, null, null, promise, undefined);
	    } else {
	        promise._progress(ret);
	    }
	};


	Promise.prototype._progressUnchecked = function (progressValue) {
	    var len = this._length();
	    var progress = this._progress;
	    for (var i = 0; i < len; i++) {
	        var handler = this._progressHandlerAt(i);
	        var promise = this._promiseAt(i);
	        if (!(promise instanceof Promise)) {
	            var receiver = this._receiverAt(i);
	            if (typeof handler === "function") {
	                handler.call(receiver, progressValue, promise);
	            } else if (receiver instanceof PromiseArray &&
	                       !receiver._isResolved()) {
	                receiver._promiseProgressed(progressValue, promise);
	            }
	            continue;
	        }

	        if (typeof handler === "function") {
	            async.invoke(this._doProgressWith, this, {
	                handler: handler,
	                promise: promise,
	                receiver: this._receiverAt(i),
	                value: progressValue
	            });
	        } else {
	            async.invoke(progress, promise, progressValue);
	        }
	    }
	};
	};


/***/ },
/* 109 */
/*!**************************************!*\
  !*** ./~/bluebird/js/main/method.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	module.exports =
	function(Promise, INTERNAL, tryConvertToPromise, apiRejection) {
	var util = __webpack_require__(/*! ./util.js */ 95);
	var tryCatch = util.tryCatch;

	Promise.method = function (fn) {
	    if (typeof fn !== "function") {
	        throw new Promise.TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    }
	    return function () {
	        var ret = new Promise(INTERNAL);
	        ret._captureStackTrace();
	        ret._pushContext();
	        var value = tryCatch(fn).apply(this, arguments);
	        ret._popContext();
	        ret._resolveFromSyncValue(value);
	        return ret;
	    };
	};

	Promise.attempt = Promise["try"] = function (fn, args, ctx) {
	    if (typeof fn !== "function") {
	        return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    }
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    ret._pushContext();
	    var value = util.isArray(args)
	        ? tryCatch(fn).apply(ctx, args)
	        : tryCatch(fn).call(ctx, args);
	    ret._popContext();
	    ret._resolveFromSyncValue(value);
	    return ret;
	};

	Promise.prototype._resolveFromSyncValue = function (value) {
	    if (value === util.errorObj) {
	        this._rejectCallback(value.e, false, true);
	    } else {
	        this._resolveCallback(value, true);
	    }
	};
	};


/***/ },
/* 110 */
/*!************************************!*\
  !*** ./~/bluebird/js/main/bind.js ***!
  \************************************/
/***/ function(module, exports) {

	"use strict";
	module.exports = function(Promise, INTERNAL, tryConvertToPromise) {
	var rejectThis = function(_, e) {
	    this._reject(e);
	};

	var targetRejected = function(e, context) {
	    context.promiseRejectionQueued = true;
	    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
	};

	var bindingResolved = function(thisArg, context) {
	    if (this._isPending()) {
	        this._resolveCallback(context.target);
	    }
	};

	var bindingRejected = function(e, context) {
	    if (!context.promiseRejectionQueued) this._reject(e);
	};

	Promise.prototype.bind = function (thisArg) {
	    var maybePromise = tryConvertToPromise(thisArg);
	    var ret = new Promise(INTERNAL);
	    ret._propagateFrom(this, 1);
	    var target = this._target();

	    ret._setBoundTo(maybePromise);
	    if (maybePromise instanceof Promise) {
	        var context = {
	            promiseRejectionQueued: false,
	            promise: ret,
	            target: target,
	            bindingPromise: maybePromise
	        };
	        target._then(INTERNAL, targetRejected, ret._progress, ret, context);
	        maybePromise._then(
	            bindingResolved, bindingRejected, ret._progress, ret, context);
	    } else {
	        ret._resolveCallback(target);
	    }
	    return ret;
	};

	Promise.prototype._setBoundTo = function (obj) {
	    if (obj !== undefined) {
	        this._bitField = this._bitField | 131072;
	        this._boundTo = obj;
	    } else {
	        this._bitField = this._bitField & (~131072);
	    }
	};

	Promise.prototype._isBound = function () {
	    return (this._bitField & 131072) === 131072;
	};

	Promise.bind = function (thisArg, value) {
	    var maybePromise = tryConvertToPromise(thisArg);
	    var ret = new Promise(INTERNAL);

	    ret._setBoundTo(maybePromise);
	    if (maybePromise instanceof Promise) {
	        maybePromise._then(function() {
	            ret._resolveCallback(value);
	        }, ret._reject, ret._progress, ret, null);
	    } else {
	        ret._resolveCallback(value);
	    }
	    return ret;
	};
	};


/***/ },
/* 111 */
/*!***************************************!*\
  !*** ./~/bluebird/js/main/finally.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(Promise, NEXT_FILTER, tryConvertToPromise) {
	var util = __webpack_require__(/*! ./util.js */ 95);
	var isPrimitive = util.isPrimitive;
	var thrower = util.thrower;

	function returnThis() {
	    return this;
	}
	function throwThis() {
	    throw this;
	}
	function return$(r) {
	    return function() {
	        return r;
	    };
	}
	function throw$(r) {
	    return function() {
	        throw r;
	    };
	}
	function promisedFinally(ret, reasonOrValue, isFulfilled) {
	    var then;
	    if (isPrimitive(reasonOrValue)) {
	        then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);
	    } else {
	        then = isFulfilled ? returnThis : throwThis;
	    }
	    return ret._then(then, thrower, undefined, reasonOrValue, undefined);
	}

	function finallyHandler(reasonOrValue) {
	    var promise = this.promise;
	    var handler = this.handler;

	    var ret = promise._isBound()
	                    ? handler.call(promise._boundValue())
	                    : handler();

	    if (ret !== undefined) {
	        var maybePromise = tryConvertToPromise(ret, promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            return promisedFinally(maybePromise, reasonOrValue,
	                                    promise.isFulfilled());
	        }
	    }

	    if (promise.isRejected()) {
	        NEXT_FILTER.e = reasonOrValue;
	        return NEXT_FILTER;
	    } else {
	        return reasonOrValue;
	    }
	}

	function tapHandler(value) {
	    var promise = this.promise;
	    var handler = this.handler;

	    var ret = promise._isBound()
	                    ? handler.call(promise._boundValue(), value)
	                    : handler(value);

	    if (ret !== undefined) {
	        var maybePromise = tryConvertToPromise(ret, promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            return promisedFinally(maybePromise, value, true);
	        }
	    }
	    return value;
	}

	Promise.prototype._passThroughHandler = function (handler, isFinally) {
	    if (typeof handler !== "function") return this.then();

	    var promiseAndHandler = {
	        promise: this,
	        handler: handler
	    };

	    return this._then(
	            isFinally ? finallyHandler : tapHandler,
	            isFinally ? finallyHandler : undefined, undefined,
	            promiseAndHandler, undefined);
	};

	Promise.prototype.lastly =
	Promise.prototype["finally"] = function (handler) {
	    return this._passThroughHandler(handler, true);
	};

	Promise.prototype.tap = function (handler) {
	    return this._passThroughHandler(handler, false);
	};
	};


/***/ },
/* 112 */
/*!**********************************************!*\
  !*** ./~/bluebird/js/main/direct_resolve.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var util = __webpack_require__(/*! ./util.js */ 95);
	var isPrimitive = util.isPrimitive;

	module.exports = function(Promise) {
	var returner = function () {
	    return this;
	};
	var thrower = function () {
	    throw this;
	};
	var returnUndefined = function() {};
	var throwUndefined = function() {
	    throw undefined;
	};

	var wrapper = function (value, action) {
	    if (action === 1) {
	        return function () {
	            throw value;
	        };
	    } else if (action === 2) {
	        return function () {
	            return value;
	        };
	    }
	};


	Promise.prototype["return"] =
	Promise.prototype.thenReturn = function (value) {
	    if (value === undefined) return this.then(returnUndefined);

	    if (isPrimitive(value)) {
	        return this._then(
	            wrapper(value, 2),
	            undefined,
	            undefined,
	            undefined,
	            undefined
	       );
	    } else if (value instanceof Promise) {
	        value._ignoreRejections();
	    }
	    return this._then(returner, undefined, undefined, value, undefined);
	};

	Promise.prototype["throw"] =
	Promise.prototype.thenThrow = function (reason) {
	    if (reason === undefined) return this.then(throwUndefined);

	    if (isPrimitive(reason)) {
	        return this._then(
	            wrapper(reason, 1),
	            undefined,
	            undefined,
	            undefined,
	            undefined
	       );
	    }
	    return this._then(thrower, undefined, undefined, reason, undefined);
	};
	};


/***/ },
/* 113 */
/*!******************************************************!*\
  !*** ./~/bluebird/js/main/synchronous_inspection.js ***!
  \******************************************************/
/***/ function(module, exports) {

	"use strict";
	module.exports = function(Promise) {
	function PromiseInspection(promise) {
	    if (promise !== undefined) {
	        promise = promise._target();
	        this._bitField = promise._bitField;
	        this._settledValue = promise._settledValue;
	    }
	    else {
	        this._bitField = 0;
	        this._settledValue = undefined;
	    }
	}

	PromiseInspection.prototype.value = function () {
	    if (!this.isFulfilled()) {
	        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
	    }
	    return this._settledValue;
	};

	PromiseInspection.prototype.error =
	PromiseInspection.prototype.reason = function () {
	    if (!this.isRejected()) {
	        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
	    }
	    return this._settledValue;
	};

	PromiseInspection.prototype.isFulfilled =
	Promise.prototype._isFulfilled = function () {
	    return (this._bitField & 268435456) > 0;
	};

	PromiseInspection.prototype.isRejected =
	Promise.prototype._isRejected = function () {
	    return (this._bitField & 134217728) > 0;
	};

	PromiseInspection.prototype.isPending =
	Promise.prototype._isPending = function () {
	    return (this._bitField & 402653184) === 0;
	};

	PromiseInspection.prototype.isResolved =
	Promise.prototype._isResolved = function () {
	    return (this._bitField & 402653184) > 0;
	};

	Promise.prototype.isPending = function() {
	    return this._target()._isPending();
	};

	Promise.prototype.isRejected = function() {
	    return this._target()._isRejected();
	};

	Promise.prototype.isFulfilled = function() {
	    return this._target()._isFulfilled();
	};

	Promise.prototype.isResolved = function() {
	    return this._target()._isResolved();
	};

	Promise.prototype._value = function() {
	    return this._settledValue;
	};

	Promise.prototype._reason = function() {
	    this._unsetRejectionIsUnhandled();
	    return this._settledValue;
	};

	Promise.prototype.value = function() {
	    var target = this._target();
	    if (!target.isFulfilled()) {
	        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
	    }
	    return target._settledValue;
	};

	Promise.prototype.reason = function() {
	    var target = this._target();
	    if (!target.isRejected()) {
	        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
	    }
	    target._unsetRejectionIsUnhandled();
	    return target._settledValue;
	};


	Promise.PromiseInspection = PromiseInspection;
	};


/***/ },
/* 114 */
/*!************************************!*\
  !*** ./~/bluebird/js/main/join.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	module.exports =
	function(Promise, PromiseArray, tryConvertToPromise, INTERNAL) {
	var util = __webpack_require__(/*! ./util.js */ 95);
	var canEvaluate = util.canEvaluate;
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var reject;

	if (true) {
	if (canEvaluate) {
	    var thenCallback = function(i) {
	        return new Function("value", "holder", "                             \n\
	            'use strict';                                                    \n\
	            holder.pIndex = value;                                           \n\
	            holder.checkFulfillment(this);                                   \n\
	            ".replace(/Index/g, i));
	    };

	    var caller = function(count) {
	        var values = [];
	        for (var i = 1; i <= count; ++i) values.push("holder.p" + i);
	        return new Function("holder", "                                      \n\
	            'use strict';                                                    \n\
	            var callback = holder.fn;                                        \n\
	            return callback(values);                                         \n\
	            ".replace(/values/g, values.join(", ")));
	    };
	    var thenCallbacks = [];
	    var callers = [undefined];
	    for (var i = 1; i <= 5; ++i) {
	        thenCallbacks.push(thenCallback(i));
	        callers.push(caller(i));
	    }

	    var Holder = function(total, fn) {
	        this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;
	        this.fn = fn;
	        this.total = total;
	        this.now = 0;
	    };

	    Holder.prototype.callers = callers;
	    Holder.prototype.checkFulfillment = function(promise) {
	        var now = this.now;
	        now++;
	        var total = this.total;
	        if (now >= total) {
	            var handler = this.callers[total];
	            promise._pushContext();
	            var ret = tryCatch(handler)(this);
	            promise._popContext();
	            if (ret === errorObj) {
	                promise._rejectCallback(ret.e, false, true);
	            } else {
	                promise._resolveCallback(ret);
	            }
	        } else {
	            this.now = now;
	        }
	    };

	    var reject = function (reason) {
	        this._reject(reason);
	    };
	}
	}

	Promise.join = function () {
	    var last = arguments.length - 1;
	    var fn;
	    if (last > 0 && typeof arguments[last] === "function") {
	        fn = arguments[last];
	        if (true) {
	            if (last < 6 && canEvaluate) {
	                var ret = new Promise(INTERNAL);
	                ret._captureStackTrace();
	                var holder = new Holder(last, fn);
	                var callbacks = thenCallbacks;
	                for (var i = 0; i < last; ++i) {
	                    var maybePromise = tryConvertToPromise(arguments[i], ret);
	                    if (maybePromise instanceof Promise) {
	                        maybePromise = maybePromise._target();
	                        if (maybePromise._isPending()) {
	                            maybePromise._then(callbacks[i], reject,
	                                               undefined, ret, holder);
	                        } else if (maybePromise._isFulfilled()) {
	                            callbacks[i].call(ret,
	                                              maybePromise._value(), holder);
	                        } else {
	                            ret._reject(maybePromise._reason());
	                        }
	                    } else {
	                        callbacks[i].call(ret, maybePromise, holder);
	                    }
	                }
	                return ret;
	            }
	        }
	    }
	    var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];}
	    if (fn) args.pop();
	    var ret = new PromiseArray(args).promise();
	    return fn !== undefined ? ret.spread(fn) : ret;
	};

	};


/***/ },
/* 115 */
/*!***********************************!*\
  !*** ./~/bluebird/js/main/map.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(Promise,
	                          PromiseArray,
	                          apiRejection,
	                          tryConvertToPromise,
	                          INTERNAL) {
	var getDomain = Promise._getDomain;
	var async = __webpack_require__(/*! ./async.js */ 97);
	var util = __webpack_require__(/*! ./util.js */ 95);
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var PENDING = {};
	var EMPTY_ARRAY = [];

	function MappingPromiseArray(promises, fn, limit, _filter) {
	    this.constructor$(promises);
	    this._promise._captureStackTrace();
	    var domain = getDomain();
	    this._callback = domain === null ? fn : domain.bind(fn);
	    this._preservedValues = _filter === INTERNAL
	        ? new Array(this.length())
	        : null;
	    this._limit = limit;
	    this._inFlight = 0;
	    this._queue = limit >= 1 ? [] : EMPTY_ARRAY;
	    async.invoke(init, this, undefined);
	}
	util.inherits(MappingPromiseArray, PromiseArray);
	function init() {this._init$(undefined, -2);}

	MappingPromiseArray.prototype._init = function () {};

	MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var values = this._values;
	    var length = this.length();
	    var preservedValues = this._preservedValues;
	    var limit = this._limit;
	    if (values[index] === PENDING) {
	        values[index] = value;
	        if (limit >= 1) {
	            this._inFlight--;
	            this._drainQueue();
	            if (this._isResolved()) return;
	        }
	    } else {
	        if (limit >= 1 && this._inFlight >= limit) {
	            values[index] = value;
	            this._queue.push(index);
	            return;
	        }
	        if (preservedValues !== null) preservedValues[index] = value;

	        var callback = this._callback;
	        var receiver = this._promise._boundValue();
	        this._promise._pushContext();
	        var ret = tryCatch(callback).call(receiver, value, index, length);
	        this._promise._popContext();
	        if (ret === errorObj) return this._reject(ret.e);

	        var maybePromise = tryConvertToPromise(ret, this._promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            if (maybePromise._isPending()) {
	                if (limit >= 1) this._inFlight++;
	                values[index] = PENDING;
	                return maybePromise._proxyPromiseArray(this, index);
	            } else if (maybePromise._isFulfilled()) {
	                ret = maybePromise._value();
	            } else {
	                return this._reject(maybePromise._reason());
	            }
	        }
	        values[index] = ret;
	    }
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= length) {
	        if (preservedValues !== null) {
	            this._filter(values, preservedValues);
	        } else {
	            this._resolve(values);
	        }

	    }
	};

	MappingPromiseArray.prototype._drainQueue = function () {
	    var queue = this._queue;
	    var limit = this._limit;
	    var values = this._values;
	    while (queue.length > 0 && this._inFlight < limit) {
	        if (this._isResolved()) return;
	        var index = queue.pop();
	        this._promiseFulfilled(values[index], index);
	    }
	};

	MappingPromiseArray.prototype._filter = function (booleans, values) {
	    var len = values.length;
	    var ret = new Array(len);
	    var j = 0;
	    for (var i = 0; i < len; ++i) {
	        if (booleans[i]) ret[j++] = values[i];
	    }
	    ret.length = j;
	    this._resolve(ret);
	};

	MappingPromiseArray.prototype.preservedValues = function () {
	    return this._preservedValues;
	};

	function map(promises, fn, options, _filter) {
	    var limit = typeof options === "object" && options !== null
	        ? options.concurrency
	        : 0;
	    limit = typeof limit === "number" &&
	        isFinite(limit) && limit >= 1 ? limit : 0;
	    return new MappingPromiseArray(promises, fn, limit, _filter);
	}

	Promise.prototype.map = function (fn, options) {
	    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");

	    return map(this, fn, options, null).promise();
	};

	Promise.map = function (promises, fn, options, _filter) {
	    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    return map(promises, fn, options, _filter).promise();
	};


	};


/***/ },
/* 116 */
/*!**************************************!*\
  !*** ./~/bluebird/js/main/cancel.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(Promise) {
	var errors = __webpack_require__(/*! ./errors.js */ 100);
	var async = __webpack_require__(/*! ./async.js */ 97);
	var CancellationError = errors.CancellationError;

	Promise.prototype._cancel = function (reason) {
	    if (!this.isCancellable()) return this;
	    var parent;
	    var promiseToReject = this;
	    while ((parent = promiseToReject._cancellationParent) !== undefined &&
	        parent.isCancellable()) {
	        promiseToReject = parent;
	    }
	    this._unsetCancellable();
	    promiseToReject._target()._rejectCallback(reason, false, true);
	};

	Promise.prototype.cancel = function (reason) {
	    if (!this.isCancellable()) return this;
	    if (reason === undefined) reason = new CancellationError();
	    async.invokeLater(this._cancel, this, reason);
	    return this;
	};

	Promise.prototype.cancellable = function () {
	    if (this._cancellable()) return this;
	    async.enableTrampoline();
	    this._setCancellable();
	    this._cancellationParent = undefined;
	    return this;
	};

	Promise.prototype.uncancellable = function () {
	    var ret = this.then();
	    ret._unsetCancellable();
	    return ret;
	};

	Promise.prototype.fork = function (didFulfill, didReject, didProgress) {
	    var ret = this._then(didFulfill, didReject, didProgress,
	                         undefined, undefined);

	    ret._setCancellable();
	    ret._cancellationParent = undefined;
	    return ret;
	};
	};


/***/ },
/* 117 */
/*!*************************************!*\
  !*** ./~/bluebird/js/main/using.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function (Promise, apiRejection, tryConvertToPromise,
	    createContext) {
	    var TypeError = __webpack_require__(/*! ./errors.js */ 100).TypeError;
	    var inherits = __webpack_require__(/*! ./util.js */ 95).inherits;
	    var PromiseInspection = Promise.PromiseInspection;

	    function inspectionMapper(inspections) {
	        var len = inspections.length;
	        for (var i = 0; i < len; ++i) {
	            var inspection = inspections[i];
	            if (inspection.isRejected()) {
	                return Promise.reject(inspection.error());
	            }
	            inspections[i] = inspection._settledValue;
	        }
	        return inspections;
	    }

	    function thrower(e) {
	        setTimeout(function(){throw e;}, 0);
	    }

	    function castPreservingDisposable(thenable) {
	        var maybePromise = tryConvertToPromise(thenable);
	        if (maybePromise !== thenable &&
	            typeof thenable._isDisposable === "function" &&
	            typeof thenable._getDisposer === "function" &&
	            thenable._isDisposable()) {
	            maybePromise._setDisposable(thenable._getDisposer());
	        }
	        return maybePromise;
	    }
	    function dispose(resources, inspection) {
	        var i = 0;
	        var len = resources.length;
	        var ret = Promise.defer();
	        function iterator() {
	            if (i >= len) return ret.resolve();
	            var maybePromise = castPreservingDisposable(resources[i++]);
	            if (maybePromise instanceof Promise &&
	                maybePromise._isDisposable()) {
	                try {
	                    maybePromise = tryConvertToPromise(
	                        maybePromise._getDisposer().tryDispose(inspection),
	                        resources.promise);
	                } catch (e) {
	                    return thrower(e);
	                }
	                if (maybePromise instanceof Promise) {
	                    return maybePromise._then(iterator, thrower,
	                                              null, null, null);
	                }
	            }
	            iterator();
	        }
	        iterator();
	        return ret.promise;
	    }

	    function disposerSuccess(value) {
	        var inspection = new PromiseInspection();
	        inspection._settledValue = value;
	        inspection._bitField = 268435456;
	        return dispose(this, inspection).thenReturn(value);
	    }

	    function disposerFail(reason) {
	        var inspection = new PromiseInspection();
	        inspection._settledValue = reason;
	        inspection._bitField = 134217728;
	        return dispose(this, inspection).thenThrow(reason);
	    }

	    function Disposer(data, promise, context) {
	        this._data = data;
	        this._promise = promise;
	        this._context = context;
	    }

	    Disposer.prototype.data = function () {
	        return this._data;
	    };

	    Disposer.prototype.promise = function () {
	        return this._promise;
	    };

	    Disposer.prototype.resource = function () {
	        if (this.promise().isFulfilled()) {
	            return this.promise().value();
	        }
	        return null;
	    };

	    Disposer.prototype.tryDispose = function(inspection) {
	        var resource = this.resource();
	        var context = this._context;
	        if (context !== undefined) context._pushContext();
	        var ret = resource !== null
	            ? this.doDispose(resource, inspection) : null;
	        if (context !== undefined) context._popContext();
	        this._promise._unsetDisposable();
	        this._data = null;
	        return ret;
	    };

	    Disposer.isDisposer = function (d) {
	        return (d != null &&
	                typeof d.resource === "function" &&
	                typeof d.tryDispose === "function");
	    };

	    function FunctionDisposer(fn, promise, context) {
	        this.constructor$(fn, promise, context);
	    }
	    inherits(FunctionDisposer, Disposer);

	    FunctionDisposer.prototype.doDispose = function (resource, inspection) {
	        var fn = this.data();
	        return fn.call(resource, resource, inspection);
	    };

	    function maybeUnwrapDisposer(value) {
	        if (Disposer.isDisposer(value)) {
	            this.resources[this.index]._setDisposable(value);
	            return value.promise();
	        }
	        return value;
	    }

	    Promise.using = function () {
	        var len = arguments.length;
	        if (len < 2) return apiRejection(
	                        "you must pass at least 2 arguments to Promise.using");
	        var fn = arguments[len - 1];
	        if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");

	        var input;
	        var spreadArgs = true;
	        if (len === 2 && Array.isArray(arguments[0])) {
	            input = arguments[0];
	            len = input.length;
	            spreadArgs = false;
	        } else {
	            input = arguments;
	            len--;
	        }
	        var resources = new Array(len);
	        for (var i = 0; i < len; ++i) {
	            var resource = input[i];
	            if (Disposer.isDisposer(resource)) {
	                var disposer = resource;
	                resource = resource.promise();
	                resource._setDisposable(disposer);
	            } else {
	                var maybePromise = tryConvertToPromise(resource);
	                if (maybePromise instanceof Promise) {
	                    resource =
	                        maybePromise._then(maybeUnwrapDisposer, null, null, {
	                            resources: resources,
	                            index: i
	                    }, undefined);
	                }
	            }
	            resources[i] = resource;
	        }

	        var promise = Promise.settle(resources)
	            .then(inspectionMapper)
	            .then(function(vals) {
	                promise._pushContext();
	                var ret;
	                try {
	                    ret = spreadArgs
	                        ? fn.apply(undefined, vals) : fn.call(undefined,  vals);
	                } finally {
	                    promise._popContext();
	                }
	                return ret;
	            })
	            ._then(
	                disposerSuccess, disposerFail, undefined, resources, undefined);
	        resources.promise = promise;
	        return promise;
	    };

	    Promise.prototype._setDisposable = function (disposer) {
	        this._bitField = this._bitField | 262144;
	        this._disposer = disposer;
	    };

	    Promise.prototype._isDisposable = function () {
	        return (this._bitField & 262144) > 0;
	    };

	    Promise.prototype._getDisposer = function () {
	        return this._disposer;
	    };

	    Promise.prototype._unsetDisposable = function () {
	        this._bitField = this._bitField & (~262144);
	        this._disposer = undefined;
	    };

	    Promise.prototype.disposer = function (fn) {
	        if (typeof fn === "function") {
	            return new FunctionDisposer(fn, this, createContext());
	        }
	        throw new TypeError();
	    };

	};


/***/ },
/* 118 */
/*!******************************************!*\
  !*** ./~/bluebird/js/main/generators.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(Promise,
	                          apiRejection,
	                          INTERNAL,
	                          tryConvertToPromise) {
	var errors = __webpack_require__(/*! ./errors.js */ 100);
	var TypeError = errors.TypeError;
	var util = __webpack_require__(/*! ./util.js */ 95);
	var errorObj = util.errorObj;
	var tryCatch = util.tryCatch;
	var yieldHandlers = [];

	function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
	    for (var i = 0; i < yieldHandlers.length; ++i) {
	        traceParent._pushContext();
	        var result = tryCatch(yieldHandlers[i])(value);
	        traceParent._popContext();
	        if (result === errorObj) {
	            traceParent._pushContext();
	            var ret = Promise.reject(errorObj.e);
	            traceParent._popContext();
	            return ret;
	        }
	        var maybePromise = tryConvertToPromise(result, traceParent);
	        if (maybePromise instanceof Promise) return maybePromise;
	    }
	    return null;
	}

	function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
	    var promise = this._promise = new Promise(INTERNAL);
	    promise._captureStackTrace();
	    this._stack = stack;
	    this._generatorFunction = generatorFunction;
	    this._receiver = receiver;
	    this._generator = undefined;
	    this._yieldHandlers = typeof yieldHandler === "function"
	        ? [yieldHandler].concat(yieldHandlers)
	        : yieldHandlers;
	}

	PromiseSpawn.prototype.promise = function () {
	    return this._promise;
	};

	PromiseSpawn.prototype._run = function () {
	    this._generator = this._generatorFunction.call(this._receiver);
	    this._receiver =
	        this._generatorFunction = undefined;
	    this._next(undefined);
	};

	PromiseSpawn.prototype._continue = function (result) {
	    if (result === errorObj) {
	        return this._promise._rejectCallback(result.e, false, true);
	    }

	    var value = result.value;
	    if (result.done === true) {
	        this._promise._resolveCallback(value);
	    } else {
	        var maybePromise = tryConvertToPromise(value, this._promise);
	        if (!(maybePromise instanceof Promise)) {
	            maybePromise =
	                promiseFromYieldHandler(maybePromise,
	                                        this._yieldHandlers,
	                                        this._promise);
	            if (maybePromise === null) {
	                this._throw(
	                    new TypeError(
	                        "A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/4Y4pDk\u000a\u000a".replace("%s", value) +
	                        "From coroutine:\u000a" +
	                        this._stack.split("\n").slice(1, -7).join("\n")
	                    )
	                );
	                return;
	            }
	        }
	        maybePromise._then(
	            this._next,
	            this._throw,
	            undefined,
	            this,
	            null
	       );
	    }
	};

	PromiseSpawn.prototype._throw = function (reason) {
	    this._promise._attachExtraTrace(reason);
	    this._promise._pushContext();
	    var result = tryCatch(this._generator["throw"])
	        .call(this._generator, reason);
	    this._promise._popContext();
	    this._continue(result);
	};

	PromiseSpawn.prototype._next = function (value) {
	    this._promise._pushContext();
	    var result = tryCatch(this._generator.next).call(this._generator, value);
	    this._promise._popContext();
	    this._continue(result);
	};

	Promise.coroutine = function (generatorFunction, options) {
	    if (typeof generatorFunction !== "function") {
	        throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
	    }
	    var yieldHandler = Object(options).yieldHandler;
	    var PromiseSpawn$ = PromiseSpawn;
	    var stack = new Error().stack;
	    return function () {
	        var generator = generatorFunction.apply(this, arguments);
	        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,
	                                      stack);
	        spawn._generator = generator;
	        spawn._next(undefined);
	        return spawn.promise();
	    };
	};

	Promise.coroutine.addYieldHandler = function(fn) {
	    if (typeof fn !== "function") throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    yieldHandlers.push(fn);
	};

	Promise.spawn = function (generatorFunction) {
	    if (typeof generatorFunction !== "function") {
	        return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
	    }
	    var spawn = new PromiseSpawn(generatorFunction, this);
	    var ret = spawn.promise();
	    spawn._run(Promise.spawn);
	    return ret;
	};
	};


/***/ },
/* 119 */
/*!***************************************!*\
  !*** ./~/bluebird/js/main/nodeify.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(Promise) {
	var util = __webpack_require__(/*! ./util.js */ 95);
	var async = __webpack_require__(/*! ./async.js */ 97);
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;

	function spreadAdapter(val, nodeback) {
	    var promise = this;
	    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
	    var ret =
	        tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}

	function successAdapter(val, nodeback) {
	    var promise = this;
	    var receiver = promise._boundValue();
	    var ret = val === undefined
	        ? tryCatch(nodeback).call(receiver, null)
	        : tryCatch(nodeback).call(receiver, null, val);
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}
	function errorAdapter(reason, nodeback) {
	    var promise = this;
	    if (!reason) {
	        var target = promise._target();
	        var newReason = target._getCarriedStackTrace();
	        newReason.cause = reason;
	        reason = newReason;
	    }
	    var ret = tryCatch(nodeback).call(promise._boundValue(), reason);
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}

	Promise.prototype.asCallback =
	Promise.prototype.nodeify = function (nodeback, options) {
	    if (typeof nodeback == "function") {
	        var adapter = successAdapter;
	        if (options !== undefined && Object(options).spread) {
	            adapter = spreadAdapter;
	        }
	        this._then(
	            adapter,
	            errorAdapter,
	            undefined,
	            this,
	            nodeback
	        );
	    }
	    return this;
	};
	};


/***/ },
/* 120 */
/*!****************************************!*\
  !*** ./~/bluebird/js/main/call_get.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var cr = Object.create;
	if (cr) {
	    var callerCache = cr(null);
	    var getterCache = cr(null);
	    callerCache[" size"] = getterCache[" size"] = 0;
	}

	module.exports = function(Promise) {
	var util = __webpack_require__(/*! ./util.js */ 95);
	var canEvaluate = util.canEvaluate;
	var isIdentifier = util.isIdentifier;

	var getMethodCaller;
	var getGetter;
	if (true) {
	var makeMethodCaller = function (methodName) {
	    return new Function("ensureMethod", "                                    \n\
	        return function(obj) {                                               \n\
	            'use strict'                                                     \n\
	            var len = this.length;                                           \n\
	            ensureMethod(obj, 'methodName');                                 \n\
	            switch(len) {                                                    \n\
	                case 1: return obj.methodName(this[0]);                      \n\
	                case 2: return obj.methodName(this[0], this[1]);             \n\
	                case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
	                case 0: return obj.methodName();                             \n\
	                default:                                                     \n\
	                    return obj.methodName.apply(obj, this);                  \n\
	            }                                                                \n\
	        };                                                                   \n\
	        ".replace(/methodName/g, methodName))(ensureMethod);
	};

	var makeGetter = function (propertyName) {
	    return new Function("obj", "                                             \n\
	        'use strict';                                                        \n\
	        return obj.propertyName;                                             \n\
	        ".replace("propertyName", propertyName));
	};

	var getCompiled = function(name, compiler, cache) {
	    var ret = cache[name];
	    if (typeof ret !== "function") {
	        if (!isIdentifier(name)) {
	            return null;
	        }
	        ret = compiler(name);
	        cache[name] = ret;
	        cache[" size"]++;
	        if (cache[" size"] > 512) {
	            var keys = Object.keys(cache);
	            for (var i = 0; i < 256; ++i) delete cache[keys[i]];
	            cache[" size"] = keys.length - 256;
	        }
	    }
	    return ret;
	};

	getMethodCaller = function(name) {
	    return getCompiled(name, makeMethodCaller, callerCache);
	};

	getGetter = function(name) {
	    return getCompiled(name, makeGetter, getterCache);
	};
	}

	function ensureMethod(obj, methodName) {
	    var fn;
	    if (obj != null) fn = obj[methodName];
	    if (typeof fn !== "function") {
	        var message = "Object " + util.classString(obj) + " has no method '" +
	            util.toString(methodName) + "'";
	        throw new Promise.TypeError(message);
	    }
	    return fn;
	}

	function caller(obj) {
	    var methodName = this.pop();
	    var fn = ensureMethod(obj, methodName);
	    return fn.apply(obj, this);
	}
	Promise.prototype.call = function (methodName) {
	    var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
	    if (true) {
	        if (canEvaluate) {
	            var maybeCaller = getMethodCaller(methodName);
	            if (maybeCaller !== null) {
	                return this._then(
	                    maybeCaller, undefined, undefined, args, undefined);
	            }
	        }
	    }
	    args.push(methodName);
	    return this._then(caller, undefined, undefined, args, undefined);
	};

	function namedGetter(obj) {
	    return obj[this];
	}
	function indexedGetter(obj) {
	    var index = +this;
	    if (index < 0) index = Math.max(0, index + obj.length);
	    return obj[index];
	}
	Promise.prototype.get = function (propertyName) {
	    var isIndex = (typeof propertyName === "number");
	    var getter;
	    if (!isIndex) {
	        if (canEvaluate) {
	            var maybeGetter = getGetter(propertyName);
	            getter = maybeGetter !== null ? maybeGetter : namedGetter;
	        } else {
	            getter = namedGetter;
	        }
	    } else {
	        getter = indexedGetter;
	    }
	    return this._then(getter, undefined, undefined, propertyName, undefined);
	};
	};


/***/ },
/* 121 */
/*!*************************************!*\
  !*** ./~/bluebird/js/main/props.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(
	    Promise, PromiseArray, tryConvertToPromise, apiRejection) {
	var util = __webpack_require__(/*! ./util.js */ 95);
	var isObject = util.isObject;
	var es5 = __webpack_require__(/*! ./es5.js */ 96);

	function PropertiesPromiseArray(obj) {
	    var keys = es5.keys(obj);
	    var len = keys.length;
	    var values = new Array(len * 2);
	    for (var i = 0; i < len; ++i) {
	        var key = keys[i];
	        values[i] = obj[key];
	        values[i + len] = key;
	    }
	    this.constructor$(values);
	}
	util.inherits(PropertiesPromiseArray, PromiseArray);

	PropertiesPromiseArray.prototype._init = function () {
	    this._init$(undefined, -3) ;
	};

	PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    this._values[index] = value;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        var val = {};
	        var keyOffset = this.length();
	        for (var i = 0, len = this.length(); i < len; ++i) {
	            val[this._values[i + keyOffset]] = this._values[i];
	        }
	        this._resolve(val);
	    }
	};

	PropertiesPromiseArray.prototype._promiseProgressed = function (value, index) {
	    this._promise._progress({
	        key: this._values[index + this.length()],
	        value: value
	    });
	};

	PropertiesPromiseArray.prototype.shouldCopyValues = function () {
	    return false;
	};

	PropertiesPromiseArray.prototype.getActualLength = function (len) {
	    return len >> 1;
	};

	function props(promises) {
	    var ret;
	    var castValue = tryConvertToPromise(promises);

	    if (!isObject(castValue)) {
	        return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/OsFKC8\u000a");
	    } else if (castValue instanceof Promise) {
	        ret = castValue._then(
	            Promise.props, undefined, undefined, undefined, undefined);
	    } else {
	        ret = new PropertiesPromiseArray(castValue).promise();
	    }

	    if (castValue instanceof Promise) {
	        ret._propagateFrom(castValue, 4);
	    }
	    return ret;
	}

	Promise.prototype.props = function () {
	    return props(this);
	};

	Promise.props = function (promises) {
	    return props(promises);
	};
	};


/***/ },
/* 122 */
/*!************************************!*\
  !*** ./~/bluebird/js/main/race.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(
	    Promise, INTERNAL, tryConvertToPromise, apiRejection) {
	var isArray = __webpack_require__(/*! ./util.js */ 95).isArray;

	var raceLater = function (promise) {
	    return promise.then(function(array) {
	        return race(array, promise);
	    });
	};

	function race(promises, parent) {
	    var maybePromise = tryConvertToPromise(promises);

	    if (maybePromise instanceof Promise) {
	        return raceLater(maybePromise);
	    } else if (!isArray(promises)) {
	        return apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
	    }

	    var ret = new Promise(INTERNAL);
	    if (parent !== undefined) {
	        ret._propagateFrom(parent, 4 | 1);
	    }
	    var fulfill = ret._fulfill;
	    var reject = ret._reject;
	    for (var i = 0, len = promises.length; i < len; ++i) {
	        var val = promises[i];

	        if (val === undefined && !(i in promises)) {
	            continue;
	        }

	        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
	    }
	    return ret;
	}

	Promise.race = function (promises) {
	    return race(promises, undefined);
	};

	Promise.prototype.race = function () {
	    return race(this, undefined);
	};

	};


/***/ },
/* 123 */
/*!**************************************!*\
  !*** ./~/bluebird/js/main/reduce.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(Promise,
	                          PromiseArray,
	                          apiRejection,
	                          tryConvertToPromise,
	                          INTERNAL) {
	var getDomain = Promise._getDomain;
	var async = __webpack_require__(/*! ./async.js */ 97);
	var util = __webpack_require__(/*! ./util.js */ 95);
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	function ReductionPromiseArray(promises, fn, accum, _each) {
	    this.constructor$(promises);
	    this._promise._captureStackTrace();
	    this._preservedValues = _each === INTERNAL ? [] : null;
	    this._zerothIsAccum = (accum === undefined);
	    this._gotAccum = false;
	    this._reducingIndex = (this._zerothIsAccum ? 1 : 0);
	    this._valuesPhase = undefined;
	    var maybePromise = tryConvertToPromise(accum, this._promise);
	    var rejected = false;
	    var isPromise = maybePromise instanceof Promise;
	    if (isPromise) {
	        maybePromise = maybePromise._target();
	        if (maybePromise._isPending()) {
	            maybePromise._proxyPromiseArray(this, -1);
	        } else if (maybePromise._isFulfilled()) {
	            accum = maybePromise._value();
	            this._gotAccum = true;
	        } else {
	            this._reject(maybePromise._reason());
	            rejected = true;
	        }
	    }
	    if (!(isPromise || this._zerothIsAccum)) this._gotAccum = true;
	    var domain = getDomain();
	    this._callback = domain === null ? fn : domain.bind(fn);
	    this._accum = accum;
	    if (!rejected) async.invoke(init, this, undefined);
	}
	function init() {
	    this._init$(undefined, -5);
	}
	util.inherits(ReductionPromiseArray, PromiseArray);

	ReductionPromiseArray.prototype._init = function () {};

	ReductionPromiseArray.prototype._resolveEmptyArray = function () {
	    if (this._gotAccum || this._zerothIsAccum) {
	        this._resolve(this._preservedValues !== null
	                        ? [] : this._accum);
	    }
	};

	ReductionPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var values = this._values;
	    values[index] = value;
	    var length = this.length();
	    var preservedValues = this._preservedValues;
	    var isEach = preservedValues !== null;
	    var gotAccum = this._gotAccum;
	    var valuesPhase = this._valuesPhase;
	    var valuesPhaseIndex;
	    if (!valuesPhase) {
	        valuesPhase = this._valuesPhase = new Array(length);
	        for (valuesPhaseIndex=0; valuesPhaseIndex<length; ++valuesPhaseIndex) {
	            valuesPhase[valuesPhaseIndex] = 0;
	        }
	    }
	    valuesPhaseIndex = valuesPhase[index];

	    if (index === 0 && this._zerothIsAccum) {
	        this._accum = value;
	        this._gotAccum = gotAccum = true;
	        valuesPhase[index] = ((valuesPhaseIndex === 0)
	            ? 1 : 2);
	    } else if (index === -1) {
	        this._accum = value;
	        this._gotAccum = gotAccum = true;
	    } else {
	        if (valuesPhaseIndex === 0) {
	            valuesPhase[index] = 1;
	        } else {
	            valuesPhase[index] = 2;
	            this._accum = value;
	        }
	    }
	    if (!gotAccum) return;

	    var callback = this._callback;
	    var receiver = this._promise._boundValue();
	    var ret;

	    for (var i = this._reducingIndex; i < length; ++i) {
	        valuesPhaseIndex = valuesPhase[i];
	        if (valuesPhaseIndex === 2) {
	            this._reducingIndex = i + 1;
	            continue;
	        }
	        if (valuesPhaseIndex !== 1) return;
	        value = values[i];
	        this._promise._pushContext();
	        if (isEach) {
	            preservedValues.push(value);
	            ret = tryCatch(callback).call(receiver, value, i, length);
	        }
	        else {
	            ret = tryCatch(callback)
	                .call(receiver, this._accum, value, i, length);
	        }
	        this._promise._popContext();

	        if (ret === errorObj) return this._reject(ret.e);

	        var maybePromise = tryConvertToPromise(ret, this._promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            if (maybePromise._isPending()) {
	                valuesPhase[i] = 4;
	                return maybePromise._proxyPromiseArray(this, i);
	            } else if (maybePromise._isFulfilled()) {
	                ret = maybePromise._value();
	            } else {
	                return this._reject(maybePromise._reason());
	            }
	        }

	        this._reducingIndex = i + 1;
	        this._accum = ret;
	    }

	    this._resolve(isEach ? preservedValues : this._accum);
	};

	function reduce(promises, fn, initialValue, _each) {
	    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
	    return array.promise();
	}

	Promise.prototype.reduce = function (fn, initialValue) {
	    return reduce(this, fn, initialValue, null);
	};

	Promise.reduce = function (promises, fn, initialValue, _each) {
	    return reduce(promises, fn, initialValue, _each);
	};
	};


/***/ },
/* 124 */
/*!**************************************!*\
  !*** ./~/bluebird/js/main/settle.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	module.exports =
	    function(Promise, PromiseArray) {
	var PromiseInspection = Promise.PromiseInspection;
	var util = __webpack_require__(/*! ./util.js */ 95);

	function SettledPromiseArray(values) {
	    this.constructor$(values);
	}
	util.inherits(SettledPromiseArray, PromiseArray);

	SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
	    this._values[index] = inspection;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        this._resolve(this._values);
	    }
	};

	SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var ret = new PromiseInspection();
	    ret._bitField = 268435456;
	    ret._settledValue = value;
	    this._promiseResolved(index, ret);
	};
	SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
	    var ret = new PromiseInspection();
	    ret._bitField = 134217728;
	    ret._settledValue = reason;
	    this._promiseResolved(index, ret);
	};

	Promise.settle = function (promises) {
	    return new SettledPromiseArray(promises).promise();
	};

	Promise.prototype.settle = function () {
	    return new SettledPromiseArray(this).promise();
	};
	};


/***/ },
/* 125 */
/*!************************************!*\
  !*** ./~/bluebird/js/main/some.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	module.exports =
	function(Promise, PromiseArray, apiRejection) {
	var util = __webpack_require__(/*! ./util.js */ 95);
	var RangeError = __webpack_require__(/*! ./errors.js */ 100).RangeError;
	var AggregateError = __webpack_require__(/*! ./errors.js */ 100).AggregateError;
	var isArray = util.isArray;


	function SomePromiseArray(values) {
	    this.constructor$(values);
	    this._howMany = 0;
	    this._unwrap = false;
	    this._initialized = false;
	}
	util.inherits(SomePromiseArray, PromiseArray);

	SomePromiseArray.prototype._init = function () {
	    if (!this._initialized) {
	        return;
	    }
	    if (this._howMany === 0) {
	        this._resolve([]);
	        return;
	    }
	    this._init$(undefined, -5);
	    var isArrayResolved = isArray(this._values);
	    if (!this._isResolved() &&
	        isArrayResolved &&
	        this._howMany > this._canPossiblyFulfill()) {
	        this._reject(this._getRangeError(this.length()));
	    }
	};

	SomePromiseArray.prototype.init = function () {
	    this._initialized = true;
	    this._init();
	};

	SomePromiseArray.prototype.setUnwrap = function () {
	    this._unwrap = true;
	};

	SomePromiseArray.prototype.howMany = function () {
	    return this._howMany;
	};

	SomePromiseArray.prototype.setHowMany = function (count) {
	    this._howMany = count;
	};

	SomePromiseArray.prototype._promiseFulfilled = function (value) {
	    this._addFulfilled(value);
	    if (this._fulfilled() === this.howMany()) {
	        this._values.length = this.howMany();
	        if (this.howMany() === 1 && this._unwrap) {
	            this._resolve(this._values[0]);
	        } else {
	            this._resolve(this._values);
	        }
	    }

	};
	SomePromiseArray.prototype._promiseRejected = function (reason) {
	    this._addRejected(reason);
	    if (this.howMany() > this._canPossiblyFulfill()) {
	        var e = new AggregateError();
	        for (var i = this.length(); i < this._values.length; ++i) {
	            e.push(this._values[i]);
	        }
	        this._reject(e);
	    }
	};

	SomePromiseArray.prototype._fulfilled = function () {
	    return this._totalResolved;
	};

	SomePromiseArray.prototype._rejected = function () {
	    return this._values.length - this.length();
	};

	SomePromiseArray.prototype._addRejected = function (reason) {
	    this._values.push(reason);
	};

	SomePromiseArray.prototype._addFulfilled = function (value) {
	    this._values[this._totalResolved++] = value;
	};

	SomePromiseArray.prototype._canPossiblyFulfill = function () {
	    return this.length() - this._rejected();
	};

	SomePromiseArray.prototype._getRangeError = function (count) {
	    var message = "Input array must contain at least " +
	            this._howMany + " items but contains only " + count + " items";
	    return new RangeError(message);
	};

	SomePromiseArray.prototype._resolveEmptyArray = function () {
	    this._reject(this._getRangeError(0));
	};

	function some(promises, howMany) {
	    if ((howMany | 0) !== howMany || howMany < 0) {
	        return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/1wAmHx\u000a");
	    }
	    var ret = new SomePromiseArray(promises);
	    var promise = ret.promise();
	    ret.setHowMany(howMany);
	    ret.init();
	    return promise;
	}

	Promise.some = function (promises, howMany) {
	    return some(promises, howMany);
	};

	Promise.prototype.some = function (howMany) {
	    return some(this, howMany);
	};

	Promise._SomePromiseArray = SomePromiseArray;
	};


/***/ },
/* 126 */
/*!*****************************************!*\
  !*** ./~/bluebird/js/main/promisify.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var THIS = {};
	var util = __webpack_require__(/*! ./util.js */ 95);
	var nodebackForPromise = __webpack_require__(/*! ./promise_resolver.js */ 107)
	    ._nodebackForPromise;
	var withAppended = util.withAppended;
	var maybeWrapAsError = util.maybeWrapAsError;
	var canEvaluate = util.canEvaluate;
	var TypeError = __webpack_require__(/*! ./errors */ 100).TypeError;
	var defaultSuffix = "Async";
	var defaultPromisified = {__isPromisified__: true};
	var noCopyProps = [
	    "arity",    "length",
	    "name",
	    "arguments",
	    "caller",
	    "callee",
	    "prototype",
	    "__isPromisified__"
	];
	var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");

	var defaultFilter = function(name) {
	    return util.isIdentifier(name) &&
	        name.charAt(0) !== "_" &&
	        name !== "constructor";
	};

	function propsFilter(key) {
	    return !noCopyPropsPattern.test(key);
	}

	function isPromisified(fn) {
	    try {
	        return fn.__isPromisified__ === true;
	    }
	    catch (e) {
	        return false;
	    }
	}

	function hasPromisified(obj, key, suffix) {
	    var val = util.getDataPropertyOrDefault(obj, key + suffix,
	                                            defaultPromisified);
	    return val ? isPromisified(val) : false;
	}
	function checkValid(ret, suffix, suffixRegexp) {
	    for (var i = 0; i < ret.length; i += 2) {
	        var key = ret[i];
	        if (suffixRegexp.test(key)) {
	            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
	            for (var j = 0; j < ret.length; j += 2) {
	                if (ret[j] === keyWithoutAsyncSuffix) {
	                    throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/iWrZbw\u000a"
	                        .replace("%s", suffix));
	                }
	            }
	        }
	    }
	}

	function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
	    var keys = util.inheritedDataKeys(obj);
	    var ret = [];
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        var value = obj[key];
	        var passesDefaultFilter = filter === defaultFilter
	            ? true : defaultFilter(key, value, obj);
	        if (typeof value === "function" &&
	            !isPromisified(value) &&
	            !hasPromisified(obj, key, suffix) &&
	            filter(key, value, obj, passesDefaultFilter)) {
	            ret.push(key, value);
	        }
	    }
	    checkValid(ret, suffix, suffixRegexp);
	    return ret;
	}

	var escapeIdentRegex = function(str) {
	    return str.replace(/([$])/, "\\$");
	};

	var makeNodePromisifiedEval;
	if (true) {
	var switchCaseArgumentOrder = function(likelyArgumentCount) {
	    var ret = [likelyArgumentCount];
	    var min = Math.max(0, likelyArgumentCount - 1 - 3);
	    for(var i = likelyArgumentCount - 1; i >= min; --i) {
	        ret.push(i);
	    }
	    for(var i = likelyArgumentCount + 1; i <= 3; ++i) {
	        ret.push(i);
	    }
	    return ret;
	};

	var argumentSequence = function(argumentCount) {
	    return util.filledRange(argumentCount, "_arg", "");
	};

	var parameterDeclaration = function(parameterCount) {
	    return util.filledRange(
	        Math.max(parameterCount, 3), "_arg", "");
	};

	var parameterCount = function(fn) {
	    if (typeof fn.length === "number") {
	        return Math.max(Math.min(fn.length, 1023 + 1), 0);
	    }
	    return 0;
	};

	makeNodePromisifiedEval =
	function(callback, receiver, originalName, fn) {
	    var newParameterCount = Math.max(0, parameterCount(fn) - 1);
	    var argumentOrder = switchCaseArgumentOrder(newParameterCount);
	    var shouldProxyThis = typeof callback === "string" || receiver === THIS;

	    function generateCallForArgumentCount(count) {
	        var args = argumentSequence(count).join(", ");
	        var comma = count > 0 ? ", " : "";
	        var ret;
	        if (shouldProxyThis) {
	            ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
	        } else {
	            ret = receiver === undefined
	                ? "ret = callback({{args}}, nodeback); break;\n"
	                : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
	        }
	        return ret.replace("{{args}}", args).replace(", ", comma);
	    }

	    function generateArgumentSwitchCase() {
	        var ret = "";
	        for (var i = 0; i < argumentOrder.length; ++i) {
	            ret += "case " + argumentOrder[i] +":" +
	                generateCallForArgumentCount(argumentOrder[i]);
	        }

	        ret += "                                                             \n\
	        default:                                                             \n\
	            var args = new Array(len + 1);                                   \n\
	            var i = 0;                                                       \n\
	            for (var i = 0; i < len; ++i) {                                  \n\
	               args[i] = arguments[i];                                       \n\
	            }                                                                \n\
	            args[i] = nodeback;                                              \n\
	            [CodeForCall]                                                    \n\
	            break;                                                           \n\
	        ".replace("[CodeForCall]", (shouldProxyThis
	                                ? "ret = callback.apply(this, args);\n"
	                                : "ret = callback.apply(receiver, args);\n"));
	        return ret;
	    }

	    var getFunctionCode = typeof callback === "string"
	                                ? ("this != null ? this['"+callback+"'] : fn")
	                                : "fn";

	    return new Function("Promise",
	                        "fn",
	                        "receiver",
	                        "withAppended",
	                        "maybeWrapAsError",
	                        "nodebackForPromise",
	                        "tryCatch",
	                        "errorObj",
	                        "notEnumerableProp",
	                        "INTERNAL","'use strict';                            \n\
	        var ret = function (Parameters) {                                    \n\
	            'use strict';                                                    \n\
	            var len = arguments.length;                                      \n\
	            var promise = new Promise(INTERNAL);                             \n\
	            promise._captureStackTrace();                                    \n\
	            var nodeback = nodebackForPromise(promise);                      \n\
	            var ret;                                                         \n\
	            var callback = tryCatch([GetFunctionCode]);                      \n\
	            switch(len) {                                                    \n\
	                [CodeForSwitchCase]                                          \n\
	            }                                                                \n\
	            if (ret === errorObj) {                                          \n\
	                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
	            }                                                                \n\
	            return promise;                                                  \n\
	        };                                                                   \n\
	        notEnumerableProp(ret, '__isPromisified__', true);                   \n\
	        return ret;                                                          \n\
	        "
	        .replace("Parameters", parameterDeclaration(newParameterCount))
	        .replace("[CodeForSwitchCase]", generateArgumentSwitchCase())
	        .replace("[GetFunctionCode]", getFunctionCode))(
	            Promise,
	            fn,
	            receiver,
	            withAppended,
	            maybeWrapAsError,
	            nodebackForPromise,
	            util.tryCatch,
	            util.errorObj,
	            util.notEnumerableProp,
	            INTERNAL
	        );
	};
	}

	function makeNodePromisifiedClosure(callback, receiver, _, fn) {
	    var defaultThis = (function() {return this;})();
	    var method = callback;
	    if (typeof method === "string") {
	        callback = fn;
	    }
	    function promisified() {
	        var _receiver = receiver;
	        if (receiver === THIS) _receiver = this;
	        var promise = new Promise(INTERNAL);
	        promise._captureStackTrace();
	        var cb = typeof method === "string" && this !== defaultThis
	            ? this[method] : callback;
	        var fn = nodebackForPromise(promise);
	        try {
	            cb.apply(_receiver, withAppended(arguments, fn));
	        } catch(e) {
	            promise._rejectCallback(maybeWrapAsError(e), true, true);
	        }
	        return promise;
	    }
	    util.notEnumerableProp(promisified, "__isPromisified__", true);
	    return promisified;
	}

	var makeNodePromisified = canEvaluate
	    ? makeNodePromisifiedEval
	    : makeNodePromisifiedClosure;

	function promisifyAll(obj, suffix, filter, promisifier) {
	    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
	    var methods =
	        promisifiableMethods(obj, suffix, suffixRegexp, filter);

	    for (var i = 0, len = methods.length; i < len; i+= 2) {
	        var key = methods[i];
	        var fn = methods[i+1];
	        var promisifiedKey = key + suffix;
	        if (promisifier === makeNodePromisified) {
	            obj[promisifiedKey] =
	                makeNodePromisified(key, THIS, key, fn, suffix);
	        } else {
	            var promisified = promisifier(fn, function() {
	                return makeNodePromisified(key, THIS, key, fn, suffix);
	            });
	            util.notEnumerableProp(promisified, "__isPromisified__", true);
	            obj[promisifiedKey] = promisified;
	        }
	    }
	    util.toFastProperties(obj);
	    return obj;
	}

	function promisify(callback, receiver) {
	    return makeNodePromisified(callback, receiver, undefined, callback);
	}

	Promise.promisify = function (fn, receiver) {
	    if (typeof fn !== "function") {
	        throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    }
	    if (isPromisified(fn)) {
	        return fn;
	    }
	    var ret = promisify(fn, arguments.length < 2 ? THIS : receiver);
	    util.copyDescriptors(fn, ret, propsFilter);
	    return ret;
	};

	Promise.promisifyAll = function (target, options) {
	    if (typeof target !== "function" && typeof target !== "object") {
	        throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/9ITlV0\u000a");
	    }
	    options = Object(options);
	    var suffix = options.suffix;
	    if (typeof suffix !== "string") suffix = defaultSuffix;
	    var filter = options.filter;
	    if (typeof filter !== "function") filter = defaultFilter;
	    var promisifier = options.promisifier;
	    if (typeof promisifier !== "function") promisifier = makeNodePromisified;

	    if (!util.isIdentifier(suffix)) {
	        throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/8FZo5V\u000a");
	    }

	    var keys = util.inheritedDataKeys(target);
	    for (var i = 0; i < keys.length; ++i) {
	        var value = target[keys[i]];
	        if (keys[i] !== "constructor" &&
	            util.isClass(value)) {
	            promisifyAll(value.prototype, suffix, filter, promisifier);
	            promisifyAll(value, suffix, filter, promisifier);
	        }
	    }

	    return promisifyAll(target, suffix, filter, promisifier);
	};
	};



/***/ },
/* 127 */
/*!***********************************!*\
  !*** ./~/bluebird/js/main/any.js ***!
  \***********************************/
/***/ function(module, exports) {

	"use strict";
	module.exports = function(Promise) {
	var SomePromiseArray = Promise._SomePromiseArray;
	function any(promises) {
	    var ret = new SomePromiseArray(promises);
	    var promise = ret.promise();
	    ret.setHowMany(1);
	    ret.setUnwrap();
	    ret.init();
	    return promise;
	}

	Promise.any = function (promises) {
	    return any(promises);
	};

	Promise.prototype.any = function () {
	    return any(this);
	};

	};


/***/ },
/* 128 */
/*!************************************!*\
  !*** ./~/bluebird/js/main/each.js ***!
  \************************************/
/***/ function(module, exports) {

	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var PromiseReduce = Promise.reduce;

	Promise.prototype.each = function (fn) {
	    return PromiseReduce(this, fn, null, INTERNAL);
	};

	Promise.each = function (promises, fn) {
	    return PromiseReduce(promises, fn, null, INTERNAL);
	};
	};


/***/ },
/* 129 */
/*!**************************************!*\
  !*** ./~/bluebird/js/main/timers.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var util = __webpack_require__(/*! ./util.js */ 95);
	var TimeoutError = Promise.TimeoutError;

	var afterTimeout = function (promise, message) {
	    if (!promise.isPending()) return;
	    
	    var err;
	    if(!util.isPrimitive(message) && (message instanceof Error)) {
	        err = message;
	    } else {
	        if (typeof message !== "string") {
	            message = "operation timed out";
	        }
	        err = new TimeoutError(message);
	    }
	    util.markAsOriginatingFromRejection(err);
	    promise._attachExtraTrace(err);
	    promise._cancel(err);
	};

	var afterValue = function(value) { return delay(+this).thenReturn(value); };
	var delay = Promise.delay = function (value, ms) {
	    if (ms === undefined) {
	        ms = value;
	        value = undefined;
	        var ret = new Promise(INTERNAL);
	        setTimeout(function() { ret._fulfill(); }, ms);
	        return ret;
	    }
	    ms = +ms;
	    return Promise.resolve(value)._then(afterValue, null, null, ms, undefined);
	};

	Promise.prototype.delay = function (ms) {
	    return delay(this, ms);
	};

	function successClear(value) {
	    var handle = this;
	    if (handle instanceof Number) handle = +handle;
	    clearTimeout(handle);
	    return value;
	}

	function failureClear(reason) {
	    var handle = this;
	    if (handle instanceof Number) handle = +handle;
	    clearTimeout(handle);
	    throw reason;
	}

	Promise.prototype.timeout = function (ms, message) {
	    ms = +ms;
	    var ret = this.then().cancellable();
	    ret._cancellationParent = this;
	    var handle = setTimeout(function timeoutTimeout() {
	        afterTimeout(ret, message);
	    }, ms);
	    return ret._then(successClear, failureClear, undefined, handle, undefined);
	};

	};


/***/ },
/* 130 */
/*!**************************************!*\
  !*** ./~/bluebird/js/main/filter.js ***!
  \**************************************/
/***/ function(module, exports) {

	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var PromiseMap = Promise.map;

	Promise.prototype.filter = function (fn, options) {
	    return PromiseMap(this, fn, options, INTERNAL);
	};

	Promise.filter = function (promises, fn, options) {
	    return PromiseMap(promises, fn, options, INTERNAL);
	};
	};


/***/ },
/* 131 */
/*!*********************************!*\
  !*** ./~/node-helpers/utils.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	//---------//
	// Imports //
	//---------//

	var xor = __webpack_require__(/*! component-xor */ 132);


	//------//
	// Main //
	//------//

	function bothNullOrEquals(left_, right_, eqFn_) {
	    var normalizedEqFn = normalizeEqualityFunction(eqFn_, "Invalid Argument: bothNullOrEquals requires an undefined, string, or function argument");
	    var res;
	    if (xor(left_ === null, right_ === null)) {
	        res = false;
	    } else if (left_ === null && right_ === null) {
	        res = true;
	    } else { // neither left nor right are null, so we can safely pass them into the equality function
	        res = normalizedEqFn(left_, right_);
	    }

	    return res;
	}

	// make sure to pass this as the eqFn into bothNullOrEquals so you don't get a null error
	function dateEqFn(left_, right_) {
	    return left_.getTime() === right_.getTime();
	}

	function normalizeEqualityFunction(eqFn_, err_) {
	    var normalizedEqFn;

	    // Logic for below is as follows:
	    //   - If eqFn is undefined, then test for strict equality
	    //   - If it is a string, then we assume the iterated element has an equality property named whatever eqFn is
	    //   - If it's a function, then we assume it takes in two arguments and returns a boolean for equality.
	    //   - normalizedEqFn turns each of the above into a normalized equality function(left, right).
	    if (typeof eqFn_ === 'undefined') {
	        normalizedEqFn = function(left, right) {
	            return left === right;
	        };
	    } else if (typeof eqFn_ === 'string') {
	        normalizedEqFn = function(left, right) {
	            return left[eqFn_](right);
	        };
	    } else if (typeof eqFn_ === 'function') {
	        normalizedEqFn = eqFn_;
	    } else {
	        var msg = (typeof err_ === 'string') ? err_ : "Invalid Argument: normalizedEqualityFunction requires an undefined, string, or function argument";

	        throw new Error(msg);
	    }

	    return normalizedEqFn;
	}

	function in_array(item, arr) {
	    return arr.indexOf(item) !== -1;
	}

	function instance_of(obj, fxn) {
	    if (typeof obj !== 'object' || obj === null) {
	        return false;
	    }

	    var found = false;
	    var objProto = Object.getPrototypeOf(obj);
	    while (objProto !== null && !found) {
	        found = objProto.constructor.name === fxn.name;
	        objProto = Object.getPrototypeOf(objProto);
	    }
	    return found;
	}

	function isNumeric(n) {
	    return !isNaN(parseFloat(n)) && isFinite(n);
	}

	function repeatString(str, count) {
	    if (typeof str !== 'string' || isNaN(count)) {
	        throw new Error("Invalid Argument: Utils.repeatString requires a typeof string followed by a number argument");
	    }

	    if (count < 1) return '';
	    var result = '';
	    while (count > 1) {
	        if (count & 1) result += str;
	        count >>= 1, str += str;
	    }
	    return result + str;
	}

	function everyCombinationOf(arrayN) {
	    var argsArray = Array.prototype.slice.call(arguments);

	    if (argsArray.length < 2) {
	        throw new Error("Invalid Argument: Utils.everyCombinationOf requires at least two arrays");
	    }

	    var allArgsAreArrays = true;
	    var i = 0;
	    while (allArgsAreArrays && i < argsArray.length) {
	        var curArg = argsArray[0];
	        if (!instance_of(curArg, Array)) {
	            allArgsAreArrays = false;
	        }
	        i += 1;
	    };
	    if (!allArgsAreArrays) {
	        throw new Error("Invalid Argument: Utils.everyCombinationOf requires all arguments to be instance_of Array");
	    }

	    var res = []
	        , oldRes = [];

	    argsArray.forEach(function(anArray, i) {
	        if (oldRes.length) {
	            oldRes.forEach(function(key) {
	                anArray.forEach(function(aVal) {
	                    res.push(key.concat(aVal));
	                });
	            });
	        } else {
	            anArray.forEach(function(aVal) {
	                res.push([aVal]);
	            });
	        }

	        if (i < argsArray.length - 1) {
	            oldRes = res;
	            res = [];
	        }
	    });

	    return res;
	}


	//---------//
	// Exports //
	//---------//

	module.exports.xor = xor;
	module.exports.bothNullOrEquals = bothNullOrEquals;
	module.exports.dateEqFn = dateEqFn;
	module.exports.normalizeEqualityFunction = normalizeEqualityFunction;
	module.exports.in_array = in_array;
	module.exports.instance_of = instance_of;
	module.exports.isNumeric = isNumeric;
	module.exports.repeatString = repeatString;
	module.exports.everyCombinationOf = everyCombinationOf;


/***/ },
/* 132 */
/*!**********************************!*\
  !*** ./~/component-xor/index.js ***!
  \**********************************/
/***/ function(module, exports) {

	/**
	 * Expose `xor`
	 */

	module.exports = xor;

	/**
	 * XOR utility
	 *
	 * T T F
	 * T F T
	 * F T T
	 * F F F
	 *
	 * @param {Boolean} a
	 * @param {Boolean} b
	 * @return {Boolean}
	 */

	function xor(a, b) {
	  return !a != !b;
	}


/***/ },
/* 133 */
/*!***************************!*\
  !*** ./~/pg/lib/index.js ***!
  \***************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2010-2016 Brian Carlson (brian.m.carlson@gmail.com)
	 * All rights reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * README.md file in the root directory of this source tree.
	 */

	var EventEmitter = __webpack_require__(/*! events */ 26).EventEmitter;
	var util = __webpack_require__(/*! util */ 16);
	var Client = __webpack_require__(/*! ./client */ 134);
	var defaults =  __webpack_require__(/*! ./defaults */ 153);
	var Connection = __webpack_require__(/*! ./connection */ 158);
	var ConnectionParameters = __webpack_require__(/*! ./connection-parameters */ 151);
	var poolFactory = __webpack_require__(/*! ./pool-factory */ 163);

	var PG = function(clientConstructor) {
	  EventEmitter.call(this);
	  this.defaults = defaults;
	  this.Client = clientConstructor;
	  this.Query = this.Client.Query;
	  this.Pool = poolFactory(this.Client);
	  this._pools = [];
	  this.Connection = Connection;
	  this.types = __webpack_require__(/*! pg-types */ 141);
	};

	util.inherits(PG, EventEmitter);

	PG.prototype.end = function() {
	  var self = this;
	  var keys = Object.keys(this._pools);
	  var count = keys.length;
	  if(count === 0) {
	    self.emit('end');
	  } else {
	    keys.forEach(function(key) {
	      var pool = self._pools[key];
	      delete self._pools[key];
	      pool.pool.drain(function() {
	        pool.pool.destroyAllNow(function() {
	          count--;
	          if(count === 0) {
	            self.emit('end');
	          }
	        });
	      });
	    });
	  }
	};

	PG.prototype.connect = function(config, callback) {
	  if(typeof config == "function") {
	    callback = config;
	    config = null;
	  }
	  var poolName = JSON.stringify(config || {});
	  if (typeof config == 'string') {
	    config = new ConnectionParameters(config);
	  }

	  config = config || {};

	  //for backwards compatibility
	  config.max = config.max || config.poolSize || defaults.poolSize;
	  config.idleTimeoutMillis = config.idleTimeoutMillis || config.poolIdleTimeout || defaults.poolIdleTimeout;
	  config.log = config.log || config.poolLog || defaults.poolLog;

	  this._pools[poolName] = this._pools[poolName] || new this.Pool(config);
	  var pool = this._pools[poolName];
	  if(!pool.listeners('error').length) {
	    //propagate errors up to pg object
	    pool.on('error', function(e) {
	      this.emit('error', e, e.client);
	    }.bind(this));
	  }
	  return pool.connect(callback);
	};

	// cancel the query running on the given client
	PG.prototype.cancel = function(config, client, query) {
	  if(client.native) {
	    return client.cancel(query);
	  }
	  var c = config;
	  //allow for no config to be passed
	  if(typeof c === 'function') {
	    c = defaults;
	  }
	  var cancellingClient = new this.Client(c);
	  cancellingClient.cancel(client, query);
	};

	if(typeof process.env.NODE_PG_FORCE_NATIVE != 'undefined') {
	  module.exports = new PG(__webpack_require__(/*! ./native */ 167));
	} else {
	  module.exports = new PG(Client);

	  //lazy require native module...the native module may not have installed
	  module.exports.__defineGetter__("native", function() {
	    delete module.exports.native;
	    var native = null;
	    try {
	      native = new PG(__webpack_require__(/*! ./native */ 167));
	    } catch (err) {
	      if (err.code !== 'MODULE_NOT_FOUND') {
	        throw err;
	      }
	      console.error(err.message);
	    }
	    module.exports.native = native;
	    return native;
	  });
	}


/***/ },
/* 134 */
/*!****************************!*\
  !*** ./~/pg/lib/client.js ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2010-2016 Brian Carlson (brian.m.carlson@gmail.com)
	 * All rights reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * README.md file in the root directory of this source tree.
	 */

	var crypto = __webpack_require__(/*! crypto */ 70);
	var EventEmitter = __webpack_require__(/*! events */ 26).EventEmitter;
	var util = __webpack_require__(/*! util */ 16);
	var pgPass = __webpack_require__(/*! pgpass */ 135);
	var TypeOverrides = __webpack_require__(/*! ./type-overrides */ 140);

	var ConnectionParameters = __webpack_require__(/*! ./connection-parameters */ 151);
	var Query = __webpack_require__(/*! ./query */ 155);
	var defaults = __webpack_require__(/*! ./defaults */ 153);
	var Connection = __webpack_require__(/*! ./connection */ 158);

	var Client = function(config) {
	  EventEmitter.call(this);

	  this.connectionParameters = new ConnectionParameters(config);
	  this.user = this.connectionParameters.user;
	  this.database = this.connectionParameters.database;
	  this.port = this.connectionParameters.port;
	  this.host = this.connectionParameters.host;
	  this.password = this.connectionParameters.password;

	  var c = config || {};

	  this._types = new TypeOverrides(c.types);

	  this.connection = c.connection || new Connection({
	    stream: c.stream,
	    ssl: this.connectionParameters.ssl,
	    keepAlive: c.keepAlive || false
	  });
	  this.queryQueue = [];
	  this.binary = c.binary || defaults.binary;
	  this.encoding = 'utf8';
	  this.processID = null;
	  this.secretKey = null;
	  this.ssl = this.connectionParameters.ssl || false;
	};

	util.inherits(Client, EventEmitter);

	Client.prototype.connect = function(callback) {
	  var self = this;
	  var con = this.connection;

	  if(this.host && this.host.indexOf('/') === 0) {
	    con.connect(this.host + '/.s.PGSQL.' + this.port);
	  } else {
	    con.connect(this.port, this.host);
	  }


	  //once connection is established send startup message
	  con.on('connect', function() {
	    if(self.ssl) {
	      con.requestSsl();
	    } else {
	      con.startup(self.getStartupConf());
	    }
	  });

	  con.on('sslconnect', function() {
	    con.startup(self.getStartupConf());
	  });

	  function checkPgPass(cb) {
	    return function(msg) {
	      if (null !== self.password) {
	        cb(msg);
	      } else {
	        pgPass(self.connectionParameters, function(pass){
	          if (undefined !== pass) {
	            self.connectionParameters.password = self.password = pass;
	          }
	          cb(msg);
	        });
	      }
	    };
	  }

	  //password request handling
	  con.on('authenticationCleartextPassword', checkPgPass(function() {
	    con.password(self.password);
	  }));

	  //password request handling
	  con.on('authenticationMD5Password', checkPgPass(function(msg) {
	    var inner = Client.md5(self.password + self.user);
	    var outer = Client.md5(Buffer.concat([new Buffer(inner), msg.salt]));
	    var md5password = "md5" + outer;
	    con.password(md5password);
	  }));

	  con.once('backendKeyData', function(msg) {
	    self.processID = msg.processID;
	    self.secretKey = msg.secretKey;
	  });

	  //hook up query handling events to connection
	  //after the connection initially becomes ready for queries
	  con.once('readyForQuery', function() {

	    //delegate rowDescription to active query
	    con.on('rowDescription', function(msg) {
	      self.activeQuery.handleRowDescription(msg);
	    });

	    //delegate dataRow to active query
	    con.on('dataRow', function(msg) {
	      self.activeQuery.handleDataRow(msg);
	    });

	    //delegate portalSuspended to active query
	    con.on('portalSuspended', function(msg) {
	      self.activeQuery.handlePortalSuspended(con);
	    });

	    //deletagate emptyQuery to active query
	    con.on('emptyQuery', function(msg) {
	      self.activeQuery.handleEmptyQuery(con);
	    });

	    //delegate commandComplete to active query
	    con.on('commandComplete', function(msg) {
	      self.activeQuery.handleCommandComplete(msg, con);
	    });

	    //if a prepared statement has a name and properly parses
	    //we track that its already been executed so we don't parse
	    //it again on the same client
	    con.on('parseComplete', function(msg) {
	      if(self.activeQuery.name) {
	        con.parsedStatements[self.activeQuery.name] = true;
	      }
	    });

	    con.on('copyInResponse', function(msg) {
	      self.activeQuery.handleCopyInResponse(self.connection);
	    });

	    con.on('copyData', function (msg) {
	      self.activeQuery.handleCopyData(msg, self.connection);
	    });

	    con.on('notification', function(msg) {
	      self.emit('notification', msg);
	    });

	    //process possible callback argument to Client#connect
	    if (callback) {
	      callback(null, self);
	      //remove callback for proper error handling
	      //after the connect event
	      callback = null;
	    }
	    self.emit('connect');
	  });

	  con.on('readyForQuery', function() {
	    var activeQuery = self.activeQuery;
	    self.activeQuery = null;
	    self.readyForQuery = true;
	    self._pulseQueryQueue();
	    if(activeQuery) {
	      activeQuery.handleReadyForQuery();
	    }
	  });

	  con.on('error', function(error) {
	    if(self.activeQuery) {
	      var activeQuery = self.activeQuery;
	      self.activeQuery = null;
	      return activeQuery.handleError(error, con);
	    }
	    if(!callback) {
	      return self.emit('error', error);
	    }
	    callback(error);
	    callback = null;
	  });

	  con.once('end', function() {
	    if ( callback ) {
	      // haven't received a connection message yet !
	      var err = new Error('Connection terminated');
	      callback(err);
	      callback = null;
	      return;
	    }
	    if(self.activeQuery) {
	      var disconnectError = new Error('Connection terminated');
	      self.activeQuery.handleError(disconnectError, con);
	      self.activeQuery = null;
	    }
	    self.emit('end');
	  });


	  con.on('notice', function(msg) {
	    self.emit('notice', msg);
	  });

	};

	Client.prototype.getStartupConf = function() {
	  var params = this.connectionParameters;

	  var data = {
	    user: params.user,
	    database: params.database
	  };

	  var appName = params.application_name || params.fallback_application_name;
	  if (appName) {
	    data.application_name = appName;
	  }

	  return data;
	};

	Client.prototype.cancel = function(client, query) {
	  if(client.activeQuery == query) {
	    var con = this.connection;

	    if(this.host && this.host.indexOf('/') === 0) {
	      con.connect(this.host + '/.s.PGSQL.' + this.port);
	    } else {
	      con.connect(this.port, this.host);
	    }

	    //once connection is established send cancel message
	    con.on('connect', function() {
	      con.cancel(client.processID, client.secretKey);
	    });
	  } else if(client.queryQueue.indexOf(query) != -1) {
	    client.queryQueue.splice(client.queryQueue.indexOf(query), 1);
	  }
	};

	Client.prototype.setTypeParser = function(oid, format, parseFn) {
	  return this._types.setTypeParser(oid, format, parseFn);
	};

	Client.prototype.getTypeParser = function(oid, format) {
	  return this._types.getTypeParser(oid, format);
	};

	// Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c
	Client.prototype.escapeIdentifier = function(str) {

	  var escaped = '"';

	  for(var i = 0; i < str.length; i++) {
	    var c = str[i];
	    if(c === '"') {
	      escaped += c + c;
	    } else {
	      escaped += c;
	    }
	  }

	  escaped += '"';

	  return escaped;
	};

	// Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c
	Client.prototype.escapeLiteral = function(str) {

	  var hasBackslash = false;
	  var escaped = '\'';

	  for(var i = 0; i < str.length; i++) {
	    var c = str[i];
	    if(c === '\'') {
	      escaped += c + c;
	    } else if (c === '\\') {
	      escaped += c + c;
	      hasBackslash = true;
	    } else {
	      escaped += c;
	    }
	  }

	  escaped += '\'';

	  if(hasBackslash === true) {
	    escaped = ' E' + escaped;
	  }

	  return escaped;
	};

	Client.prototype._pulseQueryQueue = function() {
	  if(this.readyForQuery===true) {
	    this.activeQuery = this.queryQueue.shift();
	    if(this.activeQuery) {
	      this.readyForQuery = false;
	      this.hasExecuted = true;
	      this.activeQuery.submit(this.connection);
	    } else if(this.hasExecuted) {
	      this.activeQuery = null;
	      this.emit('drain');
	    }
	  }
	};

	Client.prototype.copyFrom = function (text) {
	  throw new Error("For PostgreSQL COPY TO/COPY FROM support npm install pg-copy-streams");
	};

	Client.prototype.copyTo = function (text) {
	  throw new Error("For PostgreSQL COPY TO/COPY FROM support npm install pg-copy-streams");
	};

	Client.prototype.query = function(config, values, callback) {
	  //can take in strings, config object or query object
	  var query = (typeof config.submit == 'function') ? config :
	     new Query(config, values, callback);
	  if(this.binary && !query.binary) {
	    query.binary = true;
	  }
	  if(query._result) {
	    query._result._getTypeParser = this._types.getTypeParser.bind(this._types);
	  }

	  this.queryQueue.push(query);
	  this._pulseQueryQueue();
	  return query;
	};

	Client.prototype.end = function(cb) {
	  this.connection.end();
	  if (cb) {
	    this.connection.once('end', cb);
	  }
	};

	Client.md5 = function(string) {
	  return crypto.createHash('md5').update(string).digest('hex');
	};

	// expose a Query constructor
	Client.Query = Query;

	module.exports = Client;


/***/ },
/* 135 */
/*!*******************************!*\
  !*** ./~/pgpass/lib/index.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var path = __webpack_require__(/*! path */ 11)
	  , fs = __webpack_require__(/*! fs */ 19)
	  , helper = __webpack_require__(/*! ./helper.js */ 136)
	;


	module.exports = function(connInfo, cb) {
	    var file = helper.getFileName();
	    
	    fs.stat(file, function(err, stat){
	        if (err || !helper.usePgPass(stat, file)) {
	            return cb(undefined);
	        }

	        var st = fs.createReadStream(file);

	        helper.getPassword(connInfo, st, cb);
	    });
	};

	module.exports.warnTo = helper.warnTo;


/***/ },
/* 136 */
/*!********************************!*\
  !*** ./~/pgpass/lib/helper.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var path = __webpack_require__(/*! path */ 11)
	  , Stream = __webpack_require__(/*! stream */ 67).Stream
	  , Split = __webpack_require__(/*! split */ 137)
	  , util = __webpack_require__(/*! util */ 16)
	  , defaultPort = 5432
	  , isWin = (process.platform === 'win32')
	  , warnStream = process.stderr
	;


	var S_IRWXG = 56     //    00070(8)
	  , S_IRWXO = 7      //    00007(8)
	  , S_IFMT  = 61440  // 00170000(8)
	  , S_IFREG = 32768  //  0100000(8)
	;
	function isRegFile(mode) {
	    return ((mode & S_IFMT) == S_IFREG);
	}

	var fieldNames = [ 'host', 'port', 'database', 'user', 'password' ];
	var nrOfFields = fieldNames.length;
	var passKey = fieldNames[ nrOfFields -1 ];


	function warn() {
	    var isWritable = (
	        warnStream instanceof Stream &&
	          true === warnStream.writable
	    );

	    if (isWritable) {
	        var args = Array.prototype.slice.call(arguments).concat("\n");
	        warnStream.write( util.format.apply(util, args) );
	    }
	}


	Object.defineProperty(module.exports, 'isWin', {
	    get : function() {
	        return isWin;
	    } ,
	    set : function(val) {
	        isWin = val;
	    }
	});


	module.exports.warnTo = function(stream) {
	    var old = warnStream;
	    warnStream = stream;
	    return old;
	};

	module.exports.getFileName = function(env){
	    env = env || process.env;
	    var file = env.PGPASSFILE || (
	        isWin ?
	          path.join( env.APPDATA , 'postgresql', 'pgpass.conf' ) :
	          path.join( env.HOME, '.pgpass' )
	    );
	    return file;
	};

	module.exports.usePgPass = function(stats, fname) {
	    if (Object.prototype.hasOwnProperty.call(process.env, 'PGPASSWORD')) {
	        return false;
	    }

	    if (isWin) {
	        return true;
	    }

	    fname = fname || '<unkn>';

	    if (! isRegFile(stats.mode)) {
	        warn('WARNING: password file "%s" is not a plain file', fname);
	        return false;
	    }

	    if (stats.mode & (S_IRWXG | S_IRWXO)) {
	        /* If password file is insecure, alert the user and ignore it. */
	        warn('WARNING: password file "%s" has group or world access; permissions should be u=rw (0600) or less', fname);
	        return false;
	    }

	    return true;
	};


	var matcher = module.exports.match = function(connInfo, entry) {
	    return fieldNames.slice(0, -1).reduce(function(prev, field, idx){
	        if (idx == 1) {
	            // the port
	            if ( Number( connInfo[field] || defaultPort ) === Number( entry[field] ) ) {
	                return prev && true;
	            }
	        }
	        return prev && (
	            entry[field] === '*' ||
	              entry[field] === connInfo[field]
	        );
	    }, true);
	};


	module.exports.getPassword = function(connInfo, stream, cb) {
	    var pass;
	    var lineStream = stream.pipe(new Split());

	    function onLine(line) {
	        var entry = parseLine(line);
	        if (entry && isValidEntry(entry) && matcher(connInfo, entry)) {
	            pass = entry[passKey];
	            lineStream.end(); // -> calls onEnd(), but pass is set now
	        }
	    }

	    var onEnd = function() {
	        stream.destroy();
	        cb(pass);
	    };

	    var onErr = function(err) {
	        stream.destroy();
	        warn('WARNING: error on reading file: %s', err);
	        cb(undefined);
	    };

	    stream.on('error', onErr);
	    lineStream
	        .on('data', onLine)
	        .on('end', onEnd)
	        .on('error', onErr)
	    ;

	};


	var parseLine = module.exports.parseLine = function(line) {
	    if (line.length < 11 || line.match(/^\s+#/)) {
	        return null;
	    }

	    var curChar = '';
	    var prevChar = '';
	    var fieldIdx = 0;
	    var startIdx = 0;
	    var endIdx = 0;
	    var obj = {};
	    var isLastField = false;
	    var addToObj = function(idx, i0, i1) {
	        var field = line.substring(i0, i1);

	        if (! Object.hasOwnProperty.call(process.env, 'PGPASS_NO_DEESCAPE')) {
	            field = field.replace(/\\([:\\])/g, '$1');
	        }

	        obj[ fieldNames[idx] ] = field;
	    };

	    for (var i = 0 ; i < line.length-1 ; i += 1) {
	        curChar = line.charAt(i+1);
	        prevChar = line.charAt(i);

	        isLastField = (fieldIdx == nrOfFields-1);

	        if (isLastField) {
	            addToObj(fieldIdx, startIdx);
	            break;
	        }

	        if (i >= 0 && curChar == ':' && prevChar !== '\\') {
	            addToObj(fieldIdx, startIdx, i+1);

	            startIdx = i+2;
	            fieldIdx += 1;
	        }
	    }

	    obj = ( Object.keys(obj).length === nrOfFields ) ? obj : null;

	    return obj;
	};


	var isValidEntry = module.exports.isValidEntry = function(entry){
	    var rules = {
	        // host
	        0 : function(x){
	            return x.length > 0;
	        } ,
	        // port
	        1 : function(x){
	            if (x === '*') {
	                return true;
	            }
	            x = Number(x);
	            return (
	                isFinite(x) &&
	                  x > 0 &&
	                  x < 9007199254740992 &&
	                  Math.floor(x) === x
	            );
	        } ,
	        // database
	        2 : function(x){
	            return x.length > 0;
	        } ,
	        // username
	        3 : function(x){
	            return x.length > 0;
	        } ,
	        // password
	        4 : function(x){
	            return x.length > 0;
	        }
	    };

	    for (var idx = 0 ; idx < fieldNames.length ; idx += 1) {
	        var rule = rules[idx];
	        var value = entry[ fieldNames[idx] ] || '';

	        var res = rule(value);
	        if (!res) {
	            return false;
	        }
	    }

	    return true;
	};



/***/ },
/* 137 */
/*!***********************************!*\
  !*** ./~/pgpass/~/split/index.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	//filter will reemit the data if cb(err,pass) pass is truthy

	// reduce is more tricky
	// maybe we want to group the reductions or emit progress updates occasionally
	// the most basic reduce just emits one 'data' event after it has recieved 'end'


	var through = __webpack_require__(/*! through */ 138)
	var Decoder = __webpack_require__(/*! string_decoder */ 139).StringDecoder

	module.exports = split

	//TODO pass in a function to map across the lines.

	function split (matcher, mapper, options) {
	  var decoder = new Decoder()
	  var soFar = ''
	  var maxLength = options && options.maxLength;
	  var trailing = options && options.trailing === false ? false : true
	  if('function' === typeof matcher)
	    mapper = matcher, matcher = null
	  if (!matcher)
	    matcher = /\r?\n/

	  function emit(stream, piece) {
	    if(mapper) {
	      try {
	        piece = mapper(piece)
	      }
	      catch (err) {
	        return stream.emit('error', err)
	      }
	      if('undefined' !== typeof piece)
	        stream.queue(piece)
	    }
	    else
	      stream.queue(piece)
	  }

	  function next (stream, buffer) {
	    var pieces = ((soFar != null ? soFar : '') + buffer).split(matcher)
	    soFar = pieces.pop()

	    if (maxLength && soFar.length > maxLength)
	      stream.emit('error', new Error('maximum buffer reached'))

	    for (var i = 0; i < pieces.length; i++) {
	      var piece = pieces[i]
	      emit(stream, piece)
	    }
	  }

	  return through(function (b) {
	    next(this, decoder.write(b))
	  },
	  function () {
	    if(decoder.end)
	      next(this, decoder.end())
	    if(trailing && soFar != null)
	      emit(this, soFar)
	    this.queue(null)
	  })
	}


/***/ },
/* 138 */
/*!****************************!*\
  !*** ./~/through/index.js ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	var Stream = __webpack_require__(/*! stream */ 67)

	// through
	//
	// a stream that does nothing but re-emit the input.
	// useful for aggregating a series of changing but not ending streams into one stream)

	exports = module.exports = through
	through.through = through

	//create a readable writable stream.

	function through (write, end, opts) {
	  write = write || function (data) { this.queue(data) }
	  end = end || function () { this.queue(null) }

	  var ended = false, destroyed = false, buffer = [], _ended = false
	  var stream = new Stream()
	  stream.readable = stream.writable = true
	  stream.paused = false

	//  stream.autoPause   = !(opts && opts.autoPause   === false)
	  stream.autoDestroy = !(opts && opts.autoDestroy === false)

	  stream.write = function (data) {
	    write.call(this, data)
	    return !stream.paused
	  }

	  function drain() {
	    while(buffer.length && !stream.paused) {
	      var data = buffer.shift()
	      if(null === data)
	        return stream.emit('end')
	      else
	        stream.emit('data', data)
	    }
	  }

	  stream.queue = stream.push = function (data) {
	//    console.error(ended)
	    if(_ended) return stream
	    if(data === null) _ended = true
	    buffer.push(data)
	    drain()
	    return stream
	  }

	  //this will be registered as the first 'end' listener
	  //must call destroy next tick, to make sure we're after any
	  //stream piped from here.
	  //this is only a problem if end is not emitted synchronously.
	  //a nicer way to do this is to make sure this is the last listener for 'end'

	  stream.on('end', function () {
	    stream.readable = false
	    if(!stream.writable && stream.autoDestroy)
	      process.nextTick(function () {
	        stream.destroy()
	      })
	  })

	  function _end () {
	    stream.writable = false
	    end.call(stream)
	    if(!stream.readable && stream.autoDestroy)
	      stream.destroy()
	  }

	  stream.end = function (data) {
	    if(ended) return
	    ended = true
	    if(arguments.length) stream.write(data)
	    _end() // will emit or queue
	    return stream
	  }

	  stream.destroy = function () {
	    if(destroyed) return
	    destroyed = true
	    ended = true
	    buffer.length = 0
	    stream.writable = stream.readable = false
	    stream.emit('close')
	    return stream
	  }

	  stream.pause = function () {
	    if(stream.paused) return
	    stream.paused = true
	    return stream
	  }

	  stream.resume = function () {
	    if(stream.paused) {
	      stream.paused = false
	      stream.emit('resume')
	    }
	    drain()
	    //may have become paused again,
	    //as drain emits 'data'.
	    if(!stream.paused)
	      stream.emit('drain')
	    return stream
	  }
	  return stream
	}



/***/ },
/* 139 */
/*!*********************************!*\
  !*** external "string_decoder" ***!
  \*********************************/
/***/ function(module, exports) {

	module.exports = require("string_decoder");

/***/ },
/* 140 */
/*!************************************!*\
  !*** ./~/pg/lib/type-overrides.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2010-2016 Brian Carlson (brian.m.carlson@gmail.com)
	 * All rights reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * README.md file in the root directory of this source tree.
	 */

	var types = __webpack_require__(/*! pg-types */ 141);

	function TypeOverrides(userTypes) {
	  this._types = userTypes || types;
	  this.text = {};
	  this.binary = {};
	}

	TypeOverrides.prototype.getOverrides = function(format) {
	  switch(format) {
	    case 'text': return this.text;
	    case 'binary': return this.binary;
	    default: return {};
	  }
	};

	TypeOverrides.prototype.setTypeParser = function(oid, format, parseFn) {
	  if(typeof format == 'function') {
	    parseFn = format;
	    format = 'text';
	  }
	  this.getOverrides(format)[oid] = parseFn;
	};

	TypeOverrides.prototype.getTypeParser = function(oid, format) {
	  format = format || 'text';
	  return this.getOverrides(format)[oid] || this._types.getTypeParser(oid, format);
	};

	module.exports = TypeOverrides;


/***/ },
/* 141 */
/*!*****************************!*\
  !*** ./~/pg-types/index.js ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	var textParsers = __webpack_require__(/*! ./lib/textParsers */ 142);
	var binaryParsers = __webpack_require__(/*! ./lib/binaryParsers */ 150);
	var arrayParser = __webpack_require__(/*! ./lib/arrayParser */ 145);

	exports.getTypeParser = getTypeParser;
	exports.setTypeParser = setTypeParser;
	exports.arrayParser = arrayParser;

	var typeParsers = {
	  text: {},
	  binary: {}
	};

	//the empty parse function
	function noParse (val) {
	  return String(val);
	};

	//returns a function used to convert a specific type (specified by
	//oid) into a result javascript type
	//note: the oid can be obtained via the following sql query:
	//SELECT oid FROM pg_type WHERE typname = 'TYPE_NAME_HERE';
	function getTypeParser (oid, format) {
	  format = format || 'text';
	  if (!typeParsers[format]) {
	    return noParse;
	  }
	  return typeParsers[format][oid] || noParse;
	};

	function setTypeParser (oid, format, parseFn) {
	  if(typeof format == 'function') {
	    parseFn = format;
	    format = 'text';
	  }
	  typeParsers[format][oid] = parseFn;
	};

	textParsers.init(function(oid, converter) {
	  typeParsers.text[oid] = converter;
	});

	binaryParsers.init(function(oid, converter) {
	  typeParsers.binary[oid] = converter;
	});


/***/ },
/* 142 */
/*!***************************************!*\
  !*** ./~/pg-types/lib/textParsers.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	var array = __webpack_require__(/*! postgres-array */ 143)
	var ap = __webpack_require__(/*! ap */ 144)
	var arrayParser = __webpack_require__(/*! ./arrayParser */ 145);
	var parseDate = __webpack_require__(/*! postgres-date */ 146);
	var parseInterval = __webpack_require__(/*! postgres-interval */ 147);
	var parseByteA = __webpack_require__(/*! postgres-bytea */ 149);

	function allowNull (fn) {
	  return function nullAllowed (value) {
	    if (value === null) return value
	    return fn(value)
	  }
	}

	function parseBool (value) {
	  if (value === null) return value
	  return value === 't';
	}

	function parseBoolArray (value) {
	  if (!value) return null
	  return array.parse(value, parseBool)
	}

	function parseIntegerArray (value) {
	  if (!value) return null
	  return array.parse(value, allowNull(ap.partialRight(parseInt, 10)))
	}

	function parseBigIntegerArray (value) {
	  if (!value) return null
	  return array.parse(value, allowNull(function (entry) {
	    return parseBigInteger(entry).trim()
	  }))
	}

	var parseFloatArray = function(value) {
	  if(!value) { return null; }
	  var p = arrayParser.create(value, function(entry) {
	    if(entry !== null) {
	      entry = parseFloat(entry);
	    }
	    return entry;
	  });

	  return p.parse();
	};

	var parseStringArray = function(value) {
	  if(!value) { return null; }

	  var p = arrayParser.create(value);
	  return p.parse();
	};

	var parseDateArray = function(value) {
	  if (!value) { return null; }

	  var p = arrayParser.create(value, function(entry) {
	    if (entry !== null) {
	      entry = parseDate(entry);
	    }
	    return entry;
	  });

	  return p.parse();
	};

	var parseByteAArray = function(value) {
	  var arr = parseStringArray(value);
	  if (!arr) return arr;

	  return arr.map(function(element) {
	    return parseByteA(element);
	  });
	};

	var parseInteger = function(value) {
	  return parseInt(value, 10);
	};

	var parseBigInteger = function(value) {
	  var valStr = String(value);
	  if (/^\d+$/.test(valStr)) { return valStr; }
	  return value;
	};

	var parseJsonArray = function(value) {
	  var arr = parseStringArray(value);

	  if (!arr) {
	    return arr;
	  }

	  return arr.map(function(el) { return JSON.parse(el); });
	};

	var parsePoint = function(value) {
	  if (value[0] !== '(') { return null; }

	  value = value.substring( 1, value.length - 1 ).split(',');

	  return {
	    x: parseFloat(value[0])
	  , y: parseFloat(value[1])
	  };
	};

	var parseCircle = function(value) {
	  if (value[0] !== '<' && value[1] !== '(') { return null; }

	  var point = '(';
	  var radius = '';
	  var pointParsed = false;
	  for (var i = 2; i < value.length - 1; i++){
	    if (!pointParsed) {
	      point += value[i];
	    }

	    if (value[i] === ')') {
	      pointParsed = true;
	      continue;
	    } else if (!pointParsed) {
	      continue;
	    }

	    if (value[i] === ','){
	      continue;
	    }

	    radius += value[i];
	  }
	  var result = parsePoint(point);
	  result.radius = parseFloat(radius);

	  return result;
	};

	var init = function(register) {
	  register(20, parseBigInteger); // int8
	  register(21, parseInteger); // int2
	  register(23, parseInteger); // int4
	  register(26, parseInteger); // oid
	  register(700, parseFloat); // float4/real
	  register(701, parseFloat); // float8/double
	  register(16, parseBool);
	  register(1082, parseDate); // date
	  register(1114, parseDate); // timestamp without timezone
	  register(1184, parseDate); // timestamp
	  register(600, parsePoint); // point
	  register(718, parseCircle); // circle
	  register(1000, parseBoolArray);
	  register(1001, parseByteAArray);
	  register(1005, parseIntegerArray); // _int2
	  register(1007, parseIntegerArray); // _int4
	  register(1028, parseIntegerArray); // oid[]
	  register(1016, parseBigIntegerArray); // _int8
	  register(1021, parseFloatArray); // _float4
	  register(1022, parseFloatArray); // _float8
	  register(1231, parseFloatArray); // _numeric
	  register(1014, parseStringArray); //char
	  register(1015, parseStringArray); //varchar
	  register(1008, parseStringArray);
	  register(1009, parseStringArray);
	  register(1115, parseDateArray); // timestamp without time zone[]
	  register(1182, parseDateArray); // _date
	  register(1185, parseDateArray); // timestamp with time zone[]
	  register(1186, parseInterval);
	  register(17, parseByteA);
	  register(114, JSON.parse.bind(JSON)); // json
	  register(3802, JSON.parse.bind(JSON)); // jsonb
	  register(199, parseJsonArray); // json[]
	  register(3807, parseJsonArray); // jsonb[]
	  register(2951, parseStringArray); // uuid[]
	  register(791, parseStringArray); // money[]
	  register(1183, parseStringArray); // time[]
	};

	module.exports = {
	  init: init
	};


/***/ },
/* 143 */
/*!***********************************!*\
  !*** ./~/postgres-array/index.js ***!
  \***********************************/
/***/ function(module, exports) {

	'use strict'

	exports.parse = function (source, transform) {
	  return new ArrayParser(source, transform).parse()
	}

	function ArrayParser (source, transform) {
	  this.source = source
	  this.transform = transform || identity
	  this.position = 0
	  this.entries = []
	  this.recorded = []
	  this.dimension = 0
	}

	ArrayParser.prototype.isEof = function () {
	  return this.position >= this.source.length
	}

	ArrayParser.prototype.nextCharacter = function () {
	  var character = this.source[this.position++]
	  if (character === '\\') {
	    return {
	      value: this.source[this.position++],
	      escaped: true
	    }
	  }
	  return {
	    value: character,
	    escaped: false
	  }
	}

	ArrayParser.prototype.record = function (character) {
	  this.recorded.push(character)
	}

	ArrayParser.prototype.newEntry = function (includeEmpty) {
	  var entry
	  if (this.recorded.length > 0 || includeEmpty) {
	    entry = this.recorded.join('')
	    if (entry === 'NULL' && !includeEmpty) {
	      entry = null
	    }
	    if (entry !== null) entry = this.transform(entry)
	    this.entries.push(entry)
	    this.recorded = []
	  }
	}

	ArrayParser.prototype.parse = function (nested) {
	  var character, parser, quote
	  while (!this.isEof()) {
	    character = this.nextCharacter()
	    if (character.value === '{' && !quote) {
	      this.dimension++
	      if (this.dimension > 1) {
	        parser = new ArrayParser(this.source.substr(this.position - 1), this.transform)
	        this.entries.push(parser.parse(true))
	        this.position += parser.position - 2
	      }
	    } else if (character.value === '}' && !quote) {
	      this.dimension--
	      if (!this.dimension) {
	        this.newEntry()
	        if (nested) return this.entries
	      }
	    } else if (character.value === '"' && !character.escaped) {
	      if (quote) this.newEntry(true)
	      quote = !quote
	    } else if (character.value === ',' && !quote) {
	      this.newEntry()
	    } else {
	      this.record(character.value)
	    }
	  }
	  if (this.dimension !== 0) {
	    throw new Error('array dimension not balanced')
	  }
	  return this.entries
	}

	function identity (value) {
	  return value
	}


/***/ },
/* 144 */
/*!***********************!*\
  !*** ./~/ap/index.js ***!
  \***********************/
/***/ function(module, exports) {

	exports = module.exports = ap;
	function ap (args, fn) {
	    return function () {
	        var rest = [].slice.call(arguments)
	            , first = args.slice()
	        first.push.apply(first, rest)
	        return fn.apply(this, first);
	    };
	}

	exports.pa = pa;
	function pa (args, fn) {
	    return function () {
	        var rest = [].slice.call(arguments)
	        rest.push.apply(rest, args)
	        return fn.apply(this, rest);
	    };
	}

	exports.apa = apa;
	function apa (left, right, fn) {
	    return function () {
	        return fn.apply(this,
	            left.concat.apply(left, arguments).concat(right)
	        );
	    };
	}

	exports.partial = partial;
	function partial (fn) {
	    var args = [].slice.call(arguments, 1);
	    return ap(args, fn);
	}

	exports.partialRight = partialRight;
	function partialRight (fn) {
	    var args = [].slice.call(arguments, 1);
	    return pa(args, fn);
	}

	exports.curry = curry;
	function curry (fn) {
	    return partial(partial, fn);
	}

	exports.curryRight = function curryRight (fn) {
	    return partial(partialRight, fn);
	}


/***/ },
/* 145 */
/*!***************************************!*\
  !*** ./~/pg-types/lib/arrayParser.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	var array = __webpack_require__(/*! postgres-array */ 143);

	module.exports = {
	  create: function (source, transform) {
	    return {
	      parse: function() {
	        return array.parse(source, transform);
	      }
	    };
	  }
	};


/***/ },
/* 146 */
/*!**********************************!*\
  !*** ./~/postgres-date/index.js ***!
  \**********************************/
/***/ function(module, exports) {

	'use strict'

	var DATE_TIME = /(\d{1,})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})(\.\d{1,})?/
	var DATE = /^(\d{1,})-(\d{2})-(\d{2})$/
	var TIME_ZONE = /([Z+-])(\d{2})?:?(\d{2})?:?(\d{2})?/
	var BC = /BC$/
	var INFINITY = /^-?infinity$/

	module.exports = function parseDate (isoDate) {
	  if (INFINITY.test(isoDate)) {
	    // Capitalize to Infinity before passing to Number
	    return Number(isoDate.replace('i', 'I'))
	  }
	  var matches = DATE_TIME.exec(isoDate)

	  if (!matches) {
	    // Force YYYY-MM-DD dates to be parsed as local time
	    return DATE.test(isoDate) ?
	      getDate(isoDate) :
	      null
	  }

	  var isBC = BC.test(isoDate)
	  var year = parseInt(matches[1], 10)
	  var isFirstCentury = year > 0 && year < 100
	  year = (isBC ? '-' : '') + year

	  var month = parseInt(matches[2], 10) - 1
	  var day = matches[3]
	  var hour = parseInt(matches[4], 10)
	  var minute = parseInt(matches[5], 10)
	  var second = parseInt(matches[6], 10)

	  var ms = matches[7]
	  ms = ms ? 1000 * parseFloat(ms) : 0

	  var date
	  var offset = timeZoneOffset(isoDate)
	  if (offset != null) {
	    var utc = Date.UTC(year, month, day, hour, minute, second, ms)
	    date = new Date(utc - offset)
	  } else {
	    date = new Date(year, month, day, hour, minute, second, ms)
	  }

	  if (isFirstCentury) {
	    date.setUTCFullYear(year)
	  }

	  return date
	}

	function getDate (isoDate) {
	  var matches = DATE.exec(isoDate)
	  var year = parseInt(matches[1], 10)
	  var month = parseInt(matches[2], 10) - 1
	  var day = matches[3]
	  // YYYY-MM-DD will be parsed as local time
	  var date = new Date(year, month, day)
	  date.setFullYear(year)
	  return date
	}

	// match timezones:
	// Z (UTC)
	// -05
	// +06:30
	function timeZoneOffset (isoDate) {
	  var zone = TIME_ZONE.exec(isoDate.split(' ')[1])
	  if (!zone) return
	  var type = zone[1]

	  if (type === 'Z') {
	    return 0
	  }
	  var sign = type === '-' ? -1 : 1
	  var offset = parseInt(zone[2], 10) * 3600 +
	    parseInt(zone[3] || 0, 10) * 60 +
	    parseInt(zone[4] || 0, 10)

	  return offset * sign * 1000
	}


/***/ },
/* 147 */
/*!**************************************!*\
  !*** ./~/postgres-interval/index.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	var extend = __webpack_require__(/*! xtend/mutable */ 148)

	module.exports = PostgresInterval

	function PostgresInterval (raw) {
	  if (!(this instanceof PostgresInterval)) {
	    return new PostgresInterval(raw)
	  }
	  extend(this, parse(raw))
	}
	var properties = ['seconds', 'minutes', 'hours', 'days', 'months', 'years']
	PostgresInterval.prototype.toPostgres = function () {
	  var filtered = properties.filter(this.hasOwnProperty, this)
	  if (filtered.length === 0) return '0'
	  return filtered
	    .map(function (property) {
	      return this[property] + ' ' + property
	    }, this)
	    .join(' ')
	}

	var NUMBER = '([+-]?\\d+)'
	var YEAR = NUMBER + '\\s+years?'
	var MONTH = NUMBER + '\\s+mons?'
	var DAY = NUMBER + '\\s+days?'
	var TIME = '([+-])?([\\d]*):(\\d\\d):(\\d\\d):?(\\d\\d\\d)?'
	var INTERVAL = new RegExp([YEAR, MONTH, DAY, TIME].map(function (regexString) {
	  return '(' + regexString + ')?'
	})
	.join('\\s*'))

	// Positions of values in regex match
	var positions = {
	  years: 2,
	  months: 4,
	  days: 6,
	  hours: 9,
	  minutes: 10,
	  seconds: 11,
	  milliseconds: 12
	}
	// We can use negative time
	var negatives = ['hours', 'minutes', 'seconds']

	function parse (interval) {
	  if (!interval) return {}
	  var matches = INTERVAL.exec(interval)
	  var isNegative = matches[8] === '-'
	  return Object.keys(positions)
	    .reduce(function (parsed, property) {
	      var position = positions[property]
	      var value = matches[position]
	      // no empty string
	      if (!value) return parsed
	      value = parseInt(value, 10)
	      // no zeros
	      if (!value) return parsed
	      if (isNegative && ~negatives.indexOf(property)) {
	        value *= -1
	      }
	      parsed[property] = value
	      return parsed
	    }, {})
	}


/***/ },
/* 148 */
/*!************************************************!*\
  !*** ./~/postgres-interval/~/xtend/mutable.js ***!
  \************************************************/
/***/ function(module, exports) {

	module.exports = extend

	var hasOwnProperty = Object.prototype.hasOwnProperty;

	function extend(target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i]

	        for (var key in source) {
	            if (hasOwnProperty.call(source, key)) {
	                target[key] = source[key]
	            }
	        }
	    }

	    return target
	}


/***/ },
/* 149 */
/*!***********************************!*\
  !*** ./~/postgres-bytea/index.js ***!
  \***********************************/
/***/ function(module, exports) {

	'use strict'

	module.exports = function parseBytea (input) {
	  if (/^\\x/.test(input)) {
	    // new 'hex' style response (pg >9.0)
	    return new Buffer(input.substr(2), 'hex')
	  }
	  var output = ''
	  var i = 0
	  while (i < input.length) {
	    if (input[i] !== '\\') {
	      output += input[i]
	      ++i
	    } else {
	      if (/[0-7]{3}/.test(input.substr(i + 1, 3))) {
	        output += String.fromCharCode(parseInt(input.substr(i + 1, 3), 8))
	        i += 4
	      } else {
	        var backslashes = 1
	        while (i + backslashes < input.length && input[i + backslashes] === '\\') {
	          backslashes++
	        }
	        for (var k = 0; k < Math.floor(backslashes / 2); ++k) {
	          output += '\\'
	        }
	        i += Math.floor(backslashes / 2) * 2
	      }
	    }
	  }
	  return new Buffer(output, 'binary')
	}


/***/ },
/* 150 */
/*!*****************************************!*\
  !*** ./~/pg-types/lib/binaryParsers.js ***!
  \*****************************************/
/***/ function(module, exports) {

	var parseBits = function(data, bits, offset, invert, callback) {
	  offset = offset || 0;
	  invert = invert || false;
	  callback = callback || function(lastValue, newValue, bits) { return (lastValue * Math.pow(2, bits)) + newValue; };
	  var offsetBytes = offset >> 3;

	  var inv = function(value) {
	    if (invert) {
	      return ~value & 0xff;
	    }

	    return value;
	  };

	  // read first (maybe partial) byte
	  var mask = 0xff;
	  var firstBits = 8 - (offset % 8);
	  if (bits < firstBits) {
	    mask = (0xff << (8 - bits)) & 0xff;
	    firstBits = bits;
	  }

	  if (offset) {
	    mask = mask >> (offset % 8);
	  }

	  var result = 0;
	  if ((offset % 8) + bits >= 8) {
	    result = callback(0, inv(data[offsetBytes]) & mask, firstBits);
	  }

	  // read bytes
	  var bytes = (bits + offset) >> 3;
	  for (var i = offsetBytes + 1; i < bytes; i++) {
	    result = callback(result, inv(data[i]), 8);
	  }

	  // bits to read, that are not a complete byte
	  var lastBits = (bits + offset) % 8;
	  if (lastBits > 0) {
	    result = callback(result, inv(data[bytes]) >> (8 - lastBits), lastBits);
	  }

	  return result;
	};

	var parseFloatFromBits = function(data, precisionBits, exponentBits) {
	  var bias = Math.pow(2, exponentBits - 1) - 1;
	  var sign = parseBits(data, 1);
	  var exponent = parseBits(data, exponentBits, 1);

	  if (exponent === 0) {
	    return 0;
	  }

	  // parse mantissa
	  var precisionBitsCounter = 1;
	  var parsePrecisionBits = function(lastValue, newValue, bits) {
	    if (lastValue === 0) {
	      lastValue = 1;
	    }

	    for (var i = 1; i <= bits; i++) {
	      precisionBitsCounter /= 2;
	      if ((newValue & (0x1 << (bits - i))) > 0) {
	        lastValue += precisionBitsCounter;
	      }
	    }

	    return lastValue;
	  };

	  var mantissa = parseBits(data, precisionBits, exponentBits + 1, false, parsePrecisionBits);

	  // special cases
	  if (exponent == (Math.pow(2, exponentBits + 1) - 1)) {
	    if (mantissa === 0) {
	      return (sign === 0) ? Infinity : -Infinity;
	    }

	    return NaN;
	  }

	  // normale number
	  return ((sign === 0) ? 1 : -1) * Math.pow(2, exponent - bias) * mantissa;
	};

	var parseInt16 = function(value) {
	  if (parseBits(value, 1) == 1) {
	    return -1 * (parseBits(value, 15, 1, true) + 1);
	  }

	  return parseBits(value, 15, 1);
	};

	var parseInt32 = function(value) {
	  if (parseBits(value, 1) == 1) {
	    return -1 * (parseBits(value, 31, 1, true) + 1);
	  }

	  return parseBits(value, 31, 1);
	};

	var parseFloat32 = function(value) {
	  return parseFloatFromBits(value, 23, 8);
	};

	var parseFloat64 = function(value) {
	  return parseFloatFromBits(value, 52, 11);
	};

	var parseNumeric = function(value) {
	  var sign = parseBits(value, 16, 32);
	  if (sign == 0xc000) {
	    return NaN;
	  }

	  var weight = Math.pow(10000, parseBits(value, 16, 16));
	  var result = 0;

	  var digits = [];
	  var ndigits = parseBits(value, 16);
	  for (var i = 0; i < ndigits; i++) {
	    result += parseBits(value, 16, 64 + (16 * i)) * weight;
	    weight /= 10000;
	  }

	  var scale = Math.pow(10, parseBits(value, 16, 48));
	  return ((sign === 0) ? 1 : -1) * Math.round(result * scale) / scale;
	};

	var parseDate = function(isUTC, value) {
	  var sign = parseBits(value, 1);
	  var rawValue = parseBits(value, 63, 1);

	  // discard usecs and shift from 2000 to 1970
	  var result = new Date((((sign === 0) ? 1 : -1) * rawValue / 1000) + 946684800000);

	  if (!isUTC) {
	    result.setTime(result.getTime() + result.getTimezoneOffset() * 60000);
	  }

	  // add microseconds to the date
	  result.usec = rawValue % 1000;
	  result.getMicroSeconds = function() {
	    return this.usec;
	  };
	  result.setMicroSeconds = function(value) {
	    this.usec = value;
	  };
	  result.getUTCMicroSeconds = function() {
	    return this.usec;
	  };

	  return result;
	};

	var parseArray = function(value) {
	  var dim = parseBits(value, 32);

	  var flags = parseBits(value, 32, 32);
	  var elementType = parseBits(value, 32, 64);

	  var offset = 96;
	  var dims = [];
	  for (var i = 0; i < dim; i++) {
	    // parse dimension
	    dims[i] = parseBits(value, 32, offset);
	    offset += 32;

	    // ignore lower bounds
	    offset += 32;
	  }

	  var parseElement = function(elementType) {
	    // parse content length
	    var length = parseBits(value, 32, offset);
	    offset += 32;

	    // parse null values
	    if (length == 0xffffffff) {
	      return null;
	    }

	    var result;
	    if ((elementType == 0x17) || (elementType == 0x14)) {
	      // int/bigint
	      result = parseBits(value, length * 8, offset);
	      offset += length * 8;
	      return result;
	    }
	    else if (elementType == 0x19) {
	      // string
	      result = value.toString(this.encoding, offset >> 3, (offset += (length << 3)) >> 3);
	      return result;
	    }
	    else {
	      console.log("ERROR: ElementType not implemented: " + elementType);
	    }
	  };

	  var parse = function(dimension, elementType) {
	    var array = [];
	    var i;

	    if (dimension.length > 1) {
	      var count = dimension.shift();
	      for (i = 0; i < count; i++) {
	        array[i] = parse(dimension, elementType);
	      }
	      dimension.unshift(count);
	    }
	    else {
	      for (i = 0; i < dimension[0]; i++) {
	        array[i] = parseElement(elementType);
	      }
	    }

	    return array;
	  };

	  return parse(dims, elementType);
	};

	var parseText = function(value) {
	  return value.toString('utf8');
	};

	var parseBool = function(value) {
	  if(value === null) return null;
	  return (parseBits(value, 8) > 0);
	};

	var init = function(register) {
	  register(21, parseInt16);
	  register(23, parseInt32);
	  register(26, parseInt32);
	  register(1700, parseNumeric);
	  register(700, parseFloat32);
	  register(701, parseFloat64);
	  register(16, parseBool);
	  register(1114, parseDate.bind(null, false));
	  register(1184, parseDate.bind(null, true));
	  register(1000, parseArray);
	  register(1007, parseArray);
	  register(1016, parseArray);
	  register(1008, parseArray);
	  register(1009, parseArray);
	  register(25, parseText);
	};

	module.exports = {
	  init: init
	};


/***/ },
/* 151 */
/*!*******************************************!*\
  !*** ./~/pg/lib/connection-parameters.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2010-2016 Brian Carlson (brian.m.carlson@gmail.com)
	 * All rights reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * README.md file in the root directory of this source tree.
	 */

	var url = __webpack_require__(/*! url */ 51);
	var dns = __webpack_require__(/*! dns */ 152);

	var defaults = __webpack_require__(/*! ./defaults */ 153);

	var val = function(key, config, envVar) {
	  if (envVar === undefined) {
	    envVar = process.env[ 'PG' + key.toUpperCase() ];
	  } else if (envVar === false) {
	    // do nothing ... use false
	  } else {
	    envVar = process.env[ envVar ];
	  }

	  return config[key] ||
	    envVar ||
	    defaults[key];
	};

	//parses a connection string
	var parse = __webpack_require__(/*! pg-connection-string */ 154).parse;

	var useSsl = function() {
	  switch(process.env.PGSSLMODE) {
	  case "disable":
	    return false;
	  case "prefer":
	  case "require":
	  case "verify-ca":
	  case "verify-full":
	    return true;
	  }
	  return defaults.ssl;
	};

	var ConnectionParameters = function(config) {
	  //if a string is passed, it is a raw connection string so we parse it into a config
	  config = typeof config == 'string' ? parse(config) : (config || {});
	  //if the config has a connectionString defined, parse IT into the config we use
	  //this will override other default values with what is stored in connectionString
	  if(config.connectionString) {
	    config = parse(config.connectionString);
	  }
	  this.user = val('user', config);
	  this.database = val('database', config);
	  this.port = parseInt(val('port', config), 10);
	  this.host = val('host', config);
	  this.password = val('password', config);
	  this.binary = val('binary', config);
	  this.ssl = typeof config.ssl === 'undefined' ? useSsl() : config.ssl;
	  this.client_encoding = val("client_encoding", config);
	  //a domain socket begins with '/'
	  this.isDomainSocket = (!(this.host||'').indexOf('/'));

	  this.application_name = val('application_name', config, 'PGAPPNAME');
	  this.fallback_application_name = val('fallback_application_name', config, false);
	};

	var add = function(params, config, paramName) {
	  var value = config[paramName];
	  if(value) {
	    params.push(paramName+"='"+value+"'");
	  }
	};

	ConnectionParameters.prototype.getLibpqConnectionString = function(cb) {
	  var params = [];
	  add(params, this, 'user');
	  add(params, this, 'password');
	  add(params, this, 'port');
	  add(params, this, 'application_name');
	  add(params, this, 'fallback_application_name');

	  if(this.database) {
	    params.push("dbname='" + this.database + "'");
	  }
	  if(this.host) {
	    params.push("host=" + this.host);
	  }
	  if(this.isDomainSocket) {
	    return cb(null, params.join(' '));
	  }
	  if(this.client_encoding) {
	    params.push("client_encoding='" + this.client_encoding + "'");
	  }
	  dns.lookup(this.host, function(err, address) {
	    if(err) return cb(err, null);
	    params.push("hostaddr=" + address);
	    return cb(null, params.join(' '));
	  });
	};

	module.exports = ConnectionParameters;


/***/ },
/* 152 */
/*!**********************!*\
  !*** external "dns" ***!
  \**********************/
/***/ function(module, exports) {

	module.exports = require("dns");

/***/ },
/* 153 */
/*!******************************!*\
  !*** ./~/pg/lib/defaults.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2010-2016 Brian Carlson (brian.m.carlson@gmail.com)
	 * All rights reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * README.md file in the root directory of this source tree.
	 */

	var defaults = module.exports = {
	  // database host. defaults to localhost
	  host: 'localhost',

	  //database user's name
	  user: process.platform === 'win32' ? process.env.USERNAME : process.env.USER,

	  //name of database to connect
	  database: process.platform === 'win32' ? process.env.USERNAME : process.env.USER,

	  //database user's password
	  password: null,

	  // a Postgres connection string to be used instead of setting individual connection items
	  // NOTE:  Setting this value will cause it to override any other value (such as database or user) defined
	  // in the defaults object.
	  connectionString : undefined,

	  //database port
	  port: 5432,

	  //number of rows to return at a time from a prepared statement's
	  //portal. 0 will return all rows at once
	  rows: 0,

	  // binary result mode
	  binary: false,

	  //Connection pool options - see https://github.com/coopernurse/node-pool
	  //number of connections to use in connection pool
	  //0 will disable connection pooling
	  poolSize: 10,

	  //max milliseconds a client can go unused before it is removed
	  //from the pool and destroyed
	  poolIdleTimeout: 30000,

	  //frequency to check for idle clients within the client pool
	  reapIntervalMillis: 1000,

	  //if true the most recently released resources will be the first to be allocated
	  returnToHead: false,

	  //pool log function / boolean
	  poolLog: false,

	  client_encoding: "",

	  ssl: false,

	  application_name: undefined,
	  fallback_application_name: undefined,

	  parseInputDatesAsUTC: false
	};

	//parse int8 so you can get your count values as actual numbers
	module.exports.__defineSetter__("parseInt8", function(val) {
	  __webpack_require__(/*! pg-types */ 141).setTypeParser(20, 'text', val ? parseInt : function(val) { return val; });
	});


/***/ },
/* 154 */
/*!*****************************************!*\
  !*** ./~/pg-connection-string/index.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var url = __webpack_require__(/*! url */ 51);

	//Parse method copied from https://github.com/brianc/node-postgres
	//Copyright (c) 2010-2014 Brian Carlson (brian.m.carlson@gmail.com)
	//MIT License

	//parses a connection string
	function parse(str) {
	  var config;
	  //unix socket
	  if(str.charAt(0) === '/') {
	    config = str.split(' ');
	    return { host: config[0], database: config[1] };
	  }
	  // url parse expects spaces encoded as %20
	  if(/ |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(str)) {
	    str = encodeURI(str).replace(/\%25(\d\d)/g, "%$1");
	  }
	  var result = url.parse(str, true);
	  config = {};

	  if (result.query.application_name) {
	    config.application_name = result.query.application_name;
	  }
	  if (result.query.fallback_application_name) {
	    config.fallback_application_name = result.query.fallback_application_name;
	  }

	  config.port = result.port;
	  if(result.protocol == 'socket:') {
	    config.host = decodeURI(result.pathname);
	    config.database = result.query.db;
	    config.client_encoding = result.query.encoding;
	    return config;
	  }
	  config.host = result.hostname;

	  // result.pathname is not always guaranteed to have a '/' prefix (e.g. relative urls)
	  // only strip the slash if it is present.
	  var pathname = result.pathname;
	  if (pathname && pathname.charAt(0) === '/') {
	    pathname = result.pathname.slice(1) || null;
	  }
	  config.database = pathname && decodeURI(pathname);

	  var auth = (result.auth || ':').split(':');
	  config.user = auth[0];
	  config.password = auth.splice(1).join(':');

	  var ssl = result.query.ssl;
	  if (ssl === 'true' || ssl === '1') {
	    config.ssl = true;
	  }

	  return config;
	}

	module.exports = {
	  parse: parse
	};


/***/ },
/* 155 */
/*!***************************!*\
  !*** ./~/pg/lib/query.js ***!
  \***************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2010-2016 Brian Carlson (brian.m.carlson@gmail.com)
	 * All rights reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * README.md file in the root directory of this source tree.
	 */

	var EventEmitter = __webpack_require__(/*! events */ 26).EventEmitter;
	var util = __webpack_require__(/*! util */ 16);

	var Result = __webpack_require__(/*! ./result */ 156);
	var utils = __webpack_require__(/*! ./utils */ 157);

	var Query = function(config, values, callback) {
	  // use of "new" optional
	  if(!(this instanceof Query)) { return new Query(config, values, callback); }

	  config = utils.normalizeQueryConfig(config, values, callback);

	  this.text = config.text;
	  this.values = config.values;
	  this.rows = config.rows;
	  this.types = config.types;
	  this.name = config.name;
	  this.binary = config.binary;
	  this.stream = config.stream;
	  //use unique portal name each time
	  this.portal = config.portal || "";
	  this.callback = config.callback;
	  if(process.domain && config.callback) {
	    this.callback = process.domain.bind(config.callback);
	  }
	  this._result = new Result(config.rowMode, config.types);
	  this.isPreparedStatement = false;
	  this._canceledDueToError = false;
	  this._promise = null;
	  EventEmitter.call(this);
	};

	util.inherits(Query, EventEmitter);

	Query.prototype.then = function(onSuccess, onFailure) {
	  return this.promise().then(onSuccess, onFailure);
	};

	Query.prototype.catch = function(callback) {
	  return this.promise().catch(callback);
	};

	Query.prototype.promise = function() {
	  if (this._promise) return this._promise;
	  this._promise = new Promise(function(resolve, reject) {
	    this.once('end', resolve);
	    this.once('error', reject);
	  }.bind(this));
	  return this._promise;
	};

	Query.prototype.requiresPreparation = function() {
	  //named queries must always be prepared
	  if(this.name) { return true; }
	  //always prepare if there are max number of rows expected per
	  //portal execution
	  if(this.rows) { return true; }
	  //don't prepare empty text queries
	  if(!this.text) { return false; }
	  //binary should be prepared to specify results should be in binary
	  //unless there are no parameters
	  if(this.binary && !this.values) { return false; }
	  //prepare if there are values
	  return (this.values || 0).length > 0;
	};


	//associates row metadata from the supplied
	//message with this query object
	//metadata used when parsing row results
	Query.prototype.handleRowDescription = function(msg) {
	  this._result.addFields(msg.fields);
	  this._accumulateRows = this.callback || !this.listeners('row').length;
	};

	Query.prototype.handleDataRow = function(msg) {
	  var row = this._result.parseRow(msg.fields);
	  this.emit('row', row, this._result);
	  if (this._accumulateRows) {
	    this._result.addRow(row);
	  }
	};

	Query.prototype.handleCommandComplete = function(msg, con) {
	  this._result.addCommandComplete(msg);
	  //need to sync after each command complete of a prepared statement
	  if(this.isPreparedStatement) {
	    con.sync();
	  }
	};

	//if a named prepared statement is created with empty query text
	//the backend will send an emptyQuery message but *not* a command complete message
	//execution on the connection will hang until the backend receives a sync message
	Query.prototype.handleEmptyQuery = function(con) {
	  if (this.isPreparedStatement) {
	    con.sync();
	  }
	};

	Query.prototype.handleReadyForQuery = function() {
	  if(this._canceledDueToError) {
	    return this.handleError(this._canceledDueToError);
	  }
	  if(this.callback) {
	    this.callback(null, this._result);
	  }
	  this.emit('end', this._result);
	};

	Query.prototype.handleError = function(err, connection) {
	  //need to sync after error during a prepared statement
	  if(this.isPreparedStatement) {
	    connection.sync();
	  }
	  if(this._canceledDueToError) {
	    err = this._canceledDueToError;
	    this._canceledDueToError = false;
	  }
	  //if callback supplied do not emit error event as uncaught error
	  //events will bubble up to node process
	  if(this.callback) {
	    return this.callback(err);
	  }
	  this.emit('error', err);
	};

	Query.prototype.submit = function(connection) {
	  if(this.requiresPreparation()) {
	    this.prepare(connection);
	  } else {
	    connection.query(this.text);
	  }
	};

	Query.prototype.hasBeenParsed = function(connection) {
	  return this.name && connection.parsedStatements[this.name];
	};

	Query.prototype.handlePortalSuspended = function(connection) {
	  this._getRows(connection, this.rows);
	};

	Query.prototype._getRows = function(connection, rows) {
	  connection.execute({
	    portal: this.portalName,
	    rows: rows
	  }, true);
	  connection.flush();
	};

	Query.prototype.prepare = function(connection) {
	  var self = this;
	  //prepared statements need sync to be called after each command
	  //complete or when an error is encountered
	  this.isPreparedStatement = true;
	  //TODO refactor this poor encapsulation
	  if(!this.hasBeenParsed(connection)) {
	    connection.parse({
	      text: self.text,
	      name: self.name,
	      types: self.types
	    }, true);
	  }

	  if(self.values) {
	    self.values = self.values.map(utils.prepareValue);
	  }

	  //http://developer.postgresql.org/pgdocs/postgres/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY
	  connection.bind({
	    portal: self.portalName,
	    statement: self.name,
	    values: self.values,
	    binary: self.binary
	  }, true);

	  connection.describe({
	    type: 'P',
	    name: self.portalName || ""
	  }, true);

	  this._getRows(connection, this.rows);
	};

	Query.prototype.handleCopyInResponse = function (connection) {
	  if(this.stream) this.stream.startStreamingToConnection(connection);
	  else connection.sendCopyFail('No source stream defined');
	};

	Query.prototype.handleCopyData = function (msg, connection) {
	  var chunk = msg.chunk;
	  if(this.stream) {
	    this.stream.handleChunk(chunk);
	  }
	  //if there are no stream (for example when copy to query was sent by
	  //query method instead of copyTo) error will be handled
	  //on copyOutResponse event, so silently ignore this error here
	};
	module.exports = Query;


/***/ },
/* 156 */
/*!****************************!*\
  !*** ./~/pg/lib/result.js ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2010-2016 Brian Carlson (brian.m.carlson@gmail.com)
	 * All rights reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * README.md file in the root directory of this source tree.
	 */

	var types = __webpack_require__(/*! pg-types */ 141);

	//result object returned from query
	//in the 'end' event and also
	//passed as second argument to provided callback
	var Result = function(rowMode) {
	  this.command = null;
	  this.rowCount = null;
	  this.oid = null;
	  this.rows = [];
	  this.fields = [];
	  this._parsers = [];
	  this.RowCtor = null;
	  this.rowAsArray = rowMode == "array";
	  if(this.rowAsArray) {
	    this.parseRow = this._parseRowAsArray;
	  }
	};

	var matchRegexp = /([A-Za-z]+) ?(\d+ )?(\d+)?/;

	//adds a command complete message
	Result.prototype.addCommandComplete = function(msg) {
	  var match;
	  if(msg.text) {
	    //pure javascript
	    match = matchRegexp.exec(msg.text);
	  } else {
	    //native bindings
	    match = matchRegexp.exec(msg.command);
	  }
	  if(match) {
	    this.command = match[1];
	    //match 3 will only be existing on insert commands
	    if(match[3]) {
	      //msg.value is from native bindings
	      this.rowCount = parseInt(match[3] || msg.value, 10);
	      this.oid = parseInt(match[2], 10);
	    } else {
	      this.rowCount = parseInt(match[2], 10);
	    }
	  }
	};

	Result.prototype._parseRowAsArray = function(rowData) {
	  var row = [];
	  for(var i = 0, len = rowData.length; i < len; i++) {
	    var rawValue = rowData[i];
	    if(rawValue !== null) {
	      row.push(this._parsers[i](rawValue));
	    } else {
	      row.push(null);
	    }
	  }
	  return row;
	};

	//rowData is an array of text or binary values
	//this turns the row into a JavaScript object
	Result.prototype.parseRow = function(rowData) {
	  return new this.RowCtor(this._parsers, rowData);
	};

	Result.prototype.addRow = function(row) {
	  this.rows.push(row);
	};

	var inlineParser = function(fieldName, i) {
	  return "\nthis['" +
	    //fields containing single quotes will break
	    //the evaluated javascript unless they are escaped
	    //see https://github.com/brianc/node-postgres/issues/507
	    //Addendum: However, we need to make sure to replace all
	    //occurences of apostrophes, not just the first one.
	    //See https://github.com/brianc/node-postgres/issues/934
	    fieldName.replace(/'/g, "\\'") +
	    "'] = " +
	    "rowData[" + i + "] == null ? null : parsers[" + i + "](rowData[" + i + "]);";
	};

	Result.prototype.addFields = function(fieldDescriptions) {
	  //clears field definitions
	  //multiple query statements in 1 action can result in multiple sets
	  //of rowDescriptions...eg: 'select NOW(); select 1::int;'
	  //you need to reset the fields
	  if(this.fields.length) {
	    this.fields = [];
	    this._parsers = [];
	  }
	  var ctorBody = "";
	  for(var i = 0; i < fieldDescriptions.length; i++) {
	    var desc = fieldDescriptions[i];
	    this.fields.push(desc);
	    var parser = this._getTypeParser(desc.dataTypeID, desc.format || 'text');
	    this._parsers.push(parser);
	    //this is some craziness to compile the row result parsing
	    //results in ~60% speedup on large query result sets
	    ctorBody += inlineParser(desc.name, i);
	  }
	  if(!this.rowAsArray) {
	    this.RowCtor = Function("parsers", "rowData", ctorBody);
	  }
	};

	Result.prototype._getTypeParser = types.getTypeParser;

	module.exports = Result;


/***/ },
/* 157 */
/*!***************************!*\
  !*** ./~/pg/lib/utils.js ***!
  \***************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2010-2016 Brian Carlson (brian.m.carlson@gmail.com)
	 * All rights reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * README.md file in the root directory of this source tree.
	 */

	var defaults = __webpack_require__(/*! ./defaults */ 153);

	// convert a JS array to a postgres array literal
	// uses comma separator so won't work for types like box that use
	// a different array separator.
	function arrayString(val) {
	  var result = '{';
	  for (var i = 0 ; i < val.length; i++) {
	    if(i > 0) {
	      result = result + ',';
	    }
	    if(val[i] === null || typeof val[i] === 'undefined') {
	      result = result + 'NULL';
	    }
	    else if(Array.isArray(val[i])) {
	      result = result + arrayString(val[i]);
	    }
	    else
	    {
	      result = result + JSON.stringify(prepareValue(val[i]));
	    }
	  }
	  result = result + '}';
	  return result;
	}

	//converts values from javascript types
	//to their 'raw' counterparts for use as a postgres parameter
	//note: you can override this function to provide your own conversion mechanism
	//for complex types, etc...
	var prepareValue = function(val, seen) {
	  if (val instanceof Buffer) {
	    return val;
	  }
	  if(val instanceof Date) {
	    if(defaults.parseInputDatesAsUTC) {
	      return dateToStringUTC(val);
	    } else {
	      return dateToString(val);
	    }
	  }
	  if(Array.isArray(val)) {
	    return arrayString(val);
	  }
	  if(val === null || typeof val === 'undefined') {
	    return null;
	  }
	  if(typeof val === 'object') {
	    return prepareObject(val, seen);
	  }
	  if (typeof val === 'undefined') {
	    throw new Error('SQL queries with undefined where clause option');
	  }
	  return val.toString();
	};

	function prepareObject(val, seen) {
	  if(val.toPostgres && typeof val.toPostgres === 'function') {
	    seen = seen || [];
	    if (seen.indexOf(val) !== -1) {
	      throw new Error('circular reference detected while preparing "' + val + '" for query');
	    }
	    seen.push(val);

	    return prepareValue(val.toPostgres(prepareValue), seen);
	  }
	  return JSON.stringify(val);
	}

	function pad(number, digits) {
	  number = ""  +number;
	  while(number.length < digits)
	    number = "0" + number;
	  return number;
	}

	function dateToString(date) {

	  var offset = -date.getTimezoneOffset();
	  var ret = pad(date.getFullYear(), 4) + '-' +
	    pad(date.getMonth() + 1, 2) + '-' +
	    pad(date.getDate(), 2) + 'T' +
	    pad(date.getHours(), 2) + ':' +
	    pad(date.getMinutes(), 2) + ':' +
	    pad(date.getSeconds(), 2) + '.' +
	    pad(date.getMilliseconds(), 3);

	  if(offset < 0) {
	    ret += "-";
	    offset *= -1;
	  }
	  else
	    ret += "+";

	  return ret + pad(Math.floor(offset/60), 2) + ":" + pad(offset%60, 2);
	}

	function dateToStringUTC(date) {
	  
	  var ret = pad(date.getUTCFullYear(), 4) + '-' +
	      pad(date.getUTCMonth() + 1, 2) + '-' +
	      pad(date.getUTCDate(), 2) + 'T' +
	      pad(date.getUTCHours(), 2) + ':' +
	      pad(date.getUTCMinutes(), 2) + ':' +
	      pad(date.getUTCSeconds(), 2) + '.' +
	      pad(date.getUTCMilliseconds(), 3);
	  
	  return ret + "+00:00";
	}

	function normalizeQueryConfig (config, values, callback) {
	  //can take in strings or config objects
	  config = (typeof(config) == 'string') ? { text: config } : config;
	  if(values) {
	    if(typeof values === 'function') {
	      config.callback = values;
	    } else {
	      config.values = values;
	    }
	  }
	  if(callback) {
	    config.callback = callback;
	  }
	  return config;
	}

	module.exports = {
	  prepareValue: function prepareValueWrapper (value) {
	    //this ensures that extra arguments do not get passed into prepareValue
	    //by accident, eg: from calling values.map(utils.prepareValue)
	    return prepareValue(value);
	  },
	  normalizeQueryConfig: normalizeQueryConfig
	};


/***/ },
/* 158 */
/*!********************************!*\
  !*** ./~/pg/lib/connection.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2010-2016 Brian Carlson (brian.m.carlson@gmail.com)
	 * All rights reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * README.md file in the root directory of this source tree.
	 */

	var net = __webpack_require__(/*! net */ 20);
	var EventEmitter = __webpack_require__(/*! events */ 26).EventEmitter;
	var util = __webpack_require__(/*! util */ 16);

	var Writer = __webpack_require__(/*! buffer-writer */ 159);
	var Reader = __webpack_require__(/*! packet-reader */ 160);

	var TEXT_MODE = 0;
	var BINARY_MODE = 1;
	var Connection = function(config) {
	  EventEmitter.call(this);
	  config = config || {};
	  this.stream = config.stream || new net.Stream();
	  this._keepAlive = config.keepAlive;
	  this.lastBuffer = false;
	  this.lastOffset = 0;
	  this.buffer = null;
	  this.offset = null;
	  this.encoding = 'utf8';
	  this.parsedStatements = {};
	  this.writer = new Writer();
	  this.ssl = config.ssl || false;
	  this._ending = false;
	  this._mode = TEXT_MODE;
	  this._emitMessage = false;
	  this._reader = new Reader({
	    headerSize: 1,
	    lengthPadding: -4
	  });
	  var self = this;
	  this.on('newListener', function(eventName) {
	    if(eventName == 'message') {
	      self._emitMessage = true;
	    }
	  });
	};

	util.inherits(Connection, EventEmitter);

	Connection.prototype.connect = function(port, host) {

	  if(this.stream.readyState === 'closed') {
	    this.stream.connect(port, host);
	  } else if(this.stream.readyState == 'open') {
	    this.emit('connect');
	  }

	  var self = this;

	  this.stream.on('connect', function() {
	    if (self._keepAlive) {
	      self.stream.setKeepAlive(true);
	    }
	    self.emit('connect');
	  });

	  this.stream.on('error', function(error) {
	    //don't raise ECONNRESET errors - they can & should be ignored
	    //during disconnect
	    if(self._ending && error.code == 'ECONNRESET') {
	      return;
	    }
	    self.emit('error', error);
	  });

	  this.stream.on('close', function() {
	    // NOTE: node-0.10 emits both 'end' and 'close'
	    //       for streams closed by the peer, while
	    //       node-0.8 only emits 'close'
	    self.emit('end');
	  });

	  if(!this.ssl) {
	    return this.attachListeners(this.stream);
	  }

	  this.stream.once('data', function(buffer) {
	    var responseCode = buffer.toString('utf8');
	    if(responseCode != 'S') {
	      return self.emit('error', new Error('The server does not support SSL connections'));
	    }
	    var tls = __webpack_require__(/*! tls */ 162);
	    self.stream = tls.connect({
	      socket: self.stream,
	      servername: host,
	      rejectUnauthorized: self.ssl.rejectUnauthorized,
	      ca: self.ssl.ca,
	      pfx: self.ssl.pfx,
	      key: self.ssl.key,
	      passphrase: self.ssl.passphrase,
	      cert: self.ssl.cert,
	      NPNProtocols: self.ssl.NPNProtocols
	    });
	    self.attachListeners(self.stream);
	    self.emit('sslconnect');

	    self.stream.on('error', function(error){
	      self.emit('error', error);
	    });
	  });
	};

	Connection.prototype.attachListeners = function(stream) {
	  var self = this;
	  stream.on('data', function(buff) {
	    self._reader.addChunk(buff);
	    var packet = self._reader.read();
	    while(packet) {
	      var msg = self.parseMessage(packet);
	      if(self._emitMessage) {
	        self.emit('message', msg);
	      }
	      self.emit(msg.name, msg);
	      packet = self._reader.read();
	    }
	  });
	  stream.on('end', function() {
	    self.emit('end');
	  });
	};

	Connection.prototype.requestSsl = function() {
	  this.checkSslResponse = true;

	  var bodyBuffer = this.writer
	    .addInt16(0x04D2)
	    .addInt16(0x162F).flush();

	  var length = bodyBuffer.length + 4;

	  var buffer = new Writer()
	    .addInt32(length)
	    .add(bodyBuffer)
	    .join();
	  this.stream.write(buffer);
	};

	Connection.prototype.startup = function(config) {
	  var writer = this.writer
	    .addInt16(3)
	    .addInt16(0)
	  ;

	  Object.keys(config).forEach(function(key){
	    var val = config[key];
	    writer.addCString(key).addCString(val);
	  });

	  writer.addCString('client_encoding').addCString("'utf-8'");

	  var bodyBuffer = writer.addCString('').flush();
	  //this message is sent without a code

	  var length = bodyBuffer.length + 4;

	  var buffer = new Writer()
	    .addInt32(length)
	    .add(bodyBuffer)
	    .join();
	  this.stream.write(buffer);
	};

	Connection.prototype.cancel = function(processID, secretKey) {
	  var bodyBuffer = this.writer
	    .addInt16(1234)
	    .addInt16(5678)
	    .addInt32(processID)
	    .addInt32(secretKey)
	    .flush();

	  var length = bodyBuffer.length + 4;

	  var buffer = new Writer()
	    .addInt32(length)
	    .add(bodyBuffer)
	    .join();
	  this.stream.write(buffer);
	};

	Connection.prototype.password = function(password) {
	  //0x70 = 'p'
	  this._send(0x70, this.writer.addCString(password));
	};

	Connection.prototype._send = function(code, more) {
	  if(!this.stream.writable) { return false; }
	  if(more === true) {
	    this.writer.addHeader(code);
	  } else {
	    return this.stream.write(this.writer.flush(code));
	  }
	};

	Connection.prototype.query = function(text) {
	  //0x51 = Q
	  this.stream.write(this.writer.addCString(text).flush(0x51));
	};

	//send parse message
	//"more" === true to buffer the message until flush() is called
	Connection.prototype.parse = function(query, more) {
	  //expect something like this:
	  // { name: 'queryName',
	  //   text: 'select * from blah',
	  //   types: ['int8', 'bool'] }

	  //normalize missing query names to allow for null
	  query.name = query.name || '';
	  if (query.name.length > 63) {
	    console.error('Warning! Postgres only supports 63 characters for query names.');
	    console.error('You supplied', query.name, '(', query.name.length, ')');
	    console.error('This can cause conflicts and silent errors executing queries');
	  }
	  //normalize null type array
	  query.types = query.types || [];
	  var len = query.types.length;
	  var buffer = this.writer
	    .addCString(query.name) //name of query
	    .addCString(query.text) //actual query text
	    .addInt16(len);
	  for(var i = 0; i < len; i++) {
	    buffer.addInt32(query.types[i]);
	  }

	  var code = 0x50;
	  this._send(code, more);
	};

	//send bind message
	//"more" === true to buffer the message until flush() is called
	Connection.prototype.bind = function(config, more) {
	  //normalize config
	  config = config || {};
	  config.portal = config.portal || '';
	  config.statement = config.statement || '';
	  config.binary = config.binary || false;
	  var values = config.values || [];
	  var len = values.length;
	  var useBinary = false;
	  for (var j = 0; j < len; j++)
	    useBinary |= values[j] instanceof Buffer;
	  var buffer = this.writer
	    .addCString(config.portal)
	    .addCString(config.statement);
	  if (!useBinary)
	    buffer.addInt16(0);
	  else {
	    buffer.addInt16(len);
	    for (j = 0; j < len; j++)
	      buffer.addInt16(values[j] instanceof Buffer);
	  }
	  buffer.addInt16(len);
	  for(var i = 0; i < len; i++) {
	    var val = values[i];
	    if(val === null || typeof val === "undefined") {
	      buffer.addInt32(-1);
	    } else if (val instanceof Buffer) {
	      buffer.addInt32(val.length);
	      buffer.add(val);
	    } else {
	      buffer.addInt32(Buffer.byteLength(val));
	      buffer.addString(val);
	    }
	  }

	  if(config.binary) {
	    buffer.addInt16(1); // format codes to use binary
	    buffer.addInt16(1);
	  }
	  else {
	    buffer.addInt16(0); // format codes to use text
	  }
	  //0x42 = 'B'
	  this._send(0x42, more);
	};

	//send execute message
	//"more" === true to buffer the message until flush() is called
	Connection.prototype.execute = function(config, more) {
	  config = config || {};
	  config.portal = config.portal || '';
	  config.rows = config.rows || '';
	  this.writer
	    .addCString(config.portal)
	    .addInt32(config.rows);

	  //0x45 = 'E'
	  this._send(0x45, more);
	};

	var emptyBuffer = Buffer(0);

	Connection.prototype.flush = function() {
	  //0x48 = 'H'
	  this.writer.add(emptyBuffer);
	  this._send(0x48);
	};

	Connection.prototype.sync = function() {
	  //clear out any pending data in the writer
	  this.writer.flush(0);

	  this.writer.add(emptyBuffer);
	  this._ending = true;
	  this._send(0x53);
	};

	Connection.prototype.end = function() {
	  //0x58 = 'X'
	  this.writer.add(emptyBuffer);
	  this._ending = true;
	  this._send(0x58);
	};

	Connection.prototype.close = function(msg, more) {
	  this.writer.addCString(msg.type + (msg.name || ''));
	  this._send(0x43, more);
	};

	Connection.prototype.describe = function(msg, more) {
	  this.writer.addCString(msg.type + (msg.name || ''));
	  this._send(0x44, more);
	};

	Connection.prototype.sendCopyFromChunk = function (chunk) {
	  this.stream.write(this.writer.add(chunk).flush(0x64));
	};

	Connection.prototype.endCopyFrom = function () {
	  this.stream.write(this.writer.add(emptyBuffer).flush(0x63));
	};

	Connection.prototype.sendCopyFail = function (msg) {
	  //this.stream.write(this.writer.add(emptyBuffer).flush(0x66));
	  this.writer.addCString(msg);
	  this._send(0x66);
	};

	var Message = function(name, length) {
	  this.name = name;
	  this.length = length;
	};

	Connection.prototype.parseMessage =  function(buffer) {

	  this.offset = 0;
	  var length = buffer.length + 4;
	  switch(this._reader.header)
	  {

	  case 0x52: //R
	    return this.parseR(buffer, length);

	  case 0x53: //S
	    return this.parseS(buffer, length);

	  case 0x4b: //K
	    return this.parseK(buffer, length);

	  case 0x43: //C
	    return this.parseC(buffer, length);

	  case 0x5a: //Z
	    return this.parseZ(buffer, length);

	  case 0x54: //T
	    return this.parseT(buffer, length);

	  case 0x44: //D
	    return this.parseD(buffer, length);

	  case 0x45: //E
	    return this.parseE(buffer, length);

	  case 0x4e: //N
	    return this.parseN(buffer, length);

	  case 0x31: //1
	    return new Message('parseComplete', length);

	  case 0x32: //2
	    return new Message('bindComplete', length);

	  case 0x33: //3
	    return new Message('closeComplete', length);

	  case 0x41: //A
	    return this.parseA(buffer, length);

	  case 0x6e: //n
	    return new Message('noData', length);

	  case 0x49: //I
	    return new Message('emptyQuery', length);

	  case 0x73: //s
	    return new Message('portalSuspended', length);

	  case 0x47: //G
	    return this.parseG(buffer, length);

	  case 0x48: //H
	    return this.parseH(buffer, length);

	  case 0x63: //c
	    return new Message('copyDone', length);

	  case 0x64: //d
	    return this.parsed(buffer, length);
	  }
	};

	Connection.prototype.parseR = function(buffer, length) {
	  var code = 0;
	  var msg = new Message('authenticationOk', length);
	  if(msg.length === 8) {
	    code = this.parseInt32(buffer);
	    if(code === 3) {
	      msg.name = 'authenticationCleartextPassword';
	    }
	    return msg;
	  }
	  if(msg.length === 12) {
	    code = this.parseInt32(buffer);
	    if(code === 5) { //md5 required
	      msg.name = 'authenticationMD5Password';
	      msg.salt = new Buffer(4);
	      buffer.copy(msg.salt, 0, this.offset, this.offset + 4);
	      this.offset += 4;
	      return msg;
	    }
	  }
	  throw new Error("Unknown authenticationOk message type" + util.inspect(msg));
	};

	Connection.prototype.parseS = function(buffer, length) {
	  var msg = new Message('parameterStatus', length);
	  msg.parameterName = this.parseCString(buffer);
	  msg.parameterValue = this.parseCString(buffer);
	  return msg;
	};

	Connection.prototype.parseK = function(buffer, length) {
	  var msg = new Message('backendKeyData', length);
	  msg.processID = this.parseInt32(buffer);
	  msg.secretKey = this.parseInt32(buffer);
	  return msg;
	};

	Connection.prototype.parseC = function(buffer, length) {
	  var msg = new Message('commandComplete', length);
	  msg.text = this.parseCString(buffer);
	  return msg;
	};

	Connection.prototype.parseZ = function(buffer, length) {
	  var msg = new Message('readyForQuery', length);
	  msg.name = 'readyForQuery';
	  msg.status = this.readString(buffer, 1);
	  return msg;
	};

	var ROW_DESCRIPTION = 'rowDescription';
	Connection.prototype.parseT = function(buffer, length) {
	  var msg = new Message(ROW_DESCRIPTION, length);
	  msg.fieldCount = this.parseInt16(buffer);
	  var fields = [];
	  for(var i = 0; i < msg.fieldCount; i++){
	    fields.push(this.parseField(buffer));
	  }
	  msg.fields = fields;
	  return msg;
	};

	var Field = function() {
	  this.name = null;
	  this.tableID = null;
	  this.columnID = null;
	  this.dataTypeID = null;
	  this.dataTypeSize = null;
	  this.dataTypeModifier = null;
	  this.format = null;
	};

	var FORMAT_TEXT = 'text';
	var FORMAT_BINARY = 'binary';
	Connection.prototype.parseField = function(buffer) {
	  var field = new Field();
	  field.name = this.parseCString(buffer);
	  field.tableID = this.parseInt32(buffer);
	  field.columnID = this.parseInt16(buffer);
	  field.dataTypeID = this.parseInt32(buffer);
	  field.dataTypeSize = this.parseInt16(buffer);
	  field.dataTypeModifier = this.parseInt32(buffer);
	  if(this.parseInt16(buffer) === TEXT_MODE) {
	    this._mode = TEXT_MODE;
	    field.format = FORMAT_TEXT;
	  } else {
	    this._mode = BINARY_MODE;
	    field.format = FORMAT_BINARY;
	  }
	  return field;
	};

	var DATA_ROW = 'dataRow';
	var DataRowMessage = function(length, fieldCount) {
	  this.name = DATA_ROW;
	  this.length = length;
	  this.fieldCount = fieldCount;
	  this.fields = [];
	};


	//extremely hot-path code
	Connection.prototype.parseD = function(buffer, length) {
	  var fieldCount = this.parseInt16(buffer);
	  var msg = new DataRowMessage(length, fieldCount);
	  for(var i = 0; i < fieldCount; i++) {
	    msg.fields.push(this._readValue(buffer));
	  }
	  return msg;
	};

	//extremely hot-path code
	Connection.prototype._readValue = function(buffer) {
	  var length = this.parseInt32(buffer);
	  if(length === -1) return null;
	  if(this._mode === TEXT_MODE) {
	    return this.readString(buffer, length);
	  }
	  return this.readBytes(buffer, length);
	};

	//parses error
	Connection.prototype.parseE = function(buffer, length) {
	  var fields = {};
	  var msg, item;
	  var input = new Message('error', length);
	  var fieldType = this.readString(buffer, 1);
	  while(fieldType != '\0') {
	    fields[fieldType] = this.parseCString(buffer);
	    fieldType = this.readString(buffer, 1);
	  }
	  if(input.name === 'error') {
	    // the msg is an Error instance
	    msg = new Error(fields.M);
	    for (item in input) {
	      // copy input properties to the error
	      if(input.hasOwnProperty(item)) {
	        msg[item] = input[item];
	      }
	    }
	  } else {
	    // the msg is an object literal
	    msg = input;
	    msg.message = fields.M;
	  }
	  msg.severity = fields.S;
	  msg.code = fields.C;
	  msg.detail = fields.D;
	  msg.hint = fields.H;
	  msg.position = fields.P;
	  msg.internalPosition = fields.p;
	  msg.internalQuery = fields.q;
	  msg.where = fields.W;
	  msg.schema = fields.s;
	  msg.table = fields.t;
	  msg.column = fields.c;
	  msg.dataType = fields.d;
	  msg.constraint = fields.n;
	  msg.file = fields.F;
	  msg.line = fields.L;
	  msg.routine = fields.R;
	  return msg;
	};

	//same thing, different name
	Connection.prototype.parseN = function(buffer, length) {
	  var msg = this.parseE(buffer, length);
	  msg.name = 'notice';
	  return msg;
	};

	Connection.prototype.parseA = function(buffer, length) {
	  var msg = new Message('notification', length);
	  msg.processId = this.parseInt32(buffer);
	  msg.channel = this.parseCString(buffer);
	  msg.payload = this.parseCString(buffer);
	  return msg;
	};

	Connection.prototype.parseG = function (buffer, length) {
	  var msg = new Message('copyInResponse', length);
	  return this.parseGH(buffer, msg);
	};

	Connection.prototype.parseH = function(buffer, length) {
	  var msg = new Message('copyOutResponse', length);
	  return this.parseGH(buffer, msg);
	};

	Connection.prototype.parseGH = function (buffer, msg) {
	  var isBinary = buffer[this.offset] !== 0;
	  this.offset++;
	  msg.binary = isBinary;
	  var columnCount = this.parseInt16(buffer);
	  msg.columnTypes = [];
	  for(var i = 0; i<columnCount; i++) {
	    msg.columnTypes.push(this.parseInt16(buffer));
	  }
	  return msg;
	};

	Connection.prototype.parsed = function (buffer, length) {
	  var msg = new Message('copyData', length);
	  msg.chunk = this.readBytes(buffer, msg.length - 4);
	  return msg;
	};

	Connection.prototype.parseInt32 = function(buffer) {
	  var value = buffer.readInt32BE(this.offset, true);
	  this.offset += 4;
	  return value;
	};

	Connection.prototype.parseInt16 = function(buffer) {
	  var value = buffer.readInt16BE(this.offset, true);
	  this.offset += 2;
	  return value;
	};

	Connection.prototype.readString = function(buffer, length) {
	  return buffer.toString(this.encoding, this.offset, (this.offset += length));
	};

	Connection.prototype.readBytes = function(buffer, length) {
	  return buffer.slice(this.offset, this.offset += length);
	};

	Connection.prototype.parseCString = function(buffer) {
	  var start = this.offset;
	  while(buffer[this.offset++] !== 0) { }
	  return buffer.toString(this.encoding, start, this.offset - 1);
	};
	//end parsing methods
	module.exports = Connection;


/***/ },
/* 159 */
/*!**********************************!*\
  !*** ./~/buffer-writer/index.js ***!
  \**********************************/
/***/ function(module, exports) {

	//binary data writer tuned for creating
	//postgres message packets as effeciently as possible by reusing the
	//same buffer to avoid memcpy and limit memory allocations
	var Writer = module.exports = function(size) {
	  this.size = size || 1024;
	  this.buffer = Buffer(this.size + 5);
	  this.offset = 5;
	  this.headerPosition = 0;
	};

	//resizes internal buffer if not enough size left
	Writer.prototype._ensure = function(size) {
	  var remaining = this.buffer.length - this.offset;
	  if(remaining < size) {
	    var oldBuffer = this.buffer;
	    // exponential growth factor of around ~ 1.5
	    // https://stackoverflow.com/questions/2269063/buffer-growth-strategy
	    var newSize = oldBuffer.length + (oldBuffer.length >> 1) + size;
	    this.buffer = new Buffer(newSize);
	    oldBuffer.copy(this.buffer);
	  }
	};

	Writer.prototype.addInt32 = function(num) {
	  this._ensure(4);
	  this.buffer[this.offset++] = (num >>> 24 & 0xFF);
	  this.buffer[this.offset++] = (num >>> 16 & 0xFF);
	  this.buffer[this.offset++] = (num >>>  8 & 0xFF);
	  this.buffer[this.offset++] = (num >>>  0 & 0xFF);
	  return this;
	};

	Writer.prototype.addInt16 = function(num) {
	  this._ensure(2);
	  this.buffer[this.offset++] = (num >>>  8 & 0xFF);
	  this.buffer[this.offset++] = (num >>>  0 & 0xFF);
	  return this;
	};

	//for versions of node requiring 'length' as 3rd argument to buffer.write
	var writeString = function(buffer, string, offset, len) {
	  buffer.write(string, offset, len);
	};

	//overwrite function for older versions of node
	if(Buffer.prototype.write.length === 3) {
	  writeString = function(buffer, string, offset, len) {
	    buffer.write(string, offset);
	  };
	}

	Writer.prototype.addCString = function(string) {
	  //just write a 0 for empty or null strings
	  if(!string) {
	    this._ensure(1);
	  } else {
	    var len = Buffer.byteLength(string);
	    this._ensure(len + 1); //+1 for null terminator
	    writeString(this.buffer, string, this.offset, len);
	    this.offset += len;
	  }

	  this.buffer[this.offset++] = 0; // null terminator
	  return this;
	};

	Writer.prototype.addChar = function(c) {
	  this._ensure(1);
	  writeString(this.buffer, c, this.offset, 1);
	  this.offset++;
	  return this;
	};

	Writer.prototype.addString = function(string) {
	  string = string || "";
	  var len = Buffer.byteLength(string);
	  this._ensure(len);
	  this.buffer.write(string, this.offset);
	  this.offset += len;
	  return this;
	};

	Writer.prototype.getByteLength = function() {
	  return this.offset - 5;
	};

	Writer.prototype.add = function(otherBuffer) {
	  this._ensure(otherBuffer.length);
	  otherBuffer.copy(this.buffer, this.offset);
	  this.offset += otherBuffer.length;
	  return this;
	};

	Writer.prototype.clear = function() {
	  this.offset = 5;
	  this.headerPosition = 0;
	  this.lastEnd = 0;
	};

	//appends a header block to all the written data since the last
	//subsequent header or to the beginning if there is only one data block
	Writer.prototype.addHeader = function(code, last) {
	  var origOffset = this.offset;
	  this.offset = this.headerPosition;
	  this.buffer[this.offset++] = code;
	  //length is everything in this packet minus the code
	  this.addInt32(origOffset - (this.headerPosition+1));
	  //set next header position
	  this.headerPosition = origOffset;
	  //make space for next header
	  this.offset = origOffset;
	  if(!last) {
	    this._ensure(5);
	    this.offset += 5;
	  }
	};

	Writer.prototype.join = function(code) {
	  if(code) {
	    this.addHeader(code, true);
	  }
	  return this.buffer.slice(code ? 0 : 5, this.offset);
	};

	Writer.prototype.flush = function(code) {
	  var result = this.join(code);
	  this.clear();
	  return result;
	};


/***/ },
/* 160 */
/*!**********************************!*\
  !*** ./~/packet-reader/index.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(/*! assert */ 161)

	var Reader = module.exports = function(options) {
	  //TODO - remove for version 1.0
	  if(typeof options == 'number') {
	    options = { headerSize: options }
	  }
	  options = options || {}
	  this.offset = 0
	  this.lastChunk = false
	  this.chunk = null
	  this.headerSize = options.headerSize || 0
	  this.lengthPadding = options.lengthPadding || 0
	  this.header = null
	  assert(this.headerSize < 2, 'pre-length header of more than 1 byte length not currently supported')
	}

	Reader.prototype.addChunk = function(chunk) {
	  this.offset = 0
	  this.chunk = chunk
	  if(this.lastChunk) {
	    this.chunk = Buffer.concat([this.lastChunk, this.chunk])
	    this.lastChunk = false
	  }
	}

	Reader.prototype._save = function() {
	  //save any unread chunks for next read
	  if(this.offset < this.chunk.length) {
	    this.lastChunk = this.chunk.slice(this.offset)
	  }
	  return false
	}

	Reader.prototype.read = function() {
	  if(this.chunk.length < (this.headerSize + 4 + this.offset)) {
	    return this._save()
	  }

	  if(this.headerSize) {
	    this.header = this.chunk[this.offset]
	  }

	  //read length of next item
	  var length = this.chunk.readUInt32BE(this.offset + this.headerSize) + this.lengthPadding

	  //next item spans more chunks than we have
	  var remaining = this.chunk.length - (this.offset + 4 + this.headerSize)
	  if(length > remaining) {
	    return this._save()
	  }

	  this.offset += (this.headerSize + 4)
	  var result = this.chunk.slice(this.offset, this.offset + length)
	  this.offset += length
	  return result
	}


/***/ },
/* 161 */
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ function(module, exports) {

	module.exports = require("assert");

/***/ },
/* 162 */
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/***/ function(module, exports) {

	module.exports = require("tls");

/***/ },
/* 163 */
/*!**********************************!*\
  !*** ./~/pg/lib/pool-factory.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	var Client = __webpack_require__(/*! ./client */ 134);
	var util = __webpack_require__(/*! util */ 16);
	var Pool = __webpack_require__(/*! pg-pool */ 164);

	module.exports = function(Client) {

	  var BoundPool = function(options) {
	    var config = { Client: Client };
	    for (var key in options) {
	      config[key] = options[key];
	    }
	    Pool.call(this, config);
	  };

	  util.inherits(BoundPool, Pool);

	  return BoundPool;
	};


/***/ },
/* 164 */
/*!****************************!*\
  !*** ./~/pg-pool/index.js ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	var genericPool = __webpack_require__(/*! generic-pool */ 165)
	var util = __webpack_require__(/*! util */ 16)
	var EventEmitter = __webpack_require__(/*! events */ 26).EventEmitter
	var objectAssign = __webpack_require__(/*! object-assign */ 166)

	var Pool = module.exports = function (options, Client) {
	  if (!(this instanceof Pool)) {
	    return new Pool(options, Client)
	  }
	  EventEmitter.call(this)
	  this.options = objectAssign({}, options)
	  this.log = this.options.log || function () { }
	  this.Client = this.options.Client || Client || __webpack_require__(/*! pg */ 133).Client
	  this.Promise = this.options.Promise || Promise

	  this.options.max = this.options.max || this.options.poolSize || 10
	  this.options.create = this.options.create || this._create.bind(this)
	  this.options.destroy = this.options.destroy || this._destroy.bind(this)
	  this.pool = new genericPool.Pool(this.options)
	  this.onCreate = this.options.onCreate
	}

	util.inherits(Pool, EventEmitter)

	Pool.prototype._destroy = function (client) {
	  if (client._destroying) return
	  client._destroying = true
	  client.end()
	}

	Pool.prototype._create = function (cb) {
	  this.log('connecting new client')
	  var client = new this.Client(this.options)

	  client.on('error', function (e) {
	    this.log('connected client error:', e)
	    this.pool.destroy(client)
	    e.client = client
	    this.emit('error', e)
	  }.bind(this))

	  client.connect(function (err) {
	    if (err) {
	      this.log('client connection error:', err)
	      cb(err)
	      this.emit('error', err)
	    } else {
	      this.log('client connected')
	      this.emit('connect', client)
	      cb(null, client)
	    }
	  }.bind(this))
	}

	Pool.prototype.connect = function (cb) {
	  return new this.Promise(function (resolve, reject) {
	    this.log('acquire client begin')
	    this.pool.acquire(function (err, client) {
	      if (err) {
	        this.log('acquire client. error:', err)
	        if (cb) {
	          cb(err, null, function () {})
	        }
	        return reject(err)
	      }

	      this.log('acquire client')
	      this.emit('acquire', client)

	      client.release = function (err) {
	        delete client.release
	        if (err) {
	          this.log('destroy client. error:', err)
	          this.pool.destroy(client)
	        } else {
	          this.log('release client')
	          this.pool.release(client)
	        }
	      }.bind(this)

	      if (cb) {
	        cb(null, client, client.release)
	      }

	      return resolve(client)
	    }.bind(this))
	  }.bind(this))
	}

	Pool.prototype.take = Pool.prototype.connect

	Pool.prototype.query = function (text, values, cb) {
	  if (typeof values === 'function') {
	    cb = values
	    values = undefined
	  }

	  return new this.Promise(function (resolve, reject) {
	    this.connect(function (err, client, done) {
	      if (err) {
	        if (cb) {
	          cb(err)
	        }
	        return reject(err)
	      }
	      client.query(text, values, function (err, res) {
	        done(err)
	        err ? reject(err) : resolve(res)
	        if (cb) {
	          cb(err, res)
	        }
	      })
	    })
	  }.bind(this))
	}

	Pool.prototype.end = function (cb) {
	  this.log('draining pool')
	  return new this.Promise(function (resolve, reject) {
	    this.pool.drain(function () {
	      this.log('pool drained, calling destroy all now')
	      this.pool.destroyAllNow(function () {
	        if (cb) {
	          cb()
	        }
	        resolve()
	      })
	    }.bind(this))
	  }.bind(this))
	}


/***/ },
/* 165 */
/*!********************************************!*\
  !*** ./~/generic-pool/lib/generic-pool.js ***!
  \********************************************/
/***/ function(module, exports) {

	/**
	 * @class
	 * @private
	 */
	function PriorityQueue (size) {
	  if (!(this instanceof PriorityQueue)) {
	    return new PriorityQueue()
	  }

	  this._size = size
	  this._slots = null
	  this._total = null

	  // initialize arrays to hold queue elements
	  size = Math.max(+size | 0, 1)
	  this._slots = []
	  for (var i = 0; i < size; i += 1) {
	    this._slots.push([])
	  }
	}

	PriorityQueue.prototype.size = function size () {
	  if (this._total === null) {
	    this._total = 0
	    for (var i = 0; i < this._size; i += 1) {
	      this._total += this._slots[i].length
	    }
	  }
	  return this._total
	}

	PriorityQueue.prototype.enqueue = function enqueue (obj, priority) {
	  var priorityOrig

	  // Convert to integer with a default value of 0.
	  priority = priority && +priority | 0 || 0

	  // Clear cache for total.
	  this._total = null
	  if (priority) {
	    priorityOrig = priority
	    if (priority < 0 || priority >= this._size) {
	      priority = (this._size - 1)
	      // put obj at the end of the line
	      console.error('invalid priority: ' + priorityOrig + ' must be between 0 and ' + priority)
	    }
	  }

	  this._slots[priority].push(obj)
	}

	PriorityQueue.prototype.dequeue = function dequeue (callback) {
	  var obj = null
	  // Clear cache for total.
	  this._total = null
	  for (var i = 0, sl = this._slots.length; i < sl; i += 1) {
	    if (this._slots[i].length) {
	      obj = this._slots[i].shift()
	      break
	    }
	  }
	  return obj
	}

	function doWhileAsync (conditionFn, iterateFn, callbackFn) {
	  var next = function () {
	    if (conditionFn()) {
	      iterateFn(next)
	    } else {
	      callbackFn()
	    }
	  }
	  next()
	}

	/**
	 * Generate an Object pool with a specified `factory`.
	 *
	 * @class
	 * @param {Object} factory
	 *   Factory to be used for generating and destorying the items.
	 * @param {String} factory.name
	 *   Name of the factory. Serves only logging purposes.
	 * @param {Function} factory.create
	 *   Should create the item to be acquired,
	 *   and call it's first callback argument with the generated item as it's argument.
	 * @param {Function} factory.destroy
	 *   Should gently close any resources that the item is using.
	 *   Called before the items is destroyed.
	 * @param {Function} factory.validate
	 *   Should return true if connection is still valid and false
	 *   If it should be removed from pool. Called before item is
	 *   acquired from pool.
	 * @param {Function} factory.validateAsync
	 *   Asynchronous validate function. Receives a callback function
	 *   as its second argument, that should be called with a single
	 *   boolean argument being true if the item is still valid and false
	 *   if it should be removed from pool. Called before item is
	 *   acquired from pool. Only one of validate/validateAsync may be specified
	 * @param {Number} factory.max
	 *   Maximum number of items that can exist at the same time.  Default: 1.
	 *   Any further acquire requests will be pushed to the waiting list.
	 * @param {Number} factory.min
	 *   Minimum number of items in pool (including in-use). Default: 0.
	 *   When the pool is created, or a resource destroyed, this minimum will
	 *   be checked. If the pool resource count is below the minimum, a new
	 *   resource will be created and added to the pool.
	 * @param {Number} factory.idleTimeoutMillis
	 *   Delay in milliseconds after the idle items in the pool will be destroyed.
	 *   And idle item is that is not acquired yet. Waiting items doesn't count here.
	 * @param {Number} factory.reapIntervalMillis
	 *   Cleanup is scheduled in every `factory.reapIntervalMillis` milliseconds.
	 * @param {Boolean|Function} factory.log
	 *   Whether the pool should log activity. If function is specified,
	 *   that will be used instead. The function expects the arguments msg, loglevel
	 * @param {Number} factory.priorityRange
	 *   The range from 1 to be treated as a valid priority
	 * @param {RefreshIdle} factory.refreshIdle
	 *   Should idle resources be destroyed and recreated every idleTimeoutMillis? Default: true.
	 * @param {Bool} [factory.returnToHead=false]
	 *   Returns released object to head of available objects list
	 */
	function Pool (factory) {
	  if (!(this instanceof Pool)) {
	    return new Pool(factory)
	  }

	  if (factory.validate && factory.validateAsync) {
	    throw new Error('Only one of validate or validateAsync may be specified')
	  }

	  // defaults
	  factory.idleTimeoutMillis = factory.idleTimeoutMillis || 30000
	  factory.returnToHead = factory.returnToHead || false
	  factory.refreshIdle = ('refreshIdle' in factory) ? factory.refreshIdle : true
	  factory.reapInterval = factory.reapIntervalMillis || 1000
	  factory.priorityRange = factory.priorityRange || 1
	  factory.validate = factory.validate || function () { return true }

	  factory.max = parseInt(factory.max, 10)
	  factory.min = parseInt(factory.min, 10)

	  factory.max = Math.max(isNaN(factory.max) ? 1 : factory.max, 1)
	  factory.min = Math.min(isNaN(factory.min) ? 0 : factory.min, factory.max - 1)

	  this._factory = factory
	  this._inUseObjects = []
	  this._draining = false
	  this._waitingClients = new PriorityQueue(factory.priorityRange)
	  this._availableObjects = []
	  this._count = 0
	  this._removeIdleTimer = null
	  this._removeIdleScheduled = false

	  // create initial resources (if factory.min > 0)
	  this._ensureMinimum()
	}

	/**
	 * logs to console or user defined log function
	 * @private
	 * @param {string} str
	 * @param {string} level
	 */
	Pool.prototype._log = function log (str, level) {
	  if (typeof this._factory.log === 'function') {
	    this._factory.log(str, level)
	  } else if (this._factory.log) {
	    console.log(level.toUpperCase() + ' pool ' + this._factory.name + ' - ' + str)
	  }
	}

	/**
	 * Request the client to be destroyed. The factory's destroy handler
	 * will also be called.
	 *
	 * This should be called within an acquire() block as an alternative to release().
	 *
	 * @param {Object} obj
	 *   The acquired item to be destoyed.
	 */
	Pool.prototype.destroy = function destroy (obj) {
	  this._count -= 1
	  if (this._count < 0) this._count = 0
	  this._availableObjects = this._availableObjects.filter(function (objWithTimeout) {
	    return (objWithTimeout.obj !== obj)
	  })

	  this._inUseObjects = this._inUseObjects.filter(function (objInUse) {
	    return (objInUse !== obj)
	  })

	  this._factory.destroy(obj)

	  this._ensureMinimum()
	}

	/**
	 * Checks and removes the available (idle) clients that have timed out.
	 * @private
	 */
	Pool.prototype._removeIdle = function removeIdle () {
	  var toRemove = []
	  var now = new Date().getTime()
	  var i
	  var al
	  var tr
	  var timeout

	  this._removeIdleScheduled = false

	  // Go through the available (idle) items,
	  // check if they have timed out
	  for (i = 0, al = this._availableObjects.length; i < al && (this._factory.refreshIdle && (this._count - this._factory.min > toRemove.length)); i += 1) {
	    timeout = this._availableObjects[i].timeout
	    if (now >= timeout) {
	      // Client timed out, so destroy it.
	      this._log('removeIdle() destroying obj - now:' + now + ' timeout:' + timeout, 'verbose')
	      toRemove.push(this._availableObjects[i].obj)
	    }
	  }

	  for (i = 0, tr = toRemove.length; i < tr; i += 1) {
	    this.destroy(toRemove[i])
	  }

	  // Replace the available items with the ones to keep.
	  al = this._availableObjects.length

	  if (al > 0) {
	    this._log('this._availableObjects.length=' + al, 'verbose')
	    this._scheduleRemoveIdle()
	  } else {
	    this._log('removeIdle() all objects removed', 'verbose')
	  }
	}

	/**
	 * Schedule removal of idle items in the pool.
	 *
	 * More schedules cannot run concurrently.
	 */
	Pool.prototype._scheduleRemoveIdle = function scheduleRemoveIdle () {
	  var self = this
	  if (!this._removeIdleScheduled) {
	    this._removeIdleScheduled = true
	    this._removeIdleTimer = setTimeout(function () {
	      self._removeIdle()
	    }, this._factory.reapInterval)
	  }
	}

	/**
	 * Try to get a new client to work, and clean up pool unused (idle) items.
	 *
	 *  - If there are available clients waiting, shift the first one out (LIFO),
	 *    and call its callback.
	 *  - If there are no waiting clients, try to create one if it won't exceed
	 *    the maximum number of clients.
	 *  - If creating a new client would exceed the maximum, add the client to
	 *    the wait list.
	 * @private
	 */
	Pool.prototype._dispense = function dispense () {
	  var self = this
	  var objWithTimeout = null
	  var err = null
	  var clientCb = null
	  var waitingCount = this._waitingClients.size()

	  this._log('dispense() clients=' + waitingCount + ' available=' + this._availableObjects.length, 'info')
	  if (waitingCount > 0) {
	    if (this._factory.validateAsync) {
	      doWhileAsync(function () {
	        return self._availableObjects.length > 0
	      }, function (next) {
	        self._log('dispense() - reusing obj', 'verbose')
	        objWithTimeout = self._availableObjects[0]

	        self._factory.validateAsync(objWithTimeout.obj, function (valid) {
	          if (!valid) {
	            self.destroy(objWithTimeout.obj)
	            next()
	          } else {
	            self._availableObjects.shift()
	            self._inUseObjects.push(objWithTimeout.obj)
	            clientCb = self._waitingClients.dequeue()
	            clientCb(err, objWithTimeout.obj)
	          }
	        })
	      }, function () {
	        if (self._count < self._factory.max) {
	          self._createResource()
	        }
	      })

	      return
	    }

	    while (this._availableObjects.length > 0) {
	      this._log('dispense() - reusing obj', 'verbose')
	      objWithTimeout = this._availableObjects[0]
	      if (!this._factory.validate(objWithTimeout.obj)) {
	        this.destroy(objWithTimeout.obj)
	        continue
	      }
	      this._availableObjects.shift()
	      this._inUseObjects.push(objWithTimeout.obj)
	      clientCb = this._waitingClients.dequeue()
	      return clientCb(err, objWithTimeout.obj)
	    }
	    if (this._count < this._factory.max) {
	      this._createResource()
	    }
	  }
	}

	/**
	 * @private
	 */
	Pool.prototype._createResource = function _createResource () {
	  this._count += 1
	  this._log('createResource() - creating obj - count=' + this._count + ' min=' + this._factory.min + ' max=' + this._factory.max, 'verbose')
	  var self = this
	  this._factory.create(function () {
	    var err, obj
	    var clientCb = self._waitingClients.dequeue()
	    if (arguments.length > 1) {
	      err = arguments[0]
	      obj = arguments[1]
	    } else {
	      err = (arguments[0] instanceof Error) ? arguments[0] : null
	      obj = (arguments[0] instanceof Error) ? null : arguments[0]
	    }
	    if (err) {
	      self._count -= 1
	      if (self._count < 0) self._count = 0
	      if (clientCb) {
	        clientCb(err, obj)
	      }
	      process.nextTick(function () {
	        self._dispense()
	      })
	    } else {
	      self._inUseObjects.push(obj)
	      if (clientCb) {
	        clientCb(err, obj)
	      } else {
	        self.release(obj)
	      }
	    }
	  })
	}

	/**
	 * @private
	 */
	Pool.prototype._ensureMinimum = function _ensureMinimum () {
	  var i, diff
	  if (!this._draining && (this._count < this._factory.min)) {
	    diff = this._factory.min - this._count
	    for (i = 0; i < diff; i++) {
	      this._createResource()
	    }
	  }
	}

	/**
	 * Request a new client. The callback will be called,
	 * when a new client will be availabe, passing the client to it.
	 *
	 * @param {Function} callback
	 *   Callback function to be called after the acquire is successful.
	 *   The function will receive the acquired item as the first parameter.
	 *
	 * @param {Number} priority
	 *   Optional.  Integer between 0 and (priorityRange - 1).  Specifies the priority
	 *   of the caller if there are no available resources.  Lower numbers mean higher
	 *   priority.
	 *
	 * @returns {boolean} `true` if the pool is not fully utilized, `false` otherwise.
	 */
	Pool.prototype.acquire = function acquire (callback, priority) {
	  if (this._draining) {
	    throw new Error('pool is draining and cannot accept work')
	  }
	  this._waitingClients.enqueue(callback, priority)
	  this._dispense()
	  return (this._count < this._factory.max)
	}

	/**
	 * @deprecated
	 */
	Pool.prototype.borrow = function borrow (callback, priority) {
	  this._log('borrow() is deprecated. use acquire() instead', 'warn')
	  this.acquire(callback, priority)
	}

	/**
	 * Return the client to the pool, in case it is no longer required.
	 *
	 * @param {Object} obj
	 *   The acquired object to be put back to the pool.
	 */
	Pool.prototype.release = function release (obj) {
	  // check to see if this object has already been released (i.e., is back in the pool of this._availableObjects)
	  if (this._availableObjects.some(function (objWithTimeout) { return (objWithTimeout.obj === obj) })) {
	    this._log('release called twice for the same resource: ' + (new Error().stack), 'error')
	    return
	  }

	  // check to see if this object exists in the `in use` list and remove it
	  var index = this._inUseObjects.indexOf(obj)
	  if (index < 0) {
	    this._log('attempt to release an invalid resource: ' + (new Error().stack), 'error')
	    return
	  }

	  // this._log("return to pool")
	  this._inUseObjects.splice(index, 1)
	  var objWithTimeout = { obj: obj, timeout: (new Date().getTime() + this._factory.idleTimeoutMillis) }
	  if (this._factory.returnToHead) {
	    this._availableObjects.splice(0, 0, objWithTimeout)
	  } else {
	    this._availableObjects.push(objWithTimeout)
	  }
	  this._log('timeout: ' + objWithTimeout.timeout, 'verbose')
	  this._dispense()
	  this._scheduleRemoveIdle()
	}

	/**
	 * @deprecated
	 */
	Pool.prototype.returnToPool = function returnToPool (obj) {
	  this._log('returnToPool() is deprecated. use release() instead', 'warn')
	  this.release(obj)
	}

	/**
	 * Disallow any new requests and let the request backlog dissapate.
	 *
	 * @param {Function} callback
	 *   Optional. Callback invoked when all work is done and all clients have been
	 *   released.
	 */
	Pool.prototype.drain = function drain (callback) {
	  this._log('draining', 'info')

	  // disable the ability to put more work on the queue.
	  this._draining = true

	  var self = this
	  var check = function () {
	    if (self._waitingClients.size() > 0) {
	      // wait until all client requests have been satisfied.
	      setTimeout(check, 100)
	    } else if (self._availableObjects.length !== self._count) {
	      // wait until all objects have been released.
	      setTimeout(check, 100)
	    } else if (callback) {
	      callback()
	    }
	  }
	  check()
	}

	/**
	 * Forcibly destroys all clients regardless of timeout.  Intended to be
	 * invoked as part of a drain.  Does not prevent the creation of new
	 * clients as a result of subsequent calls to acquire.
	 *
	 * Note that if factory.min > 0, the pool will destroy all idle resources
	 * in the pool, but replace them with newly created resources up to the
	 * specified factory.min value.  If this is not desired, set factory.min
	 * to zero before calling destroyAllNow()
	 *
	 * @param {Function} callback
	 *   Optional. Callback invoked after all existing clients are destroyed.
	 */
	Pool.prototype.destroyAllNow = function destroyAllNow (callback) {
	  this._log('force destroying all objects', 'info')
	  var willDie = this._availableObjects
	  this._availableObjects = []
	  var obj = willDie.shift()
	  while (obj !== null && obj !== undefined) {
	    this.destroy(obj.obj)
	    obj = willDie.shift()
	  }
	  this._removeIdleScheduled = false
	  clearTimeout(this._removeIdleTimer)
	  if (callback) {
	    callback()
	  }
	}

	/**
	 * Decorates a function to use a acquired client from the object pool when called.
	 *
	 * @param {Function} decorated
	 *   The decorated function, accepting a client as the first argument and
	 *   (optionally) a callback as the final argument.
	 *
	 * @param {Number} priority
	 *   Optional.  Integer between 0 and (priorityRange - 1).  Specifies the priority
	 *   of the caller if there are no available resources.  Lower numbers mean higher
	 *   priority.
	 */
	Pool.prototype.pooled = function pooled (decorated, priority) {
	  var self = this
	  return function () {
	    var callerArgs = arguments
	    var callerCallback = callerArgs[callerArgs.length - 1]
	    var callerHasCallback = typeof callerCallback === 'function'
	    self.acquire(function (err, client) {
	      if (err) {
	        if (callerHasCallback) {
	          callerCallback(err)
	        }
	        return
	      }

	      var args = [client].concat(Array.prototype.slice.call(callerArgs, 0, callerHasCallback ? -1 : undefined))
	      args.push(function () {
	        self.release(client)
	        if (callerHasCallback) {
	          callerCallback.apply(null, arguments)
	        }
	      })

	      decorated.apply(null, args)
	    }, priority)
	  }
	}

	Pool.prototype.getPoolSize = function getPoolSize () {
	  return this._count
	}

	Pool.prototype.getName = function getName () {
	  return this._factory.name
	}

	Pool.prototype.availableObjectsCount = function availableObjectsCount () {
	  return this._availableObjects.length
	}

	Pool.prototype.inUseObjectsCount = function inUseObjectsCount () {
	  return this._inUseObjects.length
	}

	Pool.prototype.waitingClientsCount = function waitingClientsCount () {
	  return this._waitingClients.size()
	}

	Pool.prototype.getMaxPoolSize = function getMaxPoolSize () {
	  return this._factory.max
	}

	Pool.prototype.getMinPoolSize = function getMinPoolSize () {
	  return this._factory.min
	}

	exports.Pool = Pool


/***/ },
/* 166 */
/*!**********************************!*\
  !*** ./~/object-assign/index.js ***!
  \**********************************/
/***/ function(module, exports) {

	'use strict';
	/* eslint-disable no-unused-vars */
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (e) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (Object.getOwnPropertySymbols) {
				symbols = Object.getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};


/***/ },
/* 167 */
/*!**********************************!*\
  !*** ./~/pg/lib/native/index.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2010-2016 Brian Carlson (brian.m.carlson@gmail.com)
	 * All rights reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * README.md file in the root directory of this source tree.
	 */

	var Native = __webpack_require__(/*! pg-native */ 168);
	var TypeOverrides = __webpack_require__(/*! ../type-overrides */ 140);
	var semver = __webpack_require__(/*! semver */ 169);
	var pkg = __webpack_require__(/*! ../../package.json */ 170);
	var assert = __webpack_require__(/*! assert */ 161);
	var EventEmitter = __webpack_require__(/*! events */ 26).EventEmitter;
	var util = __webpack_require__(/*! util */ 16);
	var ConnectionParameters = __webpack_require__(/*! ../connection-parameters */ 151);

	var msg = 'Version >= ' + pkg.minNativeVersion + ' of pg-native required.';
	assert(semver.gte(Native.version, pkg.minNativeVersion), msg);

	var NativeQuery = __webpack_require__(/*! ./query */ 171);

	var Client = module.exports = function(config) {
	  EventEmitter.call(this);
	  config = config || {};

	  this._types = new TypeOverrides(config.types);

	  this.native = new Native({
	    types: this._types
	  });

	  this._queryQueue = [];
	  this._connected = false;

	  //keep these on the object for legacy reasons
	  //for the time being. TODO: deprecate all this jazz
	  var cp = this.connectionParameters = new ConnectionParameters(config);
	  this.user = cp.user;
	  this.password = cp.password;
	  this.database = cp.database;
	  this.host = cp.host;
	  this.port = cp.port;

	  //a hash to hold named queries
	  this.namedQueries = {};
	};

	util.inherits(Client, EventEmitter);

	//connect to the backend
	//pass an optional callback to be called once connected
	//or with an error if there was a connection error
	//if no callback is passed and there is a connection error
	//the client will emit an error event.
	Client.prototype.connect = function(cb) {
	  var self = this;

	  var onError = function(err) {
	    if(cb) return cb(err);
	    return self.emit('error', err);
	  };

	  this.connectionParameters.getLibpqConnectionString(function(err, conString) {
	    if(err) return onError(err);
	    self.native.connect(conString, function(err) {
	      if(err) return onError(err);

	      //set internal states to connected
	      self._connected = true;

	      //handle connection errors from the native layer
	      self.native.on('error', function(err) {
	        //error will be handled by active query
	        if(self._activeQuery && self._activeQuery.state != 'end') {
	          return;
	        }
	        self.emit('error', err);
	      });

	      self.native.on('notification', function(msg) {
	        self.emit('notification', {
	          channel: msg.relname,
	          payload: msg.extra
	        });
	      });

	      //signal we are connected now
	      self.emit('connect');
	      self._pulseQueryQueue(true);

	      //possibly call the optional callback
	      if(cb) cb();
	    });
	  });
	};

	//send a query to the server
	//this method is highly overloaded to take
	//1) string query, optional array of parameters, optional function callback
	//2) object query with {
	//    string query
	//    optional array values,
	//    optional function callback instead of as a separate parameter
	//    optional string name to name & cache the query plan
	//    optional string rowMode = 'array' for an array of results
	//  }
	Client.prototype.query = function(config, values, callback) {
	  var query = new NativeQuery(this.native);

	  //support query('text', ...) style calls
	  if(typeof config == 'string') {
	    query.text = config;
	  }

	  //support passing everything in via a config object
	  if(typeof config == 'object') {
	    query.text = config.text;
	    query.values = config.values;
	    query.name = config.name;
	    query.callback = config.callback;
	    query._arrayMode = config.rowMode == 'array';
	  }

	  //support query({...}, function() {}) style calls
	  //& support query(..., ['values'], ...) style calls
	  if(typeof values == 'function') {
	    query.callback = values;
	  }
	  else if(util.isArray(values)) {
	    query.values = values;
	  }
	  if(typeof callback == 'function') {
	    query.callback = callback;
	  }

	  this._queryQueue.push(query);
	  this._pulseQueryQueue();
	  return query;
	};

	//disconnect from the backend server
	Client.prototype.end = function(cb) {
	  var self = this;
	  if(!this._connected) {
	    this.once('connect', this.end.bind(this, cb));
	  }
	  this.native.end(function() {
	    //send an error to the active query
	    if(self._hasActiveQuery()) {
	      var msg = 'Connection terminated';
	      self._queryQueue.length = 0;
	      self._activeQuery.handleError(new Error(msg));
	    }
	    self.emit('end');
	    if(cb) cb();
	  });
	};

	Client.prototype._hasActiveQuery = function() {
	  return this._activeQuery && this._activeQuery.state != 'error' && this._activeQuery.state != 'end';
	};

	Client.prototype._pulseQueryQueue = function(initialConnection) {
	  if(!this._connected) {
	    return;
	  }
	  if(this._hasActiveQuery()) {
	    return;
	  }
	  var query = this._queryQueue.shift();
	  if(!query) {
	    if(!initialConnection) {
	      this.emit('drain');
	    }
	    return;
	  }
	  this._activeQuery = query;
	  query.submit(this);
	  var self = this;
	  query.once('_done', function() {
	    self._pulseQueryQueue();
	  });
	};

	//attempt to cancel an in-progress query
	Client.prototype.cancel = function(query) {
	  if(this._activeQuery == query) {
	    this.native.cancel(function() {});
	  } else if (this._queryQueue.indexOf(query) != -1) {
	    this._queryQueue.splice(this._queryQueue.indexOf(query), 1);
	  }
	};

	Client.prototype.setTypeParser = function(oid, format, parseFn) {
	  return this._types.setTypeParser(oid, format, parseFn);
	};

	Client.prototype.getTypeParser = function(oid, format) {
	  return this._types.getTypeParser(oid, format);
	};


/***/ },
/* 168 */
/*!****************************!*\
  !*** external "pg-native" ***!
  \****************************/
/***/ function(module, exports) {

	module.exports = require("pg-native");

/***/ },
/* 169 */
/*!*********************************!*\
  !*** ./~/pg/~/semver/semver.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;// export the class if we are in a Node-like system.
	if (typeof module === 'object' && module.exports === exports)
	  exports = module.exports = SemVer;

	// The debug function is excluded entirely from the minified version.
	/* nomin */ var debug;
	/* nomin */ if (typeof process === 'object' &&
	    /* nomin */ process.env &&
	    /* nomin */ process.env.NODE_DEBUG &&
	    /* nomin */ /\bsemver\b/i.test(process.env.NODE_DEBUG))
	  /* nomin */ debug = function() {
	    /* nomin */ var args = Array.prototype.slice.call(arguments, 0);
	    /* nomin */ args.unshift('SEMVER');
	    /* nomin */ console.log.apply(console, args);
	    /* nomin */ };
	/* nomin */ else
	  /* nomin */ debug = function() {};

	// Note: this is the semver.org version of the spec that it implements
	// Not necessarily the package version of this code.
	exports.SEMVER_SPEC_VERSION = '2.0.0';

	var MAX_LENGTH = 256;
	var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;

	// The actual regexps go on exports.re
	var re = exports.re = [];
	var src = exports.src = [];
	var R = 0;

	// The following Regular Expressions can be used for tokenizing,
	// validating, and parsing SemVer version strings.

	// ## Numeric Identifier
	// A single `0`, or a non-zero digit followed by zero or more digits.

	var NUMERICIDENTIFIER = R++;
	src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
	var NUMERICIDENTIFIERLOOSE = R++;
	src[NUMERICIDENTIFIERLOOSE] = '[0-9]+';


	// ## Non-numeric Identifier
	// Zero or more digits, followed by a letter or hyphen, and then zero or
	// more letters, digits, or hyphens.

	var NONNUMERICIDENTIFIER = R++;
	src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';


	// ## Main Version
	// Three dot-separated numeric identifiers.

	var MAINVERSION = R++;
	src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
	                   '(' + src[NUMERICIDENTIFIER] + ')\\.' +
	                   '(' + src[NUMERICIDENTIFIER] + ')';

	var MAINVERSIONLOOSE = R++;
	src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
	                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
	                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')';

	// ## Pre-release Version Identifier
	// A numeric identifier, or a non-numeric identifier.

	var PRERELEASEIDENTIFIER = R++;
	src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
	                            '|' + src[NONNUMERICIDENTIFIER] + ')';

	var PRERELEASEIDENTIFIERLOOSE = R++;
	src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
	                                 '|' + src[NONNUMERICIDENTIFIER] + ')';


	// ## Pre-release Version
	// Hyphen, followed by one or more dot-separated pre-release version
	// identifiers.

	var PRERELEASE = R++;
	src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
	                  '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))';

	var PRERELEASELOOSE = R++;
	src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
	                       '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';

	// ## Build Metadata Identifier
	// Any combination of digits, letters, or hyphens.

	var BUILDIDENTIFIER = R++;
	src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';

	// ## Build Metadata
	// Plus sign, followed by one or more period-separated build metadata
	// identifiers.

	var BUILD = R++;
	src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
	             '(?:\\.' + src[BUILDIDENTIFIER] + ')*))';


	// ## Full Version String
	// A main version, followed optionally by a pre-release version and
	// build metadata.

	// Note that the only major, minor, patch, and pre-release sections of
	// the version string are capturing groups.  The build metadata is not a
	// capturing group, because it should not ever be used in version
	// comparison.

	var FULL = R++;
	var FULLPLAIN = 'v?' + src[MAINVERSION] +
	                src[PRERELEASE] + '?' +
	                src[BUILD] + '?';

	src[FULL] = '^' + FULLPLAIN + '$';

	// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
	// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
	// common in the npm registry.
	var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
	                 src[PRERELEASELOOSE] + '?' +
	                 src[BUILD] + '?';

	var LOOSE = R++;
	src[LOOSE] = '^' + LOOSEPLAIN + '$';

	var GTLT = R++;
	src[GTLT] = '((?:<|>)?=?)';

	// Something like "2.*" or "1.2.x".
	// Note that "x.x" is a valid xRange identifer, meaning "any version"
	// Only the first item is strictly required.
	var XRANGEIDENTIFIERLOOSE = R++;
	src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
	var XRANGEIDENTIFIER = R++;
	src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';

	var XRANGEPLAIN = R++;
	src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
	                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
	                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
	                   '(?:' + src[PRERELEASE] + ')?' +
	                   src[BUILD] + '?' +
	                   ')?)?';

	var XRANGEPLAINLOOSE = R++;
	src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
	                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
	                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
	                        '(?:' + src[PRERELEASELOOSE] + ')?' +
	                        src[BUILD] + '?' +
	                        ')?)?';

	var XRANGE = R++;
	src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
	var XRANGELOOSE = R++;
	src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$';

	// Tilde ranges.
	// Meaning is "reasonably at or greater than"
	var LONETILDE = R++;
	src[LONETILDE] = '(?:~>?)';

	var TILDETRIM = R++;
	src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
	re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
	var tildeTrimReplace = '$1~';

	var TILDE = R++;
	src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
	var TILDELOOSE = R++;
	src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';

	// Caret ranges.
	// Meaning is "at least and backwards compatible with"
	var LONECARET = R++;
	src[LONECARET] = '(?:\\^)';

	var CARETTRIM = R++;
	src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
	re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
	var caretTrimReplace = '$1^';

	var CARET = R++;
	src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
	var CARETLOOSE = R++;
	src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';

	// A simple gt/lt/eq thing, or just "" to indicate "any version"
	var COMPARATORLOOSE = R++;
	src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
	var COMPARATOR = R++;
	src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$';


	// An expression to strip any whitespace between the gtlt and the thing
	// it modifies, so that `> 1.2.3` ==> `>1.2.3`
	var COMPARATORTRIM = R++;
	src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
	                      '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';

	// this one has to use the /g flag
	re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
	var comparatorTrimReplace = '$1$2$3';


	// Something like `1.2.3 - 1.2.4`
	// Note that these all use the loose form, because they'll be
	// checked against either the strict or loose comparator form
	// later.
	var HYPHENRANGE = R++;
	src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
	                   '\\s+-\\s+' +
	                   '(' + src[XRANGEPLAIN] + ')' +
	                   '\\s*$';

	var HYPHENRANGELOOSE = R++;
	src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
	                        '\\s+-\\s+' +
	                        '(' + src[XRANGEPLAINLOOSE] + ')' +
	                        '\\s*$';

	// Star ranges basically just allow anything at all.
	var STAR = R++;
	src[STAR] = '(<|>)?=?\\s*\\*';

	// Compile to actual regexp objects.
	// All are flag-free, unless they were created above with a flag.
	for (var i = 0; i < R; i++) {
	  debug(i, src[i]);
	  if (!re[i])
	    re[i] = new RegExp(src[i]);
	}

	exports.parse = parse;
	function parse(version, loose) {
	  if (version.length > MAX_LENGTH)
	    return null;

	  var r = loose ? re[LOOSE] : re[FULL];
	  if (!r.test(version))
	    return null;

	  try {
	    return new SemVer(version, loose);
	  } catch (er) {
	    return null;
	  }
	}

	exports.valid = valid;
	function valid(version, loose) {
	  var v = parse(version, loose);
	  return v ? v.version : null;
	}


	exports.clean = clean;
	function clean(version, loose) {
	  var s = parse(version.trim().replace(/^[=v]+/, ''), loose);
	  return s ? s.version : null;
	}

	exports.SemVer = SemVer;

	function SemVer(version, loose) {
	  if (version instanceof SemVer) {
	    if (version.loose === loose)
	      return version;
	    else
	      version = version.version;
	  } else if (typeof version !== 'string') {
	    throw new TypeError('Invalid Version: ' + version);
	  }

	  if (version.length > MAX_LENGTH)
	    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')

	  if (!(this instanceof SemVer))
	    return new SemVer(version, loose);

	  debug('SemVer', version, loose);
	  this.loose = loose;
	  var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);

	  if (!m)
	    throw new TypeError('Invalid Version: ' + version);

	  this.raw = version;

	  // these are actually numbers
	  this.major = +m[1];
	  this.minor = +m[2];
	  this.patch = +m[3];

	  if (this.major > MAX_SAFE_INTEGER || this.major < 0)
	    throw new TypeError('Invalid major version')

	  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)
	    throw new TypeError('Invalid minor version')

	  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)
	    throw new TypeError('Invalid patch version')

	  // numberify any prerelease numeric ids
	  if (!m[4])
	    this.prerelease = [];
	  else
	    this.prerelease = m[4].split('.').map(function(id) {
	      return (/^[0-9]+$/.test(id)) ? +id : id;
	    });

	  this.build = m[5] ? m[5].split('.') : [];
	  this.format();
	}

	SemVer.prototype.format = function() {
	  this.version = this.major + '.' + this.minor + '.' + this.patch;
	  if (this.prerelease.length)
	    this.version += '-' + this.prerelease.join('.');
	  return this.version;
	};

	SemVer.prototype.inspect = function() {
	  return '<SemVer "' + this + '">';
	};

	SemVer.prototype.toString = function() {
	  return this.version;
	};

	SemVer.prototype.compare = function(other) {
	  debug('SemVer.compare', this.version, this.loose, other);
	  if (!(other instanceof SemVer))
	    other = new SemVer(other, this.loose);

	  return this.compareMain(other) || this.comparePre(other);
	};

	SemVer.prototype.compareMain = function(other) {
	  if (!(other instanceof SemVer))
	    other = new SemVer(other, this.loose);

	  return compareIdentifiers(this.major, other.major) ||
	         compareIdentifiers(this.minor, other.minor) ||
	         compareIdentifiers(this.patch, other.patch);
	};

	SemVer.prototype.comparePre = function(other) {
	  if (!(other instanceof SemVer))
	    other = new SemVer(other, this.loose);

	  // NOT having a prerelease is > having one
	  if (this.prerelease.length && !other.prerelease.length)
	    return -1;
	  else if (!this.prerelease.length && other.prerelease.length)
	    return 1;
	  else if (!this.prerelease.length && !other.prerelease.length)
	    return 0;

	  var i = 0;
	  do {
	    var a = this.prerelease[i];
	    var b = other.prerelease[i];
	    debug('prerelease compare', i, a, b);
	    if (a === undefined && b === undefined)
	      return 0;
	    else if (b === undefined)
	      return 1;
	    else if (a === undefined)
	      return -1;
	    else if (a === b)
	      continue;
	    else
	      return compareIdentifiers(a, b);
	  } while (++i);
	};

	// preminor will bump the version up to the next minor release, and immediately
	// down to pre-release. premajor and prepatch work the same way.
	SemVer.prototype.inc = function(release, identifier) {
	  switch (release) {
	    case 'premajor':
	      this.prerelease.length = 0;
	      this.patch = 0;
	      this.minor = 0;
	      this.major++;
	      this.inc('pre', identifier);
	      break;
	    case 'preminor':
	      this.prerelease.length = 0;
	      this.patch = 0;
	      this.minor++;
	      this.inc('pre', identifier);
	      break;
	    case 'prepatch':
	      // If this is already a prerelease, it will bump to the next version
	      // drop any prereleases that might already exist, since they are not
	      // relevant at this point.
	      this.prerelease.length = 0;
	      this.inc('patch', identifier);
	      this.inc('pre', identifier);
	      break;
	    // If the input is a non-prerelease version, this acts the same as
	    // prepatch.
	    case 'prerelease':
	      if (this.prerelease.length === 0)
	        this.inc('patch', identifier);
	      this.inc('pre', identifier);
	      break;

	    case 'major':
	      // If this is a pre-major version, bump up to the same major version.
	      // Otherwise increment major.
	      // 1.0.0-5 bumps to 1.0.0
	      // 1.1.0 bumps to 2.0.0
	      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)
	        this.major++;
	      this.minor = 0;
	      this.patch = 0;
	      this.prerelease = [];
	      break;
	    case 'minor':
	      // If this is a pre-minor version, bump up to the same minor version.
	      // Otherwise increment minor.
	      // 1.2.0-5 bumps to 1.2.0
	      // 1.2.1 bumps to 1.3.0
	      if (this.patch !== 0 || this.prerelease.length === 0)
	        this.minor++;
	      this.patch = 0;
	      this.prerelease = [];
	      break;
	    case 'patch':
	      // If this is not a pre-release version, it will increment the patch.
	      // If it is a pre-release it will bump up to the same patch version.
	      // 1.2.0-5 patches to 1.2.0
	      // 1.2.0 patches to 1.2.1
	      if (this.prerelease.length === 0)
	        this.patch++;
	      this.prerelease = [];
	      break;
	    // This probably shouldn't be used publicly.
	    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
	    case 'pre':
	      if (this.prerelease.length === 0)
	        this.prerelease = [0];
	      else {
	        var i = this.prerelease.length;
	        while (--i >= 0) {
	          if (typeof this.prerelease[i] === 'number') {
	            this.prerelease[i]++;
	            i = -2;
	          }
	        }
	        if (i === -1) // didn't increment anything
	          this.prerelease.push(0);
	      }
	      if (identifier) {
	        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
	        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
	        if (this.prerelease[0] === identifier) {
	          if (isNaN(this.prerelease[1]))
	            this.prerelease = [identifier, 0];
	        } else
	          this.prerelease = [identifier, 0];
	      }
	      break;

	    default:
	      throw new Error('invalid increment argument: ' + release);
	  }
	  this.format();
	  return this;
	};

	exports.inc = inc;
	function inc(version, release, loose, identifier) {
	  if (typeof(loose) === 'string') {
	    identifier = loose;
	    loose = undefined;
	  }

	  try {
	    return new SemVer(version, loose).inc(release, identifier).version;
	  } catch (er) {
	    return null;
	  }
	}

	exports.diff = diff;
	function diff(version1, version2) {
	  if (eq(version1, version2)) {
	    return null;
	  } else {
	    var v1 = parse(version1);
	    var v2 = parse(version2);
	    if (v1.prerelease.length || v2.prerelease.length) {
	      for (var key in v1) {
	        if (key === 'major' || key === 'minor' || key === 'patch') {
	          if (v1[key] !== v2[key]) {
	            return 'pre'+key;
	          }
	        }
	      }
	      return 'prerelease';
	    }
	    for (var key in v1) {
	      if (key === 'major' || key === 'minor' || key === 'patch') {
	        if (v1[key] !== v2[key]) {
	          return key;
	        }
	      }
	    }
	  }
	}

	exports.compareIdentifiers = compareIdentifiers;

	var numeric = /^[0-9]+$/;
	function compareIdentifiers(a, b) {
	  var anum = numeric.test(a);
	  var bnum = numeric.test(b);

	  if (anum && bnum) {
	    a = +a;
	    b = +b;
	  }

	  return (anum && !bnum) ? -1 :
	         (bnum && !anum) ? 1 :
	         a < b ? -1 :
	         a > b ? 1 :
	         0;
	}

	exports.rcompareIdentifiers = rcompareIdentifiers;
	function rcompareIdentifiers(a, b) {
	  return compareIdentifiers(b, a);
	}

	exports.major = major;
	function major(a, loose) {
	  return new SemVer(a, loose).major;
	}

	exports.minor = minor;
	function minor(a, loose) {
	  return new SemVer(a, loose).minor;
	}

	exports.patch = patch;
	function patch(a, loose) {
	  return new SemVer(a, loose).patch;
	}

	exports.compare = compare;
	function compare(a, b, loose) {
	  return new SemVer(a, loose).compare(b);
	}

	exports.compareLoose = compareLoose;
	function compareLoose(a, b) {
	  return compare(a, b, true);
	}

	exports.rcompare = rcompare;
	function rcompare(a, b, loose) {
	  return compare(b, a, loose);
	}

	exports.sort = sort;
	function sort(list, loose) {
	  return list.sort(function(a, b) {
	    return exports.compare(a, b, loose);
	  });
	}

	exports.rsort = rsort;
	function rsort(list, loose) {
	  return list.sort(function(a, b) {
	    return exports.rcompare(a, b, loose);
	  });
	}

	exports.gt = gt;
	function gt(a, b, loose) {
	  return compare(a, b, loose) > 0;
	}

	exports.lt = lt;
	function lt(a, b, loose) {
	  return compare(a, b, loose) < 0;
	}

	exports.eq = eq;
	function eq(a, b, loose) {
	  return compare(a, b, loose) === 0;
	}

	exports.neq = neq;
	function neq(a, b, loose) {
	  return compare(a, b, loose) !== 0;
	}

	exports.gte = gte;
	function gte(a, b, loose) {
	  return compare(a, b, loose) >= 0;
	}

	exports.lte = lte;
	function lte(a, b, loose) {
	  return compare(a, b, loose) <= 0;
	}

	exports.cmp = cmp;
	function cmp(a, op, b, loose) {
	  var ret;
	  switch (op) {
	    case '===':
	      if (typeof a === 'object') a = a.version;
	      if (typeof b === 'object') b = b.version;
	      ret = a === b;
	      break;
	    case '!==':
	      if (typeof a === 'object') a = a.version;
	      if (typeof b === 'object') b = b.version;
	      ret = a !== b;
	      break;
	    case '': case '=': case '==': ret = eq(a, b, loose); break;
	    case '!=': ret = neq(a, b, loose); break;
	    case '>': ret = gt(a, b, loose); break;
	    case '>=': ret = gte(a, b, loose); break;
	    case '<': ret = lt(a, b, loose); break;
	    case '<=': ret = lte(a, b, loose); break;
	    default: throw new TypeError('Invalid operator: ' + op);
	  }
	  return ret;
	}

	exports.Comparator = Comparator;
	function Comparator(comp, loose) {
	  if (comp instanceof Comparator) {
	    if (comp.loose === loose)
	      return comp;
	    else
	      comp = comp.value;
	  }

	  if (!(this instanceof Comparator))
	    return new Comparator(comp, loose);

	  debug('comparator', comp, loose);
	  this.loose = loose;
	  this.parse(comp);

	  if (this.semver === ANY)
	    this.value = '';
	  else
	    this.value = this.operator + this.semver.version;

	  debug('comp', this);
	}

	var ANY = {};
	Comparator.prototype.parse = function(comp) {
	  var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
	  var m = comp.match(r);

	  if (!m)
	    throw new TypeError('Invalid comparator: ' + comp);

	  this.operator = m[1];
	  if (this.operator === '=')
	    this.operator = '';

	  // if it literally is just '>' or '' then allow anything.
	  if (!m[2])
	    this.semver = ANY;
	  else
	    this.semver = new SemVer(m[2], this.loose);
	};

	Comparator.prototype.inspect = function() {
	  return '<SemVer Comparator "' + this + '">';
	};

	Comparator.prototype.toString = function() {
	  return this.value;
	};

	Comparator.prototype.test = function(version) {
	  debug('Comparator.test', version, this.loose);

	  if (this.semver === ANY)
	    return true;

	  if (typeof version === 'string')
	    version = new SemVer(version, this.loose);

	  return cmp(version, this.operator, this.semver, this.loose);
	};


	exports.Range = Range;
	function Range(range, loose) {
	  if ((range instanceof Range) && range.loose === loose)
	    return range;

	  if (!(this instanceof Range))
	    return new Range(range, loose);

	  this.loose = loose;

	  // First, split based on boolean or ||
	  this.raw = range;
	  this.set = range.split(/\s*\|\|\s*/).map(function(range) {
	    return this.parseRange(range.trim());
	  }, this).filter(function(c) {
	    // throw out any that are not relevant for whatever reason
	    return c.length;
	  });

	  if (!this.set.length) {
	    throw new TypeError('Invalid SemVer Range: ' + range);
	  }

	  this.format();
	}

	Range.prototype.inspect = function() {
	  return '<SemVer Range "' + this.range + '">';
	};

	Range.prototype.format = function() {
	  this.range = this.set.map(function(comps) {
	    return comps.join(' ').trim();
	  }).join('||').trim();
	  return this.range;
	};

	Range.prototype.toString = function() {
	  return this.range;
	};

	Range.prototype.parseRange = function(range) {
	  var loose = this.loose;
	  range = range.trim();
	  debug('range', range, loose);
	  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
	  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
	  range = range.replace(hr, hyphenReplace);
	  debug('hyphen replace', range);
	  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
	  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
	  debug('comparator trim', range, re[COMPARATORTRIM]);

	  // `~ 1.2.3` => `~1.2.3`
	  range = range.replace(re[TILDETRIM], tildeTrimReplace);

	  // `^ 1.2.3` => `^1.2.3`
	  range = range.replace(re[CARETTRIM], caretTrimReplace);

	  // normalize spaces
	  range = range.split(/\s+/).join(' ');

	  // At this point, the range is completely trimmed and
	  // ready to be split into comparators.

	  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
	  var set = range.split(' ').map(function(comp) {
	    return parseComparator(comp, loose);
	  }).join(' ').split(/\s+/);
	  if (this.loose) {
	    // in loose mode, throw out any that are not valid comparators
	    set = set.filter(function(comp) {
	      return !!comp.match(compRe);
	    });
	  }
	  set = set.map(function(comp) {
	    return new Comparator(comp, loose);
	  });

	  return set;
	};

	// Mostly just for testing and legacy API reasons
	exports.toComparators = toComparators;
	function toComparators(range, loose) {
	  return new Range(range, loose).set.map(function(comp) {
	    return comp.map(function(c) {
	      return c.value;
	    }).join(' ').trim().split(' ');
	  });
	}

	// comprised of xranges, tildes, stars, and gtlt's at this point.
	// already replaced the hyphen ranges
	// turn into a set of JUST comparators.
	function parseComparator(comp, loose) {
	  debug('comp', comp);
	  comp = replaceCarets(comp, loose);
	  debug('caret', comp);
	  comp = replaceTildes(comp, loose);
	  debug('tildes', comp);
	  comp = replaceXRanges(comp, loose);
	  debug('xrange', comp);
	  comp = replaceStars(comp, loose);
	  debug('stars', comp);
	  return comp;
	}

	function isX(id) {
	  return !id || id.toLowerCase() === 'x' || id === '*';
	}

	// ~, ~> --> * (any, kinda silly)
	// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
	// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
	// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
	// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
	// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
	function replaceTildes(comp, loose) {
	  return comp.trim().split(/\s+/).map(function(comp) {
	    return replaceTilde(comp, loose);
	  }).join(' ');
	}

	function replaceTilde(comp, loose) {
	  var r = loose ? re[TILDELOOSE] : re[TILDE];
	  return comp.replace(r, function(_, M, m, p, pr) {
	    debug('tilde', comp, _, M, m, p, pr);
	    var ret;

	    if (isX(M))
	      ret = '';
	    else if (isX(m))
	      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
	    else if (isX(p))
	      // ~1.2 == >=1.2.0- <1.3.0-
	      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
	    else if (pr) {
	      debug('replaceTilde pr', pr);
	      if (pr.charAt(0) !== '-')
	        pr = '-' + pr;
	      ret = '>=' + M + '.' + m + '.' + p + pr +
	            ' <' + M + '.' + (+m + 1) + '.0';
	    } else
	      // ~1.2.3 == >=1.2.3 <1.3.0
	      ret = '>=' + M + '.' + m + '.' + p +
	            ' <' + M + '.' + (+m + 1) + '.0';

	    debug('tilde return', ret);
	    return ret;
	  });
	}

	// ^ --> * (any, kinda silly)
	// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
	// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
	// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
	// ^1.2.3 --> >=1.2.3 <2.0.0
	// ^1.2.0 --> >=1.2.0 <2.0.0
	function replaceCarets(comp, loose) {
	  return comp.trim().split(/\s+/).map(function(comp) {
	    return replaceCaret(comp, loose);
	  }).join(' ');
	}

	function replaceCaret(comp, loose) {
	  debug('caret', comp, loose);
	  var r = loose ? re[CARETLOOSE] : re[CARET];
	  return comp.replace(r, function(_, M, m, p, pr) {
	    debug('caret', comp, _, M, m, p, pr);
	    var ret;

	    if (isX(M))
	      ret = '';
	    else if (isX(m))
	      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
	    else if (isX(p)) {
	      if (M === '0')
	        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
	      else
	        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
	    } else if (pr) {
	      debug('replaceCaret pr', pr);
	      if (pr.charAt(0) !== '-')
	        pr = '-' + pr;
	      if (M === '0') {
	        if (m === '0')
	          ret = '>=' + M + '.' + m + '.' + p + pr +
	                ' <' + M + '.' + m + '.' + (+p + 1);
	        else
	          ret = '>=' + M + '.' + m + '.' + p + pr +
	                ' <' + M + '.' + (+m + 1) + '.0';
	      } else
	        ret = '>=' + M + '.' + m + '.' + p + pr +
	              ' <' + (+M + 1) + '.0.0';
	    } else {
	      debug('no pr');
	      if (M === '0') {
	        if (m === '0')
	          ret = '>=' + M + '.' + m + '.' + p +
	                ' <' + M + '.' + m + '.' + (+p + 1);
	        else
	          ret = '>=' + M + '.' + m + '.' + p +
	                ' <' + M + '.' + (+m + 1) + '.0';
	      } else
	        ret = '>=' + M + '.' + m + '.' + p +
	              ' <' + (+M + 1) + '.0.0';
	    }

	    debug('caret return', ret);
	    return ret;
	  });
	}

	function replaceXRanges(comp, loose) {
	  debug('replaceXRanges', comp, loose);
	  return comp.split(/\s+/).map(function(comp) {
	    return replaceXRange(comp, loose);
	  }).join(' ');
	}

	function replaceXRange(comp, loose) {
	  comp = comp.trim();
	  var r = loose ? re[XRANGELOOSE] : re[XRANGE];
	  return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
	    debug('xRange', comp, ret, gtlt, M, m, p, pr);
	    var xM = isX(M);
	    var xm = xM || isX(m);
	    var xp = xm || isX(p);
	    var anyX = xp;

	    if (gtlt === '=' && anyX)
	      gtlt = '';

	    if (xM) {
	      if (gtlt === '>' || gtlt === '<') {
	        // nothing is allowed
	        ret = '<0.0.0';
	      } else {
	        // nothing is forbidden
	        ret = '*';
	      }
	    } else if (gtlt && anyX) {
	      // replace X with 0
	      if (xm)
	        m = 0;
	      if (xp)
	        p = 0;

	      if (gtlt === '>') {
	        // >1 => >=2.0.0
	        // >1.2 => >=1.3.0
	        // >1.2.3 => >= 1.2.4
	        gtlt = '>=';
	        if (xm) {
	          M = +M + 1;
	          m = 0;
	          p = 0;
	        } else if (xp) {
	          m = +m + 1;
	          p = 0;
	        }
	      } else if (gtlt === '<=') {
	        // <=0.7.x is actually <0.8.0, since any 0.7.x should
	        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
	        gtlt = '<'
	        if (xm)
	          M = +M + 1
	        else
	          m = +m + 1
	      }

	      ret = gtlt + M + '.' + m + '.' + p;
	    } else if (xm) {
	      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
	    } else if (xp) {
	      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
	    }

	    debug('xRange return', ret);

	    return ret;
	  });
	}

	// Because * is AND-ed with everything else in the comparator,
	// and '' means "any version", just remove the *s entirely.
	function replaceStars(comp, loose) {
	  debug('replaceStars', comp, loose);
	  // Looseness is ignored here.  star is always as loose as it gets!
	  return comp.trim().replace(re[STAR], '');
	}

	// This function is passed to string.replace(re[HYPHENRANGE])
	// M, m, patch, prerelease, build
	// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
	// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
	// 1.2 - 3.4 => >=1.2.0 <3.5.0
	function hyphenReplace($0,
	                       from, fM, fm, fp, fpr, fb,
	                       to, tM, tm, tp, tpr, tb) {

	  if (isX(fM))
	    from = '';
	  else if (isX(fm))
	    from = '>=' + fM + '.0.0';
	  else if (isX(fp))
	    from = '>=' + fM + '.' + fm + '.0';
	  else
	    from = '>=' + from;

	  if (isX(tM))
	    to = '';
	  else if (isX(tm))
	    to = '<' + (+tM + 1) + '.0.0';
	  else if (isX(tp))
	    to = '<' + tM + '.' + (+tm + 1) + '.0';
	  else if (tpr)
	    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
	  else
	    to = '<=' + to;

	  return (from + ' ' + to).trim();
	}


	// if ANY of the sets match ALL of its comparators, then pass
	Range.prototype.test = function(version) {
	  if (!version)
	    return false;

	  if (typeof version === 'string')
	    version = new SemVer(version, this.loose);

	  for (var i = 0; i < this.set.length; i++) {
	    if (testSet(this.set[i], version))
	      return true;
	  }
	  return false;
	};

	function testSet(set, version) {
	  for (var i = 0; i < set.length; i++) {
	    if (!set[i].test(version))
	      return false;
	  }

	  if (version.prerelease.length) {
	    // Find the set of versions that are allowed to have prereleases
	    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
	    // That should allow `1.2.3-pr.2` to pass.
	    // However, `1.2.4-alpha.notready` should NOT be allowed,
	    // even though it's within the range set by the comparators.
	    for (var i = 0; i < set.length; i++) {
	      debug(set[i].semver);
	      if (set[i].semver === ANY)
	        return true;

	      if (set[i].semver.prerelease.length > 0) {
	        var allowed = set[i].semver;
	        if (allowed.major === version.major &&
	            allowed.minor === version.minor &&
	            allowed.patch === version.patch)
	          return true;
	      }
	    }

	    // Version has a -pre, but it's not one of the ones we like.
	    return false;
	  }

	  return true;
	}

	exports.satisfies = satisfies;
	function satisfies(version, range, loose) {
	  try {
	    range = new Range(range, loose);
	  } catch (er) {
	    return false;
	  }
	  return range.test(version);
	}

	exports.maxSatisfying = maxSatisfying;
	function maxSatisfying(versions, range, loose) {
	  return versions.filter(function(version) {
	    return satisfies(version, range, loose);
	  }).sort(function(a, b) {
	    return rcompare(a, b, loose);
	  })[0] || null;
	}

	exports.validRange = validRange;
	function validRange(range, loose) {
	  try {
	    // Return '*' instead of '' so that truthiness works.
	    // This will throw if it's invalid anyway
	    return new Range(range, loose).range || '*';
	  } catch (er) {
	    return null;
	  }
	}

	// Determine if version is less than all the versions possible in the range
	exports.ltr = ltr;
	function ltr(version, range, loose) {
	  return outside(version, range, '<', loose);
	}

	// Determine if version is greater than all the versions possible in the range.
	exports.gtr = gtr;
	function gtr(version, range, loose) {
	  return outside(version, range, '>', loose);
	}

	exports.outside = outside;
	function outside(version, range, hilo, loose) {
	  version = new SemVer(version, loose);
	  range = new Range(range, loose);

	  var gtfn, ltefn, ltfn, comp, ecomp;
	  switch (hilo) {
	    case '>':
	      gtfn = gt;
	      ltefn = lte;
	      ltfn = lt;
	      comp = '>';
	      ecomp = '>=';
	      break;
	    case '<':
	      gtfn = lt;
	      ltefn = gte;
	      ltfn = gt;
	      comp = '<';
	      ecomp = '<=';
	      break;
	    default:
	      throw new TypeError('Must provide a hilo val of "<" or ">"');
	  }

	  // If it satisifes the range it is not outside
	  if (satisfies(version, range, loose)) {
	    return false;
	  }

	  // From now on, variable terms are as if we're in "gtr" mode.
	  // but note that everything is flipped for the "ltr" function.

	  for (var i = 0; i < range.set.length; ++i) {
	    var comparators = range.set[i];

	    var high = null;
	    var low = null;

	    comparators.forEach(function(comparator) {
	      high = high || comparator;
	      low = low || comparator;
	      if (gtfn(comparator.semver, high.semver, loose)) {
	        high = comparator;
	      } else if (ltfn(comparator.semver, low.semver, loose)) {
	        low = comparator;
	      }
	    });

	    // If the edge version comparator has a operator then our version
	    // isn't outside it
	    if (high.operator === comp || high.operator === ecomp) {
	      return false;
	    }

	    // If the lowest version comparator has an operator and our version
	    // is less than it then it isn't higher than the range
	    if ((!low.operator || low.operator === comp) &&
	        ltefn(version, low.semver)) {
	      return false;
	    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
	      return false;
	    }
	  }
	  return true;
	}

	// Use the define() function if we're in AMD land
	if (true)
	  !(__WEBPACK_AMD_DEFINE_FACTORY__ = (exports), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 170 */
/*!***************************!*\
  !*** ./~/pg/package.json ***!
  \***************************/
/***/ function(module, exports) {

	module.exports = {
		"_args": [
			[
				{
					"raw": "pg@^6",
					"scope": null,
					"escapedName": "pg",
					"name": "pg",
					"rawSpec": "^6",
					"spec": ">=6.0.0 <7.0.0",
					"type": "range"
				},
				"/home/phil/git-repos/personal/weather-accuracy/node_modules/node-helpers"
			]
		],
		"_from": "pg@>=6.0.0 <7.0.0",
		"_id": "pg@6.1.0",
		"_inCache": true,
		"_location": "/pg",
		"_nodeVersion": "6.2.1",
		"_npmOperationalInternal": {
			"host": "packages-16-east.internal.npmjs.com",
			"tmp": "tmp/pg-6.1.0.tgz_1470928707731_0.8180370621848851"
		},
		"_npmUser": {
			"name": "brianc",
			"email": "brian.m.carlson@gmail.com"
		},
		"_npmVersion": "3.9.3",
		"_phantomChildren": {},
		"_requested": {
			"raw": "pg@^6",
			"scope": null,
			"escapedName": "pg",
			"name": "pg",
			"rawSpec": "^6",
			"spec": ">=6.0.0 <7.0.0",
			"type": "range"
		},
		"_requiredBy": [
			"/node-helpers"
		],
		"_resolved": "https://registry.npmjs.org/pg/-/pg-6.1.0.tgz",
		"_shasum": "4ebc58100a79187b6b98fa5caf1675d669926b41",
		"_shrinkwrap": null,
		"_spec": "pg@^6",
		"_where": "/home/phil/git-repos/personal/weather-accuracy/node_modules/node-helpers",
		"author": {
			"name": "Brian Carlson",
			"email": "brian.m.carlson@gmail.com"
		},
		"bugs": {
			"url": "https://github.com/brianc/node-postgres/issues"
		},
		"dependencies": {
			"buffer-writer": "1.0.1",
			"packet-reader": "0.2.0",
			"pg-connection-string": "0.1.3",
			"pg-pool": "1.*",
			"pg-types": "1.*",
			"pgpass": "1.x",
			"semver": "4.3.2"
		},
		"description": "PostgreSQL client - pure javascript & libpq with the same API",
		"devDependencies": {
			"async": "0.9.0",
			"co": "4.6.0",
			"jshint": "2.5.2",
			"lodash": "4.13.1",
			"pg-copy-streams": "0.3.0",
			"promise-polyfill": "5.2.1"
		},
		"directories": {},
		"dist": {
			"shasum": "4ebc58100a79187b6b98fa5caf1675d669926b41",
			"tarball": "https://registry.npmjs.org/pg/-/pg-6.1.0.tgz"
		},
		"engines": {
			"node": ">= 0.8.0"
		},
		"gitHead": "42689dac11a199d4c93dda7f219efbb2b0a830e4",
		"homepage": "http://github.com/brianc/node-postgres",
		"keywords": [
			"postgres",
			"pg",
			"libpq",
			"postgre",
			"database",
			"rdbms"
		],
		"license": "MIT",
		"main": "./lib",
		"maintainers": [
			{
				"name": "brianc",
				"email": "brian.m.carlson@gmail.com"
			}
		],
		"minNativeVersion": "1.7.0",
		"name": "pg",
		"optionalDependencies": {},
		"readme": "ERROR: No README data found!",
		"repository": {
			"type": "git",
			"url": "git://github.com/brianc/node-postgres.git"
		},
		"scripts": {
			"changelog": "npm i github-changes && ./node_modules/.bin/github-changes -o brianc -r node-postgres -d pulls -a -v",
			"test": "make test-all connectionString=postgres://postgres@localhost:5432/postgres"
		},
		"version": "6.1.0"
	};

/***/ },
/* 171 */
/*!**********************************!*\
  !*** ./~/pg/lib/native/query.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2010-2016 Brian Carlson (brian.m.carlson@gmail.com)
	 * All rights reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * README.md file in the root directory of this source tree.
	 */

	var EventEmitter = __webpack_require__(/*! events */ 26).EventEmitter;
	var util = __webpack_require__(/*! util */ 16);
	var utils = __webpack_require__(/*! ../utils */ 157);
	var NativeResult = __webpack_require__(/*! ./result */ 172);

	var NativeQuery = module.exports = function(native) {
	  EventEmitter.call(this);
	  this.native = native;
	  this.text = null;
	  this.values = null;
	  this.name = null;
	  this.callback = null;
	  this.state = 'new';
	  this._arrayMode = false;

	  //if the 'row' event is listened for
	  //then emit them as they come in
	  //without setting singleRowMode to true
	  //this has almost no meaning because libpq
	  //reads all rows into memory befor returning any
	  this._emitRowEvents = false;
	  this.on('newListener', function(event) {
	    if(event === 'row') this._emitRowEvents = true;
	  }.bind(this));
	};

	util.inherits(NativeQuery, EventEmitter);

	NativeQuery.prototype.then = function(onSuccess, onFailure) {
	  return this.promise().then(onSuccess, onFailure);
	};

	NativeQuery.prototype.catch = function(callback) {
	  return this.promise().catch(callback);
	};

	NativeQuery.prototype.promise = function() {
	  if (this._promise) return this._promise;
	  this._promise = new Promise(function(resolve, reject) {
	    this.once('end', resolve);
	    this.once('error', reject);
	  }.bind(this));
	  return this._promise;
	};

	NativeQuery.prototype.handleError = function(err) {
	  var self = this;
	  //copy pq error fields into the error object
	  var fields = self.native.pq.resultErrorFields();
	  if(fields) {
	    for(var key in fields) {
	      err[key] = fields[key];
	    }
	  }
	  if(self.callback) {
	    self.callback(err);
	  } else {
	    self.emit('error', err);
	  }
	  self.state = 'error';
	};

	NativeQuery.prototype.submit = function(client) {
	  this.state = 'running';
	  var self = this;
	  client.native.arrayMode = this._arrayMode;

	  var after = function(err, rows) {
	    client.native.arrayMode = false;
	    setImmediate(function() {
	      self.emit('_done');
	    });

	    //handle possible query error
	    if(err) {
	      return self.handleError(err);
	    }

	    var result = new NativeResult();
	    result.addCommandComplete(self.native.pq);
	    result.rows = rows;

	    //emit row events for each row in the result
	    if(self._emitRowEvents) {
	      rows.forEach(function(row) {
	        self.emit('row', row, result);
	      });
	    }


	    //handle successful result
	    self.state = 'end';
	    self.emit('end', result);
	    if(self.callback) {
	      self.callback(null, result);
	    }
	  };

	  if(process.domain) {
	    after = process.domain.bind(after);
	  }

	  //named query
	  if(this.name) {
	    if (this.name.length > 63) {
	      console.error('Warning! Postgres only supports 63 characters for query names.');
	      console.error('You supplied', this.name, '(', this.name.length, ')');
	      console.error('This can cause conflicts and silent errors executing queries');
	    }
	    var values = (this.values||[]).map(utils.prepareValue);

	    //check if the client has already executed this named query
	    //if so...just execute it again - skip the planning phase
	    if(client.namedQueries[this.name]) {
	      return this.native.execute(this.name, values, after);
	    }
	    //plan the named query the first time, then execute it
	    return this.native.prepare(this.name, this.text, values.length, function(err) {
	      if(err) return after(err);
	      client.namedQueries[self.name] = true;
	      return self.native.execute(self.name, values, after);
	    });
	  }
	  else if(this.values) {
	    var vals = this.values.map(utils.prepareValue);
	    this.native.query(this.text, vals, after);
	  } else {
	    this.native.query(this.text, after);
	  }
	};


/***/ },
/* 172 */
/*!***********************************!*\
  !*** ./~/pg/lib/native/result.js ***!
  \***********************************/
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2010-2016 Brian Carlson (brian.m.carlson@gmail.com)
	 * All rights reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * README.md file in the root directory of this source tree.
	 */

	var NativeResult = module.exports = function(pq) {
	  this.command = null;
	  this.rowCount = 0;
	  this.rows = null;
	  this.fields = null;
	};

	NativeResult.prototype.addCommandComplete = function(pq) {
	  this.command = pq.cmdStatus().split(' ')[0];
	  this.rowCount = parseInt(pq.cmdTuples(), 10);
	  var nfields = pq.nfields();
	  if(nfields < 1) return;

	  this.fields = [];
	  for(var i = 0; i < nfields; i++) {
	    this.fields.push({
	      name: pq.fname(i),
	      dataTypeID: pq.ftype(i)
	    });
	  }
	};

	NativeResult.prototype.addRow = function(row) {
	  // This is empty to ensure pg code doesn't break when switching to pg-native
	  // pg-native loads all rows into the final result object by default.
	  // This is because libpg loads all rows into memory before passing the result
	  // to pg-native.
	};


/***/ },
/* 173 */
/*!*******************************************!*\
  !*** ./~/node-helpers/lazy-extensions.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var lazy = __webpack_require__(/*! lazy.js */ 174).strict();
	var Sequence = lazy.Sequence
	    , ObjectLikeSequence = lazy.ObjectLikeSequence
	    , ArrayLikeSequence = lazy.ArrayLikeSequence
	    , AsyncSequence = lazy.AsyncSequence;
	var Utils = __webpack_require__(/*! ./utils */ 131);
	var xor = Utils.xor;


	//-----------------------------//
	// New Constructors come first //
	//-----------------------------//


	//----------//
	// Sequence //
	//----------//

	// rotate(1) moves the first element forward one, rotate(-1) moves the first element to the back of the sequence
	Sequence.prototype.rotate = function rotate(n) {
	    var self = this;
	    if (n > 0) {
	        var len = self.size();
	        self = self.concat(self.first(len - n)).rest(len - n);
	    } else if (n < 0) {
	        n = -n;
	        self = self.concat(self.first(n)).rest(n);
	    }

	    return self;
	};

	Sequence.prototype.rotateTo = function rotateTo(e, eqFn) {
	    var self = this;

	    if (['undefined', 'string', 'function'].indexOf(typeof eqFn) !== -1) {
	        self = self.rotate(-(self.indexOf(e, eqFn)));
	    } else {
	        throw new Error("Invalid Argument: <Sequence>.rotateTo expects an undefined, string, or function type for its second parameter.");
	    }

	    return self;
	};

	Sequence.prototype.indexOf = function indexOf(el, eqFn) {
	    var foundIndex = -1;

	    var normalizedEqFn = Utils.normalizeEqualityFunction(eqFn, "Inavlid Argument: <Sequence>.indexOf expects an undefined, string, or function type for its second parameter.");

	    var curIterator = this.getIterator();
	    var found = false;
	    while (curIterator.moveNext() && !found) {
	        found = normalizedEqFn(curIterator.current(), el);
	        if (found) {
	            foundIndex = curIterator.index;
	        }
	    }

	    return foundIndex;
	};

	Sequence.prototype.has = function has(el, eqFn) {
	    var normalizedEqFn = Utils.normalizeEqualityFunction(eqFn, "Inavlid Argument: <Sequence>.has expects an undefined, string, or function type for its second parameter.");
	    return (this.indexOf(el, normalizedEqFn) !== -1);
	};

	Sequence.prototype.any = Sequence.prototype.has;

	Sequence.prototype.allTypeOf = function allTypeOf(type_) {
	    if (typeof type_ !== 'string') {
	        throw new Error("Invalid Argument: <Sequence>.allTypeOf requires a string argument");
	    }
	    return this.all(function(e) {
	        return (typeof e === type_);
	    });
	};

	Sequence.prototype.allInstanceOf = function allInstanceOf(type_) {
	    if (typeof type_ !== 'function') {
	        throw new Error("Invalid Argument: <Sequence>.allInstanceOf requires a function argument");
	    }
	    return this.all(function(e) {
	        return (Utils.instance_of(e, type_));
	    });
	};

	Sequence.prototype.equals = function equals(other_, eqFn_) {
	    if (!(Utils.instance_of(other_, Sequence))) {
	        throw new Error("Invalid Argument: <Sequence>.equals requires a Sequence argument");
	    } else if (this === other_) {
	        return true;
	    } else if ((typeof this.length === 'number') && (typeof other_.length === 'number') && this.length !== other_.length) {
	        return false;
	    }

	    var normalizedEqFn = Utils.normalizeEqualityFunction(eqFn_, "Invalid Argument: <Sequence>.equals requires the second argument to be undefined, a string, or a function");

	    var thisIterator = this.getIterator();
	    var otherIterator = other_.getIterator();
	    var stillEqual = true;
	    var shouldIterate
	        , unequalLength;

	    function iterate(it1_, it2_) {
	        var it1Moved = it1_.moveNext();
	        var it2Moved = it2_.moveNext();
	        return {
	            shouldIterate: (it1Moved && it2Moved)
	            , unequalLength: (xor(it1Moved, it2Moved))
	        };
	    }

	    var itRes = iterate(thisIterator, otherIterator);
	    shouldIterate = itRes.shouldIterate;
	    unequalLength = itRes.unequalLength;
	    while (stillEqual && shouldIterate && !unequalLength) {
	        stillEqual = normalizedEqFn(thisIterator.current(), otherIterator.current());

	        itRes = iterate(thisIterator, otherIterator);
	        shouldIterate = itRes.shouldIterate;
	        unequalLength = itRes.unequalLength;
	    }

	    return stillEqual && !unequalLength;
	};

	Sequence.equals = function static_equals(left_, right_, eqFn_) {
	    var res;

	    if (xor(left_ === null, right_ === null)) {
	        res = false;
	    } else if (left_ === null && right_ === null) {
	        res = true;
	    } else { // neither left nor right are null, so we can safely pass them into the equality function
	        res = lazy(left_).equals(lazy(right_), eqFn_);
	    }

	    return res;
	};

	Sequence.prototype.doWhile = Sequence.prototype.each;

	Sequence.prototype.mustFind = function mustFind(predicate) {
	    var res = this.find(predicate);
	    if (typeof res === 'undefined') {
	        throw new Error("Invalid Argument: <Sequence>.mustFind did not find any matching elements");
	    }
	    return res;
	};

	//--------------------//
	// ObjectLikeSequence //
	//--------------------//

	ObjectLikeSequence.prototype.constructor = ObjectLikeSequence;
	ObjectLikeSequence.prototype.keys = function keys() {
	    return new KeySequence(this);
	};

	ObjectLikeSequence.prototype.values = function values() {
	    return new ValueSequence(this);
	};

	ObjectLikeSequence.prototype.equals = function equals(other_, valEqFn_) {
	    if (!(Utils.instance_of(other_, Sequence))) {
	        throw new Error("Invalid Argument: <ObjectLikeSequence>.equals requires an ObjectLikeSequence argument");
	    } else if (this === other_) {
	        return true;
	    } else if ((typeof this.length === 'number') && (typeof other_.length === 'number') && this.length !== other_.length) {
	        return false;
	    }

	    // first check the keys
	    var stillEqual = this.keys().sort().join("") === other_.keys().sort().join("");

	    // if keys are equal, then we need to test their associated values
	    if (stillEqual) {
	        var normalizedValEqFn = Utils.normalizeEqualityFunction(valEqFn_, "Invalid Argument: <ObjectLikeSequence>.equals requires the second argument to be undefined, a string, or a function");

	        var thisKit = this.keys().getIterator();
	        while (thisKit.moveNext() && stillEqual) {
	            stillEqual = normalizedValEqFn(this.get(thisKit.current()), other_.get(thisKit.current()));
	        }
	    }

	    return stillEqual;
	};


	//-------------//
	// KeySequence //
	//-------------//

	function KeySequence(parent) {
	    this.parent = parent;
	}

	KeySequence.prototype = new lazy.ObjectLikeSequence();
	KeySequence.prototype.constructor = KeySequence;

	KeySequence.prototype.each = function each(fn) {
	    return this.parent.each(function(v, k) {
	        return fn(k);
	    });
	};

	KeySequence.prototype.toArray = function toArray() {
	    return this.reduce(function(arr, element) {
	        arr.push(element);
	        return arr;
	    }, []);
	};

	KeySequence.prototype.getIterator = function getIterator() {
	    return new KeyIterator(this.parent);
	};

	function KeyIterator(sequence) {
	    this.iterator = sequence.getIterator();
	    this.index = -1;
	}

	KeyIterator.prototype.current = function current() {
	    return this.iterator.current()[0];
	};

	KeyIterator.prototype.moveNext = function moveNext() {
	    return this.iterator.moveNext();
	};


	//---------------//
	// ValueSequence //
	//---------------//

	function ValueSequence(parent) {
	    this.parent = parent;
	}

	ValueSequence.prototype = new lazy.ObjectLikeSequence();
	ValueSequence.prototype.constructor = ValueSequence;

	ValueSequence.prototype.getIterator = function getIterator() {
	    return new ValueIterator(this.parent);
	};

	ValueSequence.prototype.each = function each(fn) {
	    return this.parent.each(function(v, k) {
	        return fn(v);
	    });
	};

	ValueSequence.prototype.toArray = function toArray() {
	    return this.reduce(function(arr, element) {
	        arr.push(element);
	        return arr;
	    }, []);
	};

	function ValueIterator(sequence) {
	    this.iterator = sequence.getIterator();
	    this.index = -1;
	}

	ValueIterator.prototype.current = function current() {
	    return this.iterator.current()[1];
	};

	ValueIterator.prototype.moveNext = function moveNext() {
	    return this.iterator.moveNext();
	};


	//-------------------//
	// ArrayLikeSequence //
	//-------------------//

	ArrayLikeSequence.prototype.constructor = ArrayLikeSequence;


	//---------------//
	// AsyncSequence //
	//---------------//

	AsyncSequence.prototype.constructor = AsyncSequence;

	AsyncSequence.prototype.setNumElementsPerAsync = function setNumElementsPerAsync(num) {
	    this.numElementsPerAsync = num;
	    return this;
	};

	AsyncSequence.prototype.each = function AsyncSequence_each(fn) {
	    var iterator = this.parent.getIterator(),
	        onNextCallback = this.onNextCallback,
	        cancelCallback = this.cancelCallback,
	        i = 0,
	        numElementsPerAsync = this.numElementsPerAsync || 1;

	    var handle = new lazy.AsyncHandle(function cancel() {
	        if (cancellationId) {
	            cancelCallback(cancellationId);
	        }
	    });

	    var cancellationId = onNextCallback(function iterate() {
	        cancellationId = null;

	        try {
	            var mn
	                , shouldContinue;

	            do {
	                mn = iterator.moveNext();
	                shouldContinue = fn(iterator.current(), i++) !== false;
	            } while (mn && shouldContinue && i % numElementsPerAsync !== 0);

	            cancellationId = onNextCallback(iterate);

	            if (!mn || !shouldContinue) {
	                handle._resolve();
	            }
	        } catch (e) {
	            handle._reject(e);
	        }
	    });

	    return handle;
	};


	//---------//
	// Exports //
	//---------//

	module.exports = lazy;


/***/ },
/* 174 */
/*!********************************!*\
  !*** ./~/lazy.js/lazy.node.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	var fs     = __webpack_require__(/*! fs */ 19);
	var http   = __webpack_require__(/*! http */ 42);
	var os     = __webpack_require__(/*! os */ 175);
	var Stream = __webpack_require__(/*! stream */ 67);
	var URL    = __webpack_require__(/*! url */ 51);
	var util   = __webpack_require__(/*! util */ 16);

	// The starting point is everything that works in any environment (browser OR
	// Node.js)
	var Lazy = __webpack_require__(/*! ./lazy.js */ 176);

	/**
	 * @constructor
	 */
	function StreamedSequence(stream) {
	  this.stream = stream;
	}

	StreamedSequence.prototype = new Lazy.StreamLikeSequence();

	StreamedSequence.prototype.openStream = function(callback) {
	  this.stream.resume();
	  callback(this.stream);
	};

	/**
	 * Handles every chunk of data in this sequence.
	 *
	 * @param {function(string):*} fn The function to call on each chunk of data as
	 *     it's read from the stream. Return false from the function to stop reading
	 *     the stream.
	 */
	StreamedSequence.prototype.each = function(fn) {
	  var cancelled = false;

	  var handle = new Lazy.AsyncHandle(function cancel() { cancelled = true; });

	  this.openStream(function(stream) {
	    if (stream.setEncoding) {
	      stream.setEncoding(this.encoding || 'utf8');
	    }

	    var listener = function(e) {
	      try {
	        if (cancelled || fn(e) === false) {
	          stream.removeListener("data", listener);
	          handle._resolve(false);
	        }
	      } catch (e) {
	        handle._reject(e);
	      }
	    };

	    stream.on("data", listener);

	    stream.on("end", function() {
	      handle._resolve(true);
	    });
	  });

	  return handle;
	};

	/**
	 * Creates a {@link Sequence} of lines as they are read from a file.
	 *
	 * @return {Sequence} A sequence comprising the lines in the underlying file, as
	 *     they are read.
	 */
	StreamedSequence.prototype.lines = function() {
	  return this.split(os.EOL || "\n");
	};

	function FileStreamSequence(path, encoding) {
	  this.path = path;
	  this.encoding = encoding;
	}

	FileStreamSequence.prototype = new StreamedSequence();

	FileStreamSequence.prototype.openStream = function(callback) {
	  var stream = fs.createReadStream(this.path, { autoClose: true });
	  callback(stream);
	};

	/**
	 * Creates a {@link Sequence} from a file stream, whose elements are chunks of
	 * data as the stream is read. This is an {@link AsyncSequence}, so methods such
	 * as {@link Sequence#reduce} return an {@link AsyncHandle} rather than a value.
	 *
	 * @param {string} path A path to a file.
	 * @param {string} encoding The text encoding of the file (e.g., "utf-8").
	 * @return {Sequence} The streamed sequence.
	 */
	Lazy.readFile = function(path, encoding) {
	  return new FileStreamSequence(path, encoding);
	};

	function HttpStreamSequence(url, encoding) {
	  this.url = url;
	  this.encoding = encoding;
	}

	HttpStreamSequence.prototype = new StreamedSequence();

	HttpStreamSequence.prototype.openStream = function(callback) {
	  http.get(URL.parse(this.url), callback);
	};

	/**
	 * Creates a {@link Sequence} from an HTTP stream, whose elements are chunks of
	 * data as the stream is read. This sequence works asynchronously, so
	 * synchronous methods such as {@code indexOf}, {@code any}, and {@code toArray}
	 * won't work.
	 *
	 * @param {string} url The URL for the HTTP request.
	 * @return {Sequence} The streamed sequence.
	 */
	Lazy.makeHttpRequest = function(url) {
	  return new HttpStreamSequence(url);
	};

	if (typeof Stream.Readable !== "undefined") {
	  Lazy.Sequence.prototype.toStream = function toStream(options) {
	    return new LazyStream(this, options);
	  };

	  Lazy.Sequence.prototype.pipe = function pipe(destination) {
	    this.toStream().pipe(destination);
	  };

	  function LazyStream(sequence, options) {
	    options = Lazy(options || {})
	      .extend({ objectMode: true })
	      .toObject();

	    Stream.Readable.call(this, options);

	    this.sequence = sequence;
	    this.started  = false;
	    
	    // Find delimiter on a (parent) sequence object if set
	    while (sequence) {
	      if (sequence.delimiter) {
	        this.delimiter = sequence.delimiter;
	        break;
	      }
	      sequence = sequence.parent;
	    }
	  }

	  util.inherits(LazyStream, Stream.Readable);

	  LazyStream.prototype._read = function() {
	    var self = this;

	    if (!this.started) {
	      var handle = this.sequence.each(function(line, i) {
	        if (self.delimiter != null) {
	          line += self.delimiter;
	        }
	        return self.push(line, i);
	      });
	      if (handle instanceof Lazy.AsyncHandle) {
	        handle.onComplete(function() {
	          self.push(null);
	        });
	      }
	      this.started = true;
	    }
	  };
	}

	/*
	 * Add support for `Lazy(Stream)`.
	 */
	Lazy.extensions || (Lazy.extensions = []);

	Lazy.extensions.push(function(source) {
	  if (source instanceof Stream) {
	    return new StreamedSequence(source);
	  }
	});

	module.exports = Lazy;


/***/ },
/* 175 */
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ function(module, exports) {

	module.exports = require("os");

/***/ },
/* 176 */
/*!***************************!*\
  !*** ./~/lazy.js/lazy.js ***!
  \***************************/
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * @name Lazy.js
	 *
	 * @fileOverview
	 * Lazy.js is a lazy evaluation library for JavaScript.
	 *
	 * This has been done before. For examples see:
	 *
	 * - [wu.js](http://fitzgen.github.io/wu.js/)
	 * - [Linq.js](http://linqjs.codeplex.com/)
	 * - [from.js](https://github.com/suckgamoni/fromjs/)
	 * - [IxJS](http://rx.codeplex.com/)
	 * - [sloth.js](http://rfw.name/sloth.js/)
	 *
	 * However, at least at present, Lazy.js is faster (on average) than any of
	 * those libraries. It is also more complete, with nearly all of the
	 * functionality of [Underscore](http://underscorejs.org/) and
	 * [Lo-Dash](http://lodash.com/).
	 *
	 * Finding your way around the code
	 * --------------------------------
	 *
	 * At the heart of Lazy.js is the {@link Sequence} object. You create an initial
	 * sequence using {@link Lazy}, which can accept an array, object, or string.
	 * You can then "chain" together methods from this sequence, creating a new
	 * sequence with each call.
	 *
	 * Here's an example:
	 *
	 *     var data = getReallyBigArray();
	 *
	 *     var statistics = Lazy(data)
	 *       .map(transform)
	 *       .filter(validate)
	 *       .reduce(aggregate);
	 *
	 * {@link Sequence} is the foundation of other, more specific sequence types.
	 *
	 * An {@link ArrayLikeSequence} provides indexed access to its elements.
	 *
	 * An {@link ObjectLikeSequence} consists of key/value pairs.
	 *
	 * A {@link StringLikeSequence} is like a string (duh): actually, it is an
	 * {@link ArrayLikeSequence} whose elements happen to be characters.
	 *
	 * An {@link AsyncSequence} is special: it iterates over its elements
	 * asynchronously (so calling `each` generally begins an asynchronous loop and
	 * returns immediately).
	 *
	 * For more information
	 * --------------------
	 *
	 * I wrote a blog post that explains a little bit more about Lazy.js, which you
	 * can read [here](http://philosopherdeveloper.com/posts/introducing-lazy-js.html).
	 *
	 * You can also [create an issue on GitHub](https://github.com/dtao/lazy.js/issues)
	 * if you have any issues with the library. I work through them eventually.
	 *
	 * [@dtao](https://github.com/dtao)
	 */

	(function(root, factory) {
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports === 'object') {
	    module.exports = factory();
	  } else {
	    root.Lazy = factory();
	  }
	})(this, function(context) {
	  /**
	   * Wraps an object and returns a {@link Sequence}. For `null` or `undefined`,
	   * simply returns an empty sequence (see {@link Lazy.strict} for a stricter
	   * implementation).
	   *
	   * - For **arrays**, Lazy will create a sequence comprising the elements in
	   *   the array (an {@link ArrayLikeSequence}).
	   * - For **objects**, Lazy will create a sequence of key/value pairs
	   *   (an {@link ObjectLikeSequence}).
	   * - For **strings**, Lazy will create a sequence of characters (a
	   *   {@link StringLikeSequence}).
	   *
	   * @public
	   * @param {Array|Object|string} source An array, object, or string to wrap.
	   * @returns {Sequence} The wrapped lazy object.
	   *
	   * @exampleHelpers
	   * // Utility functions to provide to all examples
	   * function increment(x) { return x + 1; }
	   * function isEven(x) { return x % 2 === 0; }
	   * function isPositive(x) { return x > 0; }
	   * function isNegative(x) { return x < 0; }
	   *
	   * @examples
	   * Lazy([1, 2, 4])       // instanceof Lazy.ArrayLikeSequence
	   * Lazy({ foo: "bar" })  // instanceof Lazy.ObjectLikeSequence
	   * Lazy("hello, world!") // instanceof Lazy.StringLikeSequence
	   * Lazy()                // sequence: []
	   * Lazy(null)            // sequence: []
	   */
	  function Lazy(source) {
	    if (source instanceof Array) {
	      return new ArrayWrapper(source);

	    } else if (typeof source === "string") {
	      return new StringWrapper(source);

	    } else if (source instanceof Sequence) {
	      return source;
	    }

	    if (Lazy.extensions) {
	      var extensions = Lazy.extensions, length = extensions.length, result;
	      while (!result && length--) {
	        result = extensions[length](source);
	      }
	      if (result) {
	        return result;
	      }
	    }

	    return new ObjectWrapper(source);
	  }

	  Lazy.VERSION = '0.4.2';

	  /*** Utility methods of questionable value ***/

	  Lazy.noop = function noop() {};
	  Lazy.identity = function identity(x) { return x; };

	  /**
	   * Provides a stricter version of {@link Lazy} which throws an error when
	   * attempting to wrap `null`, `undefined`, or numeric or boolean values as a
	   * sequence.
	   *
	   * @public
	   * @returns {Function} A stricter version of the {@link Lazy} helper function.
	   *
	   * @examples
	   * var Strict = Lazy.strict();
	   *
	   * Strict()                  // throws
	   * Strict(null)              // throws
	   * Strict(true)              // throws
	   * Strict(5)                 // throws
	   * Strict([1, 2, 3])         // instanceof Lazy.ArrayLikeSequence
	   * Strict({ foo: "bar" })    // instanceof Lazy.ObjectLikeSequence
	   * Strict("hello, world!")   // instanceof Lazy.StringLikeSequence
	   *
	   * // Let's also ensure the static functions are still there.
	   * Strict.range(3)           // sequence: [0, 1, 2]
	   * Strict.generate(Date.now) // instanceof Lazy.GeneratedSequence
	   */
	  Lazy.strict = function strict() {
	    function StrictLazy(source) {
	      if (source == null) {
	        throw new Error("You cannot wrap null or undefined using Lazy.");
	      }

	      if (typeof source === "number" || typeof source === "boolean") {
	        throw new Error("You cannot wrap primitive values using Lazy.");
	      }

	      return Lazy(source);
	    };

	    Lazy(Lazy).each(function(property, name) {
	      StrictLazy[name] = property;
	    });

	    return StrictLazy;
	  };

	  /**
	   * The `Sequence` object provides a unified API encapsulating the notion of
	   * zero or more consecutive elements in a collection, stream, etc.
	   *
	   * Lazy evaluation
	   * ---------------
	   *
	   * Generally speaking, creating a sequence should not be an expensive operation,
	   * and should not iterate over an underlying source or trigger any side effects.
	   * This means that chaining together methods that return sequences incurs only
	   * the cost of creating the `Sequence` objects themselves and not the cost of
	   * iterating an underlying data source multiple times.
	   *
	   * The following code, for example, creates 4 sequences and does nothing with
	   * `source`:
	   *
	   *     var seq = Lazy(source) // 1st sequence
	   *       .map(func)           // 2nd
	   *       .filter(pred)        // 3rd
	   *       .reverse();          // 4th
	   *
	   * Lazy's convention is to hold off on iterating or otherwise *doing* anything
	   * (aside from creating `Sequence` objects) until you call `each`:
	   *
	   *     seq.each(function(x) { console.log(x); });
	   *
	   * Defining custom sequences
	   * -------------------------
	   *
	   * Defining your own type of sequence is relatively simple:
	   *
	   * 1. Pass a *method name* and an object containing *function overrides* to
	   *    {@link Sequence.define}. If the object includes a function called `init`,
	   *    this function will be called upon initialization.
	   * 2. The object should include at least either a `getIterator` method or an
	   *    `each` method. The former supports both asynchronous and synchronous
	   *    iteration, but is slightly more cumbersome to implement. The latter
	   *    supports synchronous iteration and can be automatically implemented in
	   *    terms of the former. You can also implement both if you want, e.g. to
	   *    optimize performance. For more info, see {@link Iterator} and
	   *    {@link AsyncSequence}.
	   *
	   * As a trivial example, the following code defines a new method, `sample`,
	   * which randomly may or may not include each element from its parent.
	   *
	   *     Lazy.Sequence.define("sample", {
	   *       each: function(fn) {
	   *         return this.parent.each(function(e) {
	   *           // 50/50 chance of including this element.
	   *           if (Math.random() > 0.5) {
	   *             return fn(e);
	   *           }
	   *         });
	   *       }
	   *     });
	   *
	   * (Of course, the above could also easily have been implemented using
	   * {@link #filter} instead of creating a custom sequence. But I *did* say this
	   * was a trivial example, to be fair.)
	   *
	   * Now it will be possible to create this type of sequence from any parent
	   * sequence by calling the method name you specified. In other words, you can
	   * now do this:
	   *
	   *     Lazy(arr).sample();
	   *     Lazy(arr).map(func).sample();
	   *     Lazy(arr).map(func).filter(pred).sample();
	   *
	   * Etc., etc.
	   *
	   * @public
	   * @constructor
	   */
	  function Sequence() {}

	  /**
	   * Create a new constructor function for a type inheriting from `Sequence`.
	   *
	   * @public
	   * @param {string|Array.<string>} methodName The name(s) of the method(s) to be
	   *     used for constructing the new sequence. The method will be attached to
	   *     the `Sequence` prototype so that it can be chained with any other
	   *     sequence methods, like {@link #map}, {@link #filter}, etc.
	   * @param {Object} overrides An object containing function overrides for this
	   *     new sequence type. **Must** include either `getIterator` or `each` (or
	   *     both). *May* include an `init` method as well. For these overrides,
	   *     `this` will be the new sequence, and `this.parent` will be the base
	   *     sequence from which the new sequence was constructed.
	   * @returns {Function} A constructor for a new type inheriting from `Sequence`.
	   *
	   * @examples
	   * // This sequence type logs every element to the specified logger as it
	   * // iterates over it.
	   * Lazy.Sequence.define("verbose", {
	   *   init: function(logger) {
	   *     this.logger = logger;
	   *   },
	   *
	   *   each: function(fn) {
	   *     var logger = this.logger;
	   *     return this.parent.each(function(e, i) {
	   *       logger(e);
	   *       return fn(e, i);
	   *     });
	   *   }
	   * });
	   *
	   * Lazy([1, 2, 3]).verbose(logger).each(Lazy.noop) // calls logger 3 times
	   */
	  Sequence.define = function define(methodName, overrides) {
	    if (!overrides || (!overrides.getIterator && !overrides.each)) {
	      throw new Error("A custom sequence must implement *at least* getIterator or each!");
	    }

	    return defineSequenceType(Sequence, methodName, overrides);
	  };

	  /**
	   * Gets the number of elements in the sequence. In some cases, this may
	   * require eagerly evaluating the sequence.
	   *
	   * @public
	   * @returns {number} The number of elements in the sequence.
	   *
	   * @examples
	   * Lazy([1, 2, 3]).size();                 // => 3
	   * Lazy([1, 2]).map(Lazy.identity).size(); // => 2
	   * Lazy([1, 2, 3]).reject(isEven).size();  // => 2
	   * Lazy([1, 2, 3]).take(1).size();         // => 1
	   * Lazy({ foo: 1, bar: 2 }).size();        // => 2
	   * Lazy('hello').size();                   // => 5
	   */
	  Sequence.prototype.size = function size() {
	    return this.getIndex().length();
	  };

	  /**
	   * Creates an {@link Iterator} object with two methods, `moveNext` -- returning
	   * true or false -- and `current` -- returning the current value.
	   *
	   * This method is used when asynchronously iterating over sequences. Any type
	   * inheriting from `Sequence` must implement this method or it can't support
	   * asynchronous iteration.
	   *
	   * Note that **this method is not intended to be used directly by application
	   * code.** Rather, it is intended as a means for implementors to potentially
	   * define custom sequence types that support either synchronous or
	   * asynchronous iteration.
	   *
	   * @public
	   * @returns {Iterator} An iterator object.
	   *
	   * @examples
	   * var iterator = Lazy([1, 2]).getIterator();
	   *
	   * iterator.moveNext(); // => true
	   * iterator.current();  // => 1
	   * iterator.moveNext(); // => true
	   * iterator.current();  // => 2
	   * iterator.moveNext(); // => false
	   */
	  Sequence.prototype.getIterator = function getIterator() {
	    return new Iterator(this);
	  };

	  /**
	   * Gets the root sequence underlying the current chain of sequences.
	   */
	  Sequence.prototype.root = function root() {
	    return this.parent.root();
	  };

	  /**
	   * Whether or not the current sequence is an asynchronous one. This is more
	   * accurate than checking `instanceof {@link AsyncSequence}` because, for
	   * example, `Lazy([1, 2, 3]).async().map(Lazy.identity)` returns a sequence
	   * that iterates asynchronously even though it's not an instance of
	   * `AsyncSequence`.
	   *
	   * @returns {boolean} Whether or not the current sequence is an asynchronous one.
	   */
	  Sequence.prototype.isAsync = function isAsync() {
	    return this.parent ? this.parent.isAsync() : false;
	  };

	  /**
	   * Evaluates the sequence and produces the appropriate value (an array in most
	   * cases, an object for {@link ObjectLikeSequence}s or a string for
	   * {@link StringLikeSequence}s).
	   *
	   * @returns {Array|string|Object} The value resulting from fully evaluating
	   *     the sequence.
	   */
	  Sequence.prototype.value = function value() {
	    return this.toArray();
	  };

	  /**
	   * Applies the current transformation chain to a given source, returning the
	   * resulting value.
	   *
	   * @examples
	   * var sequence = Lazy([])
	   *   .map(function(x) { return x * -1; })
	   *   .filter(function(x) { return x % 2 === 0; });
	   *
	   * sequence.apply([1, 2, 3, 4]); // => [-2, -4]
	   */
	  Sequence.prototype.apply = function apply(source) {
	    var root = this.root(),
	        previousSource = root.source,
	        result;

	    try {
	      root.source = source;
	      result = this.value();
	    } finally {
	      root.source = previousSource;
	    }

	    return result;
	  };

	  /**
	   * The Iterator object provides an API for iterating over a sequence.
	   *
	   * The purpose of the `Iterator` type is mainly to offer an agnostic way of
	   * iterating over a sequence -- either synchronous (i.e. with a `while` loop)
	   * or asynchronously (with recursive calls to either `setTimeout` or --- if
	   * available --- `setImmediate`). It is not intended to be used directly by
	   * application code.
	   *
	   * @public
	   * @constructor
	   * @param {Sequence} sequence The sequence to iterate over.
	   */
	  function Iterator(sequence) {
	    this.sequence = sequence;
	    this.index    = -1;
	  }

	  /**
	   * Gets the current item this iterator is pointing to.
	   *
	   * @public
	   * @returns {*} The current item.
	   */
	  Iterator.prototype.current = function current() {
	    return this.cachedIndex && this.cachedIndex.get(this.index);
	  };

	  /**
	   * Moves the iterator to the next item in a sequence, if possible.
	   *
	   * @public
	   * @returns {boolean} True if the iterator is able to move to a new item, or else
	   *     false.
	   */
	  Iterator.prototype.moveNext = function moveNext() {
	    var cachedIndex = this.cachedIndex;

	    if (!cachedIndex) {
	      cachedIndex = this.cachedIndex = this.sequence.getIndex();
	    }

	    if (this.index >= cachedIndex.length() - 1) {
	      return false;
	    }

	    ++this.index;
	    return true;
	  };

	  /**
	   * Creates an array snapshot of a sequence.
	   *
	   * Note that for indefinite sequences, this method may raise an exception or
	   * (worse) cause the environment to hang.
	   *
	   * @public
	   * @returns {Array} An array containing the current contents of the sequence.
	   *
	   * @examples
	   * Lazy([1, 2, 3]).toArray() // => [1, 2, 3]
	   */
	  Sequence.prototype.toArray = function toArray() {
	    return this.reduce(function(arr, element) {
	      arr.push(element);
	      return arr;
	    }, []);
	  };

	  /**
	   * Provides an indexed view into the sequence.
	   *
	   * For sequences that are already indexed, this will simply return the
	   * sequence. For non-indexed sequences, this will eagerly evaluate the
	   * sequence.
	   *
	   * @returns {ArrayLikeSequence} A sequence containing the current contents of
	   *     the sequence.
	   *
	   * @examples
	   * Lazy([1, 2, 3]).filter(isEven)            // instanceof Lazy.Sequence
	   * Lazy([1, 2, 3]).filter(isEven).getIndex() // instanceof Lazy.ArrayLikeSequence
	   */
	  Sequence.prototype.getIndex = function getIndex() {
	    return new ArrayWrapper(this.toArray());
	  };

	  /**
	   * Returns the element at the specified index. Note that, for sequences that
	   * are not {@link ArrayLikeSequence}s, this may require partially evaluating
	   * the sequence, iterating to reach the result. (In other words for such
	   * sequences this method is not O(1).)
	   *
	   * @public
	   * @param {number} i The index to access.
	   * @returns {*} The element.
	   *
	   */
	  Sequence.prototype.get = function get(i) {
	    var element;
	    this.each(function(e, index) {
	      if (index === i) {
	        element = e;
	        return false;
	      }
	    });
	    return element;
	  };

	  /**
	   * Provides an indexed, memoized view into the sequence. This will cache the
	   * result whenever the sequence is first iterated, so that subsequent
	   * iterations will access the same element objects.
	   *
	   * @public
	   * @returns {ArrayLikeSequence} An indexed, memoized sequence containing this
	   *     sequence's elements, cached after the first iteration.
	   *
	   * @example
	   * function createObject() { return new Object(); }
	   *
	   * var plain    = Lazy.generate(createObject, 10),
	   *     memoized = Lazy.generate(createObject, 10).memoize();
	   *
	   * plain.toArray()[0] === plain.toArray()[0];       // => false
	   * memoized.toArray()[0] === memoized.toArray()[0]; // => true
	   */
	  Sequence.prototype.memoize = function memoize() {
	    return new MemoizedSequence(this);
	  };

	  /**
	   * @constructor
	   */
	  function MemoizedSequence(parent) {
	    this.parent = parent;
	  }

	  // MemoizedSequence needs to have its prototype set up after ArrayLikeSequence

	  /**
	   * Creates an object from a sequence of key/value pairs.
	   *
	   * @public
	   * @returns {Object} An object with keys and values corresponding to the pairs
	   *     of elements in the sequence.
	   *
	   * @examples
	   * var details = [
	   *   ["first", "Dan"],
	   *   ["last", "Tao"],
	   *   ["age", 29]
	   * ];
	   *
	   * Lazy(details).toObject() // => { first: "Dan", last: "Tao", age: 29 }
	   */
	  Sequence.prototype.toObject = function toObject() {
	    return this.reduce(function(object, pair) {
	      object[pair[0]] = pair[1];
	      return object;
	    }, {});
	  };

	  /**
	   * Iterates over this sequence and executes a function for every element.
	   *
	   * @public
	   * @aka forEach
	   * @param {Function} fn The function to call on each element in the sequence.
	   *     Return false from the function to end the iteration.
	   * @returns {boolean} `true` if the iteration evaluated the entire sequence,
	   *     or `false` if iteration was ended early.
	   *
	   * @examples
	   * Lazy([1, 2, 3, 4]).each(fn) // calls fn 4 times
	   */
	  Sequence.prototype.each = function each(fn) {
	    var iterator = this.getIterator(),
	        i = -1;

	    while (iterator.moveNext()) {
	      if (fn(iterator.current(), ++i) === false) {
	        return false;
	      }
	    }

	    return true;
	  };

	  Sequence.prototype.forEach = function forEach(fn) {
	    return this.each(fn);
	  };

	  /**
	   * Creates a new sequence whose values are calculated by passing this sequence's
	   * elements through some mapping function.
	   *
	   * @public
	   * @aka collect
	   * @param {Function} mapFn The mapping function used to project this sequence's
	   *     elements onto a new sequence. This function takes up to two arguments:
	   *     the element, and the current index.
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * function addIndexToValue(e, i) { return e + i; }
	   *
	   * Lazy([]).map(increment)              // sequence: []
	   * Lazy([1, 2, 3]).map(increment)       // sequence: [2, 3, 4]
	   * Lazy([1, 2, 3]).map(addIndexToValue) // sequence: [1, 3, 5]
	   *
	   * @benchmarks
	   * function increment(x) { return x + 1; }
	   *
	   * var smArr = Lazy.range(10).toArray(),
	   *     lgArr = Lazy.range(100).toArray();
	   *
	   * Lazy(smArr).map(increment).each(Lazy.noop) // lazy - 10 elements
	   * Lazy(lgArr).map(increment).each(Lazy.noop) // lazy - 100 elements
	   * _.each(_.map(smArr, increment), _.noop)    // lodash - 10 elements
	   * _.each(_.map(lgArr, increment), _.noop)    // lodash - 100 elements
	   */
	  Sequence.prototype.map = function map(mapFn) {
	    return new MappedSequence(this, createCallback(mapFn));
	  };

	  Sequence.prototype.collect = function collect(mapFn) {
	    return this.map(mapFn);
	  };

	  /**
	   * @constructor
	   */
	  function MappedSequence(parent, mapFn) {
	    this.parent = parent;
	    this.mapFn  = mapFn;
	  }

	  MappedSequence.prototype = new Sequence();

	  MappedSequence.prototype.getIterator = function getIterator() {
	    return new MappingIterator(this.parent, this.mapFn);
	  };

	  MappedSequence.prototype.each = function each(fn) {
	    var mapFn = this.mapFn;
	    return this.parent.each(function(e, i) {
	      return fn(mapFn(e, i), i);
	    });
	  };

	  /**
	   * @constructor
	   */
	  function MappingIterator(sequence, mapFn) {
	    this.iterator = sequence.getIterator();
	    this.mapFn    = mapFn;
	    this.index    = -1;
	  }

	  MappingIterator.prototype.current = function current() {
	    return this.mapFn(this.iterator.current(), this.index);
	  };

	  MappingIterator.prototype.moveNext = function moveNext() {
	    if (this.iterator.moveNext()) {
	      ++this.index;
	      return true;
	    }

	    return false;
	  };

	  /**
	   * Creates a new sequence whose values are calculated by accessing the specified
	   * property from each element in this sequence.
	   *
	   * @public
	   * @param {string} propertyName The name of the property to access for every
	   *     element in this sequence.
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * var people = [
	   *   { first: "Dan", last: "Tao" },
	   *   { first: "Bob", last: "Smith" }
	   * ];
	   *
	   * Lazy(people).pluck("last") // sequence: ["Tao", "Smith"]
	   */
	  Sequence.prototype.pluck = function pluck(property) {
	    return this.map(property);
	  };

	  /**
	   * Creates a new sequence whose values are calculated by invoking the specified
	   * function on each element in this sequence.
	   *
	   * @public
	   * @param {string} methodName The name of the method to invoke for every element
	   *     in this sequence.
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * function Person(first, last) {
	   *   this.fullName = function fullName() {
	   *     return first + " " + last;
	   *   };
	   * }
	   *
	   * var people = [
	   *   new Person("Dan", "Tao"),
	   *   new Person("Bob", "Smith")
	   * ];
	   *
	   * Lazy(people).invoke("fullName") // sequence: ["Dan Tao", "Bob Smith"]
	   */
	  Sequence.prototype.invoke = function invoke(methodName) {
	    return this.map(function(e) {
	      return e[methodName]();
	    });
	  };

	  /**
	   * Creates a new sequence whose values are the elements of this sequence which
	   * satisfy the specified predicate.
	   *
	   * @public
	   * @aka select
	   * @param {Function} filterFn The predicate to call on each element in this
	   *     sequence, which returns true if the element should be included.
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * var numbers = [1, 2, 3, 4, 5, 6];
	   *
	   * Lazy(numbers).filter(isEven) // sequence: [2, 4, 6]
	   *
	   * @benchmarks
	   * function isEven(x) { return x % 2 === 0; }
	   *
	   * var smArr = Lazy.range(10).toArray(),
	   *     lgArr = Lazy.range(100).toArray();
	   *
	   * Lazy(smArr).filter(isEven).each(Lazy.noop) // lazy - 10 elements
	   * Lazy(lgArr).filter(isEven).each(Lazy.noop) // lazy - 100 elements
	   * _.each(_.filter(smArr, isEven), _.noop)    // lodash - 10 elements
	   * _.each(_.filter(lgArr, isEven), _.noop)    // lodash - 100 elements
	   */
	  Sequence.prototype.filter = function filter(filterFn) {
	    return new FilteredSequence(this, createCallback(filterFn));
	  };

	  Sequence.prototype.select = function select(filterFn) {
	    return this.filter(filterFn);
	  };

	  /**
	   * @constructor
	   */
	  function FilteredSequence(parent, filterFn) {
	    this.parent   = parent;
	    this.filterFn = filterFn;
	  }

	  FilteredSequence.prototype = new Sequence();

	  FilteredSequence.prototype.getIterator = function getIterator() {
	    return new FilteringIterator(this.parent, this.filterFn);
	  };

	  FilteredSequence.prototype.each = function each(fn) {
	    var filterFn = this.filterFn,
	        j = 0;

	    return this.parent.each(function(e, i) {
	      if (filterFn(e, i)) {
	        return fn(e, j++);
	      }
	    });
	  };

	  FilteredSequence.prototype.reverse = function reverse() {
	    return this.parent.reverse().filter(this.filterFn);
	  };

	  /**
	   * @constructor
	   */
	  function FilteringIterator(sequence, filterFn) {
	    this.iterator = sequence.getIterator();
	    this.filterFn = filterFn;
	    this.index    = 0;
	  }

	  FilteringIterator.prototype.current = function current() {
	    return this.value;
	  };

	  FilteringIterator.prototype.moveNext = function moveNext() {
	    var iterator = this.iterator,
	        filterFn = this.filterFn,
	        value;

	    while (iterator.moveNext()) {
	      value = iterator.current();
	      if (filterFn(value, this.index++)) {
	        this.value = value;
	        return true;
	      }
	    }

	    this.value = undefined;
	    return false;
	  };

	  /**
	   * Creates a new sequence whose values exclude the elements of this sequence
	   * identified by the specified predicate.
	   *
	   * @public
	   * @param {Function} rejectFn The predicate to call on each element in this
	   *     sequence, which returns true if the element should be omitted.
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * Lazy([1, 2, 3, 4, 5]).reject(isEven)              // sequence: [1, 3, 5]
	   * Lazy([{ foo: 1 }, { bar: 2 }]).reject('foo')      // sequence: [{ bar: 2 }]
	   * Lazy([{ foo: 1 }, { foo: 2 }]).reject({ foo: 2 }) // sequence: [{ foo: 1 }]
	   */
	  Sequence.prototype.reject = function reject(rejectFn) {
	    rejectFn = createCallback(rejectFn);
	    return this.filter(function(e) { return !rejectFn(e); });
	  };

	  /**
	   * Creates a new sequence whose values have the specified type, as determined
	   * by the `typeof` operator.
	   *
	   * @public
	   * @param {string} type The type of elements to include from the underlying
	   *     sequence, i.e. where `typeof [element] === [type]`.
	   * @returns {Sequence} The new sequence, comprising elements of the specified
	   *     type.
	   *
	   * @examples
	   * Lazy([1, 2, 'foo', 'bar']).ofType('number')  // sequence: [1, 2]
	   * Lazy([1, 2, 'foo', 'bar']).ofType('string')  // sequence: ['foo', 'bar']
	   * Lazy([1, 2, 'foo', 'bar']).ofType('boolean') // sequence: []
	   */
	  Sequence.prototype.ofType = function ofType(type) {
	    return this.filter(function(e) { return typeof e === type; });
	  };

	  /**
	   * Creates a new sequence whose values are the elements of this sequence with
	   * property names and values matching those of the specified object.
	   *
	   * @public
	   * @param {Object} properties The properties that should be found on every
	   *     element that is to be included in this sequence.
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * var people = [
	   *   { first: "Dan", last: "Tao" },
	   *   { first: "Bob", last: "Smith" }
	   * ];
	   *
	   * Lazy(people).where({ first: "Dan" }) // sequence: [{ first: "Dan", last: "Tao" }]
	   *
	   * @benchmarks
	   * var animals = ["dog", "cat", "mouse", "horse", "pig", "snake"];
	   *
	   * Lazy(animals).where({ length: 3 }).each(Lazy.noop) // lazy
	   * _.each(_.where(animals, { length: 3 }), _.noop)    // lodash
	   */
	  Sequence.prototype.where = function where(properties) {
	    return this.filter(properties);
	  };

	  /**
	   * Creates a new sequence with the same elements as this one, but to be iterated
	   * in the opposite order.
	   *
	   * Note that in some (but not all) cases, the only way to create such a sequence
	   * may require iterating the entire underlying source when `each` is called.
	   *
	   * @public
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * Lazy([1, 2, 3]).reverse() // sequence: [3, 2, 1]
	   * Lazy([]).reverse()        // sequence: []
	   */
	  Sequence.prototype.reverse = function reverse() {
	    return new ReversedSequence(this);
	  };

	  /**
	   * @constructor
	   */
	  function ReversedSequence(parent) {
	    this.parent = parent;
	  }

	  ReversedSequence.prototype = new Sequence();

	  ReversedSequence.prototype.getIterator = function getIterator() {
	    return new ReversedIterator(this.parent);
	  };

	  /**
	   * @constuctor
	   */
	  function ReversedIterator(sequence) {
	    this.sequence = sequence;
	  }

	  ReversedIterator.prototype.current = function current() {
	    return this.getIndex().get(this.index);
	  };

	  ReversedIterator.prototype.moveNext = function moveNext() {
	    var index  = this.getIndex(),
	        length = index.length();

	    if (typeof this.index === "undefined") {
	      this.index = length;
	    }

	    return (--this.index >= 0);
	  };

	  ReversedIterator.prototype.getIndex = function getIndex() {
	    if (!this.cachedIndex) {
	      this.cachedIndex = this.sequence.getIndex();
	    }

	    return this.cachedIndex;
	  };

	  /**
	   * Creates a new sequence with all of the elements of this one, plus those of
	   * the given array(s).
	   *
	   * @public
	   * @param {...*} var_args One or more values (or arrays of values) to use for
	   *     additional items after this sequence.
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * var left  = [1, 2, 3];
	   * var right = [4, 5, 6];
	   *
	   * Lazy(left).concat(right)         // sequence: [1, 2, 3, 4, 5, 6]
	   * Lazy(left).concat(Lazy(right))   // sequence: [1, 2, 3, 4, 5, 6]
	   * Lazy(left).concat(right, [7, 8]) // sequence: [1, 2, 3, 4, 5, 6, 7, 8]
	   */
	  Sequence.prototype.concat = function concat(var_args) {
	    return new ConcatenatedSequence(this, arraySlice.call(arguments, 0));
	  };

	  /**
	   * @constructor
	   */
	  function ConcatenatedSequence(parent, arrays) {
	    this.parent = parent;
	    this.arrays = arrays;
	  }

	  ConcatenatedSequence.prototype = new Sequence();

	  ConcatenatedSequence.prototype.each = function each(fn) {
	    var done = false,
	        i = 0;

	    this.parent.each(function(e) {
	      if (fn(e, i++) === false) {
	        done = true;
	        return false;
	      }
	    });

	    if (!done) {
	      Lazy(this.arrays).flatten().each(function(e) {
	        if (fn(e, i++) === false) {
	          return false;
	        }
	      });
	    }
	  };

	  /**
	   * Creates a new sequence comprising the first N elements from this sequence, OR
	   * (if N is `undefined`) simply returns the first element of this sequence.
	   *
	   * @public
	   * @aka head, take
	   * @param {number=} count The number of elements to take from this sequence. If
	   *     this value exceeds the length of the sequence, the resulting sequence
	   *     will be essentially the same as this one.
	   * @returns {*} The new sequence (or the first element from this sequence if
	   *     no count was given).
	   *
	   * @examples
	   * function powerOfTwo(exp) {
	   *   return Math.pow(2, exp);
	   * }
	   *
	   * Lazy.generate(powerOfTwo).first()          // => 1
	   * Lazy.generate(powerOfTwo).first(5)         // sequence: [1, 2, 4, 8, 16]
	   * Lazy.generate(powerOfTwo).skip(2).first()  // => 4
	   * Lazy.generate(powerOfTwo).skip(2).first(2) // sequence: [4, 8]
	   */
	  Sequence.prototype.first = function first(count) {
	    if (typeof count === "undefined") {
	      return getFirst(this);
	    }
	    return new TakeSequence(this, count);
	  };

	  Sequence.prototype.head =
	  Sequence.prototype.take = function (count) {
	    return this.first(count);
	  };

	  /**
	   * @constructor
	   */
	  function TakeSequence(parent, count) {
	    this.parent = parent;
	    this.count  = count;
	  }

	  TakeSequence.prototype = new Sequence();

	  TakeSequence.prototype.getIterator = function getIterator() {
	    return new TakeIterator(this.parent, this.count);
	  };

	  TakeSequence.prototype.each = function each(fn) {
	    var count = this.count,
	        i     = 0;

	    var result;
	    var handle = this.parent.each(function(e) {
	      if (i < count) { result = fn(e, i++); }
	      if (i >= count) { return false; }
	      return result;
	    });

	    if (handle instanceof AsyncHandle) {
	      return handle;
	    }

	    return i === count && result !== false;
	  };

	  /**
	   * @constructor
	   */
	  function TakeIterator(sequence, count) {
	    this.iterator = sequence.getIterator();
	    this.count    = count;
	  }

	  TakeIterator.prototype.current = function current() {
	    return this.iterator.current();
	  };

	  TakeIterator.prototype.moveNext = function moveNext() {
	    return ((--this.count >= 0) && this.iterator.moveNext());
	  };

	  /**
	   * Creates a new sequence comprising the elements from the head of this sequence
	   * that satisfy some predicate. Once an element is encountered that doesn't
	   * satisfy the predicate, iteration will stop.
	   *
	   * @public
	   * @param {Function} predicate
	   * @returns {Sequence} The new sequence
	   *
	   * @examples
	   * function lessThan(x) {
	   *   return function(y) {
	   *     return y < x;
	   *   };
	   * }
	   *
	   * Lazy([1, 2, 3, 4]).takeWhile(lessThan(3)) // sequence: [1, 2]
	   * Lazy([1, 2, 3, 4]).takeWhile(lessThan(0)) // sequence: []
	   */
	  Sequence.prototype.takeWhile = function takeWhile(predicate) {
	    return new TakeWhileSequence(this, predicate);
	  };

	  /**
	   * @constructor
	   */
	  function TakeWhileSequence(parent, predicate) {
	    this.parent    = parent;
	    this.predicate = predicate;
	  }

	  TakeWhileSequence.prototype = new Sequence();

	  TakeWhileSequence.prototype.each = function each(fn) {
	    var predicate = this.predicate,
	        finished = false,
	        j = 0;

	    var result = this.parent.each(function(e, i) {
	      if (!predicate(e, i)) {
	        finished = true;
	        return false;
	      }

	      return fn(e, j++);
	    });

	    if (result instanceof AsyncHandle) {
	      return result;
	    }

	    return finished;
	  };

	  /**
	   * Creates a new sequence comprising all but the last N elements of this
	   * sequence.
	   *
	   * @public
	   * @param {number=} count The number of items to omit from the end of the
	   *     sequence (defaults to 1).
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * Lazy([1, 2, 3, 4]).initial()                    // sequence: [1, 2, 3]
	   * Lazy([1, 2, 3, 4]).initial(2)                   // sequence: [1, 2]
	   * Lazy([1, 2, 3]).filter(Lazy.identity).initial() // sequence: [1, 2]
	   */
	  Sequence.prototype.initial = function initial(count) {
	    return new InitialSequence(this, count);
	  };

	  function InitialSequence(parent, count) {
	    this.parent = parent;
	    this.count = typeof count === "number" ? count : 1;
	  }

	  InitialSequence.prototype = new Sequence();

	  InitialSequence.prototype.each = function each(fn) {
	    var index = this.parent.getIndex();
	    return index.take(index.length() - this.count).each(fn);
	  };

	  /**
	   * Creates a new sequence comprising the last N elements of this sequence, OR
	   * (if N is `undefined`) simply returns the last element of this sequence.
	   *
	   * @public
	   * @param {number=} count The number of items to take from the end of the
	   *     sequence.
	   * @returns {*} The new sequence (or the last element from this sequence
	   *     if no count was given).
	   *
	   * @examples
	   * Lazy([1, 2, 3]).last()                 // => 3
	   * Lazy([1, 2, 3]).last(2)                // sequence: [2, 3]
	   * Lazy([1, 2, 3]).filter(isEven).last(2) // sequence: [2]
	   */
	  Sequence.prototype.last = function last(count) {
	    if (typeof count === "undefined") {
	      return this.reverse().first();
	    }
	    return this.reverse().take(count).reverse();
	  };

	  /**
	   * Returns the first element in this sequence with property names and values
	   * matching those of the specified object.
	   *
	   * @public
	   * @param {Object} properties The properties that should be found on some
	   *     element in this sequence.
	   * @returns {*} The found element, or `undefined` if none exists in this
	   *     sequence.
	   *
	   * @examples
	   * var words = ["foo", "bar"];
	   *
	   * Lazy(words).findWhere({ 0: "f" }); // => "foo"
	   * Lazy(words).findWhere({ 0: "z" }); // => undefined
	   */
	  Sequence.prototype.findWhere = function findWhere(properties) {
	    return this.where(properties).first();
	  };

	  /**
	   * Creates a new sequence comprising all but the first N elements of this
	   * sequence.
	   *
	   * @public
	   * @aka skip, tail, rest
	   * @param {number=} count The number of items to omit from the beginning of the
	   *     sequence (defaults to 1).
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * Lazy([1, 2, 3, 4]).rest()  // sequence: [2, 3, 4]
	   * Lazy([1, 2, 3, 4]).rest(0) // sequence: [1, 2, 3, 4]
	   * Lazy([1, 2, 3, 4]).rest(2) // sequence: [3, 4]
	   * Lazy([1, 2, 3, 4]).rest(5) // sequence: []
	   */
	  Sequence.prototype.rest = function rest(count) {
	    return new DropSequence(this, count);
	  };

	  Sequence.prototype.skip =
	  Sequence.prototype.tail =
	  Sequence.prototype.drop = function drop(count) {
	    return this.rest(count);
	  };

	  /**
	   * @constructor
	   */
	  function DropSequence(parent, count) {
	    this.parent = parent;
	    this.count  = typeof count === "number" ? count : 1;
	  }

	  DropSequence.prototype = new Sequence();

	  DropSequence.prototype.each = function each(fn) {
	    var count   = this.count,
	        dropped = 0,
	        i       = 0;

	    return this.parent.each(function(e) {
	      if (dropped++ < count) { return; }
	      return fn(e, i++);
	    });
	  };

	  /**
	   * Creates a new sequence comprising the elements from this sequence *after*
	   * those that satisfy some predicate. The sequence starts with the first
	   * element that does not match the predicate.
	   *
	   * @public
	   * @aka skipWhile
	   * @param {Function} predicate
	   * @returns {Sequence} The new sequence
	   */
	  Sequence.prototype.dropWhile = function dropWhile(predicate) {
	    return new DropWhileSequence(this, predicate);
	  };

	  Sequence.prototype.skipWhile = function skipWhile(predicate) {
	    return this.dropWhile(predicate);
	  };

	  /**
	   * @constructor
	   */
	  function DropWhileSequence(parent, predicate) {
	    this.parent    = parent;
	    this.predicate = predicate;
	  }

	  DropWhileSequence.prototype = new Sequence();

	  DropWhileSequence.prototype.each = function each(fn) {
	    var predicate = this.predicate,
	        done      = false;

	    return this.parent.each(function(e) {
	      if (!done) {
	        if (predicate(e)) {
	          return;
	        }

	        done = true;
	      }

	      return fn(e);
	    });
	  };

	  /**
	   * Creates a new sequence with the same elements as this one, but ordered
	   * using the specified comparison function.
	   *
	   * This has essentially the same behavior as calling
	   * [`Array#sort`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort),
	   * but obviously instead of modifying the collection it returns a new
	   * {@link Sequence} object.
	   *
	   * @public
	   * @param {Function=} sortFn The function used to compare elements in the
	   *     sequence. The function will be passed two elements and should return:
	   *     - 1 if the first is greater
	   *     - -1 if the second is greater
	   *     - 0 if the two values are the same
	   * @param {boolean} descending Whether or not the resulting sequence should be
	   *     in descending order (defaults to `false`).
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * Lazy([5, 10, 1]).sort()                // sequence: [1, 5, 10]
	   * Lazy(['foo', 'bar']).sort()            // sequence: ['bar', 'foo']
	   * Lazy(['b', 'c', 'a']).sort(null, true) // sequence: ['c', 'b', 'a']
	   * Lazy([5, 10, 1]).sort(null, true)      // sequence: [10, 5, 1]
	   *
	   * // Sorting w/ custom comparison function
	   * Lazy(['a', 'ab', 'aa', 'ba', 'b', 'abc']).sort(function compare(x, y) {
	   *   if (x.length && (x.length !== y.length)) { return compare(x.length, y.length); }
	   *   if (x === y) { return 0; }
	   *   return x > y ? 1 : -1;
	   * });
	   * // => sequence: ['a', 'b', 'aa', 'ab', 'ba', 'abc']
	   */
	  Sequence.prototype.sort = function sort(sortFn, descending) {
	    sortFn || (sortFn = compare);
	    if (descending) { sortFn = reverseArguments(sortFn); }
	    return new SortedSequence(this, sortFn);
	  };

	  /**
	   * Creates a new sequence with the same elements as this one, but ordered by
	   * the results of the given function.
	   *
	   * You can pass:
	   *
	   * - a *string*, to sort by the named property
	   * - a function, to sort by the result of calling the function on each element
	   *
	   * @public
	   * @param {Function} sortFn The function to call on the elements in this
	   *     sequence, in order to sort them.
	   * @param {boolean} descending Whether or not the resulting sequence should be
	   *     in descending order (defaults to `false`).
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * function population(country) {
	   *   return country.pop;
	   * }
	   *
	   * function area(country) {
	   *   return country.sqkm;
	   * }
	   *
	   * var countries = [
	   *   { name: "USA", pop: 320000000, sqkm: 9600000 },
	   *   { name: "Brazil", pop: 194000000, sqkm: 8500000 },
	   *   { name: "Nigeria", pop: 174000000, sqkm: 924000 },
	   *   { name: "China", pop: 1350000000, sqkm: 9700000 },
	   *   { name: "Russia", pop: 143000000, sqkm: 17000000 },
	   *   { name: "Australia", pop: 23000000, sqkm: 7700000 }
	   * ];
	   *
	   * Lazy(countries).sortBy(population).last(3).pluck('name') // sequence: ["Brazil", "USA", "China"]
	   * Lazy(countries).sortBy(area).last(3).pluck('name')       // sequence: ["USA", "China", "Russia"]
	   * Lazy(countries).sortBy(area, true).first(3).pluck('name') // sequence: ["Russia", "China", "USA"]
	   *
	   * @benchmarks
	   * var randoms = Lazy.generate(Math.random).take(100).toArray();
	   *
	   * Lazy(randoms).sortBy(Lazy.identity).each(Lazy.noop) // lazy
	   * _.each(_.sortBy(randoms, Lazy.identity), _.noop)    // lodash
	   */
	  Sequence.prototype.sortBy = function sortBy(sortFn, descending) {
	    sortFn = createComparator(sortFn);
	    if (descending) { sortFn = reverseArguments(sortFn); }
	    return new SortedSequence(this, sortFn);
	  };

	  /**
	   * @constructor
	   */
	  function SortedSequence(parent, sortFn) {
	    this.parent = parent;
	    this.sortFn = sortFn;
	  }

	  SortedSequence.prototype = new Sequence();

	  SortedSequence.prototype.each = function each(fn) {
	    var sortFn = this.sortFn,
	        result = this.parent.toArray();

	    result.sort(sortFn);

	    return forEach(result, fn);
	  };

	  /**
	   * @examples
	   * var items = [{ a: 4 }, { a: 3 }, { a: 5 }];
	   *
	   * Lazy(items).sortBy('a').reverse();
	   * // => sequence: [{ a: 5 }, { a: 4 }, { a: 3 }]
	   *
	   * Lazy(items).sortBy('a').reverse().reverse();
	   * // => sequence: [{ a: 3 }, { a: 4 }, { a: 5 }]
	   */
	  SortedSequence.prototype.reverse = function reverse() {
	    return new SortedSequence(this.parent, reverseArguments(this.sortFn));
	  };

	  /**
	   * Creates a new {@link ObjectLikeSequence} comprising the elements in this
	   * one, grouped together according to some key. The value associated with each
	   * key in the resulting object-like sequence is an array containing all of
	   * the elements in this sequence with that key.
	   *
	   * @public
	   * @param {Function|string} keyFn The function to call on the elements in this
	   *     sequence to obtain a key by which to group them, or a string representing
	   *     a parameter to read from all the elements in this sequence.
	   * @param {Function|string} valFn (Optional) The function to call on the elements
	   *     in this sequence to assign to the value for each instance to appear in the
	   *     group, or a string representing a parameter to read from all the elements
	   *     in this sequence.
	   * @returns {ObjectLikeSequence} The new sequence.
	   *
	   * @examples
	   * function oddOrEven(x) {
	   *   return x % 2 === 0 ? 'even' : 'odd';
	   * }
	   * function square(x) {
	   *   return x*x;
	   * }
	   *
	   * var numbers = [1, 2, 3, 4, 5];
	   *
	   * Lazy(numbers).groupBy(oddOrEven)                     // sequence: { odd: [1, 3, 5], even: [2, 4] }
	   * Lazy(numbers).groupBy(oddOrEven).get("odd")          // => [1, 3, 5]
	   * Lazy(numbers).groupBy(oddOrEven).get("foo")          // => undefined
	   * Lazy(numbers).groupBy(oddOrEven, square).get("even") // => [4, 16]
	   *
	   * Lazy([
	   *   { name: 'toString' },
	   *   { name: 'toString' }
	   * ]).groupBy('name');
	   * // => sequence: {
	   *   'toString': [
	   *     { name: 'toString' },
	   *     { name: 'toString' }
	   *   ]
	   * }
	   */
	  Sequence.prototype.groupBy = function groupBy(keyFn, valFn) {
	    return new GroupedSequence(this, keyFn, valFn);
	  };

	  /**
	   * @constructor
	   */
	  function GroupedSequence(parent, keyFn, valFn) {
	    this.parent = parent;
	    this.keyFn  = keyFn;
	    this.valFn  = valFn;
	  }

	  // GroupedSequence must have its prototype set after ObjectLikeSequence has
	  // been fully initialized.

	  /**
	   * Creates a new {@link ObjectLikeSequence} comprising the elements in this
	   * one, indexed according to some key.
	   *
	   * @public
	   * @param {Function|string} keyFn The function to call on the elements in this
	   *     sequence to obtain a key by which to index them, or a string
	   *     representing a property to read from all the elements in this sequence.
	   * @param {Function|string} valFn (Optional) The function to call on the elements
	   *     in this sequence to assign to the value of the indexed object, or a string
	   *     representing a parameter to read from all the elements in this sequence.
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * var people = [
	   *   { name: 'Bob', age: 25 },
	   *   { name: 'Fred', age: 34 }
	   * ];
	   *
	   * var bob  = people[0],
	   *     fred = people[1];
	   *
	   * Lazy(people).indexBy('name')        // sequence: { 'Bob': bob, 'Fred': fred }
	   * Lazy(people).indexBy('name', 'age') // sequence: { 'Bob': 25, 'Fred': 34 }
	   */
	  Sequence.prototype.indexBy = function(keyFn, valFn) {
	    return new IndexedSequence(this, keyFn, valFn);
	  };

	  /**
	   * @constructor
	   */
	  function IndexedSequence(parent, keyFn, valFn) {
	    this.parent = parent;
	    this.keyFn  = keyFn;
	    this.valFn  = valFn;
	  }

	  // IndexedSequence must have its prototype set after ObjectLikeSequence has
	  // been fully initialized.

	  /**
	   * Creates a new {@link ObjectLikeSequence} containing the unique keys of all
	   * the elements in this sequence, each paired with the number of elements
	   * in this sequence having that key.
	   *
	   * @public
	   * @param {Function|string} keyFn The function to call on the elements in this
	   *     sequence to obtain a key by which to count them, or a string representing
	   *     a parameter to read from all the elements in this sequence.
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * function oddOrEven(x) {
	   *   return x % 2 === 0 ? 'even' : 'odd';
	   * }
	   *
	   * var numbers = [1, 2, 3, 4, 5];
	   *
	   * Lazy(numbers).countBy(oddOrEven)            // sequence: { odd: 3, even: 2 }
	   * Lazy(numbers).countBy(oddOrEven).get("odd") // => 3
	   * Lazy(numbers).countBy(oddOrEven).get("foo") // => undefined
	   */
	  Sequence.prototype.countBy = function countBy(keyFn) {
	    return new CountedSequence(this, keyFn);
	  };

	  /**
	   * @constructor
	   */
	  function CountedSequence(parent, keyFn) {
	    this.parent = parent;
	    this.keyFn  = keyFn;
	  }

	  // CountedSequence, like GroupedSequence, must have its prototype set after
	  // ObjectLikeSequence has been fully initialized.

	  /**
	   * Creates a new sequence with every unique element from this one appearing
	   * exactly once (i.e., with duplicates removed).
	   *
	   * @public
	   * @aka unique
	   * @param {Function} keyFn An optional function to produce the key for each
	   *     object. This key is then tested for uniqueness as  opposed to the
	   *     object reference.
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * Lazy([1, 2, 2, 3, 3, 3]).uniq() // sequence: [1, 2, 3]
	   * Lazy([{ name: 'mike' }, 
	   * 	{ name: 'sarah' }, 
	   * 	{ name: 'mike' }
	   * ]).uniq('name')
	   * // sequence: [{ name: 'mike' }, { name: 'sarah' }]
	   *
	   * @benchmarks
	   * function randomOf(array) {
	   *   return function() {
	   *     return array[Math.floor(Math.random() * array.length)];
	   *   };
	   * }
	   *
	   * var mostUnique = Lazy.generate(randomOf(_.range(100)), 100).toArray(),
	   *     someUnique = Lazy.generate(randomOf(_.range(50)), 100).toArray(),
	   *     mostDupes  = Lazy.generate(randomOf(_.range(5)), 100).toArray();
	   *
	   * Lazy(mostUnique).uniq().each(Lazy.noop) // lazy - mostly unique elements
	   * Lazy(someUnique).uniq().each(Lazy.noop) // lazy - some unique elements
	   * Lazy(mostDupes).uniq().each(Lazy.noop)  // lazy - mostly duplicate elements
	   * _.each(_.uniq(mostUnique), _.noop)      // lodash - mostly unique elements
	   * _.each(_.uniq(someUnique), _.noop)      // lodash - some unique elements
	   * _.each(_.uniq(mostDupes), _.noop)       // lodash - mostly duplicate elements
	   */
	  Sequence.prototype.uniq = function uniq(keyFn) {
	    return new UniqueSequence(this, keyFn);
	  };

	  Sequence.prototype.unique = function unique(keyFn) {
	    return this.uniq(keyFn);
	  };

	  /**
	   * @constructor
	   */
	  function UniqueSequence(parent, keyFn) {
	    this.parent = parent;
	    this.keyFn  = keyFn;
	  }

	  UniqueSequence.prototype = new Sequence();

	  UniqueSequence.prototype.each = function each(fn) {
	    var cache = new Set(),
	        keyFn = this.keyFn,
	        i     = 0;

	    if (keyFn) {
	      keyFn = createCallback(keyFn);
	      return this.parent.each(function(e) {
	        if (cache.add(keyFn(e))) {
	          return fn(e, i++);
	        }
	      });

	    } else {
	      return this.parent.each(function(e) {
	        if (cache.add(e)) {
	          return fn(e, i++);
	        }
	      });
	    }
	  };

	  /**
	   * Creates a new sequence by combining the elements from this sequence with
	   * corresponding elements from the specified array(s).
	   *
	   * @public
	   * @param {...Array} var_args One or more arrays of elements to combine with
	   *     those of this sequence.
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * Lazy([1, 2]).zip([3, 4]) // sequence: [[1, 3], [2, 4]]
	   *
	   * @benchmarks
	   * var smArrL = Lazy.range(10).toArray(),
	   *     smArrR = Lazy.range(10, 20).toArray(),
	   *     lgArrL = Lazy.range(100).toArray(),
	   *     lgArrR = Lazy.range(100, 200).toArray();
	   *
	   * Lazy(smArrL).zip(smArrR).each(Lazy.noop) // lazy - zipping 10-element arrays
	   * Lazy(lgArrL).zip(lgArrR).each(Lazy.noop) // lazy - zipping 100-element arrays
	   * _.each(_.zip(smArrL, smArrR), _.noop)    // lodash - zipping 10-element arrays
	   * _.each(_.zip(lgArrL, lgArrR), _.noop)    // lodash - zipping 100-element arrays
	   */
	  Sequence.prototype.zip = function zip(var_args) {
	    if (arguments.length === 1) {
	      return new SimpleZippedSequence(this, (/** @type {Array} */ var_args));
	    } else {
	      return new ZippedSequence(this, arraySlice.call(arguments, 0));
	    }
	  };

	  /**
	   * @constructor
	   */
	  function ZippedSequence(parent, arrays) {
	    this.parent = parent;
	    this.arrays = arrays;
	  }

	  ZippedSequence.prototype = new Sequence();

	  ZippedSequence.prototype.each = function each(fn) {
	    var arrays = this.arrays,
	        i = 0;
	    this.parent.each(function(e) {
	      var group = [e];
	      for (var j = 0; j < arrays.length; ++j) {
	        if (arrays[j].length > i) {
	          group.push(arrays[j][i]);
	        }
	      }
	      return fn(group, i++);
	    });
	  };

	  /**
	   * Creates a new sequence with the same elements as this one, in a randomized
	   * order.
	   *
	   * @public
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * Lazy([1, 2, 3, 4, 5]).shuffle().value() // =~ [1, 2, 3, 4, 5]
	   */
	  Sequence.prototype.shuffle = function shuffle() {
	    return new ShuffledSequence(this);
	  };

	  /**
	   * @constructor
	   */
	  function ShuffledSequence(parent) {
	    this.parent = parent;
	  }

	  ShuffledSequence.prototype = new Sequence();

	  ShuffledSequence.prototype.each = function each(fn) {
	    var shuffled = this.parent.toArray(),
	        floor = Math.floor,
	        random = Math.random,
	        j = 0;

	    for (var i = shuffled.length - 1; i > 0; --i) {
	      swap(shuffled, i, floor(random() * (i + 1)));
	      if (fn(shuffled[i], j++) === false) {
	        return;
	      }
	    }
	    fn(shuffled[0], j);
	  };

	  /**
	   * Creates a new sequence with every element from this sequence, and with arrays
	   * exploded so that a sequence of arrays (of arrays) becomes a flat sequence of
	   * values.
	   *
	   * @public
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * Lazy([1, [2, 3], [4, [5]]]).flatten() // sequence: [1, 2, 3, 4, 5]
	   * Lazy([1, Lazy([2, 3])]).flatten()     // sequence: [1, 2, 3]
	   */
	  Sequence.prototype.flatten = function flatten() {
	    return new FlattenedSequence(this);
	  };

	  /**
	   * @constructor
	   */
	  function FlattenedSequence(parent) {
	    this.parent = parent;
	  }

	  FlattenedSequence.prototype = new Sequence();

	  FlattenedSequence.prototype.each = function each(fn) {
	    var index = 0;

	    return this.parent.each(function recurseVisitor(e) {
	      if (e instanceof Array) {
	        return forEach(e, recurseVisitor);
	      }

	      if (e instanceof Sequence) {
	        return e.each(recurseVisitor);
	      }

	      return fn(e, index++);
	    });
	  };

	  /**
	   * Creates a new sequence with the same elements as this one, except for all
	   * falsy values (`false`, `0`, `""`, `null`, and `undefined`).
	   *
	   * @public
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * Lazy(["foo", null, "bar", undefined]).compact() // sequence: ["foo", "bar"]
	   */
	  Sequence.prototype.compact = function compact() {
	    return this.filter(function(e) { return !!e; });
	  };

	  /**
	   * Creates a new sequence with all the elements of this sequence that are not
	   * also among the specified arguments.
	   *
	   * @public
	   * @aka difference
	   * @param {...*} var_args The values, or array(s) of values, to be excluded from the
	   *     resulting sequence.
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * Lazy([1, 2, 3, 4, 5]).without(2, 3)   // sequence: [1, 4, 5]
	   * Lazy([1, 2, 3, 4, 5]).without([4, 5]) // sequence: [1, 2, 3]
	   */
	  Sequence.prototype.without = function without(var_args) {
	    return new WithoutSequence(this, arraySlice.call(arguments, 0));
	  };

	  Sequence.prototype.difference = function difference(var_args) {
	    return this.without.apply(this, arguments);
	  };

	  /**
	   * @constructor
	   */
	  function WithoutSequence(parent, values) {
	    this.parent = parent;
	    this.values = values;
	  }

	  WithoutSequence.prototype = new Sequence();

	  WithoutSequence.prototype.each = function each(fn) {
	    var set = createSet(this.values),
	        i = 0;
	    return this.parent.each(function(e) {
	      if (!set.contains(e)) {
	        return fn(e, i++);
	      }
	    });
	  };

	  /**
	   * Creates a new sequence with all the unique elements either in this sequence
	   * or among the specified arguments.
	   *
	   * @public
	   * @param {...*} var_args The values, or array(s) of values, to be additionally
	   *     included in the resulting sequence.
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * Lazy(["foo", "bar"]).union([])             // sequence: ["foo", "bar"]
	   * Lazy(["foo", "bar"]).union(["bar", "baz"]) // sequence: ["foo", "bar", "baz"]
	   */
	  Sequence.prototype.union = function union(var_args) {
	    return this.concat(var_args).uniq();
	  };

	  /**
	   * Creates a new sequence with all the elements of this sequence that also
	   * appear among the specified arguments.
	   *
	   * @public
	   * @param {...*} var_args The values, or array(s) of values, in which elements
	   *     from this sequence must also be included to end up in the resulting sequence.
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * Lazy(["foo", "bar"]).intersection([])             // sequence: []
	   * Lazy(["foo", "bar"]).intersection(["bar", "baz"]) // sequence: ["bar"]
	   */
	  Sequence.prototype.intersection = function intersection(var_args) {
	    if (arguments.length === 1 && arguments[0] instanceof Array) {
	      return new SimpleIntersectionSequence(this, (/** @type {Array} */ var_args));
	    } else {
	      return new IntersectionSequence(this, arraySlice.call(arguments, 0));
	    }
	  };

	  /**
	   * @constructor
	   */
	  function IntersectionSequence(parent, arrays) {
	    this.parent = parent;
	    this.arrays = arrays;
	  }

	  IntersectionSequence.prototype = new Sequence();

	  IntersectionSequence.prototype.each = function each(fn) {
	    var sets = Lazy(this.arrays).map(function(values) {
	      return new UniqueMemoizer(Lazy(values).getIterator());
	    });

	    var setIterator = new UniqueMemoizer(sets.getIterator()),
	        i = 0;

	    return this.parent.each(function(e) {
	      var includedInAll = true;
	      setIterator.each(function(set) {
	        if (!set.contains(e)) {
	          includedInAll = false;
	          return false;
	        }
	      });

	      if (includedInAll) {
	        return fn(e, i++);
	      }
	    });
	  };

	  /**
	   * @constructor
	   */
	  function UniqueMemoizer(iterator) {
	    this.iterator     = iterator;
	    this.set          = new Set();
	    this.memo         = [];
	    this.currentValue = undefined;
	  }

	  UniqueMemoizer.prototype.current = function current() {
	    return this.currentValue;
	  };

	  UniqueMemoizer.prototype.moveNext = function moveNext() {
	    var iterator = this.iterator,
	        set = this.set,
	        memo = this.memo,
	        current;

	    while (iterator.moveNext()) {
	      current = iterator.current();
	      if (set.add(current)) {
	        memo.push(current);
	        this.currentValue = current;
	        return true;
	      }
	    }
	    return false;
	  };

	  UniqueMemoizer.prototype.each = function each(fn) {
	    var memo = this.memo,
	        length = memo.length,
	        i = -1;

	    while (++i < length) {
	      if (fn(memo[i], i) === false) {
	        return false;
	      }
	    }

	    while (this.moveNext()) {
	      if (fn(this.currentValue, i++) === false) {
	        break;
	      }
	    }
	  };

	  UniqueMemoizer.prototype.contains = function contains(e) {
	    if (this.set.contains(e)) {
	      return true;
	    }

	    while (this.moveNext()) {
	      if (this.currentValue === e) {
	        return true;
	      }
	    }

	    return false;
	  };

	  /**
	   * Checks whether every element in this sequence satisfies a given predicate.
	   *
	   * @public
	   * @aka all
	   * @param {Function} predicate A function to call on (potentially) every element
	   *     in this sequence.
	   * @returns {boolean} True if `predicate` returns true for every element in the
	   *     sequence (or the sequence is empty). False if `predicate` returns false
	   *     for at least one element.
	   *
	   * @examples
	   * var numbers = [1, 2, 3, 4, 5];
	   *
	   * var objects = [{ foo: true }, { foo: false, bar: true }];
	   *
	   * Lazy(numbers).every(isEven)     // => false
	   * Lazy(numbers).every(isPositive) // => true
	   * Lazy(objects).all('foo')        // => false
	   * Lazy(objects).all('bar')        // => false
	   */
	  Sequence.prototype.every = function every(predicate) {
	    predicate = createCallback(predicate);

	    return this.each(function(e, i) {
	      return !!predicate(e, i);
	    });
	  };

	  Sequence.prototype.all = function all(predicate) {
	    return this.every(predicate);
	  };

	  /**
	   * Checks whether at least one element in this sequence satisfies a given
	   * predicate (or, if no predicate is specified, whether the sequence contains at
	   * least one element).
	   *
	   * @public
	   * @aka any
	   * @param {Function=} predicate A function to call on (potentially) every element
	   *     in this sequence.
	   * @returns {boolean} True if `predicate` returns true for at least one element
	   *     in the sequence. False if `predicate` returns false for every element (or
	   *     the sequence is empty).
	   *
	   * @examples
	   * var numbers = [1, 2, 3, 4, 5];
	   *
	   * Lazy(numbers).some()           // => true
	   * Lazy(numbers).some(isEven)     // => true
	   * Lazy(numbers).some(isNegative) // => false
	   * Lazy([]).some()                // => false
	   */
	  Sequence.prototype.some = function some(predicate) {
	    predicate = createCallback(predicate, true);

	    var success = false;
	    this.each(function(e) {
	      if (predicate(e)) {
	        success = true;
	        return false;
	      }
	    });
	    return success;
	  };

	  Sequence.prototype.any = function any(predicate) {
	    return this.some(predicate);
	  };

	  /**
	   * Checks whether NO elements in this sequence satisfy the given predicate
	   * (the opposite of {@link Sequence#all}, basically).
	   *
	   * @public
	   * @param {Function=} predicate A function to call on (potentially) every element
	   *     in this sequence.
	   * @returns {boolean} True if `predicate` does not return true for any element
	   *     in the sequence. False if `predicate` returns true for at least one
	   *     element.
	   *
	   * @examples
	   * var numbers = [1, 2, 3, 4, 5];
	   *
	   * Lazy(numbers).none()           // => false
	   * Lazy(numbers).none(isEven)     // => false
	   * Lazy(numbers).none(isNegative) // => true
	   * Lazy([]).none(isEven)          // => true
	   * Lazy([]).none(isNegative)      // => true
	   * Lazy([]).none()                // => true
	   */
	  Sequence.prototype.none = function none(predicate) {
	    return !this.any(predicate);
	  };

	  /**
	   * Checks whether the sequence has no elements.
	   *
	   * @public
	   * @returns {boolean} True if the sequence is empty, false if it contains at
	   *     least one element.
	   *
	   * @examples
	   * Lazy([]).isEmpty()        // => true
	   * Lazy([1, 2, 3]).isEmpty() // => false
	   */
	  Sequence.prototype.isEmpty = function isEmpty() {
	    return !this.any();
	  };

	  /**
	   * Performs (at worst) a linear search from the head of this sequence,
	   * returning the first index at which the specified value is found.
	   *
	   * @public
	   * @param {*} value The element to search for in the sequence.
	   * @returns {number} The index within this sequence where the given value is
	   *     located, or -1 if the sequence doesn't contain the value.
	   *
	   * @examples
	   * function reciprocal(x) { return 1 / x; }
	   *
	   * Lazy(["foo", "bar", "baz"]).indexOf("bar")   // => 1
	   * Lazy([1, 2, 3]).indexOf(4)                   // => -1
	   * Lazy([1, 2, 3]).map(reciprocal).indexOf(0.5) // => 1
	   */
	  Sequence.prototype.indexOf = function indexOf(value) {
	    var foundIndex = -1;
	    this.each(function(e, i) {
	      if (e === value) {
	        foundIndex = i;
	        return false;
	      }
	    });
	    return foundIndex;
	  };

	  /**
	   * Performs (at worst) a linear search from the tail of this sequence,
	   * returning the last index at which the specified value is found.
	   *
	   * @public
	   * @param {*} value The element to search for in the sequence.
	   * @returns {number} The last index within this sequence where the given value
	   *     is located, or -1 if the sequence doesn't contain the value.
	   *
	   * @examples
	   * Lazy(["a", "b", "c", "b", "a"]).lastIndexOf("b")    // => 3
	   * Lazy([1, 2, 3]).lastIndexOf(0)                      // => -1
	   * Lazy([2, 2, 1, 2, 4]).filter(isEven).lastIndexOf(2) // 2
	   */
	  Sequence.prototype.lastIndexOf = function lastIndexOf(value) {
	    var reversed = this.getIndex().reverse(),
	        index    = reversed.indexOf(value);
	    if (index !== -1) {
	      index = reversed.length() - index - 1;
	    }
	    return index;
	  };

	  /**
	   * Performs a binary search of this sequence, returning the lowest index where
	   * the given value is either found, or where it belongs (if it is not already
	   * in the sequence).
	   *
	   * This method assumes the sequence is in sorted order and will fail otherwise.
	   *
	   * @public
	   * @param {*} value The element to search for in the sequence.
	   * @returns {number} An index within this sequence where the given value is
	   *     located, or where it belongs in sorted order.
	   *
	   * @examples
	   * Lazy([1, 3, 6, 9]).sortedIndex(3)                    // => 1
	   * Lazy([1, 3, 6, 9]).sortedIndex(7)                    // => 3
	   * Lazy([5, 10, 15, 20]).filter(isEven).sortedIndex(10) // => 0
	   * Lazy([5, 10, 15, 20]).filter(isEven).sortedIndex(12) // => 1
	   */
	  Sequence.prototype.sortedIndex = function sortedIndex(value) {
	    var indexed = this.getIndex(),
	        lower   = 0,
	        upper   = indexed.length(),
	        i;

	    while (lower < upper) {
	      i = (lower + upper) >>> 1;
	      if (compare(indexed.get(i), value) === -1) {
	        lower = i + 1;
	      } else {
	        upper = i;
	      }
	    }
	    return lower;
	  };

	  /**
	   * Checks whether the given value is in this sequence.
	   *
	   * @public
	   * @param {*} value The element to search for in the sequence.
	   * @returns {boolean} True if the sequence contains the value, false if not.
	   *
	   * @examples
	   * var numbers = [5, 10, 15, 20];
	   *
	   * Lazy(numbers).contains(15) // => true
	   * Lazy(numbers).contains(13) // => false
	   */
	  Sequence.prototype.contains = function contains(value) {
	    return this.indexOf(value) !== -1;
	  };

	  /**
	   * Aggregates a sequence into a single value according to some accumulator
	   * function.
	   *
	   * For an asynchronous sequence, instead of immediately returning a result
	   * (which it can't, obviously), this method returns an {@link AsyncHandle}
	   * whose `onComplete` method can be called to supply a callback to handle the
	   * final result once iteration has completed.
	   *
	   * @public
	   * @aka inject, foldl
	   * @param {Function} aggregator The function through which to pass every element
	   *     in the sequence. For every element, the function will be passed the total
	   *     aggregated result thus far and the element itself, and should return a
	   *     new aggregated result.
	   * @param {*=} memo The starting value to use for the aggregated result
	   *     (defaults to the first element in the sequence).
	   * @returns {*} The result of the aggregation, or, for asynchronous sequences,
	   *     an {@link AsyncHandle} whose `onComplete` method accepts a callback to
	   *     handle the final result.
	   *
	   * @examples
	   * function multiply(x, y) { return x * y; }
	   *
	   * var numbers = [1, 2, 3, 4];
	   *
	   * Lazy(numbers).reduce(multiply)    // => 24
	   * Lazy(numbers).reduce(multiply, 5) // => 120
	   */
	  Sequence.prototype.reduce = function reduce(aggregator, memo) {
	    if (arguments.length < 2) {
	      return this.tail().reduce(aggregator, this.head());
	    }

	    var eachResult = this.each(function(e, i) {
	      memo = aggregator(memo, e, i);
	    });

	    // TODO: Think of a way more efficient solution to this problem.
	    if (eachResult instanceof AsyncHandle) {
	      return eachResult.then(function() { return memo; });
	    }

	    return memo;
	  };

	  Sequence.prototype.inject =
	  Sequence.prototype.foldl = function foldl(aggregator, memo) {
	    return this.reduce(aggregator, memo);
	  };

	  /**
	   * Aggregates a sequence, from the tail, into a single value according to some
	   * accumulator function.
	   *
	   * @public
	   * @aka foldr
	   * @param {Function} aggregator The function through which to pass every element
	   *     in the sequence. For every element, the function will be passed the total
	   *     aggregated result thus far and the element itself, and should return a
	   *     new aggregated result.
	   * @param {*} memo The starting value to use for the aggregated result.
	   * @returns {*} The result of the aggregation.
	   *
	   * @examples
	   * function append(s1, s2) {
	   *   return s1 + s2;
	   * }
	   *
	   * function isVowel(str) {
	   *   return "aeiou".indexOf(str) !== -1;
	   * }
	   *
	   * Lazy("abcde").reduceRight(append)                 // => "edcba"
	   * Lazy("abcde").filter(isVowel).reduceRight(append) // => "ea"
	   */
	  Sequence.prototype.reduceRight = function reduceRight(aggregator, memo) {
	    if (arguments.length < 2) {
	      return this.initial(1).reduceRight(aggregator, this.last());
	    }

	    // This bothers me... but frankly, calling reverse().reduce() is potentially
	    // going to eagerly evaluate the sequence anyway; so it's really not an issue.
	    var indexed = this.getIndex(),
	        i = indexed.length() - 1;
	    return indexed.reverse().reduce(function(m, e) {
	      return aggregator(m, e, i--);
	    }, memo);
	  };

	  Sequence.prototype.foldr = function foldr(aggregator, memo) {
	    return this.reduceRight(aggregator, memo);
	  };

	  /**
	   * Groups this sequence into consecutive (overlapping) segments of a specified
	   * length. If the underlying sequence has fewer elements than the specfied
	   * length, then this sequence will be empty.
	   *
	   * @public
	   * @param {number} length The length of each consecutive segment.
	   * @returns {Sequence} The resulting sequence of consecutive segments.
	   *
	   * @examples
	   * Lazy([]).consecutive(2)        // => sequence: []
	   * Lazy([1]).consecutive(2)       // => sequence: []
	   * Lazy([1, 2]).consecutive(2)    // => sequence: [[1, 2]]
	   * Lazy([1, 2, 3]).consecutive(2) // => sequence: [[1, 2], [2, 3]]
	   * Lazy([1, 2, 3]).consecutive(0) // => sequence: [[]]
	   * Lazy([1, 2, 3]).consecutive(1) // => sequence: [[1], [2], [3]]
	   */
	  Sequence.prototype.consecutive = function consecutive(count) {
	    var queue    = new Queue(count);
	    var segments = this.map(function(element) {
	      if (queue.add(element).count === count) {
	        return queue.toArray();
	      }
	    });
	    return segments.compact();
	  };

	  /**
	   * Breaks this sequence into chunks (arrays) of a specified length.
	   *
	   * @public
	   * @param {number} size The size of each chunk.
	   * @returns {Sequence} The resulting sequence of chunks.
	   *
	   * @examples
	   * Lazy([]).chunk(2)        // sequence: []
	   * Lazy([1, 2, 3]).chunk(2) // sequence: [[1, 2], [3]]
	   * Lazy([1, 2, 3]).chunk(1) // sequence: [[1], [2], [3]]
	   * Lazy([1, 2, 3]).chunk(4) // sequence: [[1, 2, 3]]
	   * Lazy([1, 2, 3]).chunk(0) // throws
	   */
	  Sequence.prototype.chunk = function chunk(size) {
	    if (size < 1) {
	      throw new Error("You must specify a positive chunk size.");
	    }

	    return new ChunkedSequence(this, size);
	  };

	  /**
	   * @constructor
	   */
	  function ChunkedSequence(parent, size) {
	    this.parent    = parent;
	    this.chunkSize = size;
	  }

	  ChunkedSequence.prototype = new Sequence();

	  ChunkedSequence.prototype.getIterator = function getIterator() {
	    return new ChunkedIterator(this.parent, this.chunkSize);
	  };

	  /**
	   * @constructor
	   */
	  function ChunkedIterator(sequence, size) {
	    this.iterator = sequence.getIterator();
	    this.size     = size;
	  }

	  ChunkedIterator.prototype.current = function current() {
	    return this.currentChunk;
	  };

	  ChunkedIterator.prototype.moveNext = function moveNext() {
	    var iterator  = this.iterator,
	        chunkSize = this.size,
	        chunk     = [];

	    while (chunk.length < chunkSize && iterator.moveNext()) {
	      chunk.push(iterator.current());
	    }

	    if (chunk.length === 0) {
	      return false;
	    }

	    this.currentChunk = chunk;
	    return true;
	  };

	  /**
	   * Passes each element in the sequence to the specified callback during
	   * iteration. This is like {@link Sequence#each}, except that it can be
	   * inserted anywhere in the middle of a chain of methods to "intercept" the
	   * values in the sequence at that point.
	   *
	   * @public
	   * @param {Function} callback A function to call on every element in the
	   *     sequence during iteration. The return value of this function does not
	   *     matter.
	   * @returns {Sequence} A sequence comprising the same elements as this one.
	   *
	   * @examples
	   * Lazy([1, 2, 3]).tap(fn).each(Lazy.noop); // calls fn 3 times
	   */
	  Sequence.prototype.tap = function tap(callback) {
	    return new TappedSequence(this, callback);
	  };

	  /**
	   * @constructor
	   */
	  function TappedSequence(parent, callback) {
	    this.parent = parent;
	    this.callback = callback;
	  }

	  TappedSequence.prototype = new Sequence();

	  TappedSequence.prototype.each = function each(fn) {
	    var callback = this.callback;
	    return this.parent.each(function(e, i) {
	      callback(e, i);
	      return fn(e, i);
	    });
	  };

	  /**
	   * Seaches for the first element in the sequence satisfying a given predicate.
	   *
	   * @public
	   * @aka detect
	   * @param {Function} predicate A function to call on (potentially) every element
	   *     in the sequence.
	   * @returns {*} The first element in the sequence for which `predicate` returns
	   *     `true`, or `undefined` if no such element is found.
	   *
	   * @examples
	   * function divisibleBy3(x) {
	   *   return x % 3 === 0;
	   * }
	   *
	   * var numbers = [5, 6, 7, 8, 9, 10];
	   *
	   * Lazy(numbers).find(divisibleBy3) // => 6
	   * Lazy(numbers).find(isNegative)   // => undefined
	   */
	  Sequence.prototype.find = function find(predicate) {
	    return this.filter(predicate).first();
	  };

	  Sequence.prototype.detect = function detect(predicate) {
	    return this.find(predicate);
	  };

	  /**
	   * Gets the minimum value in the sequence.
	   *
	   * @public
	   * @param {Function=} valueFn The function by which the value for comparison is
	   *     calculated for each element in the sequence.
	   * @returns {*} The element with the lowest value in the sequence, or
	   *     `Infinity` if the sequence is empty.
	   *
	   * @examples
	   * function negate(x) { return x * -1; }
	   *
	   * Lazy([]).min()                       // => Infinity
	   * Lazy([6, 18, 2, 49, 34]).min()       // => 2
	   * Lazy([6, 18, 2, 49, 34]).min(negate) // => 49
	   */
	  Sequence.prototype.min = function min(valueFn) {
	    if (typeof valueFn !== "undefined") {
	      return this.minBy(valueFn);
	    }

	    return this.reduce(function(x, y) { return y < x ? y : x; }, Infinity);
	  };

	  Sequence.prototype.minBy = function minBy(valueFn) {
	    valueFn = createCallback(valueFn);
	    return this.reduce(function(x, y) { return valueFn(y) < valueFn(x) ? y : x; });
	  };

	  /**
	   * Gets the maximum value in the sequence.
	   *
	   * @public
	   * @param {Function=} valueFn The function by which the value for comparison is
	   *     calculated for each element in the sequence.
	   * @returns {*} The element with the highest value in the sequence, or
	   *     `-Infinity` if the sequence is empty.
	   *
	   * @examples
	   * function reverseDigits(x) {
	   *   return Number(String(x).split('').reverse().join(''));
	   * }
	   *
	   * Lazy([]).max()                              // => -Infinity
	   * Lazy([6, 18, 2, 48, 29]).max()              // => 48
	   * Lazy([6, 18, 2, 48, 29]).max(reverseDigits) // => 29
	   */
	  Sequence.prototype.max = function max(valueFn) {
	    if (typeof valueFn !== "undefined") {
	      return this.maxBy(valueFn);
	    }

	    return this.reduce(function(x, y) { return y > x ? y : x; }, -Infinity);
	  };

	  Sequence.prototype.maxBy = function maxBy(valueFn) {
	    valueFn = createCallback(valueFn);
	    return this.reduce(function(x, y) { return valueFn(y) > valueFn(x) ? y : x; });
	  };

	  /**
	   * Gets the sum of the values in the sequence.
	   *
	   * @public
	   * @param {Function=} valueFn The function used to select the values that will
	   *     be summed up.
	   * @returns {*} The sum.
	   *
	   * @examples
	   * Lazy([]).sum()                     // => 0
	   * Lazy([1, 2, 3, 4]).sum()           // => 10
	   * Lazy([1.2, 3.4]).sum(Math.floor)   // => 4
	   * Lazy(['foo', 'bar']).sum('length') // => 6
	   */
	  Sequence.prototype.sum = function sum(valueFn) {
	    if (typeof valueFn !== "undefined") {
	      return this.sumBy(valueFn);
	    }

	    return this.reduce(function(x, y) { return x + y; }, 0);
	  };

	  Sequence.prototype.sumBy = function sumBy(valueFn) {
	    valueFn = createCallback(valueFn);
	    return this.reduce(function(x, y) { return x + valueFn(y); }, 0);
	  };

	  /**
	   * Creates a string from joining together all of the elements in this sequence,
	   * separated by the given delimiter.
	   *
	   * @public
	   * @aka toString
	   * @param {string=} delimiter The separator to insert between every element from
	   *     this sequence in the resulting string (defaults to `","`).
	   * @returns {string} The delimited string.
	   *
	   * @examples
	   * Lazy([6, 29, 1984]).join("/")  // => "6/29/1984"
	   * Lazy(["a", "b", "c"]).join()   // => "a,b,c"
	   * Lazy(["a", "b", "c"]).join("") // => "abc"
	   * Lazy([1, 2, 3]).join()         // => "1,2,3"
	   * Lazy([1, 2, 3]).join("")       // => "123"
	   * Lazy(["", "", ""]).join(",")   // => ",,"
	   */
	  Sequence.prototype.join = function join(delimiter) {
	    delimiter = typeof delimiter === "string" ? delimiter : ",";

	    return this.reduce(function(str, e, i) {
	      if (i > 0) {
	        str += delimiter;
	      }
	      return str + e;
	    }, "");
	  };

	  Sequence.prototype.toString = function toString(delimiter) {
	    return this.join(delimiter);
	  };

	  /**
	   * Creates a sequence, with the same elements as this one, that will be iterated
	   * over asynchronously when calling `each`.
	   *
	   * @public
	   * @param {number=} interval The approximate period, in milliseconds, that
	   *     should elapse between each element in the resulting sequence. Omitting
	   *     this argument will result in the fastest possible asynchronous iteration.
	   * @returns {AsyncSequence} The new asynchronous sequence.
	   *
	   * @examples
	   * Lazy([1, 2, 3]).async(100).each(fn) // calls fn 3 times asynchronously
	   */
	  Sequence.prototype.async = function async(interval) {
	    return new AsyncSequence(this, interval);
	  };

	  /**
	   * @constructor
	   */
	  function SimpleIntersectionSequence(parent, array) {
	    this.parent = parent;
	    this.array  = array;
	    this.each   = getEachForIntersection(array);
	  }

	  SimpleIntersectionSequence.prototype = new Sequence();

	  SimpleIntersectionSequence.prototype.eachMemoizerCache = function eachMemoizerCache(fn) {
	    var iterator = new UniqueMemoizer(Lazy(this.array).getIterator()),
	        i = 0;

	    return this.parent.each(function(e) {
	      if (iterator.contains(e)) {
	        return fn(e, i++);
	      }
	    });
	  };

	  SimpleIntersectionSequence.prototype.eachArrayCache = function eachArrayCache(fn) {
	    var array = this.array,
	        find  = arrayContains,
	        i = 0;

	    return this.parent.each(function(e) {
	      if (find(array, e)) {
	        return fn(e, i++);
	      }
	    });
	  };

	  function getEachForIntersection(source) {
	    if (source.length < 40) {
	      return SimpleIntersectionSequence.prototype.eachArrayCache;
	    } else {
	      return SimpleIntersectionSequence.prototype.eachMemoizerCache;
	    }
	  }

	  /**
	   * An optimized version of {@link ZippedSequence}, when zipping a sequence with
	   * only one array.
	   *
	   * @param {Sequence} parent The underlying sequence.
	   * @param {Array} array The array with which to zip the sequence.
	   * @constructor
	   */
	  function SimpleZippedSequence(parent, array) {
	    this.parent = parent;
	    this.array  = array;
	  }

	  SimpleZippedSequence.prototype = new Sequence();

	  SimpleZippedSequence.prototype.each = function each(fn) {
	    var array = this.array;
	    return this.parent.each(function(e, i) {
	      return fn([e, array[i]], i);
	    });
	  };

	  /**
	   * An `ArrayLikeSequence` is a {@link Sequence} that provides random access to
	   * its elements. This extends the API for iterating with the additional methods
	   * {@link #get} and {@link #length}, allowing a sequence to act as a "view" into
	   * a collection or other indexed data source.
	   *
	   * The initial sequence created by wrapping an array with `Lazy(array)` is an
	   * `ArrayLikeSequence`.
	   *
	   * All methods of `ArrayLikeSequence` that conceptually should return
	   * something like a array (with indexed access) return another
	   * `ArrayLikeSequence`, for example:
	   *
	   * - {@link Sequence#map}
	   * - {@link ArrayLikeSequence#slice}
	   * - {@link Sequence#take} and {@link Sequence#drop}
	   * - {@link Sequence#reverse}
	   *
	   * The above is not an exhaustive list. There are also certain other cases
	   * where it might be possible to return an `ArrayLikeSequence` (e.g., calling
	   * {@link Sequence#concat} with a single array argument), but this is not
	   * guaranteed by the API.
	   *
	   * Note that in many cases, it is not possible to provide indexed access
	   * without first performing at least a partial iteration of the underlying
	   * sequence. In these cases an `ArrayLikeSequence` will not be returned:
	   *
	   * - {@link Sequence#filter}
	   * - {@link Sequence#uniq}
	   * - {@link Sequence#union}
	   * - {@link Sequence#intersect}
	   *
	   * etc. The above methods only return ordinary {@link Sequence} objects.
	   *
	   * Defining custom array-like sequences
	   * ------------------------------------
	   *
	   * Creating a custom `ArrayLikeSequence` is essentially the same as creating a
	   * custom {@link Sequence}. You just have a couple more methods you need to
	   * implement: `get` and (optionally) `length`.
	   *
	   * Here's an example. Let's define a sequence type called `OffsetSequence` that
	   * offsets each of its parent's elements by a set distance, and circles back to
	   * the beginning after reaching the end. **Remember**: the initialization
	   * function you pass to {@link #define} should always accept a `parent` as its
	   * first parameter.
	   *
	   *     ArrayLikeSequence.define("offset", {
	   *       init: function(parent, offset) {
	   *         this.offset = offset;
	   *       },
	   *
	   *       get: function(i) {
	   *         return this.parent.get((i + this.offset) % this.parent.length());
	   *       }
	   *     });
	   *
	   * It's worth noting a couple of things here.
	   *
	   * First, Lazy's default implementation of `length` simply returns the parent's
	   * length. In this case, since an `OffsetSequence` will always have the same
	   * number of elements as its parent, that implementation is fine; so we don't
	   * need to override it.
	   *
	   * Second, the default implementation of `each` uses `get` and `length` to
	   * essentially create a `for` loop, which is fine here. If you want to implement
	   * `each` your own way, you can do that; but in most cases (as here), you can
	   * probably just stick with the default.
	   *
	   * So we're already done, after only implementing `get`! Pretty easy, huh?
	   *
	   * Now the `offset` method will be chainable from any `ArrayLikeSequence`. So
	   * for example:
	   *
	   *     Lazy([1, 2, 3]).map(mapFn).offset(3);
	   *
	   * ...will work, but:
	   *
	   *     Lazy([1, 2, 3]).filter(mapFn).offset(3);
	   *
	   * ...will not (because `filter` does not return an `ArrayLikeSequence`).
	   *
	   * (Also, as with the example provided for defining custom {@link Sequence}
	   * types, this example really could have been implemented using a function
	   * already available as part of Lazy.js: in this case, {@link Sequence#map}.)
	   *
	   * @public
	   * @constructor
	   *
	   * @examples
	   * Lazy([1, 2, 3])                    // instanceof Lazy.ArrayLikeSequence
	   * Lazy([1, 2, 3]).map(Lazy.identity) // instanceof Lazy.ArrayLikeSequence
	   * Lazy([1, 2, 3]).take(2)            // instanceof Lazy.ArrayLikeSequence
	   * Lazy([1, 2, 3]).drop(2)            // instanceof Lazy.ArrayLikeSequence
	   * Lazy([1, 2, 3]).reverse()          // instanceof Lazy.ArrayLikeSequence
	   * Lazy([1, 2, 3]).slice(1, 2)        // instanceof Lazy.ArrayLikeSequence
	   */
	  function ArrayLikeSequence() {}

	  ArrayLikeSequence.prototype = new Sequence();

	  /**
	   * Create a new constructor function for a type inheriting from
	   * `ArrayLikeSequence`.
	   *
	   * @public
	   * @param {string|Array.<string>} methodName The name(s) of the method(s) to be
	   *     used for constructing the new sequence. The method will be attached to
	   *     the `ArrayLikeSequence` prototype so that it can be chained with any other
	   *     methods that return array-like sequences.
	   * @param {Object} overrides An object containing function overrides for this
	   *     new sequence type. **Must** include `get`. *May* include `init`,
	   *     `length`, `getIterator`, and `each`. For each function, `this` will be
	   *     the new sequence and `this.parent` will be the source sequence.
	   * @returns {Function} A constructor for a new type inheriting from
	   *     `ArrayLikeSequence`.
	   *
	   * @examples
	   * Lazy.ArrayLikeSequence.define("offset", {
	   *   init: function(offset) {
	   *     this.offset = offset;
	   *   },
	   *
	   *   get: function(i) {
	   *     return this.parent.get((i + this.offset) % this.parent.length());
	   *   }
	   * });
	   *
	   * Lazy([1, 2, 3]).offset(1) // sequence: [2, 3, 1]
	   */
	  ArrayLikeSequence.define = function define(methodName, overrides) {
	    if (!overrides || typeof overrides.get !== 'function') {
	      throw new Error("A custom array-like sequence must implement *at least* get!");
	    }

	    return defineSequenceType(ArrayLikeSequence, methodName, overrides);
	  };

	  /**
	   * Returns the element at the specified index.
	   *
	   * @public
	   * @param {number} i The index to access.
	   * @returns {*} The element.
	   *
	   * @examples
	   * function increment(x) { return x + 1; }
	   *
	   * Lazy([1, 2, 3]).get(1)                // => 2
	   * Lazy([1, 2, 3]).get(-1)               // => undefined
	   * Lazy([1, 2, 3]).map(increment).get(1) // => 3
	   */
	  ArrayLikeSequence.prototype.get = function get(i) {
	    return this.parent.get(i);
	  };

	  /**
	   * Returns the length of the sequence.
	   *
	   * @public
	   * @returns {number} The length.
	   *
	   * @examples
	   * function increment(x) { return x + 1; }
	   *
	   * Lazy([]).length()                       // => 0
	   * Lazy([1, 2, 3]).length()                // => 3
	   * Lazy([1, 2, 3]).map(increment).length() // => 3
	   */
	  ArrayLikeSequence.prototype.length = function length() {
	    return this.parent.length();
	  };

	  /**
	   * Returns the current sequence (since it is already indexed).
	   */
	  ArrayLikeSequence.prototype.getIndex = function getIndex() {
	    return this;
	  };

	  /**
	   * An optimized version of {@link Sequence#getIterator}.
	   */
	  ArrayLikeSequence.prototype.getIterator = function getIterator() {
	    return new IndexedIterator(this);
	  };

	  /**
	   * An optimized version of {@link Iterator} meant to work with already-indexed
	   * sequences.
	   *
	   * @param {ArrayLikeSequence} sequence The sequence to iterate over.
	   * @constructor
	   */
	  function IndexedIterator(sequence) {
	    this.sequence = sequence;
	    this.index    = -1;
	  }

	  IndexedIterator.prototype.current = function current() {
	    return this.sequence.get(this.index);
	  };

	  IndexedIterator.prototype.moveNext = function moveNext() {
	    if (this.index >= this.sequence.length() - 1) {
	      return false;
	    }

	    ++this.index;
	    return true;
	  };

	  /**
	   * An optimized version of {@link Sequence#each}.
	   */
	  ArrayLikeSequence.prototype.each = function each(fn) {
	    var length = this.length(),
	        i = -1;

	    while (++i < length) {
	      if (fn(this.get(i), i) === false) {
	        return false;
	      }
	    }

	    return true;
	  };

	  /**
	   * Returns a new sequence with the same elements as this one, minus the last
	   * element.
	   *
	   * @public
	   * @returns {ArrayLikeSequence} The new array-like sequence.
	   *
	   * @examples
	   * Lazy([1, 2, 3]).pop() // sequence: [1, 2]
	   * Lazy([]).pop()        // sequence: []
	   */
	  ArrayLikeSequence.prototype.pop = function pop() {
	    return this.initial();
	  };

	  /**
	   * Returns a new sequence with the same elements as this one, minus the first
	   * element.
	   *
	   * @public
	   * @returns {ArrayLikeSequence} The new array-like sequence.
	   *
	   * @examples
	   * Lazy([1, 2, 3]).shift() // sequence: [2, 3]
	   * Lazy([]).shift()        // sequence: []
	   */
	  ArrayLikeSequence.prototype.shift = function shift() {
	    return this.drop();
	  };

	  /**
	   * Returns a new sequence comprising the portion of this sequence starting
	   * from the specified starting index and continuing until the specified ending
	   * index or to the end of the sequence.
	   *
	   * @public
	   * @param {number} begin The index at which the new sequence should start.
	   * @param {number=} end The index at which the new sequence should end.
	   * @returns {ArrayLikeSequence} The new array-like sequence.
	   *
	   * @examples
	   * Lazy([1, 2, 3, 4, 5]).slice(0)     // sequence: [1, 2, 3, 4, 5]
	   * Lazy([1, 2, 3, 4, 5]).slice(2)     // sequence: [3, 4, 5]
	   * Lazy([1, 2, 3, 4, 5]).slice(2, 4)  // sequence: [3, 4]
	   * Lazy([1, 2, 3, 4, 5]).slice(-1)    // sequence: [5]
	   * Lazy([1, 2, 3, 4, 5]).slice(1, -1) // sequence: [2, 3, 4]
	   * Lazy([1, 2, 3, 4, 5]).slice(0, 10) // sequence: [1, 2, 3, 4, 5]
	   */
	  ArrayLikeSequence.prototype.slice = function slice(begin, end) {
	    var length = this.length();

	    if (begin < 0) {
	      begin = length + begin;
	    }

	    var result = this.drop(begin);

	    if (typeof end === "number") {
	      if (end < 0) {
	        end = length + end;
	      }
	      result = result.take(end - begin);
	    }

	    return result;
	  };

	  /**
	   * An optimized version of {@link Sequence#map}, which creates an
	   * {@link ArrayLikeSequence} so that the result still provides random access.
	   *
	   * @public
	   *
	   * @examples
	   * Lazy([1, 2, 3]).map(Lazy.identity) // instanceof Lazy.ArrayLikeSequence
	   */
	  ArrayLikeSequence.prototype.map = function map(mapFn) {
	    return new IndexedMappedSequence(this, createCallback(mapFn));
	  };

	  /**
	   * @constructor
	   */
	  function IndexedMappedSequence(parent, mapFn) {
	    this.parent = parent;
	    this.mapFn  = mapFn;
	  }

	  IndexedMappedSequence.prototype = new ArrayLikeSequence();

	  IndexedMappedSequence.prototype.get = function get(i) {
	    if (i < 0 || i >= this.parent.length()) {
	      return undefined;
	    }

	    return this.mapFn(this.parent.get(i), i);
	  };

	  /**
	   * An optimized version of {@link Sequence#filter}.
	   */
	  ArrayLikeSequence.prototype.filter = function filter(filterFn) {
	    return new IndexedFilteredSequence(this, createCallback(filterFn));
	  };

	  /**
	   * @constructor
	   */
	  function IndexedFilteredSequence(parent, filterFn) {
	    this.parent   = parent;
	    this.filterFn = filterFn;
	  }

	  IndexedFilteredSequence.prototype = new FilteredSequence();

	  IndexedFilteredSequence.prototype.each = function each(fn) {
	    var parent = this.parent,
	        filterFn = this.filterFn,
	        length = this.parent.length(),
	        i = -1,
	        j = 0,
	        e;

	    while (++i < length) {
	      e = parent.get(i);
	      if (filterFn(e, i) && fn(e, j++) === false) {
	        return false;
	      }
	    }

	    return true;
	  };

	  /**
	   * An optimized version of {@link Sequence#reverse}, which creates an
	   * {@link ArrayLikeSequence} so that the result still provides random access.
	   *
	   * @public
	   *
	   * @examples
	   * Lazy([1, 2, 3]).reverse() // instanceof Lazy.ArrayLikeSequence
	   */
	  ArrayLikeSequence.prototype.reverse = function reverse() {
	    return new IndexedReversedSequence(this);
	  };

	  /**
	   * @constructor
	   */
	  function IndexedReversedSequence(parent) {
	    this.parent = parent;
	  }

	  IndexedReversedSequence.prototype = new ArrayLikeSequence();

	  IndexedReversedSequence.prototype.get = function get(i) {
	    return this.parent.get(this.length() - i - 1);
	  };

	  /**
	   * An optimized version of {@link Sequence#first}, which creates an
	   * {@link ArrayLikeSequence} so that the result still provides random access.
	   *
	   * @public
	   *
	   * @examples
	   * Lazy([1, 2, 3]).first(2) // instanceof Lazy.ArrayLikeSequence
	   */
	  ArrayLikeSequence.prototype.first = function first(count) {
	    if (typeof count === "undefined") {
	      return this.get(0);
	    }

	    return new IndexedTakeSequence(this, count);
	  };

	  /**
	   * @constructor
	   */
	  function IndexedTakeSequence(parent, count) {
	    this.parent = parent;
	    this.count  = count;
	  }

	  IndexedTakeSequence.prototype = new ArrayLikeSequence();

	  IndexedTakeSequence.prototype.length = function length() {
	    var parentLength = this.parent.length();
	    return this.count <= parentLength ? this.count : parentLength;
	  };

	  /**
	   * An optimized version of {@link Sequence#rest}, which creates an
	   * {@link ArrayLikeSequence} so that the result still provides random access.
	   *
	   * @public
	   *
	   * @examples
	   * Lazy([1, 2, 3]).rest() // instanceof Lazy.ArrayLikeSequence
	   */
	  ArrayLikeSequence.prototype.rest = function rest(count) {
	    return new IndexedDropSequence(this, count);
	  };

	  /**
	   * @constructor
	   */
	  function IndexedDropSequence(parent, count) {
	    this.parent = parent;
	    this.count  = typeof count === "number" ? count : 1;
	  }

	  IndexedDropSequence.prototype = new ArrayLikeSequence();

	  IndexedDropSequence.prototype.get = function get(i) {
	    return this.parent.get(this.count + i);
	  };

	  IndexedDropSequence.prototype.length = function length() {
	    var parentLength = this.parent.length();
	    return this.count <= parentLength ? parentLength - this.count : 0;
	  };

	  /**
	   * An optimized version of {@link Sequence#concat} that returns another
	   * {@link ArrayLikeSequence} *if* the argument is an array.
	   *
	   * @public
	   * @param {...*} var_args
	   *
	   * @examples
	   * Lazy([1, 2]).concat([3, 4]) // instanceof Lazy.ArrayLikeSequence
	   * Lazy([1, 2]).concat([3, 4]) // sequence: [1, 2, 3, 4]
	   */
	  ArrayLikeSequence.prototype.concat = function concat(var_args) {
	    if (arguments.length === 1 && arguments[0] instanceof Array) {
	      return new IndexedConcatenatedSequence(this, (/** @type {Array} */ var_args));
	    } else {
	      return Sequence.prototype.concat.apply(this, arguments);
	    }
	  };

	  /**
	   * @constructor
	   */
	  function IndexedConcatenatedSequence(parent, other) {
	    this.parent = parent;
	    this.other  = other;
	  }

	  IndexedConcatenatedSequence.prototype = new ArrayLikeSequence();

	  IndexedConcatenatedSequence.prototype.get = function get(i) {
	    var parentLength = this.parent.length();
	    if (i < parentLength) {
	      return this.parent.get(i);
	    } else {
	      return this.other[i - parentLength];
	    }
	  };

	  IndexedConcatenatedSequence.prototype.length = function length() {
	    return this.parent.length() + this.other.length;
	  };

	  /**
	   * An optimized version of {@link Sequence#uniq}.
	   */
	  ArrayLikeSequence.prototype.uniq = function uniq(keyFn) {
	    return new IndexedUniqueSequence(this, createCallback(keyFn));
	  };

	  /**
	   * @param {ArrayLikeSequence} parent
	   * @constructor
	   */
	  function IndexedUniqueSequence(parent, keyFn) {
	    this.parent = parent;
	    this.each   = getEachForParent(parent);
	    this.keyFn  = keyFn;
	  }

	  IndexedUniqueSequence.prototype = new Sequence();

	  IndexedUniqueSequence.prototype.eachArrayCache = function eachArrayCache(fn) {
	    // Basically the same implementation as w/ the set, but using an array because
	    // it's cheaper for smaller sequences.
	    var parent = this.parent,
	        keyFn  = this.keyFn,
	        length = parent.length(),
	        cache  = [],
	        find   = arrayContains,
	        key, value,
	        i = -1,
	        j = 0;

	    while (++i < length) {
	      value = parent.get(i);
	      key = keyFn(value);
	      if (!find(cache, key)) {
	        cache.push(key);
	        if (fn(value, j++) === false) {
	          return false;
	        }
	      }
	    }
	  };

	  IndexedUniqueSequence.prototype.eachSetCache = UniqueSequence.prototype.each;

	  function getEachForParent(parent) {
	    if (parent.length() < 100) {
	      return IndexedUniqueSequence.prototype.eachArrayCache;
	    } else {
	      return UniqueSequence.prototype.each;
	    }
	  }

	  // Now that we've fully initialized the ArrayLikeSequence prototype, we can
	  // set the prototype for MemoizedSequence.

	  MemoizedSequence.prototype = new ArrayLikeSequence();

	  MemoizedSequence.prototype.cache = function cache() {
	    return this.cachedResult || (this.cachedResult = this.parent.toArray());
	  };

	  MemoizedSequence.prototype.get = function get(i) {
	    return this.cache()[i];
	  };

	  MemoizedSequence.prototype.length = function length() {
	    return this.cache().length;
	  };

	  MemoizedSequence.prototype.slice = function slice(begin, end) {
	    return this.cache().slice(begin, end);
	  };

	  MemoizedSequence.prototype.toArray = function toArray() {
	    return this.cache().slice(0);
	  };

	  /**
	   * ArrayWrapper is the most basic {@link Sequence}. It directly wraps an array
	   * and implements the same methods as {@link ArrayLikeSequence}, but more
	   * efficiently.
	   *
	   * @constructor
	   */
	  function ArrayWrapper(source) {
	    this.source = source;
	  }

	  ArrayWrapper.prototype = new ArrayLikeSequence();

	  ArrayWrapper.prototype.root = function root() {
	    return this;
	  };

	  ArrayWrapper.prototype.isAsync = function isAsync() {
	    return false;
	  };

	  /**
	   * Returns the element at the specified index in the source array.
	   *
	   * @param {number} i The index to access.
	   * @returns {*} The element.
	   */
	  ArrayWrapper.prototype.get = function get(i) {
	    return this.source[i];
	  };

	  /**
	   * Returns the length of the source array.
	   *
	   * @returns {number} The length.
	   */
	  ArrayWrapper.prototype.length = function length() {
	    return this.source.length;
	  };

	  /**
	   * An optimized version of {@link Sequence#each}.
	   */
	  ArrayWrapper.prototype.each = function each(fn) {
	    return forEach(this.source, fn);
	  };

	  /**
	   * An optimized version of {@link Sequence#map}.
	   */
	  ArrayWrapper.prototype.map = function map(mapFn) {
	    return new MappedArrayWrapper(this, createCallback(mapFn));
	  };

	  /**
	   * An optimized version of {@link Sequence#filter}.
	   */
	  ArrayWrapper.prototype.filter = function filter(filterFn) {
	    return new FilteredArrayWrapper(this, createCallback(filterFn));
	  };

	  /**
	   * An optimized version of {@link Sequence#uniq}.
	   */
	  ArrayWrapper.prototype.uniq = function uniq(keyFn) {
	    return new UniqueArrayWrapper(this, keyFn);
	  };

	  /**
	   * An optimized version of {@link ArrayLikeSequence#concat}.
	   *
	   * @param {...*} var_args
	   */
	  ArrayWrapper.prototype.concat = function concat(var_args) {
	    if (arguments.length === 1 && arguments[0] instanceof Array) {
	      return new ConcatArrayWrapper(this, (/** @type {Array} */ var_args));
	    } else {
	      return ArrayLikeSequence.prototype.concat.apply(this, arguments);
	    }
	  };

	  /**
	   * An optimized version of {@link Sequence#toArray}.
	   */
	  ArrayWrapper.prototype.toArray = function toArray() {
	    return this.source.slice(0);
	  };

	  /**
	   * @constructor
	   */
	  function MappedArrayWrapper(parent, mapFn) {
	    this.parent = parent;
	    this.mapFn  = mapFn;
	  }

	  MappedArrayWrapper.prototype = new ArrayLikeSequence();

	  MappedArrayWrapper.prototype.get = function get(i) {
	    var source = this.parent.source;

	    if (i < 0 || i >= source.length) {
	      return undefined;
	    }

	    return this.mapFn(source[i]);
	  };

	  MappedArrayWrapper.prototype.length = function length() {
	    return this.parent.source.length;
	  };

	  MappedArrayWrapper.prototype.each = function each(fn) {
	    var source = this.parent.source,
	        length = source.length,
	        mapFn  = this.mapFn,
	        i = -1;

	    while (++i < length) {
	      if (fn(mapFn(source[i], i), i) === false) {
	        return false;
	      }
	    }

	    return true;
	  };

	  /**
	   * @constructor
	   */
	  function FilteredArrayWrapper(parent, filterFn) {
	    this.parent   = parent;
	    this.filterFn = filterFn;
	  }

	  FilteredArrayWrapper.prototype = new FilteredSequence();

	  FilteredArrayWrapper.prototype.each = function each(fn) {
	    var source = this.parent.source,
	        filterFn = this.filterFn,
	        length = source.length,
	        i = -1,
	        j = 0,
	        e;

	    while (++i < length) {
	      e = source[i];
	      if (filterFn(e, i) && fn(e, j++) === false) {
	        return false;
	      }
	    }

	    return true;
	  };

	  /**
	   * @constructor
	   */
	  function UniqueArrayWrapper(parent, keyFn) {
	    this.parent = parent;
	    this.each   = getEachForSource(parent.source);
	    this.keyFn  = keyFn;
	  }

	  UniqueArrayWrapper.prototype = new Sequence();

	  UniqueArrayWrapper.prototype.eachNoCache = function eachNoCache(fn) {
	    var source = this.parent.source,
	        keyFn  = this.keyFn,
	        length = source.length,
	        find   = arrayContainsBefore,
	        value,

	        // Yes, this is hideous.
	        // Trying to get performance first, will refactor next!
	        i = -1,
	        k = 0;

	    while (++i < length) {
	      value = source[i];
	      if (!find(source, value, i, keyFn) && fn(value, k++) === false) {
	        return false;
	      }
	    }

	    return true;
	  };

	  UniqueArrayWrapper.prototype.eachArrayCache = function eachArrayCache(fn) {
	    // Basically the same implementation as w/ the set, but using an array because
	    // it's cheaper for smaller sequences.
	    var source = this.parent.source,
	        keyFn  = this.keyFn,
	        length = source.length,
	        cache  = [],
	        find   = arrayContains,
	        key, value,
	        i = -1,
	        j = 0;

	    if (keyFn) {
	      keyFn = createCallback(keyFn);
	      while (++i < length) {
	        value = source[i];
	        key = keyFn(value);
	        if (!find(cache, key)) {
	          cache.push(key);
	          if (fn(value, j++) === false) {
	            return false;
	          }
	        }
	      }

	    } else {
	      while (++i < length) {
	        value = source[i];
	        if (!find(cache, value)) {
	          cache.push(value);
	          if (fn(value, j++) === false) {
	            return false;
	          }
	        }
	      }
	    }

	    return true;
	  };

	  UniqueArrayWrapper.prototype.eachSetCache = UniqueSequence.prototype.each;

	  /**
	   * My latest findings here...
	   *
	   * So I hadn't really given the set-based approach enough credit. The main issue
	   * was that my Set implementation was totally not optimized at all. After pretty
	   * heavily optimizing it (just take a look; it's a monstrosity now!), it now
	   * becomes the fastest option for much smaller values of N.
	   */
	  function getEachForSource(source) {
	    if (source.length < 40) {
	      return UniqueArrayWrapper.prototype.eachNoCache;
	    } else if (source.length < 100) {
	      return UniqueArrayWrapper.prototype.eachArrayCache;
	    } else {
	      return UniqueArrayWrapper.prototype.eachSetCache;
	    }
	  }

	  /**
	   * @constructor
	   */
	  function ConcatArrayWrapper(parent, other) {
	    this.parent = parent;
	    this.other  = other;
	  }

	  ConcatArrayWrapper.prototype = new ArrayLikeSequence();

	  ConcatArrayWrapper.prototype.get = function get(i) {
	    var source = this.parent.source,
	        sourceLength = source.length;

	    if (i < sourceLength) {
	      return source[i];
	    } else {
	      return this.other[i - sourceLength];
	    }
	  };

	  ConcatArrayWrapper.prototype.length = function length() {
	    return this.parent.source.length + this.other.length;
	  };

	  ConcatArrayWrapper.prototype.each = function each(fn) {
	    var source = this.parent.source,
	        sourceLength = source.length,
	        other = this.other,
	        otherLength = other.length,
	        i = 0,
	        j = -1;

	    while (++j < sourceLength) {
	      if (fn(source[j], i++) === false) {
	        return false;
	      }
	    }

	    j = -1;
	    while (++j < otherLength) {
	      if (fn(other[j], i++) === false) {
	        return false;
	      }
	    }

	    return true;
	  };

	  /**
	   * An `ObjectLikeSequence` object represents a sequence of key/value pairs.
	   *
	   * The initial sequence you get by wrapping an object with `Lazy(object)` is
	   * an `ObjectLikeSequence`.
	   *
	   * All methods of `ObjectLikeSequence` that conceptually should return
	   * something like an object return another `ObjectLikeSequence`.
	   *
	   * @public
	   * @constructor
	   *
	   * @examples
	   * var obj = { foo: 'bar' };
	   *
	   * Lazy(obj).assign({ bar: 'baz' })   // instanceof Lazy.ObjectLikeSequence
	   * Lazy(obj).defaults({ bar: 'baz' }) // instanceof Lazy.ObjectLikeSequence
	   * Lazy(obj).invert()                 // instanceof Lazy.ObjectLikeSequence
	   */
	  function ObjectLikeSequence() {}

	  ObjectLikeSequence.prototype = new Sequence();

	  /**
	   * Create a new constructor function for a type inheriting from
	   * `ObjectLikeSequence`.
	   *
	   * @public
	   * @param {string|Array.<string>} methodName The name(s) of the method(s) to be
	   *     used for constructing the new sequence. The method will be attached to
	   *     the `ObjectLikeSequence` prototype so that it can be chained with any other
	   *     methods that return object-like sequences.
	   * @param {Object} overrides An object containing function overrides for this
	   *     new sequence type. **Must** include `each`. *May* include `init` and
	   *     `get` (for looking up an element by key).
	   * @returns {Function} A constructor for a new type inheriting from
	   *     `ObjectLikeSequence`.
	   *
	   * @examples
	   * function downcaseKey(value, key) {
	   *   return [key.toLowerCase(), value];
	   * }
	   *
	   * Lazy.ObjectLikeSequence.define("caseInsensitive", {
	   *   init: function() {
	   *     var downcased = this.parent
	   *       .map(downcaseKey)
	   *       .toObject();
	   *     this.downcased = Lazy(downcased);
	   *   },
	   *
	   *   get: function(key) {
	   *     return this.downcased.get(key.toLowerCase());
	   *   },
	   *
	   *   each: function(fn) {
	   *     return this.downcased.each(fn);
	   *   }
	   * });
	   *
	   * Lazy({ Foo: 'bar' }).caseInsensitive()            // sequence: { foo: 'bar' }
	   * Lazy({ FOO: 'bar' }).caseInsensitive().get('foo') // => 'bar'
	   * Lazy({ FOO: 'bar' }).caseInsensitive().get('FOO') // => 'bar'
	   */
	  ObjectLikeSequence.define = function define(methodName, overrides) {
	    if (!overrides || typeof overrides.each !== 'function') {
	      throw new Error("A custom object-like sequence must implement *at least* each!");
	    }

	    return defineSequenceType(ObjectLikeSequence, methodName, overrides);
	  };

	  ObjectLikeSequence.prototype.value = function value() {
	    return this.toObject();
	  };

	  /**
	   * Gets the element at the specified key in this sequence.
	   *
	   * @public
	   * @param {string} key The key.
	   * @returns {*} The element.
	   *
	   * @examples
	   * Lazy({ foo: "bar" }).get("foo")                          // => "bar"
	   * Lazy({ foo: "bar" }).extend({ foo: "baz" }).get("foo")   // => "baz"
	   * Lazy({ foo: "bar" }).defaults({ bar: "baz" }).get("bar") // => "baz"
	   * Lazy({ foo: "bar" }).invert().get("bar")                 // => "foo"
	   * Lazy({ foo: 1, bar: 2 }).pick(["foo"]).get("foo")        // => 1
	   * Lazy({ foo: 1, bar: 2 }).pick(["foo"]).get("bar")        // => undefined
	   * Lazy({ foo: 1, bar: 2 }).omit(["foo"]).get("bar")        // => 2
	   * Lazy({ foo: 1, bar: 2 }).omit(["foo"]).get("foo")        // => undefined
	   */
	  ObjectLikeSequence.prototype.get = function get(key) {
	    var pair = this.pairs().find(function(pair) {
	      return pair[0] === key;
	    });

	    return pair ? pair[1] : undefined;
	  };

	  /**
	   * Returns a {@link Sequence} whose elements are the keys of this object-like
	   * sequence.
	   *
	   * @public
	   * @returns {Sequence} The sequence based on this sequence's keys.
	   *
	   * @examples
	   * Lazy({ hello: "hola", goodbye: "hasta luego" }).keys() // sequence: ["hello", "goodbye"]
	   */
	  ObjectLikeSequence.prototype.keys = function keys() {
	    return this.map(function(v, k) { return k; });
	  };

	  /**
	   * Returns a {@link Sequence} whose elements are the values of this object-like
	   * sequence.
	   *
	   * @public
	   * @returns {Sequence} The sequence based on this sequence's values.
	   *
	   * @examples
	   * Lazy({ hello: "hola", goodbye: "hasta luego" }).values() // sequence: ["hola", "hasta luego"]
	   */
	  ObjectLikeSequence.prototype.values = function values() {
	    return this.map(function(v, k) { return v; });
	  };

	  /**
	   * Throws an exception. Asynchronous iteration over object-like sequences is
	   * not supported.
	   *
	   * @public
	   * @examples
	   * Lazy({ foo: 'bar' }).async() // throws
	   */
	  ObjectLikeSequence.prototype.async = function async() {
	    throw new Error('An ObjectLikeSequence does not support asynchronous iteration.');
	  };

	  ObjectLikeSequence.prototype.filter = function filter(filterFn) {
	    return new FilteredObjectLikeSequence(this, createCallback(filterFn));
	  };

	  function FilteredObjectLikeSequence(parent, filterFn) {
	    this.parent = parent;
	    this.filterFn = filterFn;
	  }

	  FilteredObjectLikeSequence.prototype = new ObjectLikeSequence();

	  FilteredObjectLikeSequence.prototype.each = function each(fn) {
	    var filterFn = this.filterFn;

	    return this.parent.each(function(v, k) {
	      if (filterFn(v, k)) {
	        return fn(v, k);
	      }
	    });
	  };

	  /**
	   * Returns this same sequence. (Reversing an object-like sequence doesn't make
	   * any sense.)
	   */
	  ObjectLikeSequence.prototype.reverse = function reverse() {
	    return this;
	  };

	  /**
	   * Returns an {@link ObjectLikeSequence} whose elements are the combination of
	   * this sequence and another object. In the case of a key appearing in both this
	   * sequence and the given object, the other object's value will override the
	   * one in this sequence.
	   *
	   * @public
	   * @aka extend
	   * @param {Object} other The other object to assign to this sequence.
	   * @returns {ObjectLikeSequence} A new sequence comprising elements from this
	   *     sequence plus the contents of `other`.
	   *
	   * @examples
	   * Lazy({ "uno": 1, "dos": 2 }).assign({ "tres": 3 }) // sequence: { uno: 1, dos: 2, tres: 3 }
	   * Lazy({ foo: "bar" }).assign({ foo: "baz" });       // sequence: { foo: "baz" }
	   */
	  ObjectLikeSequence.prototype.assign = function assign(other) {
	    return new AssignSequence(this, other);
	  };

	  ObjectLikeSequence.prototype.extend = function extend(other) {
	    return this.assign(other);
	  };

	  /**
	   * @constructor
	   */
	  function AssignSequence(parent, other) {
	    this.parent = parent;
	    this.other  = other;
	  }

	  AssignSequence.prototype = new ObjectLikeSequence();

	  AssignSequence.prototype.get = function get(key) {
	    return this.other[key] || this.parent.get(key);
	  };

	  AssignSequence.prototype.each = function each(fn) {
	    var merged = new Set(),
	        done   = false;

	    Lazy(this.other).each(function(value, key) {
	      if (fn(value, key) === false) {
	        done = true;
	        return false;
	      }

	      merged.add(key);
	    });

	    if (!done) {
	      return this.parent.each(function(value, key) {
	        if (!merged.contains(key) && fn(value, key) === false) {
	          return false;
	        }
	      });
	    }
	  };

	  /**
	   * Returns an {@link ObjectLikeSequence} whose elements are the combination of
	   * this sequence and a 'default' object. In the case of a key appearing in both
	   * this sequence and the given object, this sequence's value will override the
	   * default object's.
	   *
	   * @public
	   * @param {Object} defaults The 'default' object to use for missing keys in this
	   *     sequence.
	   * @returns {ObjectLikeSequence} A new sequence comprising elements from this
	   *     sequence supplemented by the contents of `defaults`.
	   *
	   * @examples
	   * Lazy({ name: "Dan" }).defaults({ name: "User", password: "passw0rd" }) // sequence: { name: "Dan", password: "passw0rd" }
	   */
	  ObjectLikeSequence.prototype.defaults = function defaults(defaults) {
	    return new DefaultsSequence(this, defaults);
	  };

	  /**
	   * @constructor
	   */
	  function DefaultsSequence(parent, defaults) {
	    this.parent   = parent;
	    this.defaults = defaults;
	  }

	  DefaultsSequence.prototype = new ObjectLikeSequence();

	  DefaultsSequence.prototype.get = function get(key) {
	    return this.parent.get(key) || this.defaults[key];
	  };

	  DefaultsSequence.prototype.each = function each(fn) {
	    var merged = new Set(),
	        done   = false;

	    this.parent.each(function(value, key) {
	      if (fn(value, key) === false) {
	        done = true;
	        return false;
	      }

	      if (typeof value !== "undefined") {
	        merged.add(key);
	      }
	    });

	    if (!done) {
	      Lazy(this.defaults).each(function(value, key) {
	        if (!merged.contains(key) && fn(value, key) === false) {
	          return false;
	        }
	      });
	    }
	  };

	  /**
	   * Returns an {@link ObjectLikeSequence} whose values are this sequence's keys,
	   * and whose keys are this sequence's values.
	   *
	   * @public
	   * @returns {ObjectLikeSequence} A new sequence comprising the inverted keys and
	   *     values from this sequence.
	   *
	   * @examples
	   * Lazy({ first: "Dan", last: "Tao" }).invert() // sequence: { Dan: "first", Tao: "last" }
	   */
	  ObjectLikeSequence.prototype.invert = function invert() {
	    return new InvertedSequence(this);
	  };

	  /**
	   * @constructor
	   */
	  function InvertedSequence(parent) {
	    this.parent = parent;
	  }

	  InvertedSequence.prototype = new ObjectLikeSequence();

	  InvertedSequence.prototype.each = function each(fn) {
	    this.parent.each(function(value, key) {
	      return fn(key, value);
	    });
	  };

	  /**
	   * Produces an {@link ObjectLikeSequence} consisting of all the recursively
	   * merged values from this and the given object(s) or sequence(s).
	   *
	   * Note that by default this method only merges "vanilla" objects (bags of
	   * key/value pairs), not arrays or any other custom object types. To customize
	   * how merging works, you can provide the mergeFn argument, e.g. to handling
	   * merging arrays, strings, or other types of objects.
	   *
	   * @public
	   * @param {...Object|ObjectLikeSequence} others The other object(s) or
	   *     sequence(s) whose values will be merged into this one.
	   * @param {Function=} mergeFn An optional function used to customize merging
	   *     behavior. The function should take two values as parameters and return
	   *     whatever the "merged" form of those values is. If the function returns
	   *     undefined then the new value will simply replace the old one in the
	   *     final result.
	   * @returns {ObjectLikeSequence} The new sequence consisting of merged values.
	   *
	   * @examples
	   * // These examples are completely stolen from Lo-Dash's documentation:
	   * // lodash.com/docs#merge
	   *
	   * var names = {
	   *   'characters': [
	   *     { 'name': 'barney' },
	   *     { 'name': 'fred' }
	   *   ]
	   * };
	   *
	   * var ages = {
	   *   'characters': [
	   *     { 'age': 36 },
	   *     { 'age': 40 }
	   *   ]
	   * };
	   *
	   * var food = {
	   *   'fruits': ['apple'],
	   *   'vegetables': ['beet']
	   * };
	   *
	   * var otherFood = {
	   *   'fruits': ['banana'],
	   *   'vegetables': ['carrot']
	   * };
	   *
	   * function mergeArrays(a, b) {
	   *   return Array.isArray(a) ? a.concat(b) : undefined;
	   * }
	   *
	   * Lazy(names).merge(ages); // => sequence: { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
	   * Lazy(food).merge(otherFood, mergeArrays); // => sequence: { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
	   *
	   * // ----- Now for my own tests: -----
	   *
	   * // merges objects
	   * Lazy({ foo: 1 }).merge({ foo: 2 }); // => sequence: { foo: 2 }
	   * Lazy({ foo: 1 }).merge({ bar: 2 }); // => sequence: { foo: 1, bar: 2 }
	   *
	   * // goes deep
	   * Lazy({ foo: { bar: 1 } }).merge({ foo: { bar: 2 } }); // => sequence: { foo: { bar: 2 } }
	   * Lazy({ foo: { bar: 1 } }).merge({ foo: { baz: 2 } }); // => sequence: { foo: { bar: 1, baz: 2 } }
	   * Lazy({ foo: { bar: 1 } }).merge({ foo: { baz: 2 } }); // => sequence: { foo: { bar: 1, baz: 2 } }
	   *
	   * // gives precedence to later sources
	   * Lazy({ foo: 1 }).merge({ bar: 2 }, { bar: 3 }); // => sequence: { foo: 1, bar: 3 }
	   *
	   * // undefined gets passed over
	   * Lazy({ foo: 1 }).merge({ foo: undefined }); // => sequence: { foo: 1 }
	   *
	   * // null doesn't get passed over
	   * Lazy({ foo: 1 }).merge({ foo: null }); // => sequence: { foo: null }
	   *
	   * // array contents get merged as well
	   * Lazy({ foo: [{ bar: 1 }] }).merge({ foo: [{ baz: 2 }] }); // => sequence: { foo: [{ bar: 1, baz: 2}] }
	   */
	  ObjectLikeSequence.prototype.merge = function merge(var_args) {
	    var mergeFn = arguments.length > 1 && typeof arguments[arguments.length - 1] === "function" ?
	      arrayPop.call(arguments) : null;
	    return new MergedSequence(this, arraySlice.call(arguments, 0), mergeFn);
	  };

	  /**
	   * @constructor
	   */
	  function MergedSequence(parent, others, mergeFn) {
	    this.parent  = parent;
	    this.others  = others;
	    this.mergeFn = mergeFn;
	  }

	  MergedSequence.prototype = new ObjectLikeSequence();

	  MergedSequence.prototype.each = function each(fn) {
	    var others  = this.others,
	        mergeFn = this.mergeFn || mergeObjects,
	        keys    = {};

	    var iteratedFullSource = this.parent.each(function(value, key) {
	      var merged = value;

	      forEach(others, function(other) {
	        if (key in other) {
	          merged = mergeFn(merged, other[key]);
	        }
	      });

	      keys[key] = true;

	      return fn(merged, key);
	    });

	    if (iteratedFullSource === false) {
	      return false;
	    }

	    var remaining = {};

	    forEach(others, function(other) {
	      for (var k in other) {
	        if (!keys[k]) {
	          remaining[k] = mergeFn(remaining[k], other[k]);
	        }
	      }
	    });

	    return Lazy(remaining).each(fn);
	  };

	  /**
	   * @private
	   * @examples
	   * mergeObjects({ foo: 1 }, { bar: 2 }); // => { foo: 1, bar: 2 }
	   * mergeObjects({ foo: { bar: 1 } }, { foo: { baz: 2 } }); // => { foo: { bar: 1, baz: 2 } }
	   * mergeObjects({ foo: { bar: 1 } }, { foo: undefined }); // => { foo: { bar: 1 } }
	   * mergeObjects({ foo: { bar: 1 } }, { foo: null }); // => { foo: null }
	   * mergeObjects({ array: [0, 1, 2] }, { array: [3, 4, 5] }).array; // instanceof Array
	   * mergeObjects({ date: new Date() }, { date: new Date() }).date; // instanceof Date
	   * mergeObjects([{ foo: 1 }], [{ bar: 2 }]); // => [{ foo: 1, bar: 2 }]
	   */
	  function mergeObjects(a, b) {
	    var merged, prop;

	    if (typeof b === 'undefined') {
	      return a;
	    }

	    // Check that we're dealing with two objects or two arrays.
	    if (isVanillaObject(a) && isVanillaObject(b)) {
	      merged = {};
	    } else if (a instanceof Array && b instanceof Array) {
	      merged = [];
	    } else {
	      // Otherwise there's no merging to do -- just replace a w/ b.
	      return b;
	    }

	    for (prop in a) {
	      merged[prop] = mergeObjects(a[prop], b[prop]);
	    }
	    for (prop in b) {
	      if (!merged[prop]) {
	        merged[prop] = b[prop];
	      }
	    }
	    return merged;
	  }

	  /**
	   * Checks whether an object is a "vanilla" object, i.e. {'foo': 'bar'} as
	   * opposed to an array, date, etc.
	   *
	   * @private
	   * @examples
	   * isVanillaObject({foo: 'bar'}); // => true
	   * isVanillaObject(new Date());   // => false
	   * isVanillaObject([1, 2, 3]);    // => false
	   */
	  function isVanillaObject(object) {
	    return object && object.constructor === Object;
	  }

	  /**
	   * Creates a {@link Sequence} consisting of the keys from this sequence whose
	   *     values are functions.
	   *
	   * @public
	   * @aka methods
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * var dog = {
	   *   name: "Fido",
	   *   breed: "Golden Retriever",
	   *   bark: function() { console.log("Woof!"); },
	   *   wagTail: function() { console.log("TODO: implement robotic dog interface"); }
	   * };
	   *
	   * Lazy(dog).functions() // sequence: ["bark", "wagTail"]
	   */
	  ObjectLikeSequence.prototype.functions = function functions() {
	    return this
	      .filter(function(v, k) { return typeof(v) === "function"; })
	      .map(function(v, k) { return k; });
	  };

	  ObjectLikeSequence.prototype.methods = function methods() {
	    return this.functions();
	  };

	  /**
	   * Creates an {@link ObjectLikeSequence} consisting of the key/value pairs from
	   * this sequence whose keys are included in the given array of property names.
	   *
	   * @public
	   * @param {Array} properties An array of the properties to "pick" from this
	   *     sequence.
	   * @returns {ObjectLikeSequence} The new sequence.
	   *
	   * @examples
	   * var players = {
	   *   "who": "first",
	   *   "what": "second",
	   *   "i don't know": "third"
	   * };
	   *
	   * Lazy(players).pick(["who", "what"]) // sequence: { who: "first", what: "second" }
	   */
	  ObjectLikeSequence.prototype.pick = function pick(properties) {
	    return new PickSequence(this, properties);
	  };

	  /**
	   * @constructor
	   */
	  function PickSequence(parent, properties) {
	    this.parent     = parent;
	    this.properties = properties;
	  }

	  PickSequence.prototype = new ObjectLikeSequence();

	  PickSequence.prototype.get = function get(key) {
	    return arrayContains(this.properties, key) ? this.parent.get(key) : undefined;
	  };

	  PickSequence.prototype.each = function each(fn) {
	    var inArray    = arrayContains,
	        properties = this.properties;

	    return this.parent.each(function(value, key) {
	      if (inArray(properties, key)) {
	        return fn(value, key);
	      }
	    });
	  };

	  /**
	   * Creates an {@link ObjectLikeSequence} consisting of the key/value pairs from
	   * this sequence excluding those with the specified keys.
	   *
	   * @public
	   * @param {Array} properties An array of the properties to *omit* from this
	   *     sequence.
	   * @returns {ObjectLikeSequence} The new sequence.
	   *
	   * @examples
	   * var players = {
	   *   "who": "first",
	   *   "what": "second",
	   *   "i don't know": "third"
	   * };
	   *
	   * Lazy(players).omit(["who", "what"]) // sequence: { "i don't know": "third" }
	   */
	  ObjectLikeSequence.prototype.omit = function omit(properties) {
	    return new OmitSequence(this, properties);
	  };

	  /**
	   * @constructor
	   */
	  function OmitSequence(parent, properties) {
	    this.parent     = parent;
	    this.properties = properties;
	  }

	  OmitSequence.prototype = new ObjectLikeSequence();

	  OmitSequence.prototype.get = function get(key) {
	    return arrayContains(this.properties, key) ? undefined : this.parent.get(key);
	  };

	  OmitSequence.prototype.each = function each(fn) {
	    var inArray    = arrayContains,
	        properties = this.properties;

	    return this.parent.each(function(value, key) {
	      if (!inArray(properties, key)) {
	        return fn(value, key);
	      }
	    });
	  };

	  /**
	   * Maps the key/value pairs in this sequence to arrays.
	   *
	   * @public
	   * @aka toArray
	   * @returns {Sequence} An sequence of `[key, value]` pairs.
	   *
	   * @examples
	   * var colorCodes = {
	   *   red: "#f00",
	   *   green: "#0f0",
	   *   blue: "#00f"
	   * };
	   *
	   * Lazy(colorCodes).pairs() // sequence: [["red", "#f00"], ["green", "#0f0"], ["blue", "#00f"]]
	   */
	  ObjectLikeSequence.prototype.pairs = function pairs() {
	    return this.map(function(v, k) { return [k, v]; });
	  };

	  /**
	   * Creates an array from the key/value pairs in this sequence.
	   *
	   * @public
	   * @returns {Array} An array of `[key, value]` elements.
	   *
	   * @examples
	   * var colorCodes = {
	   *   red: "#f00",
	   *   green: "#0f0",
	   *   blue: "#00f"
	   * };
	   *
	   * Lazy(colorCodes).toArray() // => [["red", "#f00"], ["green", "#0f0"], ["blue", "#00f"]]
	   */
	  ObjectLikeSequence.prototype.toArray = function toArray() {
	    return this.pairs().toArray();
	  };

	  /**
	   * Creates an object with the key/value pairs from this sequence.
	   *
	   * @public
	   * @returns {Object} An object with the same key/value pairs as this sequence.
	   *
	   * @examples
	   * var colorCodes = {
	   *   red: "#f00",
	   *   green: "#0f0",
	   *   blue: "#00f"
	   * };
	   *
	   * Lazy(colorCodes).toObject() // => { red: "#f00", green: "#0f0", blue: "#00f" }
	   */
	  ObjectLikeSequence.prototype.toObject = function toObject() {
	    return this.reduce(function(object, value, key) {
	      object[key] = value;
	      return object;
	    }, {});
	  };

	  // Now that we've fully initialized the ObjectLikeSequence prototype, we can
	  // actually set the prototypes for GroupedSequence, IndexedSequence, and
	  // CountedSequence.

	  GroupedSequence.prototype = new ObjectLikeSequence();

	  GroupedSequence.prototype.each = function each(fn) {
	    var keyFn   = createCallback(this.keyFn),
	        valFn   = createCallback(this.valFn),
	        result;

	    result = this.parent.reduce(function(grouped,e) {
	      var key = keyFn(e),
	          val = valFn(e);
	      if (!(grouped[key] instanceof Array)) {
	        grouped[key] = [val];
	      } else {
	        grouped[key].push(val);
	      }
	      return grouped;
	    },{});

	    return transform(function(grouped) {
	      for (var key in grouped) {
	        if (fn(grouped[key], key) === false) {
	          return false;
	        }
	      }
	    }, result);
	  };

	  IndexedSequence.prototype = new ObjectLikeSequence();

	  IndexedSequence.prototype.each = function each(fn) {
	    var keyFn   = createCallback(this.keyFn),
	        valFn   = createCallback(this.valFn),
	        indexed = {};

	    return this.parent.each(function(e) {
	      var key = keyFn(e),
	          val = valFn(e);

	      if (!indexed[key]) {
	        indexed[key] = val;
	        return fn(val, key);
	      }
	    });
	  };

	  CountedSequence.prototype = new ObjectLikeSequence();

	  CountedSequence.prototype.each = function each(fn) {
	    var keyFn   = createCallback(this.keyFn),
	        counted = {};

	    this.parent.each(function(e) {
	      var key = keyFn(e);
	      if (!counted[key]) {
	        counted[key] = 1;
	      } else {
	        counted[key] += 1;
	      }
	    });

	    for (var key in counted) {
	      if (fn(counted[key], key) === false) {
	        return false;
	      }
	    }

	    return true;
	  };

	  /**
	   * Watches for all changes to a specified property (or properties) of an
	   * object and produces a sequence whose elements have the properties
	   * `{ property, value }` indicating which property changed and what it was
	   * changed to.
	   *
	   * Note that this method **only works on directly wrapped objects**; it will
	   * *not* work on any arbitrary {@link ObjectLikeSequence}.
	   *
	   * @public
	   * @param {(string|Array)=} propertyNames A property name or array of property
	   *     names to watch. If this parameter is `undefined`, all of the object's
	   *     current (enumerable) properties will be watched.
	   * @returns {Sequence} A sequence comprising `{ property, value }` objects
	   *     describing each change to the specified property/properties.
	   *
	   * @examples
	   * var obj = {},
	   *     changes = [];
	   *
	   * Lazy(obj).watch('foo').each(function(change) {
	   *   changes.push(change);
	   * });
	   *
	   * obj.foo = 1;
	   * obj.bar = 2;
	   * obj.foo = 3;
	   *
	   * obj.foo; // => 3
	   * changes; // => [{ property: 'foo', value: 1 }, { property: 'foo', value: 3 }]
	   */
	  ObjectLikeSequence.prototype.watch = function watch(propertyNames) {
	    throw new Error('You can only call #watch on a directly wrapped object.');
	  };

	  /**
	   * @constructor
	   */
	  function ObjectWrapper(source) {
	    this.source = source;
	  }

	  ObjectWrapper.prototype = new ObjectLikeSequence();

	  ObjectWrapper.prototype.root = function root() {
	    return this;
	  };

	  ObjectWrapper.prototype.isAsync = function isAsync() {
	    return false;
	  };

	  ObjectWrapper.prototype.get = function get(key) {
	    return this.source[key];
	  };

	  ObjectWrapper.prototype.each = function each(fn) {
	    var source = this.source,
	        key;

	    for (key in source) {
	      if (fn(source[key], key) === false) {
	        return false;
	      }
	    }

	    return true;
	  };

	  /**
	   * A `StringLikeSequence` represents a sequence of characters.
	   *
	   * The initial sequence you get by wrapping a string with `Lazy(string)` is a
	   * `StringLikeSequence`.
	   *
	   * All methods of `StringLikeSequence` that conceptually should return
	   * something like a string return another `StringLikeSequence`.
	   *
	   * @public
	   * @constructor
	   *
	   * @examples
	   * function upcase(str) { return str.toUpperCase(); }
	   *
	   * Lazy('foo')               // instanceof Lazy.StringLikeSequence
	   * Lazy('foo').toUpperCase() // instanceof Lazy.StringLikeSequence
	   * Lazy('foo').reverse()     // instanceof Lazy.StringLikeSequence
	   * Lazy('foo').take(2)       // instanceof Lazy.StringLikeSequence
	   * Lazy('foo').drop(1)       // instanceof Lazy.StringLikeSequence
	   * Lazy('foo').substring(1)  // instanceof Lazy.StringLikeSequence
	   *
	   * // Note that `map` does not create a `StringLikeSequence` because there's
	   * // no guarantee the mapping function will return characters. In the event
	   * // you do want to map a string onto a string-like sequence, use
	   * // `mapString`:
	   * Lazy('foo').map(Lazy.identity)       // instanceof Lazy.ArrayLikeSequence
	   * Lazy('foo').mapString(Lazy.identity) // instanceof Lazy.StringLikeSequence
	   */
	  function StringLikeSequence() {}

	  StringLikeSequence.prototype = new ArrayLikeSequence();

	  /**
	   * Create a new constructor function for a type inheriting from
	   * `StringLikeSequence`.
	   *
	   * @public
	   * @param {string|Array.<string>} methodName The name(s) of the method(s) to be
	   *     used for constructing the new sequence. The method will be attached to
	   *     the `StringLikeSequence` prototype so that it can be chained with any other
	   *     methods that return string-like sequences.
	   * @param {Object} overrides An object containing function overrides for this
	   *     new sequence type. Has the same requirements as
	   *     {@link ArrayLikeSequence.define}.
	   * @returns {Function} A constructor for a new type inheriting from
	   *     `StringLikeSequence`.
	   *
	   * @examples
	   * Lazy.StringLikeSequence.define("zomg", {
	   *   length: function() {
	   *     return this.parent.length() + "!!ZOMG!!!1".length;
	   *   },
	   *
	   *   get: function(i) {
	   *     if (i < this.parent.length()) {
	   *       return this.parent.get(i);
	   *     }
	   *     return "!!ZOMG!!!1".charAt(i - this.parent.length());
	   *   }
	   * });
	   *
	   * Lazy('foo').zomg() // sequence: "foo!!ZOMG!!!1"
	   */
	  StringLikeSequence.define = function define(methodName, overrides) {
	    if (!overrides || typeof overrides.get !== 'function') {
	      throw new Error("A custom string-like sequence must implement *at least* get!");
	    }

	    return defineSequenceType(StringLikeSequence, methodName, overrides);
	  };

	  StringLikeSequence.prototype.value = function value() {
	    return this.toString();
	  };

	  /**
	   * Returns an {@link IndexedIterator} that will step over each character in this
	   * sequence one by one.
	   *
	   * @returns {IndexedIterator} The iterator.
	   */
	  StringLikeSequence.prototype.getIterator = function getIterator() {
	    return new CharIterator(this);
	  };

	  /**
	   * @constructor
	   */
	  function CharIterator(source) {
	    this.source = Lazy(source);
	    this.index = -1;
	  }

	  CharIterator.prototype.current = function current() {
	    return this.source.charAt(this.index);
	  };

	  CharIterator.prototype.moveNext = function moveNext() {
	    return (++this.index < this.source.length());
	  };

	  /**
	   * Returns the character at the given index of this sequence, or the empty
	   * string if the specified index lies outside the bounds of the sequence.
	   *
	   * @public
	   * @param {number} i The index of this sequence.
	   * @returns {string} The character at the specified index.
	   *
	   * @examples
	   * Lazy("foo").charAt(0)  // => "f"
	   * Lazy("foo").charAt(-1) // => ""
	   * Lazy("foo").charAt(10) // => ""
	   */
	  StringLikeSequence.prototype.charAt = function charAt(i) {
	    return this.get(i);
	  };

	  /**
	   * Returns the character code at the given index of this sequence, or `NaN` if
	   * the index lies outside the bounds of the sequence.
	   *
	   * @public
	   * @param {number} i The index of the character whose character code you want.
	   * @returns {number} The character code.
	   *
	   * @examples
	   * Lazy("abc").charCodeAt(0)  // => 97
	   * Lazy("abc").charCodeAt(-1) // => NaN
	   * Lazy("abc").charCodeAt(10) // => NaN
	   */
	  StringLikeSequence.prototype.charCodeAt = function charCodeAt(i) {
	    var char = this.charAt(i);
	    if (!char) { return NaN; }

	    return char.charCodeAt(0);
	  };

	  /**
	   * Returns a {@link StringLikeSequence} comprising the characters from *this*
	   * sequence starting at `start` and ending at `stop` (exclusive), or---if
	   * `stop` is `undefined`, including the rest of the sequence.
	   *
	   * @public
	   * @param {number} start The index where this sequence should begin.
	   * @param {number=} stop The index (exclusive) where this sequence should end.
	   * @returns {StringLikeSequence} The new sequence.
	   *
	   * @examples
	   * Lazy("foo").substring(1)      // sequence: "oo"
	   * Lazy("foo").substring(-1)     // sequence: "foo"
	   * Lazy("hello").substring(1, 3) // sequence: "el"
	   * Lazy("hello").substring(1, 9) // sequence: "ello"
	   */
	  StringLikeSequence.prototype.substring = function substring(start, stop) {
	    return new StringSegment(this, start, stop);
	  };

	  /**
	   * @constructor
	   */
	  function StringSegment(parent, start, stop) {
	    this.parent = parent;
	    this.start  = Math.max(0, start);
	    this.stop   = stop;
	  }

	  StringSegment.prototype = new StringLikeSequence();

	  StringSegment.prototype.get = function get(i) {
	    return this.parent.get(i + this.start);
	  };

	  StringSegment.prototype.length = function length() {
	    return (typeof this.stop === "number" ? this.stop : this.parent.length()) - this.start;
	  };

	  /**
	   * An optimized version of {@link Sequence#first} that returns another
	   * {@link StringLikeSequence} (or just the first character, if `count` is
	   * undefined).
	   *
	   * @public
	   * @examples
	   * Lazy('foo').first()                // => 'f'
	   * Lazy('fo').first(2)                // sequence: 'fo'
	   * Lazy('foo').first(10)              // sequence: 'foo'
	   * Lazy('foo').toUpperCase().first()  // => 'F'
	   * Lazy('foo').toUpperCase().first(2) // sequence: 'FO'
	   */
	  StringLikeSequence.prototype.first = function first(count) {
	    if (typeof count === "undefined") {
	      return this.charAt(0);
	    }

	    return this.substring(0, count);
	  };

	  /**
	   * An optimized version of {@link Sequence#last} that returns another
	   * {@link StringLikeSequence} (or just the last character, if `count` is
	   * undefined).
	   *
	   * @public
	   * @examples
	   * Lazy('foo').last()                // => 'o'
	   * Lazy('foo').last(2)               // sequence: 'oo'
	   * Lazy('foo').last(10)              // sequence: 'foo'
	   * Lazy('foo').toUpperCase().last()  // => 'O'
	   * Lazy('foo').toUpperCase().last(2) // sequence: 'OO'
	   */
	  StringLikeSequence.prototype.last = function last(count) {
	    if (typeof count === "undefined") {
	      return this.charAt(this.length() - 1);
	    }

	    return this.substring(this.length() - count);
	  };

	  StringLikeSequence.prototype.drop = function drop(count) {
	    return this.substring(count);
	  };

	  /**
	   * Finds the index of the first occurrence of the given substring within this
	   * sequence, starting from the specified index (or the beginning of the
	   * sequence).
	   *
	   * @public
	   * @param {string} substring The substring to search for.
	   * @param {number=} startIndex The index from which to start the search.
	   * @returns {number} The first index where the given substring is found, or
	   *     -1 if it isn't in the sequence.
	   *
	   * @examples
	   * Lazy('canal').indexOf('a')    // => 1
	   * Lazy('canal').indexOf('a', 2) // => 3
	   * Lazy('canal').indexOf('ana')  // => 1
	   * Lazy('canal').indexOf('andy') // => -1
	   * Lazy('canal').indexOf('x')    // => -1
	   */
	  StringLikeSequence.prototype.indexOf = function indexOf(substring, startIndex) {
	    return this.toString().indexOf(substring, startIndex);
	  };

	  /**
	   * Finds the index of the last occurrence of the given substring within this
	   * sequence, starting from the specified index (or the end of the sequence)
	   * and working backwards.
	   *
	   * @public
	   * @param {string} substring The substring to search for.
	   * @param {number=} startIndex The index from which to start the search.
	   * @returns {number} The last index where the given substring is found, or
	   *     -1 if it isn't in the sequence.
	   *
	   * @examples
	   * Lazy('canal').lastIndexOf('a')    // => 3
	   * Lazy('canal').lastIndexOf('a', 2) // => 1
	   * Lazy('canal').lastIndexOf('ana')  // => 1
	   * Lazy('canal').lastIndexOf('andy') // => -1
	   * Lazy('canal').lastIndexOf('x')    // => -1
	   */
	  StringLikeSequence.prototype.lastIndexOf = function lastIndexOf(substring, startIndex) {
	    return this.toString().lastIndexOf(substring, startIndex);
	  };

	  /**
	   * Checks if this sequence contains a given substring.
	   *
	   * @public
	   * @param {string} substring The substring to check for.
	   * @returns {boolean} Whether or not this sequence contains `substring`.
	   *
	   * @examples
	   * Lazy('hello').contains('ell') // => true
	   * Lazy('hello').contains('')    // => true
	   * Lazy('hello').contains('abc') // => false
	   */
	  StringLikeSequence.prototype.contains = function contains(substring) {
	    return this.indexOf(substring) !== -1;
	  };

	  /**
	   * Checks if this sequence ends with a given suffix.
	   *
	   * @public
	   * @param {string} suffix The suffix to check for.
	   * @returns {boolean} Whether or not this sequence ends with `suffix`.
	   *
	   * @examples
	   * Lazy('foo').endsWith('oo')  // => true
	   * Lazy('foo').endsWith('')    // => true
	   * Lazy('foo').endsWith('abc') // => false
	   */
	  StringLikeSequence.prototype.endsWith = function endsWith(suffix) {
	    return this.substring(this.length() - suffix.length).toString() === suffix;
	  };

	  /**
	   * Checks if this sequence starts with a given prefix.
	   *
	   * @public
	   * @param {string} prefix The prefix to check for.
	   * @returns {boolean} Whether or not this sequence starts with `prefix`.
	   *
	   * @examples
	   * Lazy('foo').startsWith('fo')  // => true
	   * Lazy('foo').startsWith('')    // => true
	   * Lazy('foo').startsWith('abc') // => false
	   */
	  StringLikeSequence.prototype.startsWith = function startsWith(prefix) {
	    return this.substring(0, prefix.length).toString() === prefix;
	  };

	  /**
	   * Converts all of the characters in this string to uppercase.
	   *
	   * @public
	   * @returns {StringLikeSequence} A new sequence with the same characters as
	   *     this sequence, all uppercase.
	   *
	   * @examples
	   * function nextLetter(a) {
	   *   return String.fromCharCode(a.charCodeAt(0) + 1);
	   * }
	   *
	   * Lazy('foo').toUpperCase()                       // sequence: 'FOO'
	   * Lazy('foo').substring(1).toUpperCase()          // sequence: 'OO'
	   * Lazy('abc').mapString(nextLetter).toUpperCase() // sequence: 'BCD'
	   */
	  StringLikeSequence.prototype.toUpperCase = function toUpperCase() {
	    return this.mapString(function(char) { return char.toUpperCase(); });
	  };

	  /**
	   * Converts all of the characters in this string to lowercase.
	   *
	   * @public
	   * @returns {StringLikeSequence} A new sequence with the same characters as
	   *     this sequence, all lowercase.
	   *
	   * @examples
	   * function nextLetter(a) {
	   *   return String.fromCharCode(a.charCodeAt(0) + 1);
	   * }
	   *
	   * Lazy('FOO').toLowerCase()                       // sequence: 'foo'
	   * Lazy('FOO').substring(1).toLowerCase()          // sequence: 'oo'
	   * Lazy('ABC').mapString(nextLetter).toLowerCase() // sequence: 'bcd'
	   */
	  StringLikeSequence.prototype.toLowerCase = function toLowerCase() {
	    return this.mapString(function(char) { return char.toLowerCase(); });
	  };

	  /**
	   * Maps the characters of this sequence onto a new {@link StringLikeSequence}.
	   *
	   * @public
	   * @param {Function} mapFn The function used to map characters from this
	   *     sequence onto the new sequence.
	   * @returns {StringLikeSequence} The new sequence.
	   *
	   * @examples
	   * function upcase(char) { return char.toUpperCase(); }
	   *
	   * Lazy("foo").mapString(upcase)               // sequence: "FOO"
	   * Lazy("foo").mapString(upcase).charAt(0)     // => "F"
	   * Lazy("foo").mapString(upcase).charCodeAt(0) // => 70
	   * Lazy("foo").mapString(upcase).substring(1)  // sequence: "OO"
	   */
	  StringLikeSequence.prototype.mapString = function mapString(mapFn) {
	    return new MappedStringLikeSequence(this, mapFn);
	  };

	  /**
	   * @constructor
	   */
	  function MappedStringLikeSequence(parent, mapFn) {
	    this.parent = parent;
	    this.mapFn  = mapFn;
	  }

	  MappedStringLikeSequence.prototype = new StringLikeSequence();
	  MappedStringLikeSequence.prototype.get = IndexedMappedSequence.prototype.get;
	  MappedStringLikeSequence.prototype.length = IndexedMappedSequence.prototype.length;

	  /**
	   * Returns a copy of this sequence that reads back to front.
	   *
	   * @public
	   *
	   * @examples
	   * Lazy("abcdefg").reverse() // sequence: "gfedcba"
	   */
	  StringLikeSequence.prototype.reverse = function reverse() {
	    return new ReversedStringLikeSequence(this);
	  };

	  /**
	   * @constructor
	   */
	  function ReversedStringLikeSequence(parent) {
	    this.parent = parent;
	  }

	  ReversedStringLikeSequence.prototype = new StringLikeSequence();
	  ReversedStringLikeSequence.prototype.get = IndexedReversedSequence.prototype.get;
	  ReversedStringLikeSequence.prototype.length = IndexedReversedSequence.prototype.length;

	  StringLikeSequence.prototype.toString = function toString() {
	    return this.join("");
	  };

	  /**
	   * Creates a {@link Sequence} comprising all of the matches for the specified
	   * pattern in the underlying string.
	   *
	   * @public
	   * @param {RegExp} pattern The pattern to match.
	   * @returns {Sequence} A sequence of all the matches.
	   *
	   * @examples
	   * Lazy("abracadabra").match(/a[bcd]/) // sequence: ["ab", "ac", "ad", "ab"]
	   * Lazy("fee fi fo fum").match(/\w+/)  // sequence: ["fee", "fi", "fo", "fum"]
	   * Lazy("hello").match(/xyz/)          // sequence: []
	   */
	  StringLikeSequence.prototype.match = function match(pattern) {
	    return new StringMatchSequence(this, pattern);
	  };

	  /**
	   * @constructor
	   */
	  function StringMatchSequence(parent, pattern) {
	    this.parent = parent;
	    this.pattern = pattern;
	  }

	  StringMatchSequence.prototype = new Sequence();

	  StringMatchSequence.prototype.getIterator = function getIterator() {
	    return new StringMatchIterator(this.parent.toString(), this.pattern);
	  };

	  /**
	   * @constructor
	   */
	  function StringMatchIterator(source, pattern) {
	    this.source  = source;
	    this.pattern = cloneRegex(pattern);
	  }

	  StringMatchIterator.prototype.current = function current() {
	    return this.match[0];
	  };

	  StringMatchIterator.prototype.moveNext = function moveNext() {
	    return !!(this.match = this.pattern.exec(this.source));
	  };

	  /**
	   * Creates a {@link Sequence} comprising all of the substrings of this string
	   * separated by the given delimiter, which can be either a string or a regular
	   * expression.
	   *
	   * @public
	   * @param {string|RegExp} delimiter The delimiter to use for recognizing
	   *     substrings.
	   * @returns {Sequence} A sequence of all the substrings separated by the given
	   *     delimiter.
	   *
	   * @examples
	   * Lazy("foo").split("")                      // sequence: ["f", "o", "o"]
	   * Lazy("yo dawg").split(" ")                 // sequence: ["yo", "dawg"]
	   * Lazy("bah bah\tblack  sheep").split(/\s+/) // sequence: ["bah", "bah", "black", "sheep"]
	   */
	  StringLikeSequence.prototype.split = function split(delimiter) {
	    return new SplitStringSequence(this, delimiter);
	  };

	  /**
	   * @constructor
	   */
	  function SplitStringSequence(parent, pattern) {
	    this.parent = parent;
	    this.pattern = pattern;
	  }

	  SplitStringSequence.prototype = new Sequence();

	  SplitStringSequence.prototype.getIterator = function getIterator() {
	    var source = this.parent.toString();

	    if (this.pattern instanceof RegExp) {
	      if (this.pattern.source === "" || this.pattern.source === "(?:)") {
	        return new CharIterator(source);
	      } else {
	        return new SplitWithRegExpIterator(source, this.pattern);
	      }
	    } else if (this.pattern === "") {
	      return new CharIterator(source);
	    } else {
	      return new SplitWithStringIterator(source, this.pattern);
	    }
	  };

	  /**
	   * @constructor
	   */
	  function SplitWithRegExpIterator(source, pattern) {
	    this.source  = source;
	    this.pattern = cloneRegex(pattern);
	  }

	  SplitWithRegExpIterator.prototype.current = function current() {
	    return this.source.substring(this.start, this.end);
	  };

	  SplitWithRegExpIterator.prototype.moveNext = function moveNext() {
	    if (!this.pattern) {
	      return false;
	    }

	    var match = this.pattern.exec(this.source);

	    if (match) {
	      this.start = this.nextStart ? this.nextStart : 0;
	      this.end = match.index;
	      this.nextStart = match.index + match[0].length;
	      return true;

	    } else if (this.pattern) {
	      this.start = this.nextStart;
	      this.end = undefined;
	      this.nextStart = undefined;
	      this.pattern = undefined;
	      return true;
	    }

	    return false;
	  };

	  /**
	   * @constructor
	   */
	  function SplitWithStringIterator(source, delimiter) {
	    this.source = source;
	    this.delimiter = delimiter;
	  }

	  SplitWithStringIterator.prototype.current = function current() {
	    return this.source.substring(this.leftIndex, this.rightIndex);
	  };

	  SplitWithStringIterator.prototype.moveNext = function moveNext() {
	    if (!this.finished) {
	      this.leftIndex = typeof this.leftIndex !== "undefined" ?
	        this.rightIndex + this.delimiter.length :
	        0;
	      this.rightIndex = this.source.indexOf(this.delimiter, this.leftIndex);
	    }

	    if (this.rightIndex === -1) {
	      this.finished = true;
	      this.rightIndex = undefined;
	      return true;
	    }

	    return !this.finished;
	  };

	  /**
	   * Wraps a string exposing {@link #match} and {@link #split} methods that return
	   * {@link Sequence} objects instead of arrays, improving on the efficiency of
	   * JavaScript's built-in `String#split` and `String.match` methods and
	   * supporting asynchronous iteration.
	   *
	   * @param {string} source The string to wrap.
	   * @constructor
	   */
	  function StringWrapper(source) {
	    this.source = source;
	  }

	  StringWrapper.prototype = new StringLikeSequence();

	  StringWrapper.prototype.root = function root() {
	    return this;
	  };

	  StringWrapper.prototype.isAsync = function isAsync() {
	    return false;
	  };

	  StringWrapper.prototype.get = function get(i) {
	    return this.source.charAt(i);
	  };

	  StringWrapper.prototype.length = function length() {
	    return this.source.length;
	  };

	  StringWrapper.prototype.toString = function toString() {
	    return this.source;
	  };

	  /**
	   * A `GeneratedSequence` does not wrap an in-memory colllection but rather
	   * determines its elements on-the-fly during iteration according to a generator
	   * function.
	   *
	   * You create a `GeneratedSequence` by calling {@link Lazy.generate}.
	   *
	   * @public
	   * @constructor
	   * @param {function(number):*} generatorFn A function which accepts an index
	   *     and returns a value for the element at that position in the sequence.
	   * @param {number=} length The length of the sequence. If this argument is
	   *     omitted, the sequence will go on forever.
	   */
	  function GeneratedSequence(generatorFn, length) {
	    this.get = generatorFn;
	    this.fixedLength = length;
	  }

	  GeneratedSequence.prototype = new Sequence();

	  GeneratedSequence.prototype.isAsync = function isAsync() {
	    return false;
	  };

	  /**
	   * Returns the length of this sequence.
	   *
	   * @public
	   * @returns {number} The length, or `undefined` if this is an indefinite
	   *     sequence.
	   */
	  GeneratedSequence.prototype.length = function length() {
	    return this.fixedLength;
	  };

	  /**
	   * Iterates over the sequence produced by invoking this sequence's generator
	   * function up to its specified length, or, if length is `undefined`,
	   * indefinitely (in which case the sequence will go on forever--you would need
	   * to call, e.g., {@link Sequence#take} to limit iteration).
	   *
	   * @public
	   * @param {Function} fn The function to call on each output from the generator
	   *     function.
	   */
	  GeneratedSequence.prototype.each = function each(fn) {
	    var generatorFn = this.get,
	        length = this.fixedLength,
	        i = 0;

	    while (typeof length === "undefined" || i < length) {
	      if (fn(generatorFn(i), i++) === false) {
	        return false;
	      }
	    }

	    return true;
	  };

	  GeneratedSequence.prototype.getIterator = function getIterator() {
	    return new GeneratedIterator(this);
	  };

	  /**
	   * Iterates over a generated sequence. (This allows generated sequences to be
	   * iterated asynchronously.)
	   *
	   * @param {GeneratedSequence} sequence The generated sequence to iterate over.
	   * @constructor
	   */
	  function GeneratedIterator(sequence) {
	    this.sequence     = sequence;
	    this.index        = 0;
	    this.currentValue = null;
	  }

	  GeneratedIterator.prototype.current = function current() {
	    return this.currentValue;
	  };

	  GeneratedIterator.prototype.moveNext = function moveNext() {
	    var sequence = this.sequence;

	    if (typeof sequence.fixedLength === "number" && this.index >= sequence.fixedLength) {
	      return false;
	    }

	    this.currentValue = sequence.get(this.index++);
	    return true;
	  };

	  /**
	   * An `AsyncSequence` iterates over its elements asynchronously when
	   * {@link #each} is called.
	   *
	   * You get an `AsyncSequence` by calling {@link Sequence#async} on any
	   * sequence. Note that some sequence types may not support asynchronous
	   * iteration.
	   *
	   * Returning values
	   * ----------------
	   *
	   * Because of its asynchronous nature, an `AsyncSequence` cannot be used in the
	   * same way as other sequences for functions that return values directly (e.g.,
	   * `reduce`, `max`, `any`, even `toArray`).
	   *
	   * Instead, these methods return an `AsyncHandle` whose `onComplete` method
	   * accepts a callback that will be called with the final result once iteration
	   * has finished.
	   *
	   * Defining custom asynchronous sequences
	   * --------------------------------------
	   *
	   * There are plenty of ways to define an asynchronous sequence. Here's one.
	   *
	   * 1. First, implement an {@link Iterator}. This is an object whose prototype
	   *    has the methods {@link Iterator#moveNext} (which returns a `boolean`) and
	   *    {@link current} (which returns the current value).
	   * 2. Next, create a simple wrapper that inherits from `AsyncSequence`, whose
	   *    `getIterator` function returns an instance of the iterator type you just
	   *    defined.
	   *
	   * The default implementation for {@link #each} on an `AsyncSequence` is to
	   * create an iterator and then asynchronously call {@link Iterator#moveNext}
	   * (using `setImmediate`, if available, otherwise `setTimeout`) until the iterator
	   * can't move ahead any more.
	   *
	   * @public
	   * @constructor
	   * @param {Sequence} parent A {@link Sequence} to wrap, to expose asynchronous
	   *     iteration.
	   * @param {number=} interval How many milliseconds should elapse between each
	   *     element when iterating over this sequence. If this argument is omitted,
	   *     asynchronous iteration will be executed as fast as possible.
	   */
	  function AsyncSequence(parent, interval) {
	    if (parent instanceof AsyncSequence) {
	      throw new Error("Sequence is already asynchronous!");
	    }

	    this.parent         = parent;
	    this.interval       = interval;
	    this.onNextCallback = getOnNextCallback(interval);
	    this.cancelCallback = getCancelCallback(interval);
	  }

	  AsyncSequence.prototype = new Sequence();

	  AsyncSequence.prototype.isAsync = function isAsync() {
	    return true;
	  };

	  /**
	   * Throws an exception. You cannot manually iterate over an asynchronous
	   * sequence.
	   *
	   * @public
	   * @example
	   * Lazy([1, 2, 3]).async().getIterator() // throws
	   */
	  AsyncSequence.prototype.getIterator = function getIterator() {
	    throw new Error('An AsyncSequence does not support synchronous iteration.');
	  };

	  /**
	   * An asynchronous version of {@link Sequence#each}.
	   *
	   * @public
	   * @param {Function} fn The function to invoke asynchronously on each element in
	   *     the sequence one by one.
	   * @returns {AsyncHandle} An {@link AsyncHandle} providing the ability to
	   *     cancel the asynchronous iteration (by calling `cancel()`) as well as
	   *     supply callback(s) for when an error is encountered (`onError`) or when
	   *     iteration is complete (`onComplete`).
	   */
	  AsyncSequence.prototype.each = function each(fn) {
	    var iterator = this.parent.getIterator(),
	        onNextCallback = this.onNextCallback,
	        cancelCallback = this.cancelCallback,
	        i = 0;

	    var handle = new AsyncHandle(function cancel() {
	      if (cancellationId) {
	        cancelCallback(cancellationId);
	      }
	    });

	    var cancellationId = onNextCallback(function iterate() {
	      cancellationId = null;

	      try {
	        if (iterator.moveNext() && fn(iterator.current(), i++) !== false) {
	          cancellationId = onNextCallback(iterate);

	        } else {
	          handle._resolve();
	        }

	      } catch (e) {
	        handle._reject(e);
	      }
	    });

	    return handle;
	  };

	  /**
	   * An `AsyncHandle` provides a [Promises/A+](http://promises-aplus.github.io/promises-spec/)
	   * compliant interface for an {@link AsyncSequence} that is currently (or was)
	   * iterating over its elements.
	   *
	   * In addition to behaving as a promise, an `AsyncHandle` provides the ability
	   * to {@link AsyncHandle#cancel} iteration (if `cancelFn` is provided)
	   * and also offers convenient {@link AsyncHandle#onComplete} and
	   * {@link AsyncHandle#onError} methods to attach listeners for when iteration
	   * is complete or an error is thrown during iteration.
	   *
	   * @public
	   * @param {Function} cancelFn A function to cancel asynchronous iteration.
	   *     This is passed in to support different cancellation mechanisms for
	   *     different forms of asynchronous sequences (e.g., timeout-based
	   *     sequences, sequences based on I/O, etc.).
	   * @constructor
	   *
	   * @example
	   * // Create a sequence of 100,000 random numbers, in chunks of 100.
	   * var sequence = Lazy.generate(Math.random)
	   *   .chunk(100)
	   *   .async()
	   *   .take(1000);
	   *
	   * // Reduce-style operations -- i.e., operations that return a *value* (as
	   * // opposed to a *sequence*) -- return an AsyncHandle for async sequences.
	   * var handle = sequence.toArray();
	   *
	   * handle.onComplete(function(array) {
	   *   // Do something w/ 1,000-element array.
	   * });
	   *
	   * // Since an AsyncHandle is a promise, you can also use it to create
	   * // subsequent promises using `then` (see the Promises/A+ spec for more
	   * // info).
	   * var flattened = handle.then(function(array) {
	   *   return Lazy(array).flatten();
	   * });
	   */
	  function AsyncHandle(cancelFn) {
	    this.resolveListeners = [];
	    this.rejectListeners = [];
	    this.state = PENDING;
	    this.cancelFn = cancelFn;
	  }

	  // Async handle states
	  var PENDING  = 1,
	      RESOLVED = 2,
	      REJECTED = 3;

	  AsyncHandle.prototype.then = function then(onFulfilled, onRejected) {
	    var promise = new AsyncHandle(this.cancelFn);

	    this.resolveListeners.push(function(value) {
	      try {
	        if (typeof onFulfilled !== 'function') {
	          resolve(promise, value);
	          return;
	        }

	        resolve(promise, onFulfilled(value));

	      } catch (e) {
	        promise._reject(e);
	      }
	    });

	    this.rejectListeners.push(function(reason) {
	      try {
	        if (typeof onRejected !== 'function') {
	          promise._reject(reason);
	          return;
	        }

	        resolve(promise, onRejected(reason));

	      } catch (e) {
	        promise._reject(e);
	      }
	    });

	    if (this.state === RESOLVED) {
	      this._resolve(this.value);
	    }

	    if (this.state === REJECTED) {
	      this._reject(this.reason);
	    }

	    return promise;
	  };

	  AsyncHandle.prototype._resolve = function _resolve(value) {
	    if (this.state === REJECTED) {
	      return;
	    }

	    if (this.state === PENDING) {
	      this.state = RESOLVED;
	      this.value = value;
	    }

	    consumeListeners(this.resolveListeners, this.value);
	  };

	  AsyncHandle.prototype._reject = function _reject(reason) {
	    if (this.state === RESOLVED) {
	      return;
	    }

	    if (this.state === PENDING) {
	      this.state = REJECTED;
	      this.reason = reason;
	    }

	    consumeListeners(this.rejectListeners, this.reason);
	  };

	  /**
	   * Cancels asynchronous iteration.
	   *
	   * @public
	   */
	  AsyncHandle.prototype.cancel = function cancel() {
	    if (this.cancelFn) {
	      this.cancelFn();
	      this.cancelFn = null;
	      this._resolve(false);
	    }
	  };

	  /**
	   * Updates the handle with a callback to execute when iteration is completed.
	   *
	   * @public
	   * @param {Function} callback The function to call when the asynchronous
	   *     iteration is completed.
	   * @return {AsyncHandle} A reference to the handle (for chaining).
	   */
	  AsyncHandle.prototype.onComplete = function onComplete(callback) {
	    this.resolveListeners.push(callback);
	    return this;
	  };

	  /**
	   * Updates the handle with a callback to execute if/when any error is
	   * encountered during asynchronous iteration.
	   *
	   * @public
	   * @param {Function} callback The function to call, with any associated error
	   *     object, when an error occurs.
	   * @return {AsyncHandle} A reference to the handle (for chaining).
	   */
	  AsyncHandle.prototype.onError = function onError(callback) {
	    this.rejectListeners.push(callback);
	    return this;
	  };

	  /**
	   * Promise resolution procedure:
	   * http://promises-aplus.github.io/promises-spec/#the_promise_resolution_procedure
	   */
	  function resolve(promise, x) {
	    if (promise === x) {
	      promise._reject(new TypeError('Cannot resolve a promise to itself'));
	      return;
	    }

	    if (x instanceof AsyncHandle) {
	      x.then(
	        function(value) { resolve(promise, value); },
	        function(reason) { promise._reject(reason); }
	      );
	      return;
	    }

	    var then;
	    try {
	      then = (/function|object/).test(typeof x) && x != null && x.then;
	    } catch (e) {
	      promise._reject(e);
	      return;
	    }

	    var thenableState = PENDING;
	    if (typeof then === 'function') {
	      try {
	        then.call(
	          x,
	          function resolvePromise(value) {
	            if (thenableState !== PENDING) {
	              return;
	            }
	            thenableState = RESOLVED;
	            resolve(promise, value);
	          },
	          function rejectPromise(reason) {
	            if (thenableState !== PENDING) {
	              return;
	            }
	            thenableState = REJECTED;
	            promise._reject(reason);
	          }
	        );
	      } catch (e) {
	        if (thenableState !== PENDING) {
	          return;
	        }

	        promise._reject(e);
	      }

	      return;
	    }

	    promise._resolve(x);
	  }

	  function consumeListeners(listeners, value, callback) {
	    callback || (callback = getOnNextCallback());

	    callback(function() {
	      if (listeners.length > 0) {
	        listeners.shift()(value);
	        consumeListeners(listeners, value, callback);
	      }
	    });
	  }

	  function getOnNextCallback(interval) {
	    if (typeof interval === "undefined") {
	      if (typeof setImmediate === "function") {
	        return setImmediate;
	      }
	    }

	    interval = interval || 0;
	    return function(fn) {
	      return setTimeout(fn, interval);
	    };
	  }

	  function getCancelCallback(interval) {
	    if (typeof interval === "undefined") {
	      if (typeof clearImmediate === "function") {
	        return clearImmediate;
	      }
	    }

	    return clearTimeout;
	  }

	  /**
	   * Transform a value, whether the value is retrieved asynchronously or directly.
	   *
	   * @private
	   * @param {Function} fn The function that transforms the value.
	   * @param {*} value The value to be transformed. This can be an {@link AsyncHandle} when the value
	   *     is retrieved asynchronously, otherwise it can be anything.
	   * @returns {*} An {@link AsyncHandle} when `value` is also an {@link AsyncHandle}, otherwise
	   *     whatever `fn` resulted in.
	   */
	  function transform(fn, value) {
	    if (value instanceof AsyncHandle) {
	      return value.then(function() { fn(value); });
	    }
	    return fn(value);
	  }

	  /**
	   * An async version of {@link Sequence#reverse}.
	   */
	  AsyncSequence.prototype.reverse = function reverse() {
	    return this.parent.reverse().async();
	  };

	  /**
	   * A version of {@link Sequence#find} which returns an {@link AsyncHandle}.
	   *
	   * @public
	   * @param {Function} predicate A function to call on (potentially) every element
	   *     in the sequence.
	   * @returns {AsyncHandle} An {@link AsyncHandle} (promise) which resolves to
	   *     the found element, once it is detected, or else `undefined`.
	   */
	  AsyncSequence.prototype.find = function find(predicate) {
	    var found;

	    var handle = this.each(function(e, i) {
	      if (predicate(e, i)) {
	        found = e;
	        return false;
	      }
	    });

	    return handle.then(function() { return found; });
	  };

	  /**
	   * A version of {@link Sequence#indexOf} which returns an {@link AsyncHandle}.
	   *
	   * @public
	   * @param {*} value The element to search for in the sequence.
	   * @returns {AsyncHandle} An {@link AsyncHandle} (promise) which resolves to
	   *     the found index, once it is detected, or -1.
	   */
	  AsyncSequence.prototype.indexOf = function indexOf(value) {
	    var foundIndex = -1;

	    var handle = this.each(function(e, i) {
	      if (e === value) {
	        foundIndex = i;
	        return false;
	      }
	    });

	    return handle.then(function() {
	      return foundIndex;
	    });
	  };

	  /**
	   * A version of {@link Sequence#contains} which returns an {@link AsyncHandle}.
	   *
	   * @public
	   * @param {*} value The element to search for in the sequence.
	   * @returns {AsyncHandle} An {@link AsyncHandle} (promise) which resolves to
	   *     either `true` or `false` to indicate whether the element was found.
	   */
	  AsyncSequence.prototype.contains = function contains(value) {
	    var found = false;

	    var handle = this.each(function(e) {
	      if (e === value) {
	        found = true;
	        return false;
	      }
	    });

	    return handle.then(function() {
	      return found;
	    });
	  };

	  /**
	   * Just return the same sequence for `AsyncSequence#async` (I see no harm in this).
	   */
	  AsyncSequence.prototype.async = function async() {
	    return this;
	  };

	  /**
	   * See {@link ObjectLikeSequence#watch} for docs.
	   */
	  ObjectWrapper.prototype.watch = function watch(propertyNames) {
	    return new WatchedPropertySequence(this.source, propertyNames);
	  };

	  function WatchedPropertySequence(object, propertyNames) {
	    this.listeners = [];

	    if (!propertyNames) {
	      propertyNames = Lazy(object).keys().toArray();
	    } else if (!(propertyNames instanceof Array)) {
	      propertyNames = [propertyNames];
	    }

	    var listeners = this.listeners,
	        index     = 0;

	    Lazy(propertyNames).each(function(propertyName) {
	      var propertyValue = object[propertyName];

	      Object.defineProperty(object, propertyName, {
	        get: function() {
	          return propertyValue;
	        },

	        set: function(value) {
	          for (var i = listeners.length - 1; i >= 0; --i) {
	            if (listeners[i]({ property: propertyName, value: value }, index) === false) {
	              listeners.splice(i, 1);
	            }
	          }
	          propertyValue = value;
	          ++index;
	        }
	      });
	    });
	  }

	  WatchedPropertySequence.prototype = new AsyncSequence();

	  WatchedPropertySequence.prototype.each = function each(fn) {
	    this.listeners.push(fn);
	  };

	  /**
	   * A StreamLikeSequence comprises a sequence of 'chunks' of data, which are
	   * typically multiline strings.
	   *
	   * @constructor
	   */
	  function StreamLikeSequence() {}

	  StreamLikeSequence.prototype = new AsyncSequence();

	  StreamLikeSequence.prototype.isAsync = function isAsync() {
	    return true;
	  };

	  StreamLikeSequence.prototype.split = function split(delimiter) {
	    return new SplitStreamSequence(this, delimiter);
	  };

	  /**
	   * @constructor
	   */
	  function SplitStreamSequence(parent, delimiter) {
	    this.parent    = parent;
	    this.delimiter = delimiter;
	    this.each      = this.getEachForDelimiter(delimiter);
	  }

	  SplitStreamSequence.prototype = new Sequence();

	  SplitStreamSequence.prototype.getEachForDelimiter = function getEachForDelimiter(delimiter) {
	    if (delimiter instanceof RegExp) {
	      return this.regexEach;
	    }

	    return this.stringEach;
	  };

	  SplitStreamSequence.prototype.regexEach = function each(fn) {
	    var delimiter = cloneRegex(this.delimiter),
	        buffer = '',
	        start = 0, end,
	        index = 0;

	    var handle = this.parent.each(function(chunk) {
	      buffer += chunk;

	      var match;
	      while (match = delimiter.exec(buffer)) {
	        end = match.index;
	        if (fn(buffer.substring(start, end), index++) === false) {
	          return false;
	        }
	        start = end + match[0].length;
	      }

	      buffer = buffer.substring(start);
	      start = 0;
	    });

	    handle.onComplete(function() {
	      if (buffer.length > 0) {
	        fn(buffer, index++);
	      }
	    });

	    return handle;
	  };

	  SplitStreamSequence.prototype.stringEach = function each(fn) {
	    var delimiter  = this.delimiter,
	        pieceIndex = 0,
	        buffer = '',
	        bufferIndex = 0;

	    var handle = this.parent.each(function(chunk) {
	      buffer += chunk;
	      var delimiterIndex;
	      while ((delimiterIndex = buffer.indexOf(delimiter)) >= 0) {
	        var piece = buffer.substr(0,delimiterIndex);
	        buffer = buffer.substr(delimiterIndex+delimiter.length);
	        if (fn(piece,pieceIndex++) === false) {
	          return false;
	        }
	      }
	      return true;
	    });

	    handle.onComplete(function() {
	      fn(buffer, pieceIndex++);
	    });

	    return handle;
	  };

	  StreamLikeSequence.prototype.lines = function lines() {
	    return this.split("\n");
	  };

	  StreamLikeSequence.prototype.match = function match(pattern) {
	    return new MatchedStreamSequence(this, pattern);
	  };

	  /**
	   * @constructor
	   */
	  function MatchedStreamSequence(parent, pattern) {
	    this.parent  = parent;
	    this.pattern = cloneRegex(pattern);
	  }

	  MatchedStreamSequence.prototype = new AsyncSequence();

	  MatchedStreamSequence.prototype.each = function each(fn) {
	    var pattern = this.pattern,
	        done      = false,
	        i         = 0;

	    return this.parent.each(function(chunk) {
	      Lazy(chunk).match(pattern).each(function(match) {
	        if (fn(match, i++) === false) {
	          done = true;
	          return false;
	        }
	      });

	      return !done;
	    });
	  };

	  /**
	   * Defines a wrapper for custom {@link StreamLikeSequence}s. This is useful
	   * if you want a way to handle a stream of events as a sequence, but you can't
	   * use Lazy's existing interface (i.e., you're wrapping an object from a
	   * library with its own custom events).
	   *
	   * This method defines a *factory*: that is, it produces a function that can
	   * be used to wrap objects and return a {@link Sequence}. Hopefully the
	   * example will make this clear.
	   *
	   * @public
	   * @param {Function} initializer An initialization function called on objects
	   *     created by this factory. `this` will be bound to the created object,
	   *     which is an instance of {@link StreamLikeSequence}. Use `emit` to
	   *     generate data for the sequence.
	   * @returns {Function} A function that creates a new {@link StreamLikeSequence},
	   *     initializes it using the specified function, and returns it.
	   *
	   * @example
	   * var factory = Lazy.createWrapper(function(eventSource) {
	   *   var sequence = this;
	   *
	   *   eventSource.handleEvent(function(data) {
	   *     sequence.emit(data);
	   *   });
	   * });
	   *
	   * var eventEmitter = {
	   *   triggerEvent: function(data) {
	   *     eventEmitter.eventHandler(data);
	   *   },
	   *   handleEvent: function(handler) {
	   *     eventEmitter.eventHandler = handler;
	   *   },
	   *   eventHandler: function() {}
	   * };
	   *
	   * var events = [];
	   *
	   * factory(eventEmitter).each(function(e) {
	   *   events.push(e);
	   * });
	   *
	   * eventEmitter.triggerEvent('foo');
	   * eventEmitter.triggerEvent('bar');
	   *
	   * events // => ['foo', 'bar']
	   */
	  Lazy.createWrapper = function createWrapper(initializer) {
	    var ctor = function() {
	      this.listeners = [];
	    };

	    ctor.prototype = new StreamLikeSequence();

	    ctor.prototype.each = function(listener) {
	      this.listeners.push(listener);
	    };

	    ctor.prototype.emit = function(data) {
	      var listeners = this.listeners;

	      for (var len = listeners.length, i = len - 1; i >= 0; --i) {
	        if (listeners[i](data) === false) {
	          listeners.splice(i, 1);
	        }
	      }
	    };

	    return function() {
	      var sequence = new ctor();
	      initializer.apply(sequence, arguments);
	      return sequence;
	    };
	  };

	  /**
	   * Creates a {@link GeneratedSequence} using the specified generator function
	   * and (optionally) length.
	   *
	   * @public
	   * @param {function(number):*} generatorFn The function used to generate the
	   *     sequence. This function accepts an index as a parameter and should return
	   *     a value for that index in the resulting sequence.
	   * @param {number=} length The length of the sequence, for sequences with a
	   *     definite length.
	   * @returns {GeneratedSequence} The generated sequence.
	   *
	   * @examples
	   * var randomNumbers = Lazy.generate(Math.random);
	   * var countingNumbers = Lazy.generate(function(i) { return i + 1; }, 5);
	   *
	   * randomNumbers          // instanceof Lazy.GeneratedSequence
	   * randomNumbers.length() // => undefined
	   * countingNumbers          // sequence: [1, 2, 3, 4, 5]
	   * countingNumbers.length() // => 5
	   */
	  Lazy.generate = function generate(generatorFn, length) {
	    return new GeneratedSequence(generatorFn, length);
	  };

	  /**
	   * Creates a sequence from a given starting value, up to a specified stopping
	   * value, incrementing by a given step. Invalid values for any of these
	   * arguments (e.g., a step of 0) result in an empty sequence.
	   *
	   * @public
	   * @returns {GeneratedSequence} The sequence defined by the given ranges.
	   *
	   * @examples
	   * Lazy.range(3)         // sequence: [0, 1, 2]
	   * Lazy.range(1, 4)      // sequence: [1, 2, 3]
	   * Lazy.range(2, 10, 2)  // sequence: [2, 4, 6, 8]
	   * Lazy.range(5, 1, 2)   // sequence: []
	   * Lazy.range(5, 15, -2) // sequence: []
	   * Lazy.range(3, 10, 3)  // sequence: [3, 6, 9]
	   * Lazy.range(5, 2)      // sequence: [5, 4, 3]
	   * Lazy.range(7, 2, -2)  // sequence: [7, 5, 3]
	   * Lazy.range(3, 5, 0)   // sequence: []
	   */
	  Lazy.range = function range() {
	    var start = arguments.length > 1 ? arguments[0] : 0,
	        stop  = arguments.length > 1 ? arguments[1] : arguments[0],
	        step  = arguments.length > 2 && arguments[2];

	    if (step === false) {
	      step = stop > start ? 1 : -1;
	    }

	    if (step === 0) {
	      return Lazy([]);
	    }

	    return Lazy.generate(function(i) { return start + (step * i); })
	      .take(Math.ceil((stop - start) / step));
	  };

	  /**
	   * Creates a sequence consisting of the given value repeated a specified number
	   * of times.
	   *
	   * @public
	   * @param {*} value The value to repeat.
	   * @param {number=} count The number of times the value should be repeated in
	   *     the sequence. If this argument is omitted, the value will repeat forever.
	   * @returns {GeneratedSequence} The sequence containing the repeated value.
	   *
	   * @examples
	   * Lazy.repeat("hi", 3)          // sequence: ["hi", "hi", "hi"]
	   * Lazy.repeat("young")          // instanceof Lazy.GeneratedSequence
	   * Lazy.repeat("young").length() // => undefined
	   * Lazy.repeat("young").take(3)  // sequence: ["young", "young", "young"]
	   */
	  Lazy.repeat = function repeat(value, count) {
	    return Lazy.generate(function() { return value; }, count);
	  };

	  Lazy.Sequence           = Sequence;
	  Lazy.ArrayLikeSequence  = ArrayLikeSequence;
	  Lazy.ObjectLikeSequence = ObjectLikeSequence;
	  Lazy.StringLikeSequence = StringLikeSequence;
	  Lazy.StreamLikeSequence = StreamLikeSequence;
	  Lazy.GeneratedSequence  = GeneratedSequence;
	  Lazy.AsyncSequence      = AsyncSequence;
	  Lazy.AsyncHandle        = AsyncHandle;

	  /*** Useful utility methods ***/

	  /**
	   * Creates a shallow copy of an array or object.
	   *
	   * @examples
	   * var array  = [1, 2, 3], clonedArray,
	   *     object = { foo: 1, bar: 2 }, clonedObject;
	   *
	   * clonedArray = Lazy.clone(array); // => [1, 2, 3]
	   * clonedArray.push(4); // clonedArray == [1, 2, 3, 4]
	   * array; // => [1, 2, 3]
	   *
	   * clonedObject = Lazy.clone(object); // => { foo: 1, bar: 2 }
	   * clonedObject.baz = 3; // clonedObject == { foo: 1, bar: 2, baz: 3 }
	   * object; // => { foo: 1, bar: 2 }
	   */
	  Lazy.clone = function clone(target) {
	    return Lazy(target).value();
	  };

	  /**
	   * Marks a method as deprecated, so calling it will issue a console warning.
	   */
	  Lazy.deprecate = function deprecate(message, fn) {
	    return function() {
	      console.warn(message);
	      return fn.apply(this, arguments);
	    };
	  };

	  var arrayPop   = Array.prototype.pop,
	      arraySlice = Array.prototype.slice;

	  /**
	   * Creates a callback... you know, Lo-Dash style.
	   *
	   * - for functions, just returns the function
	   * - for strings, returns a pluck-style callback
	   * - for objects, returns a where-style callback
	   *
	   * @private
	   * @param {Function|string|Object} callback A function, string, or object to
	   *     convert to a callback.
	   * @param {*} defaultReturn If the callback is undefined, a default return
	   *     value to use for the function.
	   * @returns {Function} The callback function.
	   *
	   * @examples
	   * createCallback(function() {})                  // instanceof Function
	   * createCallback('foo')                          // instanceof Function
	   * createCallback('foo')({ foo: 'bar'})           // => 'bar'
	   * createCallback({ foo: 'bar' })({ foo: 'bar' }) // => true
	   * createCallback({ foo: 'bar' })({ foo: 'baz' }) // => false
	   */
	  function createCallback(callback, defaultValue) {
	    switch (typeof callback) {
	      case "function":
	        return callback;

	      case "string":
	        return function(e) {
	          return e[callback];
	        };

	      case "object":
	        return function(e) {
	          return Lazy(callback).all(function(value, key) {
	            return e[key] === value;
	          });
	        };

	      case "undefined":
	        return defaultValue ?
	          function() { return defaultValue; } :
	          Lazy.identity;

	      default:
	        throw new Error("Don't know how to make a callback from a " + typeof callback + "!");
	    }
	  }

	  /**
	   * Takes a function that returns a value for one argument and produces a
	   * function that compares two arguments.
	   *
	   * @private
	   * @param {Function|string|Object} callback A function, string, or object to
	   *     convert to a callback using `createCallback`.
	   * @returns {Function} A function that accepts two values and returns 1 if
	   *     the first is greater, -1 if the second is greater, or 0 if they are
	   *     equivalent.
	   *
	   * @examples
	   * createComparator('a')({ a: 1 }, { a: 2 });       // => -1
	   * createComparator('a')({ a: 6 }, { a: 2 });       // => 1
	   * createComparator('a')({ a: 1 }, { a: 1 });       // => 0
	   * createComparator()(3, 5);                        // => -1
	   * createComparator()(7, 5);                        // => 1
	   * createComparator()(3, 3);                        // => 0
	   */
	  function createComparator(callback, descending) {
	    if (!callback) { return compare; }

	    callback = createCallback(callback);

	    return function(x, y) {
	      return compare(callback(x), callback(y));
	    };
	  }

	  /**
	   * Takes a function and returns a function with the same logic but the
	   * arguments reversed. Only applies to functions w/ arity=2 as this is private
	   * and I can do what I want.
	   *
	   * @private
	   * @param {Function} fn The function to "reverse"
	   * @returns {Function} The "reversed" function
	   *
	   * @examples
	   * reverseArguments(function(x, y) { return x + y; })('a', 'b'); // => 'ba'
	   */
	  function reverseArguments(fn) {
	    return function(x, y) { return fn(y, x); };
	  }

	  /**
	   * Creates a Set containing the specified values.
	   *
	   * @param {...Array} values One or more array(s) of values used to populate the
	   *     set.
	   * @returns {Set} A new set containing the values passed in.
	   */
	  function createSet(values) {
	    var set = new Set();
	    Lazy(values || []).flatten().each(function(e) {
	      set.add(e);
	    });
	    return set;
	  }

	  /**
	   * Compares two elements for sorting purposes.
	   *
	   * @private
	   * @param {*} x The left element to compare.
	   * @param {*} y The right element to compare.
	   * @returns {number} 1 if x > y, -1 if x < y, or 0 if x and y are equal.
	   *
	   * @examples
	   * compare(1, 2)     // => -1
	   * compare(1, 1)     // => 0
	   * compare(2, 1)     // => 1
	   * compare('a', 'b') // => -1
	   */
	  function compare(x, y) {
	    if (x === y) {
	      return 0;
	    }

	    return x > y ? 1 : -1;
	  }

	  /**
	   * Iterates over every element in an array.
	   *
	   * @param {Array} array The array.
	   * @param {Function} fn The function to call on every element, which can return
	   *     false to stop the iteration early.
	   * @returns {boolean} True if every element in the entire sequence was iterated,
	   *     otherwise false.
	   */
	  function forEach(array, fn) {
	    var i = -1,
	        len = array.length;

	    while (++i < len) {
	      if (fn(array[i], i) === false) {
	        return false;
	      }
	    }

	    return true;
	  }

	  function getFirst(sequence) {
	    var result;
	    sequence.each(function(e) {
	      result = e;
	      return false;
	    });
	    return result;
	  }

	  /**
	   * Checks if an element exists in an array.
	   *
	   * @private
	   * @param {Array} array
	   * @param {*} element
	   * @returns {boolean} Whether or not the element exists in the array.
	   *
	   * @examples
	   * arrayContains([1, 2], 2)              // => true
	   * arrayContains([1, 2], 3)              // => false
	   * arrayContains([undefined], undefined) // => true
	   * arrayContains([NaN], NaN)             // => true
	   */
	  function arrayContains(array, element) {
	    var i = -1,
	        length = array.length;

	    // Special handling for NaN
	    if (element !== element) {
	      while (++i < length) {
	        if (array[i] !== array[i]) {
	          return true;
	        }
	      }
	      return false;
	    }

	    while (++i < length) {
	      if (array[i] === element) {
	        return true;
	      }
	    }
	    return false;
	  }

	  /**
	   * Checks if an element exists in an array before a given index.
	   *
	   * @private
	   * @param {Array} array
	   * @param {*} element
	   * @param {number} index
	   * @param {Function} keyFn
	   * @returns {boolean}
	   *
	   * @examples
	   * arrayContainsBefore([1, 2, 3], 3, 2) // => false
	   * arrayContainsBefore([1, 2, 3], 3, 3) // => true
	   */
	  function arrayContainsBefore(array, element, index, keyFn) {
	    var i = -1;

	    if (keyFn) {
	      keyFn = createCallback(keyFn);
	      while (++i < index) {
	        if (keyFn(array[i]) === keyFn(element)) {
	          return true;
	        }
	      }

	    } else {
	      while (++i < index) {
	        if (array[i] === element) {
	          return true;
	        }
	      }
	    }

	    return false;
	  }

	  /**
	   * Swaps the elements at two specified positions of an array.
	   *
	   * @private
	   * @param {Array} array
	   * @param {number} i
	   * @param {number} j
	   *
	   * @examples
	   * var array = [1, 2, 3, 4, 5];
	   *
	   * swap(array, 2, 3) // array == [1, 2, 4, 3, 5]
	   */
	  function swap(array, i, j) {
	    var temp = array[i];
	    array[i] = array[j];
	    array[j] = temp;
	  }

	  /**
	   * "Clones" a regular expression (but makes it always global).
	   *
	   * @private
	   * @param {RegExp|string} pattern
	   * @returns {RegExp}
	   */
	  function cloneRegex(pattern) {
	    return eval("" + pattern + (!pattern.global ? "g" : ""));
	  };

	  /**
	   * A collection of unique elements.
	   *
	   * @private
	   * @constructor
	   *
	   * @examples
	   * var set  = new Set(),
	   *     obj1 = {},
	   *     obj2 = {},
	   *     fn1 = function fn1() {},
	   *     fn2 = function fn2() {};
	   *
	   * set.add('foo')            // => true
	   * set.add('foo')            // => false
	   * set.add(1)                // => true
	   * set.add(1)                // => false
	   * set.add('1')              // => true
	   * set.add('1')              // => false
	   * set.add(obj1)             // => true
	   * set.add(obj1)             // => false
	   * set.add(obj2)             // => true
	   * set.add(fn1)              // => true
	   * set.add(fn2)              // => true
	   * set.add(fn2)              // => false
	   * set.contains('__proto__') // => false
	   * set.add('__proto__')      // => true
	   * set.add('__proto__')      // => false
	   * set.contains('add')       // => false
	   * set.add('add')            // => true
	   * set.add('add')            // => false
	   * set.contains(undefined)   // => false
	   * set.add(undefined)        // => true
	   * set.contains(undefined)   // => true
	   * set.contains('undefined') // => false
	   * set.add('undefined')      // => true
	   * set.contains('undefined') // => true
	   * set.contains(NaN)         // => false
	   * set.add(NaN)              // => true
	   * set.contains(NaN)         // => true
	   * set.contains('NaN')       // => false
	   * set.add('NaN')            // => true
	   * set.contains('NaN')       // => true
	   * set.contains('@foo')      // => false
	   * set.add('@foo')           // => true
	   * set.contains('@foo')      // => true
	   */
	  function Set() {
	    this.table   = {};
	    this.objects = [];
	  }

	  /**
	   * Attempts to add a unique value to the set.
	   *
	   * @param {*} value The value to add.
	   * @returns {boolean} True if the value was added to the set (meaning an equal
	   *     value was not already present), or else false.
	   */
	  Set.prototype.add = function add(value) {
	    var table = this.table,
	        type  = typeof value,

	        // only applies for strings
	        firstChar,

	        // only applies for objects
	        objects;

	    switch (type) {
	      case "number":
	      case "boolean":
	      case "undefined":
	        if (!table[value]) {
	          table[value] = true;
	          return true;
	        }
	        return false;

	      case "string":
	        // Essentially, escape the first character if it could possibly collide
	        // with a number, boolean, or undefined (or a string that happens to start
	        // with the escape character!), OR if it could override a special property
	        // such as '__proto__' or 'constructor'.
	        switch (value.charAt(0)) {
	          case "_": // e.g., __proto__
	          case "f": // for 'false'
	          case "t": // for 'true'
	          case "c": // for 'constructor'
	          case "u": // for 'undefined'
	          case "@": // escaped
	          case "0":
	          case "1":
	          case "2":
	          case "3":
	          case "4":
	          case "5":
	          case "6":
	          case "7":
	          case "8":
	          case "9":
	          case "N": // for NaN
	            value = "@" + value;
	        }
	        if (!table[value]) {
	          table[value] = true;
	          return true;
	        }
	        return false;

	      default:
	        // For objects and functions, we can't really do anything other than store
	        // them in an array and do a linear search for reference equality.
	        objects = this.objects;
	        if (!arrayContains(objects, value)) {
	          objects.push(value);
	          return true;
	        }
	        return false;
	    }
	  };

	  /**
	   * Checks whether the set contains a value.
	   *
	   * @param {*} value The value to check for.
	   * @returns {boolean} True if the set contains the value, or else false.
	   */
	  Set.prototype.contains = function contains(value) {
	    var type = typeof value,

	        // only applies for strings
	        firstChar;

	    switch (type) {
	      case "number":
	      case "boolean":
	      case "undefined":
	        return !!this.table[value];

	      case "string":
	        // Essentially, escape the first character if it could possibly collide
	        // with a number, boolean, or undefined (or a string that happens to start
	        // with the escape character!), OR if it could override a special property
	        // such as '__proto__' or 'constructor'.
	        switch (value.charAt(0)) {
	          case "_": // e.g., __proto__
	          case "f": // for 'false'
	          case "t": // for 'true'
	          case "c": // for 'constructor'
	          case "u": // for 'undefined'
	          case "@": // escaped
	          case "0":
	          case "1":
	          case "2":
	          case "3":
	          case "4":
	          case "5":
	          case "6":
	          case "7":
	          case "8":
	          case "9":
	          case "N": // for NaN
	            value = "@" + value;
	        }
	        return !!this.table[value];

	      default:
	        // For objects and functions, we can't really do anything other than store
	        // them in an array and do a linear search for reference equality.
	        return arrayContains(this.objects, value);
	    }
	  };

	  /**
	   * A "rolling" queue, with a fixed capacity. As items are added to the head,
	   * excess items are dropped from the tail.
	   *
	   * @private
	   * @constructor
	   *
	   * @examples
	   * var queue = new Queue(3);
	   *
	   * queue.add(1).toArray()        // => [1]
	   * queue.add(2).toArray()        // => [1, 2]
	   * queue.add(3).toArray()        // => [1, 2, 3]
	   * queue.add(4).toArray()        // => [2, 3, 4]
	   * queue.add(5).add(6).toArray() // => [4, 5, 6]
	   * queue.add(7).add(8).toArray() // => [6, 7, 8]
	   *
	   * // also want to check corner cases
	   * new Queue(1).add('foo').add('bar').toArray() // => ['bar']
	   * new Queue(0).add('foo').toArray()            // => []
	   * new Queue(-1)                                // throws
	   *
	   * @benchmarks
	   * function populateQueue(count, capacity) {
	   *   var q = new Queue(capacity);
	   *   for (var i = 0; i < count; ++i) {
	   *     q.add(i);
	   *   }
	   * }
	   *
	   * function populateArray(count, capacity) {
	   *   var arr = [];
	   *   for (var i = 0; i < count; ++i) {
	   *     if (arr.length === capacity) { arr.shift(); }
	   *     arr.push(i);
	   *   }
	   * }
	   *
	   * populateQueue(100, 10); // populating a Queue
	   * populateArray(100, 10); // populating an Array
	   */
	  function Queue(capacity) {
	    this.contents = new Array(capacity);
	    this.start    = 0;
	    this.count    = 0;
	  }

	  /**
	   * Adds an item to the queue, and returns the queue.
	   */
	  Queue.prototype.add = function add(element) {
	    var contents = this.contents,
	        capacity = contents.length,
	        start    = this.start;

	    if (this.count === capacity) {
	      contents[start] = element;
	      this.start = (start + 1) % capacity;

	    } else {
	      contents[this.count++] = element;
	    }

	    return this;
	  };

	  /**
	   * Returns an array containing snapshot of the queue's contents.
	   */
	  Queue.prototype.toArray = function toArray() {
	    var contents = this.contents,
	        start    = this.start,
	        count    = this.count;

	    var snapshot = contents.slice(start, start + count);
	    if (snapshot.length < count) {
	      snapshot = snapshot.concat(contents.slice(0, count - snapshot.length));
	    }

	    return snapshot;
	  };

	  /**
	   * Shared base method for defining new sequence types.
	   */
	  function defineSequenceType(base, name, overrides) {
	    /** @constructor */
	    var ctor = function ctor() {};

	    // Make this type inherit from the specified base.
	    ctor.prototype = new base();

	    // Attach overrides to the new sequence type's prototype.
	    for (var override in overrides) {
	      ctor.prototype[override] = overrides[override];
	    }

	    // Define a factory method that sets the new sequence's parent to the caller
	    // and (optionally) applies any additional initialization logic.
	    // Expose this as a chainable method so that we can do:
	    // Lazy(...).map(...).filter(...).blah(...);
	    var factory = function factory() {
	      var sequence = new ctor();

	      // Every sequence needs a reference to its parent in order to work.
	      sequence.parent = this;

	      // If a custom init function was supplied, call it now.
	      if (sequence.init) {
	        sequence.init.apply(sequence, arguments);
	      }

	      return sequence;
	    };

	    var methodNames = typeof name === 'string' ? [name] : name;
	    for (var i = 0; i < methodNames.length; ++i) {
	      base.prototype[methodNames[i]] = factory;
	    }

	    return ctor;
	  }

	  return Lazy;
	});


/***/ },
/* 177 */
/*!***************************************!*\
  !*** ./~/node-helpers/environment.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';


	//---------//
	// Imports //
	//---------//

	var lazy = __webpack_require__(/*! ./lazy-extensions */ 173);


	//-------------------//
	// Static Properties //
	//-------------------//

	Environment.DEV = 'dev';
	Environment.TEST = 'test';
	Environment.PROD = 'prod';

	Environment.ENVS = lazy([
	  Environment.DEV
	  , Environment.TEST
	  , Environment.PROD
	]);

	Environment.CLIENT_ENV = 'ENV_NODE_ENV';


	//------//
	// Main //
	//------//

	function Environment() {
	  var self = this;

	  var my = {
	    HardCoded: null
	    , ServerEnv: null
	    , DefaultServerEnv: 'WEATHER_ACCURACY_NODE_ENV'
	    , AllowDefaultServerEnv: true
	  };

	  self.HardCoded = function(hardcoded_) {
	    var res = my.HardCoded;
	    if (arguments.length > 0) {
	      if (hardcoded_ !== null) {
	        if (!self.AllowDefaultServerEnv() && self.ServerEnv() !== null) {
	          throw new Error('Invalid State: When setting ValidateHardCoded, ServerEnv must equal null');
	        }
	        Environment.ValidateHardCoded(hardcoded_, true);
	      }
	      my.HardCoded = hardcoded_;
	      res = self;
	    }
	    return res;
	  };

	  self.ServerEnv = function(serverenv_) {
	    var res = my.ServerEnv;
	    if (arguments.length > 0) {
	      if (serverenv_ !== null) {
	        if (self.HardCoded()) {
	          throw new Error('Invalid State: When setting ValidateServerEnv, HardCoded must equal null');
	        }
	        Environment.ValidateServerEnv(serverenv_, true);
	      }
	      my.ServerEnv = serverenv_;
	      res = self;
	    } else if (self.AllowDefaultServerEnv()) {
	      res = res || my.DefaultServerEnv;
	    }
	    return res;
	  };

	  self.AllowDefaultServerEnv = function(allowdefaultserverenv_) {
	    var res = my.AllowDefaultServerEnv;
	    if (arguments.length > 0) {
	      if (allowdefaultserverenv_ !== null) {
	        Environment.ValidateAllowDefaultServerEnv(allowdefaultserverenv_, true);
	      }
	      my.AllowDefaultServerEnv = allowdefaultserverenv_;
	      res = self;
	    }
	    return res;
	  };
	}


	//------------//
	// Validation //
	//------------//

	Environment.ValidateHardCoded = function ValidateHardCoded(input, throwErr) {
	  var msg = '';

	  if (typeof input !== 'string') {
	    msg = 'Invalid Argument: <Environment>.ValidateHardCoded requires a typeof string argument';
	  } else {
	    msg = Environment.ValidateEnv(input, throwErr);
	  }

	  if (throwErr && msg) {
	    throw new Error(msg);
	  }

	  return msg;
	};

	Environment.ValidateServerEnv = function ValidateServerEnv(input, throwErr) {
	  var msg = '';

	  if (typeof input !== 'string') {
	    msg = 'Invalid Argument: <Environment>.ValidateServerEnv requires a typeof string';
	  } else if (!process
	    || !process.env
	    || typeof process.env[input] === 'undefined'
	    || Environment.ValidateEnv(process.env[input])) {

	    msg = "Invalid Argument: process.env." + input + " is undefined.  <Environment>.ValidateServerEnv requires an existing environment variable name";
	  }

	  if (throwErr && msg) {
	    throw new Error(msg);
	  }

	  return msg;
	};

	Environment.ValidateAllowDefaultServerEnv = function ValidateAllowDefaultServerEnv(input, throwErr) {
	  var msg = '';
	  if (typeof input !== 'boolean') {
	    msg = 'Invalid Argument: <Environment>.ValidateAllowDefaultServerEnv requires a typeof boolean argument';
	  }

	  if (throwErr && msg) {
	    throw new Error(msg);
	  }

	  return msg;
	};

	Environment.ValidateEnv = function ValidateEnv(env, throwErr) {
	  var msg = "";

	  if (typeof env !== 'string') {
	    throw new Error("Invalid Argument: Environment.ValidateEnv only validates environment strings");
	  }

	  if (!Environment.ENVS.has(env.toLowerCase())) {
	    msg = "Invalid Argument: environment '" + env + "' doesn't match one of the following " + Environment.ENVS.toArray();
	  }

	  if (throwErr && msg) {
	    throw new Error(msg);
	  }

	  return msg;
	};


	//-----------------------//
	// Prototyped Extensions //
	//-----------------------//

	Environment.prototype.getCurrentEnvironment = function getCurrentEnvironment() {
	  this._validateState();

	  var res;

	  if (this.HardCoded()) {
	    res = this.HardCoded();
	  } else if (process
	    && process.env
	    && process.env[this.ServerEnv()]
	    && Environment.ENVS.contains(process.env[this.ServerEnv()].toLowerCase())) {
	    res = process.env[this.ServerEnv()];
	  } else if (Environment.ENVS.contains(Environment.CLIENT_ENV)) {
	    res = Environment.CLIENT_ENV;
	  }

	  if (!res || !Environment.ENVS.contains(res.toLowerCase())) {
	    throw new Error('Invalid State: No environment was found.  This could be due to relying on a non-existent default ServerEnv.');
	  }

	  return res;
	};
	Environment.prototype.curEnv = Environment.prototype.getCurrentEnvironment;

	Environment.prototype.isDev = function isDev() {
	  return this.getCurrentEnvironment() === Environment.DEV;
	};
	Environment.prototype.isTest = function isTest() {
	  return this.getCurrentEnvironment() === Environment.TEST;
	};
	Environment.prototype.isProd = function isProd() {
	  return this.getCurrentEnvironment() === Environment.PROD;
	};


	//-------------------------------//
	// Private Prototyped Extensions //
	//-------------------------------//

	Environment.prototype._validateState = function _validateState() {
	  // invalid if default server environment isn't allowed, and neither HardCoded nor ServerEnv are set
	  if (this.HardCoded() === null
	    && this.ServerEnv() === null
	    && !Environment.ENVS.contains(Environment.CLIENT_ENV)) {

	    throw new Error("Invalid State: None of the following cases were met\n1) A hard coded environment string is passed.\n2) Called server-side with an environment variable"
	      + "(specified by ServerEnv()) declared.\n3) Called client-side with the server replacing ENV_" + "NODE_ENV with the proper node environment string");
	  }
	};


	//---------//
	// Exports //
	//---------//

	module.exports = Environment;


/***/ },
/* 178 */
/*!******************************************!*\
  !*** ./~/node-helpers/bunyan-streams.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	//---------//
	// Imports //
	//---------//

	var bunyan = __webpack_require__(/*! bunyan */ 179)
	    , moment = __webpack_require__(/*! moment */ 209)
	    , Environment = __webpack_require__(/*! ./environment */ 177);


	//------//
	// Main //
	//------//

	function bstreams(appName, env, optLevel) {
	    Environment.ValidateEnv(env, true);

	    envMapping = getEnvironmentMapping();

	    var logLevel = optLevel;
	    // if optLevel wasn't passed, then we get the default level based on the passed environment
	    if (!optLevel) {
	        logLevel = envMapping[env].level;
	    }

	    var logType = envMapping[env].type;
	    var logSrc = envMapping[env].src;

	    var MyStream = function() {};
	    MyStream.prototype.write = envMapping[env].formatter;

	    return {
	        stream: new MyStream()
	        , level: logLevel
	        , type: logType
	        , source: logSrc
	    };
	}

	function getEnvironmentMapping() {
	    var res = {};
	    res[Environment.DEV] = {
	        'level': bunyan.TRACE
	        , 'formatter': localFormatter
	        , 'type': 'raw'
	        , 'src': true
	    };
	    res[Environment.TEST] = {
	        'level': bunyan.DEBUG
	        , 'formatter': testFormatter
	        , 'type': 'raw'
	        , 'src': false
	    };
	    res[Environment.PROD] = {
	        'level': bunyan.INFO
	        , 'formatter': prodFormatter
	        , 'type': 'stream'
	        , 'src': false
	    };

	    return res;
	}


	//-------------//
	// Helper Fxns //
	//-------------//

	function localFormatter(rec) {
	    if (rec.level >= bunyan.WARN) {
	        console.log('Time: %s\n App: %s\n Level: %s\n Message: %s\n Source\n   File: %s\n   Line: %s\n   Fxn: %s\n'
	            , moment(rec.time).format('HH:mm:ss.SS')
	            , rec.name
	            , mapLevelToName(rec.level)
	            , rec.msg
	            , rec.src.file
	            , rec.src.line
	            , rec.src.func
	        );
	    } else { // level == trace || debug || info
	        console.log('[%s] %s: %s'
	            , moment(rec.time).format('HH:mm:ss.SS')
	            , mapLevelToName(rec.level)
	            , rec.msg);
	    }
	}

	function testFormatter(rec) {
	    console.log('Time: %s\n App: %s\n Level: %s\n Message: %s\n'
	        , moment(rec.time).format('HH:mm:ss.SS')
	        , rec.name
	        , mapLevelToName(rec.level)
	        , rec.msg
	    );
	}

	function prodFormatter(rec) {
	    console.log(rec);
	}

	function mapLevelToName(level) {
	    var res = '';
	    switch (level) {
	        case bunyan.TRACE:
	            res = 'DEBUG';
	            break;
	        case bunyan.DEBUG:
	            res = 'DEBUG';
	            break;
	        case bunyan.INFO:
	            res = 'INFO';
	            break;
	        case bunyan.WARN:
	            res = 'WARN';
	            break;
	        case bunyan.ERROR:
	            res = 'ERROR';
	            break;
	        case bunyan.FATAL:
	            res = 'FATAL';
	            break;
	    }
	    return res;
	}


	//---------//
	// Exports //
	//---------//

	module.exports = bstreams;
	module.exports.EnvironmentMapping = getEnvironmentMapping();


/***/ },
/* 179 */
/*!********************************!*\
  !*** ./~/bunyan/lib/bunyan.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014 Trent Mick. All rights reserved.
	 * Copyright (c) 2014 Joyent Inc. All rights reserved.
	 *
	 * The bunyan logging library for node.js.
	 *
	 * -*- mode: js -*-
	 * vim: expandtab:ts=4:sw=4
	 */

	var VERSION = '1.3.5';

	// Bunyan log format version. This becomes the 'v' field on all log records.
	// `0` is until I release a version '1.0.0' of node-bunyan. Thereafter,
	// starting with `1`, this will be incremented if there is any backward
	// incompatible change to the log record format. Details will be in
	// 'CHANGES.md' (the change log).
	var LOG_VERSION = 0;


	var xxx = function xxx(s) { // internal dev/debug logging
	    var args = ['XX' + 'X: ' + s].concat(
	        Array.prototype.slice.call(arguments, 1));
	    console.error.apply(this, args);
	};
	var xxx = function xxx() {}; // comment out to turn on debug logging


	var os = __webpack_require__(/*! os */ 175);
	var fs = __webpack_require__(/*! fs */ 19);
	var util = __webpack_require__(/*! util */ 16);
	var assert = __webpack_require__(/*! assert */ 161);
	try {
	    /* Use `+ ''` to hide this import from browserify. */
	    var dtrace = __webpack_require__(/*! dtrace-provider */ 180);
	} catch (e) {
	    dtrace = null;
	}
	var EventEmitter = __webpack_require__(/*! events */ 26).EventEmitter;

	try {
	    var safeJsonStringify = __webpack_require__(/*! safe-json-stringify */ 181);
	} catch (e) {
	    safeJsonStringify = null;
	}
	if (process.env.BUNYAN_TEST_NO_SAFE_JSON_STRINGIFY) {
	    safeJsonStringify = null;
	}

	// The 'mv' module is required for rotating-file stream support.
	try {
	    /* Use `+ ''` to hide this import from browserify. */
	    var mv = __webpack_require__(/*! mv */ 182);
	} catch (e) {
	    mv = null;
	}

	// Are we in the browser (e.g. running via browserify)?
	var isBrowser = function() {
	    return typeof(window) !== 'undefined' && this === window;
	}();

	try {
	    /* Use `+ ''` to hide this import from browserify. */
	    var sourceMapSupport = __webpack_require__(/*! source-map-support */ 199);
	} catch (_) {
	    sourceMapSupport = null;
	}



	//---- Internal support stuff

	/**
	 * A shallow copy of an object. Bunyan logging attempts to never cause
	 * exceptions, so this function attempts to handle non-objects gracefully.
	 */
	function objCopy(obj) {
	    if (obj == null) { // null or undefined
	        return obj;
	    } else if (Array.isArray(obj)) {
	        return obj.slice();
	    } else if (typeof(obj) === 'object') {
	        var copy = {};
	        Object.keys(obj).forEach(function(k) {
	            copy[k] = obj[k];
	        });
	        return copy;
	    } else {
	        return obj;
	    }
	}

	var format = util.format;
	if (!format) {
	    // If node < 0.6, then use its `util.format`:
	    // <https://github.com/joyent/node/blob/master/lib/util.js#L22>:
	    var inspect = util.inspect;
	    var formatRegExp = /%[sdj%]/g;
	    format = function format(f) {
	        if (typeof(f) !== 'string') {
	            var objects = [];
	            for (var i = 0; i < arguments.length; i++) {
	                objects.push(inspect(arguments[i]));
	            }
	            return objects.join(' ');
	        }

	        var i = 1;
	        var args = arguments;
	        var len = args.length;
	        var str = String(f).replace(formatRegExp, function(x) {
	            if (i >= len)
	                return x;
	            switch (x) {
	                case '%s':
	                    return String(args[i++]);
	                case '%d':
	                    return Number(args[i++]);
	                case '%j':
	                    return JSON.stringify(args[i++], safeCycles());
	                case '%%':
	                    return '%';
	                default:
	                    return x;
	            }
	        });
	        for (var x = args[i]; i < len; x = args[++i]) {
	            if (x === null || typeof(x) !== 'object') {
	                str += ' ' + x;
	            } else {
	                str += ' ' + inspect(x);
	            }
	        }
	        return str;
	    };
	}


	/**
	 * Gather some caller info 3 stack levels up.
	 * See <http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi>.
	 */
	function getCaller3Info() {
	    var obj = {};
	    var saveLimit = Error.stackTraceLimit;
	    var savePrepare = Error.prepareStackTrace;
	    Error.stackTraceLimit = 3;

	    if (typeof Error.captureStackTrace === 'function') {
	        Error.captureStackTrace(this, getCaller3Info);
	    }

	    Error.prepareStackTrace = function(_, stack) {
	        var caller = stack[2];
	        if (sourceMapSupport) {
	            caller = sourceMapSupport.wrapCallSite(caller);
	        }
	        obj.file = caller.getFileName();
	        obj.line = caller.getLineNumber();
	        var func = caller.getFunctionName();
	        if (func)
	            obj.func = func;
	    };
	    this.stack;
	    Error.stackTraceLimit = saveLimit;
	    Error.prepareStackTrace = savePrepare;
	    return obj;
	}


	function _indent(s, indent) {
	    if (!indent) indent = '    ';
	    var lines = s.split(/\r?\n/g);
	    return indent + lines.join('\n' + indent);
	}


	/**
	 * Warn about an bunyan processing error.
	 *
	 * @param msg {String} Message with which to warn.
	 * @param dedupKey {String} Optional. A short string key for this warning to
	 *      have its warning only printed once.
	 */
	function _warn(msg, dedupKey) {
	    assert.ok(msg);
	    if (dedupKey) {
	        if (_warned[dedupKey]) {
	            return;
	        }
	        _warned[dedupKey] = true;
	    }
	    process.stderr.write(msg + '\n');
	}

	function _haveWarned(dedupKey) {
	    return _warned[dedupKey];
	}
	var _warned = {};


	function ConsoleRawStream() {}
	ConsoleRawStream.prototype.write = function(rec) {
	    if (rec.level < INFO) {
	        console.log(rec);
	    } else if (rec.level < WARN) {
	        console.info(rec);
	    } else if (rec.level < ERROR) {
	        console.warn(rec);
	    } else {
	        console.error(rec);
	    }
	};


	//---- Levels

	var TRACE = 10;
	var DEBUG = 20;
	var INFO = 30;
	var WARN = 40;
	var ERROR = 50;
	var FATAL = 60;

	var levelFromName = {
	    'trace': TRACE,
	    'debug': DEBUG,
	    'info': INFO,
	    'warn': WARN,
	    'error': ERROR,
	    'fatal': FATAL
	};
	var nameFromLevel = {};
	Object.keys(levelFromName).forEach(function(name) {
	    nameFromLevel[levelFromName[name]] = name;
	});

	// Dtrace probes.
	var dtp = undefined;
	var probes = dtrace && {};

	/**
	 * Resolve a level number, name (upper or lowercase) to a level number value.
	 *
	 * @api public
	 */
	function resolveLevel(nameOrNum) {
	    var level = (typeof(nameOrNum) === 'string'
	        ? levelFromName[nameOrNum.toLowerCase()]
	        : nameOrNum);
	    return level;
	}



	//---- Logger class

	/**
	 * Create a Logger instance.
	 *
	 * @param options {Object} See documentation for full details. At minimum
	 *    this must include a 'name' string key. Configuration keys:
	 *      - `streams`: specify the logger output streams. This is an array of
	 *        objects with these fields:
	 *          - `type`: The stream type. See README.md for full details.
	 *            Often this is implied by the other fields. Examples are
	 *            'file', 'stream' and "raw".
	 *          - `level`: Defaults to 'info'.
	 *          - `path` or `stream`: The specify the file path or writeable
	 *            stream to which log records are written. E.g.
	 *            `stream: process.stdout`.
	 *          - `closeOnExit` (boolean): Optional. Default is true for a
	 *            'file' stream when `path` is given, false otherwise.
	 *        See README.md for full details.
	 *      - `level`: set the level for a single output stream (cannot be used
	 *        with `streams`)
	 *      - `stream`: the output stream for a logger with just one, e.g.
	 *        `process.stdout` (cannot be used with `streams`)
	 *      - `serializers`: object mapping log record field names to
	 *        serializing functions. See README.md for details.
	 *      - `src`: Boolean (default false). Set true to enable 'src' automatic
	 *        field with log call source info.
	 *    All other keys are log record fields.
	 *
	 * An alternative *internal* call signature is used for creating a child:
	 *    new Logger(<parent logger>, <child options>[, <child opts are simple>]);
	 *
	 * @param _childSimple (Boolean) An assertion that the given `_childOptions`
	 *    (a) only add fields (no config) and (b) no serialization handling is
	 *    required for them. IOW, this is a fast path for frequent child
	 *    creation.
	 */
	function Logger(options, _childOptions, _childSimple) {
	    xxx('Logger start:', options)
	    if (!(this instanceof Logger)) {
	        return new Logger(options, _childOptions);
	    }

	    // Input arg validation.
	    var parent;
	    if (_childOptions !== undefined) {
	        parent = options;
	        options = _childOptions;
	        if (!(parent instanceof Logger)) {
	            throw new TypeError(
	                'invalid Logger creation: do not pass a second arg');
	        }
	    }
	    if (!options) {
	        throw new TypeError('options (object) is required');
	    }
	    if (!parent) {
	        if (!options.name) {
	            throw new TypeError('options.name (string) is required');
	        }
	    } else {
	        if (options.name) {
	            throw new TypeError(
	                'invalid options.name: child cannot set logger name');
	        }
	    }
	    if (options.stream && options.streams) {
	        throw new TypeError('cannot mix "streams" and "stream" options');
	    }
	    if (options.streams && !Array.isArray(options.streams)) {
	        throw new TypeError('invalid options.streams: must be an array')
	    }
	    if (options.serializers && (typeof(options.serializers) !== 'object' ||
	            Array.isArray(options.serializers))) {
	        throw new TypeError('invalid options.serializers: must be an object')
	    }

	    EventEmitter.call(this);

	    // Fast path for simple child creation.
	    if (parent && _childSimple) {
	        // `_isSimpleChild` is a signal to stream close handling that this child
	        // owns none of its streams.
	        this._isSimpleChild = true;

	        this._level = parent._level;
	        this.streams = parent.streams;
	        this.serializers = parent.serializers;
	        this.src = parent.src;
	        var fields = this.fields = {};
	        var parentFieldNames = Object.keys(parent.fields);
	        for (var i = 0; i < parentFieldNames.length; i++) {
	            var name = parentFieldNames[i];
	            fields[name] = parent.fields[name];
	        }
	        var names = Object.keys(options);
	        for (var i = 0; i < names.length; i++) {
	            var name = names[i];
	            fields[name] = options[name];
	        }
	        return;
	    }

	    // Null values.
	    var self = this;
	    if (parent) {
	        this._level = parent._level;
	        this.streams = [];
	        for (var i = 0; i < parent.streams.length; i++) {
	            var s = objCopy(parent.streams[i]);
	            s.closeOnExit = false; // Don't own parent stream.
	            this.streams.push(s);
	        }
	        this.serializers = objCopy(parent.serializers);
	        this.src = parent.src;
	        this.fields = objCopy(parent.fields);
	        if (options.level) {
	            this.level(options.level);
	        }
	    } else {
	        this._level = Number.POSITIVE_INFINITY;
	        this.streams = [];
	        this.serializers = null;
	        this.src = false;
	        this.fields = {};
	    }

	    if (!dtp && dtrace) {
	        dtp = dtrace.createDTraceProvider('bunyan');

	        for (var level in levelFromName) {
	            var probe;

	            probes[levelFromName[level]] = probe =
	                dtp.addProbe('log-' + level, 'char *');

	            // Explicitly add a reference to dtp to prevent it from being GC'd
	            probe.dtp = dtp;
	        }

	        dtp.enable();
	    }

	    // Handle *config* options (i.e. options that are not just plain data
	    // for log records).
	    if (options.stream) {
	        self.addStream({
	            type: 'stream',
	            stream: options.stream,
	            closeOnExit: false,
	            level: options.level
	        });
	    } else if (options.streams) {
	        options.streams.forEach(function(s) {
	            self.addStream(s, options.level);
	        });
	    } else if (parent && options.level) {
	        this.level(options.level);
	    } else if (!parent) {
	        if (isBrowser) {
	            /*
	             * In the browser we'll be emitting to console.log by default.
	             * Any console.log worth its salt these days can nicely render
	             * and introspect objects (e.g. the Firefox and Chrome console)
	             * so let's emit the raw log record. Are there browsers for which
	             * that breaks things?
	             */
	            self.addStream({
	                type: 'raw',
	                stream: new ConsoleRawStream(),
	                closeOnExit: false,
	                level: options.level
	            });
	        } else {
	            self.addStream({
	                type: 'stream',
	                stream: process.stdout,
	                closeOnExit: false,
	                level: options.level
	            });
	        }
	    }
	    if (options.serializers) {
	        self.addSerializers(options.serializers);
	    }
	    if (options.src) {
	        this.src = true;
	    }
	    xxx('Logger: ', self)

	    // Fields.
	    // These are the default fields for log records (minus the attributes
	    // removed in this constructor). To allow storing raw log records
	    // (unrendered), `this.fields` must never be mutated. Create a copy for
	    // any changes.
	    var fields = objCopy(options);
	    delete fields.stream;
	    delete fields.level;
	    delete fields.streams;
	    delete fields.serializers;
	    delete fields.src;
	    if (this.serializers) {
	        this._applySerializers(fields);
	    }
	    if (!fields.hostname) {
	        fields.hostname = os.hostname();
	    }
	    if (!fields.pid) {
	        fields.pid = process.pid;
	    }
	    Object.keys(fields).forEach(function(k) {
	        self.fields[k] = fields[k];
	    });
	}

	util.inherits(Logger, EventEmitter);


	/**
	 * Add a stream
	 *
	 * @param stream {Object}. Object with these fields:
	 *    - `type`: The stream type. See README.md for full details.
	 *      Often this is implied by the other fields. Examples are
	 *      'file', 'stream' and "raw".
	 *    - `path` or `stream`: The specify the file path or writeable
	 *      stream to which log records are written. E.g.
	 *      `stream: process.stdout`.
	 *    - `level`: Optional. Falls back to `defaultLevel`.
	 *    - `closeOnExit` (boolean): Optional. Default is true for a
	 *      'file' stream when `path` is given, false otherwise.
	 *    See README.md for full details.
	 * @param defaultLevel {Number|String} Optional. A level to use if
	 *      `stream.level` is not set. If neither is given, this defaults to INFO.
	 */
	Logger.prototype.addStream = function addStream(s, defaultLevel) {
	    var self = this;
	    if (defaultLevel === null || defaultLevel === undefined) {
	        defaultLevel = INFO;
	    }

	    s = objCopy(s);

	    // Implicit 'type' from other args.
	    var type = s.type;
	    if (!s.type) {
	        if (s.stream) {
	            s.type = 'stream';
	        } else if (s.path) {
	            s.type = 'file'
	        }
	    }
	    s.raw = (s.type === 'raw'); // PERF: Allow for faster check in `_emit`.

	    if (s.level) {
	        s.level = resolveLevel(s.level);
	    } else {
	        s.level = resolveLevel(defaultLevel);
	    }
	    if (s.level < self._level) {
	        self._level = s.level;
	    }

	    switch (s.type) {
	        case 'stream':
	            if (!s.closeOnExit) {
	                s.closeOnExit = false;
	            }
	            break;
	        case 'file':
	            if (!s.stream) {
	                s.stream = fs.createWriteStream(s.path, {
	                    flags: 'a', encoding: 'utf8'
	                });
	                s.stream.on('error', function(err) {
	                    self.emit('error', err, s);
	                });
	                if (!s.closeOnExit) {
	                    s.closeOnExit = true;
	                }
	            } else {
	                if (!s.closeOnExit) {
	                    s.closeOnExit = false;
	                }
	            }
	            break;
	        case 'rotating-file':
	            assert.ok(!s.stream,
	                '"rotating-file" stream should not give a "stream"');
	            assert.ok(s.path);
	            assert.ok(mv, '"rotating-file" stream type is not supported: '
	                + 'missing "mv" module');
	            s.stream = new RotatingFileStream(s);
	            if (!s.closeOnExit) {
	                s.closeOnExit = true;
	            }
	            break;
	        case 'raw':
	            if (!s.closeOnExit) {
	                s.closeOnExit = false;
	            }
	            break;
	        default:
	            throw new TypeError('unknown stream type "' + s.type + '"');
	    }

	    self.streams.push(s);
	    delete self.haveNonRawStreams;  // reset
	}


	/**
	 * Add serializers
	 *
	 * @param serializers {Object} Optional. Object mapping log record field names
	 *    to serializing functions. See README.md for details.
	 */
	Logger.prototype.addSerializers = function addSerializers(serializers) {
	    var self = this;

	    if (!self.serializers) {
	        self.serializers = {};
	    }
	    Object.keys(serializers).forEach(function(field) {
	        var serializer = serializers[field];
	        if (typeof(serializer) !== 'function') {
	            throw new TypeError(format(
	                'invalid serializer for "%s" field: must be a function',
	                field));
	        } else {
	            self.serializers[field] = serializer;
	        }
	    });
	}



	/**
	 * Create a child logger, typically to add a few log record fields.
	 *
	 * This can be useful when passing a logger to a sub-component, e.g. a
	 * 'wuzzle' component of your service:
	 *
	 *    var wuzzleLog = log.child({component: 'wuzzle'})
	 *    var wuzzle = new Wuzzle({..., log: wuzzleLog})
	 *
	 * Then log records from the wuzzle code will have the same structure as
	 * the app log, *plus the component='wuzzle' field*.
	 *
	 * @param options {Object} Optional. Set of options to apply to the child.
	 *    All of the same options for a new Logger apply here. Notes:
	 *      - The parent's streams are inherited and cannot be removed in this
	 *        call. Any given `streams` are *added* to the set inherited from
	 *        the parent.
	 *      - The parent's serializers are inherited, though can effectively be
	 *        overwritten by using duplicate keys.
	 *      - Can use `level` to set the level of the streams inherited from
	 *        the parent. The level for the parent is NOT affected.
	 * @param simple {Boolean} Optional. Set to true to assert that `options`
	 *    (a) only add fields (no config) and (b) no serialization handling is
	 *    required for them. IOW, this is a fast path for frequent child
	 *    creation. See 'tools/timechild.js' for numbers.
	 */
	Logger.prototype.child = function (options, simple) {
	    return new (this.constructor)(this, options || {}, simple);
	}


	/**
	 * A convenience method to reopen 'file' streams on a logger. This can be
	 * useful with external log rotation utilities that move and re-open log files
	 * (e.g. logrotate on Linux, logadm on SmartOS/Illumos). Those utilities
	 * typically have rotation options to copy-and-truncate the log file, but
	 * you may not want to use that. An alternative is to do this in your
	 * application:
	 *
	 *      var log = bunyan.createLogger(...);
	 *      ...
	 *      process.on('SIGUSR2', function () {
	 *          log.reopenFileStreams();
	 *      });
	 *      ...
	 *
	 * See <https://github.com/trentm/node-bunyan/issues/104>.
	 */
	Logger.prototype.reopenFileStreams = function() {
	    var self = this;
	    self.streams.forEach(function(s) {
	        if (s.type === 'file') {
	            if (s.stream) {
	                // Not sure if typically would want this, or more immediate
	                // `s.stream.destroy()`.
	                s.stream.end();
	                s.stream.destroySoon();
	                delete s.stream;
	            }
	            s.stream = fs.createWriteStream(s.path, {
	                flags: 'a', encoding: 'utf8'
	            });
	            s.stream.on('error', function(err) {
	                self.emit('error', err, s);
	            });
	        }
	    });
	};


	/* BEGIN JSSTYLED */
	/**
	 * Close this logger.
	 *
	 * This closes streams (that it owns, as per 'endOnClose' attributes on
	 * streams), etc. Typically you **don't** need to bother calling this.
	Logger.prototype.close = function () {
	    if (this._closed) {
	        return;
	    }
	    if (!this._isSimpleChild) {
	        self.streams.forEach(function (s) {
	            if (s.endOnClose) {
	                xxx('closing stream s:', s);
	                s.stream.end();
	                s.endOnClose = false;
	            }
	        });
	    }
	    this._closed = true;
	}
	 */
	/* END JSSTYLED */


	/**
	 * Get/set the level of all streams on this logger.
	 *
	 * Get Usage:
	 *    // Returns the current log level (lowest level of all its streams).
	 *    log.level() -> INFO
	 *
	 * Set Usage:
	 *    log.level(INFO)       // set all streams to level INFO
	 *    log.level('info')     // can use 'info' et al aliases
	 */
	Logger.prototype.level = function level(value) {
	    if (value === undefined) {
	        return this._level;
	    }
	    var newLevel = resolveLevel(value);
	    var len = this.streams.length;
	    for (var i = 0; i < len; i++) {
	        this.streams[i].level = newLevel;
	    }
	    this._level = newLevel;
	}


	/**
	 * Get/set the level of a particular stream on this logger.
	 *
	 * Get Usage:
	 *    // Returns an array of the levels of each stream.
	 *    log.levels() -> [TRACE, INFO]
	 *
	 *    // Returns a level of the identified stream.
	 *    log.levels(0) -> TRACE      // level of stream at index 0
	 *    log.levels('foo')           // level of stream with name 'foo'
	 *
	 * Set Usage:
	 *    log.levels(0, INFO)         // set level of stream 0 to INFO
	 *    log.levels(0, 'info')       // can use 'info' et al aliases
	 *    log.levels('foo', WARN)     // set stream named 'foo' to WARN
	 *
	 * Stream names: When streams are defined, they can optionally be given
	 * a name. For example,
	 *       log = new Logger({
	 *         streams: [
	 *           {
	 *             name: 'foo',
	 *             path: '/var/log/my-service/foo.log'
	 *             level: 'trace'
	 *           },
	 *         ...
	 *
	 * @param name {String|Number} The stream index or name.
	 * @param value {Number|String} The level value (INFO) or alias ('info').
	 *    If not given, this is a 'get' operation.
	 * @throws {Error} If there is no stream with the given name.
	 */
	Logger.prototype.levels = function levels(name, value) {
	    if (name === undefined) {
	        assert.equal(value, undefined);
	        return this.streams.map(
	            function(s) {
	                return s.level
	            });
	    }
	    var stream;
	    if (typeof(name) === 'number') {
	        stream = this.streams[name];
	        if (stream === undefined) {
	            throw new Error('invalid stream index: ' + name);
	        }
	    } else {
	        var len = this.streams.length;
	        for (var i = 0; i < len; i++) {
	            var s = this.streams[i];
	            if (s.name === name) {
	                stream = s;
	                break;
	            }
	        }
	        if (!stream) {
	            throw new Error(format('no stream with name "%s"', name));
	        }
	    }
	    if (value === undefined) {
	        return stream.level;
	    } else {
	        var newLevel = resolveLevel(value);
	        stream.level = newLevel;
	        if (newLevel < this._level) {
	            this._level = newLevel;
	        }
	    }
	}


	/**
	 * Apply registered serializers to the appropriate keys in the given fields.
	 *
	 * Pre-condition: This is only called if there is at least one serializer.
	 *
	 * @param fields (Object) The log record fields.
	 * @param excludeFields (Object) Optional mapping of keys to `true` for
	 *    keys to NOT apply a serializer.
	 */
	Logger.prototype._applySerializers = function(fields, excludeFields) {
	    var self = this;

	    xxx('_applySerializers: excludeFields', excludeFields);

	    // Check each serializer against these (presuming number of serializers
	    // is typically less than number of fields).
	    Object.keys(this.serializers).forEach(function(name) {
	        if (fields[name] === undefined ||
	            (excludeFields && excludeFields[name])) {
	            return;
	        }
	        xxx('_applySerializers; apply to "%s" key', name)
	        try {
	            fields[name] = self.serializers[name](fields[name]);
	        } catch (err) {
	            _warn(format('bunyan: ERROR: Exception thrown from the "%s" '
	                + 'Bunyan serializer. This should never happen. This is a bug'
	                + 'in that serializer function.\n%s',
	                name, err.stack || err));
	            fields[name] = format('(Error in Bunyan log "%s" serializer '
	                + 'broke field. See stderr for details.)', name);
	        }
	    });
	}


	/**
	 * Emit a log record.
	 *
	 * @param rec {log record}
	 * @param noemit {Boolean} Optional. Set to true to skip emission
	 *      and just return the JSON string.
	 */
	Logger.prototype._emit = function(rec, noemit) {
	    var i;

	    // Lazily determine if this Logger has non-'raw' streams. If there are
	    // any, then we need to stringify the log record.
	    if (this.haveNonRawStreams === undefined) {
	        this.haveNonRawStreams = false;
	        for (i = 0; i < this.streams.length; i++) {
	            if (!this.streams[i].raw) {
	                this.haveNonRawStreams = true;
	                break;
	            }
	        }
	    }

	    // Stringify the object. Attempt to warn/recover on error.
	    var str;
	    if (noemit || this.haveNonRawStreams) {
	        try {
	            str = JSON.stringify(rec, safeCycles()) + '\n';
	        } catch (e) {
	            if (safeJsonStringify) {
	                str = safeJsonStringify(rec) + '\n';
	            } else {
	                var dedupKey = e.stack.split(/\n/g, 2).join('\n');
	                _warn('bunyan: ERROR: Exception in '
	                    + '`JSON.stringify(rec)`. You can install the '
	                    + '"safe-json-stringify" module to have Bunyan fallback '
	                    + 'to safer stringification. Record:\n'
	                    + _indent(format('%s\n%s', util.inspect(rec), e.stack)),
	                    dedupKey);
	                str = format('(Exception in JSON.stringify(rec): %j. '
	                    + 'See stderr for details.)\n', e.message);
	            }
	        }
	    }

	    if (noemit)
	        return str;

	    var level = rec.level;
	    for (i = 0; i < this.streams.length; i++) {
	        var s = this.streams[i];
	        if (s.level <= level) {
	            xxx('writing log rec "%s" to "%s" stream (%d <= %d): %j',
	                rec.msg, s.type, s.level, level, rec);
	            s.stream.write(s.raw ? rec : str);
	        }
	    };

	    return str;
	}


	/**
	 * Build a log emitter function for level minLevel. I.e. this is the
	 * creator of `log.info`, `log.error`, etc.
	 */
	function mkLogEmitter(minLevel) {
	    return function() {
	        var log = this;

	        function mkRecord(args) {
	            var excludeFields;
	            if (args[0] instanceof Error) {
	                // `log.<level>(err, ...)`
	                fields = {
	                    // Use this Logger's err serializer, if defined.
	                    err: (log.serializers && log.serializers.err
	                        ? log.serializers.err(args[0])
	                        : Logger.stdSerializers.err(args[0]))
	                };
	                excludeFields = {
	                    err: true
	                };
	                if (args.length === 1) {
	                    msgArgs = [fields.err.message];
	                } else {
	                    msgArgs = Array.prototype.slice.call(args, 1);
	                }
	            } else if (typeof(args[0]) !== 'object' && args[0] !== null ||
	                Array.isArray(args[0])) {
	                // `log.<level>(msg, ...)`
	                fields = null;
	                msgArgs = Array.prototype.slice.call(args);
	            } else if (Buffer.isBuffer(args[0])) { // `log.<level>(buf, ...)`
	                // Almost certainly an error, show `inspect(buf)`. See bunyan
	                // issue #35.
	                fields = null;
	                msgArgs = Array.prototype.slice.call(args);
	                msgArgs[0] = util.inspect(msgArgs[0]);
	            } else { // `log.<level>(fields, msg, ...)`
	                fields = args[0];
	                msgArgs = Array.prototype.slice.call(args, 1);
	            }

	            // Build up the record object.
	            var rec = objCopy(log.fields);
	            var level = rec.level = minLevel;
	            var recFields = (fields ? objCopy(fields) : null);
	            if (recFields) {
	                if (log.serializers) {
	                    log._applySerializers(recFields, excludeFields);
	                }
	                Object.keys(recFields).forEach(function(k) {
	                    rec[k] = recFields[k];
	                });
	            }
	            rec.msg = format.apply(log, msgArgs);
	            if (!rec.time) {
	                rec.time = (new Date());
	            }
	            // Get call source info
	            if (log.src && !rec.src) {
	                rec.src = getCaller3Info()
	            }
	            rec.v = LOG_VERSION;

	            return rec;
	        };

	        var fields = null;
	        var msgArgs = arguments;
	        var str = null;
	        var rec = null;
	        if (!this._emit) {
	            /*
	             * Show this invalid Bunyan usage warning *once*.
	             *
	             * See <https://github.com/trentm/node-bunyan/issues/100> for
	             * an example of how this can happen.
	             */
	            var dedupKey = 'unbound';
	            if (!_haveWarned[dedupKey]) {
	                var caller = getCaller3Info();
	                _warn(format('bunyan usage error: %s:%s: attempt to log '
	                        + 'with an unbound log method: `this` is: %s',
	                        caller.file, caller.line, util.inspect(this)),
	                    dedupKey);
	            }
	            return;
	        } else if (arguments.length === 0) { // `log.<level>()`
	            return (this._level <= minLevel);
	        } else if (this._level > minLevel) {
	            /* pass through */
	        } else {
	            rec = mkRecord(msgArgs);
	            str = this._emit(rec);
	        }
	        probes && probes[minLevel].fire(function() {
	            return [str ||
	                (rec && log._emit(rec, true)) ||
	                log._emit(mkRecord(msgArgs), true)
	            ];
	        });
	    }
	}


	/**
	 * The functions below log a record at a specific level.
	 *
	 * Usages:
	 *    log.<level>()  -> boolean is-trace-enabled
	 *    log.<level>(<Error> err, [<string> msg, ...])
	 *    log.<level>(<string> msg, ...)
	 *    log.<level>(<object> fields, <string> msg, ...)
	 *
	 * where <level> is the lowercase version of the log level. E.g.:
	 *
	 *    log.info()
	 *
	 * @params fields {Object} Optional set of additional fields to log.
	 * @params msg {String} Log message. This can be followed by additional
	 *    arguments that are handled like
	 *    [util.format](http://nodejs.org/docs/latest/api/all.html#util.format).
	 */
	Logger.prototype.trace = mkLogEmitter(TRACE);
	Logger.prototype.debug = mkLogEmitter(DEBUG);
	Logger.prototype.info = mkLogEmitter(INFO);
	Logger.prototype.warn = mkLogEmitter(WARN);
	Logger.prototype.error = mkLogEmitter(ERROR);
	Logger.prototype.fatal = mkLogEmitter(FATAL);



	//---- Standard serializers
	// A serializer is a function that serializes a JavaScript object to a
	// JSON representation for logging. There is a standard set of presumed
	// interesting objects in node.js-land.

	Logger.stdSerializers = {};

	// Serialize an HTTP request.
	Logger.stdSerializers.req = function req(req) {
	    if (!req || !req.connection)
	        return req;
	    return {
	        method: req.method,
	        url: req.url,
	        headers: req.headers,
	        remoteAddress: req.connection.remoteAddress,
	        remotePort: req.connection.remotePort
	    };
	    // Trailers: Skipping for speed. If you need trailers in your app, then
	    // make a custom serializer.
	    //if (Object.keys(trailers).length > 0) {
	    //  obj.trailers = req.trailers;
	    //}
	};

	// Serialize an HTTP response.
	Logger.stdSerializers.res = function res(res) {
	    if (!res || !res.statusCode)
	        return res;
	    return {
	        statusCode: res.statusCode,
	        header: res._header
	    }
	};


	/*
	 * This function dumps long stack traces for exceptions having a cause()
	 * method. The error classes from
	 * [verror](https://github.com/davepacheco/node-verror) and
	 * [restify v2.0](https://github.com/mcavage/node-restify) are examples.
	 *
	 * Based on `dumpException` in
	 * https://github.com/davepacheco/node-extsprintf/blob/master/lib/extsprintf.js
	 */
	function getFullErrorStack(ex) {
	    var ret = ex.stack || ex.toString();
	    if (ex.cause && typeof(ex.cause) === 'function') {
	        var cex = ex.cause();
	        if (cex) {
	            ret += '\nCaused by: ' + getFullErrorStack(cex);
	        }
	    }
	    return (ret);
	}

	// Serialize an Error object
	// (Core error properties are enumerable in node 0.4, not in 0.6).
	var errSerializer = Logger.stdSerializers.err = function err(err) {
	    if (!err || !err.stack)
	        return err;
	    var obj = {
	        message: err.message,
	        name: err.name,
	        stack: getFullErrorStack(err),
	        code: err.code,
	        signal: err.signal
	    }
	    return obj;
	};


	// A JSON stringifier that handles cycles safely.
	// Usage: JSON.stringify(obj, safeCycles())
	function safeCycles() {
	    var seen = [];
	    return function(key, val) {
	        if (!val || typeof(val) !== 'object') {
	            return val;
	        }
	        if (seen.indexOf(val) !== -1) {
	            return '[Circular]';
	        }
	        seen.push(val);
	        return val;
	    };
	}


	/**
	 * RingBuffer is a Writable Stream that just stores the last N records in
	 * memory.
	 *
	 * @param options {Object}, with the following fields:
	 *
	 *    - limit: number of records to keep in memory
	 */
	function RingBuffer(options) {
	    this.limit = options && options.limit ? options.limit : 100;
	    this.writable = true;
	    this.records = [];
	    EventEmitter.call(this);
	}

	util.inherits(RingBuffer, EventEmitter);

	RingBuffer.prototype.write = function(record) {
	    if (!this.writable)
	        throw (new Error('RingBuffer has been ended already'));

	    this.records.push(record);

	    if (this.records.length > this.limit)
	        this.records.shift();

	    return (true);
	};

	RingBuffer.prototype.end = function() {
	    if (arguments.length > 0)
	        this.write.apply(this, Array.prototype.slice.call(arguments));
	    this.writable = false;
	};

	RingBuffer.prototype.destroy = function() {
	    this.writable = false;
	    this.emit('close');
	};

	RingBuffer.prototype.destroySoon = function() {
	    this.destroy();
	};


	//---- Exports

	module.exports = Logger;

	module.exports.TRACE = TRACE;
	module.exports.DEBUG = DEBUG;
	module.exports.INFO = INFO;
	module.exports.WARN = WARN;
	module.exports.ERROR = ERROR;
	module.exports.FATAL = FATAL;
	module.exports.resolveLevel = resolveLevel;
	module.exports.levelFromName = levelFromName;
	module.exports.nameFromLevel = nameFromLevel;

	module.exports.VERSION = VERSION;
	module.exports.LOG_VERSION = LOG_VERSION;

	module.exports.createLogger = function createLogger(options) {
	    return new Logger(options);
	};

	module.exports.RingBuffer = RingBuffer;

	// Useful for custom `type == 'raw'` streams that may do JSON stringification
	// of log records themselves. Usage:
	//    var str = JSON.stringify(rec, bunyan.safeCycles());
	module.exports.safeCycles = safeCycles;


/***/ },
/* 180 */
/*!**********************************************!*\
  !*** ./~/dtrace-provider/dtrace-provider.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	var DTraceProvider;

	function DTraceProviderStub() {}
	DTraceProviderStub.prototype.addProbe = function(name) {
	    var p = { 'fire': function () {} };
	    this[name] = p;
	    return (p);
	};
	DTraceProviderStub.prototype.enable = function() {};
	DTraceProviderStub.prototype.fire = function() {};
	DTraceProviderStub.prototype.disable = function() {};

	var builds = ['Release', 'default', 'Debug'];

	for (var i in builds) {
	    try {
	        var binding = !(function webpackMissingModule() { var e = new Error("Cannot find module \"./build\""); e.code = 'MODULE_NOT_FOUND'; throw e; }());
	        DTraceProvider = binding.DTraceProvider;
	        break;
	    } catch (e) {
	        // if the platform looks like it _should_ have DTrace
	        // available, log a failure to load the bindings.
	        if (process.platform == 'darwin' ||
	            process.platform == 'solaris' ||
	            process.platform == 'freebsd') {
	            console.error(e);
	        }
	    }
	}

	if (!DTraceProvider) {
	    DTraceProvider = DTraceProviderStub;
	}

	exports.DTraceProvider = DTraceProvider;
	exports.createDTraceProvider = function(name, module) {
	    if (arguments.length == 2)
	        return (new exports.DTraceProvider(name, module));
	    return (new exports.DTraceProvider(name));
	};


/***/ },
/* 181 */
/*!****************************************!*\
  !*** ./~/safe-json-stringify/index.js ***!
  \****************************************/
/***/ function(module, exports) {

	var hasProp = Object.prototype.hasOwnProperty;

	function throwsMessage(err) {
		return '[Throws: ' + (err ? err.message : '?') + ']';
	}

	function safeGetValueFromPropertyOnObject(obj, property) {
		if (hasProp.call(obj, property)) {
			try {
				return obj[property];
			}
			catch (err) {
				return throwsMessage(err);
			}
		}

		return obj[property];
	}

	function ensureProperties(obj) {
		var seen = [ ]; // store references to objects we have seen before

		function visit(obj) {
			if (obj === null || typeof obj !== 'object') {
				return obj;
			}

			if (seen.indexOf(obj) !== -1) {
				return '[Circular]';
			}
			seen.push(obj);

			if (typeof obj.toJSON === 'function') {
				try {
					return visit(obj.toJSON());
				} catch(err) {
					return throwsMessage(err);
				}
			}

			if (Array.isArray(obj)) {
				return obj.map(visit);
			}

			return Object.keys(obj).reduce(function(result, prop) {
				// prevent faulty defined getter properties
				result[prop] = visit(safeGetValueFromPropertyOnObject(obj, prop));
				return result;
			}, {});
		};

		return visit(obj);
	}

	module.exports = function(data) {
		return JSON.stringify(ensureProperties(data));
	}

	module.exports.ensureProperties = ensureProperties;


/***/ },
/* 182 */
/*!***********************!*\
  !*** ./~/mv/index.js ***!
  \***********************/
/***/ function(module, exports, __webpack_require__) {

	var fs = __webpack_require__(/*! fs */ 19);
	var ncp = __webpack_require__(/*! ncp */ 183).ncp;
	var path = __webpack_require__(/*! path */ 11);
	var rimraf = __webpack_require__(/*! rimraf */ 184);
	var mkdirp = __webpack_require__(/*! mkdirp */ 198);

	module.exports = mv;

	function mv(source, dest, options, cb){
	  if (typeof options === 'function') {
	    cb = options;
	    options = {};
	  }
	  var shouldMkdirp = !!options.mkdirp;
	  var clobber = options.clobber !== false;
	  var limit = options.limit || 16;

	  if (shouldMkdirp) {
	    mkdirs();
	  } else {
	    doRename();
	  }

	  function mkdirs() {
	    mkdirp(path.dirname(dest), function(err) {
	      if (err) return cb(err);
	      doRename();
	    });
	  }

	  function doRename() {
	    if (clobber) {
	      fs.rename(source, dest, function(err) {
	        if (!err) return cb();
	        if (err.code !== 'EXDEV') return cb(err);
	        moveFileAcrossDevice(source, dest, clobber, limit, cb);
	      });
	    } else {
	      fs.link(source, dest, function(err) {
	        if (err) {
	          if (err.code === 'EXDEV') {
	            moveFileAcrossDevice(source, dest, clobber, limit, cb);
	            return;
	          }
	          if (err.code === 'EISDIR' || err.code === 'EPERM') {
	            moveDirAcrossDevice(source, dest, clobber, limit, cb);
	            return;
	          }
	          cb(err);
	          return;
	        }
	        fs.unlink(source, cb);
	      });
	    }
	  }
	}

	function moveFileAcrossDevice(source, dest, clobber, limit, cb) {
	  var outFlags = clobber ? 'w' : 'wx';
	  var ins = fs.createReadStream(source);
	  var outs = fs.createWriteStream(dest, {flags: outFlags});
	  ins.on('error', function(err){
	    ins.destroy();
	    outs.destroy();
	    outs.removeListener('close', onClose);
	    if (err.code === 'EISDIR' || err.code === 'EPERM') {
	      moveDirAcrossDevice(source, dest, clobber, limit, cb);
	    } else {
	      cb(err);
	    }
	  });
	  outs.on('error', function(err){
	    ins.destroy();
	    outs.destroy();
	    outs.removeListener('close', onClose);
	    cb(err);
	  });
	  outs.once('close', onClose);
	  ins.pipe(outs);
	  function onClose(){
	    fs.unlink(source, cb);
	  }
	}

	function moveDirAcrossDevice(source, dest, clobber, limit, cb) {
	  var options = {
	    stopOnErr: true,
	    clobber: false,
	    limit: limit,
	  };
	  if (clobber) {
	    rimraf(dest, { disableGlob: true }, function(err) {
	      if (err) return cb(err);
	      startNcp();
	    });
	  } else {
	    startNcp();
	  }
	  function startNcp() {
	    ncp(source, dest, options, function(errList) {
	      if (errList) return cb(errList[0]);
	      rimraf(source, { disableGlob: true }, cb);
	    });
	  }
	}


/***/ },
/* 183 */
/*!**************************!*\
  !*** ./~/ncp/lib/ncp.js ***!
  \**************************/
/***/ function(module, exports, __webpack_require__) {

	var fs = __webpack_require__(/*! fs */ 19),
	    path = __webpack_require__(/*! path */ 11);

	module.exports = ncp;
	ncp.ncp = ncp;

	function ncp (source, dest, options, callback) {
	  var cback = callback;

	  if (!callback) {
	    cback = options;
	    options = {};
	  }

	  var basePath = process.cwd(),
	      currentPath = path.resolve(basePath, source),
	      targetPath = path.resolve(basePath, dest),
	      filter = options.filter,
	      rename = options.rename,
	      transform = options.transform,
	      clobber = options.clobber !== false,
	      modified = options.modified,
	      dereference = options.dereference,
	      errs = null,
	      started = 0,
	      finished = 0,
	      running = 0,
	      limit = options.limit || ncp.limit || 16;

	  limit = (limit < 1) ? 1 : (limit > 512) ? 512 : limit;

	  startCopy(currentPath);
	  
	  function startCopy(source) {
	    started++;
	    if (filter) {
	      if (filter instanceof RegExp) {
	        if (!filter.test(source)) {
	          return cb(true);
	        }
	      }
	      else if (typeof filter === 'function') {
	        if (!filter(source)) {
	          return cb(true);
	        }
	      }
	    }
	    return getStats(source);
	  }

	  function getStats(source) {
	    var stat = dereference ? fs.stat : fs.lstat;
	    if (running >= limit) {
	      return setImmediate(function () {
	        getStats(source);
	      });
	    }
	    running++;
	    stat(source, function (err, stats) {
	      var item = {};
	      if (err) {
	        return onError(err);
	      }

	      // We need to get the mode from the stats object and preserve it.
	      item.name = source;
	      item.mode = stats.mode;
	      item.mtime = stats.mtime; //modified time
	      item.atime = stats.atime; //access time

	      if (stats.isDirectory()) {
	        return onDir(item);
	      }
	      else if (stats.isFile()) {
	        return onFile(item);
	      }
	      else if (stats.isSymbolicLink()) {
	        // Symlinks don't really need to know about the mode.
	        return onLink(source);
	      }
	    });
	  }

	  function onFile(file) {
	    var target = file.name.replace(currentPath, targetPath);
	    if(rename) {
	      target =  rename(target);
	    }
	    isWritable(target, function (writable) {
	      if (writable) {
	        return copyFile(file, target);
	      }
	      if(clobber) {
	        rmFile(target, function () {
	          copyFile(file, target);
	        });
	      }
	      if (modified) {
	        var stat = dereference ? fs.stat : fs.lstat;
	        stat(target, function(err, stats) {
	            //if souce modified time greater to target modified time copy file
	            if (file.mtime.getTime()>stats.mtime.getTime())
	                copyFile(file, target);
	            else return cb();
	        });
	      }
	      else {
	        return cb();
	      }
	    });
	  }

	  function copyFile(file, target) {
	    var readStream = fs.createReadStream(file.name),
	        writeStream = fs.createWriteStream(target, { mode: file.mode });
	    
	    readStream.on('error', onError);
	    writeStream.on('error', onError);
	    
	    if(transform) {
	      transform(readStream, writeStream, file);
	    } else {
	      writeStream.on('open', function() {
	        readStream.pipe(writeStream);
	      });
	    }
	    writeStream.once('finish', function() {
	        if (modified) {
	            //target file modified date sync.
	            fs.utimesSync(target, file.atime, file.mtime);
	            cb();
	        }
	        else cb();
	    });
	  }

	  function rmFile(file, done) {
	    fs.unlink(file, function (err) {
	      if (err) {
	        return onError(err);
	      }
	      return done();
	    });
	  }

	  function onDir(dir) {
	    var target = dir.name.replace(currentPath, targetPath);
	    isWritable(target, function (writable) {
	      if (writable) {
	        return mkDir(dir, target);
	      }
	      copyDir(dir.name);
	    });
	  }

	  function mkDir(dir, target) {
	    fs.mkdir(target, dir.mode, function (err) {
	      if (err) {
	        return onError(err);
	      }
	      copyDir(dir.name);
	    });
	  }

	  function copyDir(dir) {
	    fs.readdir(dir, function (err, items) {
	      if (err) {
	        return onError(err);
	      }
	      items.forEach(function (item) {
	        startCopy(path.join(dir, item));
	      });
	      return cb();
	    });
	  }

	  function onLink(link) {
	    var target = link.replace(currentPath, targetPath);
	    fs.readlink(link, function (err, resolvedPath) {
	      if (err) {
	        return onError(err);
	      }
	      checkLink(resolvedPath, target);
	    });
	  }

	  function checkLink(resolvedPath, target) {
	    if (dereference) {
	      resolvedPath = path.resolve(basePath, resolvedPath);
	    }
	    isWritable(target, function (writable) {
	      if (writable) {
	        return makeLink(resolvedPath, target);
	      }
	      fs.readlink(target, function (err, targetDest) {
	        if (err) {
	          return onError(err);
	        }
	        if (dereference) {
	          targetDest = path.resolve(basePath, targetDest);
	        }
	        if (targetDest === resolvedPath) {
	          return cb();
	        }
	        return rmFile(target, function () {
	          makeLink(resolvedPath, target);
	        });
	      });
	    });
	  }

	  function makeLink(linkPath, target) {
	    fs.symlink(linkPath, target, function (err) {
	      if (err) {
	        return onError(err);
	      }
	      return cb();
	    });
	  }

	  function isWritable(path, done) {
	    fs.lstat(path, function (err) {
	      if (err) {
	        if (err.code === 'ENOENT') return done(true);
	        return done(false);
	      }
	      return done(false);
	    });
	  }

	  function onError(err) {
	    if (options.stopOnError) {
	      return cback(err);
	    }
	    else if (!errs && options.errs) {
	      errs = fs.createWriteStream(options.errs);
	    }
	    else if (!errs) {
	      errs = [];
	    }
	    if (typeof errs.write === 'undefined') {
	      errs.push(err);
	    }
	    else { 
	      errs.write(err.stack + '\n\n');
	    }
	    return cb();
	  }

	  function cb(skipped) {
	    if (!skipped) running--;
	    finished++;
	    if ((started === finished) && (running === 0)) {
	      if (cback !== undefined ) {
	        return errs ? cback(errs) : cback(null);
	      }
	    }
	  }
	}




/***/ },
/* 184 */
/*!*********************************!*\
  !*** ./~/mv/~/rimraf/rimraf.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = rimraf
	rimraf.sync = rimrafSync

	var assert = __webpack_require__(/*! assert */ 161)
	var path = __webpack_require__(/*! path */ 11)
	var fs = __webpack_require__(/*! fs */ 19)
	var glob = __webpack_require__(/*! glob */ 185)

	var globOpts = {
	  nosort: true,
	  nocomment: true,
	  nonegate: true,
	  silent: true
	}

	// for EMFILE handling
	var timeout = 0

	var isWindows = (process.platform === "win32")

	function defaults (options) {
	  var methods = [
	    'unlink',
	    'chmod',
	    'stat',
	    'lstat',
	    'rmdir',
	    'readdir'
	  ]
	  methods.forEach(function(m) {
	    options[m] = options[m] || fs[m]
	    m = m + 'Sync'
	    options[m] = options[m] || fs[m]
	  })

	  options.maxBusyTries = options.maxBusyTries || 3
	  options.emfileWait = options.emfileWait || 1000
	  options.disableGlob = options.disableGlob || false
	}

	function rimraf (p, options, cb) {
	  if (typeof options === 'function') {
	    cb = options
	    options = {}
	  }

	  assert(p, 'rimraf: missing path')
	  assert.equal(typeof p, 'string', 'rimraf: path should be a string')
	  assert(options, 'rimraf: missing options')
	  assert.equal(typeof options, 'object', 'rimraf: options should be object')
	  assert.equal(typeof cb, 'function', 'rimraf: callback function required')

	  defaults(options)

	  var busyTries = 0
	  var errState = null
	  var n = 0

	  if (options.disableGlob || !glob.hasMagic(p))
	    return afterGlob(null, [p])

	  fs.lstat(p, function (er, stat) {
	    if (!er)
	      return afterGlob(null, [p])

	    glob(p, globOpts, afterGlob)
	  })

	  function next (er) {
	    errState = errState || er
	    if (--n === 0)
	      cb(errState)
	  }

	  function afterGlob (er, results) {
	    if (er)
	      return cb(er)

	    n = results.length
	    if (n === 0)
	      return cb()

	    results.forEach(function (p) {
	      rimraf_(p, options, function CB (er) {
	        if (er) {
	          if (isWindows && (er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") &&
	              busyTries < options.maxBusyTries) {
	            busyTries ++
	            var time = busyTries * 100
	            // try again, with the same exact callback as this one.
	            return setTimeout(function () {
	              rimraf_(p, options, CB)
	            }, time)
	          }

	          // this one won't happen if graceful-fs is used.
	          if (er.code === "EMFILE" && timeout < options.emfileWait) {
	            return setTimeout(function () {
	              rimraf_(p, options, CB)
	            }, timeout ++)
	          }

	          // already gone
	          if (er.code === "ENOENT") er = null
	        }

	        timeout = 0
	        next(er)
	      })
	    })
	  }
	}

	// Two possible strategies.
	// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
	// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
	//
	// Both result in an extra syscall when you guess wrong.  However, there
	// are likely far more normal files in the world than directories.  This
	// is based on the assumption that a the average number of files per
	// directory is >= 1.
	//
	// If anyone ever complains about this, then I guess the strategy could
	// be made configurable somehow.  But until then, YAGNI.
	function rimraf_ (p, options, cb) {
	  assert(p)
	  assert(options)
	  assert(typeof cb === 'function')

	  // sunos lets the root user unlink directories, which is... weird.
	  // so we have to lstat here and make sure it's not a dir.
	  options.lstat(p, function (er, st) {
	    if (er && er.code === "ENOENT")
	      return cb(null)

	    if (st && st.isDirectory())
	      return rmdir(p, options, er, cb)

	    options.unlink(p, function (er) {
	      if (er) {
	        if (er.code === "ENOENT")
	          return cb(null)
	        if (er.code === "EPERM")
	          return (isWindows)
	            ? fixWinEPERM(p, options, er, cb)
	            : rmdir(p, options, er, cb)
	        if (er.code === "EISDIR")
	          return rmdir(p, options, er, cb)
	      }
	      return cb(er)
	    })
	  })
	}

	function fixWinEPERM (p, options, er, cb) {
	  assert(p)
	  assert(options)
	  assert(typeof cb === 'function')
	  if (er)
	    assert(er instanceof Error)

	  options.chmod(p, 666, function (er2) {
	    if (er2)
	      cb(er2.code === "ENOENT" ? null : er)
	    else
	      options.stat(p, function(er3, stats) {
	        if (er3)
	          cb(er3.code === "ENOENT" ? null : er)
	        else if (stats.isDirectory())
	          rmdir(p, options, er, cb)
	        else
	          options.unlink(p, cb)
	      })
	  })
	}

	function fixWinEPERMSync (p, options, er) {
	  assert(p)
	  assert(options)
	  if (er)
	    assert(er instanceof Error)

	  try {
	    options.chmodSync(p, 666)
	  } catch (er2) {
	    if (er2.code === "ENOENT")
	      return
	    else
	      throw er
	  }

	  try {
	    var stats = options.statSync(p)
	  } catch (er3) {
	    if (er3.code === "ENOENT")
	      return
	    else
	      throw er
	  }

	  if (stats.isDirectory())
	    rmdirSync(p, options, er)
	  else
	    options.unlinkSync(p)
	}

	function rmdir (p, options, originalEr, cb) {
	  assert(p)
	  assert(options)
	  if (originalEr)
	    assert(originalEr instanceof Error)
	  assert(typeof cb === 'function')

	  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
	  // if we guessed wrong, and it's not a directory, then
	  // raise the original error.
	  options.rmdir(p, function (er) {
	    if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
	      rmkids(p, options, cb)
	    else if (er && er.code === "ENOTDIR")
	      cb(originalEr)
	    else
	      cb(er)
	  })
	}

	function rmkids(p, options, cb) {
	  assert(p)
	  assert(options)
	  assert(typeof cb === 'function')

	  options.readdir(p, function (er, files) {
	    if (er)
	      return cb(er)
	    var n = files.length
	    if (n === 0)
	      return options.rmdir(p, cb)
	    var errState
	    files.forEach(function (f) {
	      rimraf(path.join(p, f), options, function (er) {
	        if (errState)
	          return
	        if (er)
	          return cb(errState = er)
	        if (--n === 0)
	          options.rmdir(p, cb)
	      })
	    })
	  })
	}

	// this looks simpler, and is strictly *faster*, but will
	// tie up the JavaScript thread and fail on excessively
	// deep directory trees.
	function rimrafSync (p, options) {
	  options = options || {}
	  defaults(options)

	  assert(p, 'rimraf: missing path')
	  assert.equal(typeof p, 'string', 'rimraf: path should be a string')
	  assert(options, 'rimraf: missing options')
	  assert.equal(typeof options, 'object', 'rimraf: options should be object')

	  var results

	  if (options.disableGlob || !glob.hasMagic(p)) {
	    results = [p]
	  } else {
	    try {
	      fs.lstatSync(p)
	      results = [p]
	    } catch (er) {
	      results = glob.sync(p, globOpts)
	    }
	  }

	  if (!results.length)
	    return

	  for (var i = 0; i < results.length; i++) {
	    var p = results[i]

	    try {
	      var st = options.lstatSync(p)
	    } catch (er) {
	      if (er.code === "ENOENT")
	        return
	    }

	    try {
	      // sunos lets the root user unlink directories, which is... weird.
	      if (st && st.isDirectory())
	        rmdirSync(p, options, null)
	      else
	        options.unlinkSync(p)
	    } catch (er) {
	      if (er.code === "ENOENT")
	        return
	      if (er.code === "EPERM")
	        return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
	      if (er.code !== "EISDIR")
	        throw er
	      rmdirSync(p, options, er)
	    }
	  }
	}

	function rmdirSync (p, options, originalEr) {
	  assert(p)
	  assert(options)
	  if (originalEr)
	    assert(originalEr instanceof Error)

	  try {
	    options.rmdirSync(p)
	  } catch (er) {
	    if (er.code === "ENOENT")
	      return
	    if (er.code === "ENOTDIR")
	      throw originalEr
	    if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
	      rmkidsSync(p, options)
	  }
	}

	function rmkidsSync (p, options) {
	  assert(p)
	  assert(options)
	  options.readdirSync(p).forEach(function (f) {
	    rimrafSync(path.join(p, f), options)
	  })
	  options.rmdirSync(p, options)
	}


/***/ },
/* 185 */
/*!*****************************!*\
  !*** ./~/mv/~/glob/glob.js ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	// Approach:
	//
	// 1. Get the minimatch set
	// 2. For each pattern in the set, PROCESS(pattern, false)
	// 3. Store matches per-set, then uniq them
	//
	// PROCESS(pattern, inGlobStar)
	// Get the first [n] items from pattern that are all strings
	// Join these together.  This is PREFIX.
	//   If there is no more remaining, then stat(PREFIX) and
	//   add to matches if it succeeds.  END.
	//
	// If inGlobStar and PREFIX is symlink and points to dir
	//   set ENTRIES = []
	// else readdir(PREFIX) as ENTRIES
	//   If fail, END
	//
	// with ENTRIES
	//   If pattern[n] is GLOBSTAR
	//     // handle the case where the globstar match is empty
	//     // by pruning it out, and testing the resulting pattern
	//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
	//     // handle other cases.
	//     for ENTRY in ENTRIES (not dotfiles)
	//       // attach globstar + tail onto the entry
	//       // Mark that this entry is a globstar match
	//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
	//
	//   else // not globstar
	//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
	//       Test ENTRY against pattern[n]
	//       If fails, continue
	//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
	//
	// Caveat:
	//   Cache all stats and readdirs results to minimize syscall.  Since all
	//   we ever care about is existence and directory-ness, we can just keep
	//   `true` for files, and [children,...] for directories, or `false` for
	//   things that don't exist.

	module.exports = glob

	var fs = __webpack_require__(/*! fs */ 19)
	var minimatch = __webpack_require__(/*! minimatch */ 186)
	var Minimatch = minimatch.Minimatch
	var inherits = __webpack_require__(/*! inherits */ 190)
	var EE = __webpack_require__(/*! events */ 26).EventEmitter
	var path = __webpack_require__(/*! path */ 11)
	var assert = __webpack_require__(/*! assert */ 161)
	var isAbsolute = __webpack_require__(/*! path-is-absolute */ 192)
	var globSync = __webpack_require__(/*! ./sync.js */ 193)
	var common = __webpack_require__(/*! ./common.js */ 194)
	var alphasort = common.alphasort
	var alphasorti = common.alphasorti
	var setopts = common.setopts
	var ownProp = common.ownProp
	var inflight = __webpack_require__(/*! inflight */ 195)
	var util = __webpack_require__(/*! util */ 16)
	var childrenIgnored = common.childrenIgnored
	var isIgnored = common.isIgnored

	var once = __webpack_require__(/*! once */ 197)

	function glob (pattern, options, cb) {
	  if (typeof options === 'function') cb = options, options = {}
	  if (!options) options = {}

	  if (options.sync) {
	    if (cb)
	      throw new TypeError('callback provided to sync glob')
	    return globSync(pattern, options)
	  }

	  return new Glob(pattern, options, cb)
	}

	glob.sync = globSync
	var GlobSync = glob.GlobSync = globSync.GlobSync

	// old api surface
	glob.glob = glob

	function extend (origin, add) {
	  if (add === null || typeof add !== 'object') {
	    return origin
	  }

	  var keys = Object.keys(add)
	  var i = keys.length
	  while (i--) {
	    origin[keys[i]] = add[keys[i]]
	  }
	  return origin
	}

	glob.hasMagic = function (pattern, options_) {
	  var options = extend({}, options_)
	  options.noprocess = true

	  var g = new Glob(pattern, options)
	  var set = g.minimatch.set
	  if (set.length > 1)
	    return true

	  for (var j = 0; j < set[0].length; j++) {
	    if (typeof set[0][j] !== 'string')
	      return true
	  }

	  return false
	}

	glob.Glob = Glob
	inherits(Glob, EE)
	function Glob (pattern, options, cb) {
	  if (typeof options === 'function') {
	    cb = options
	    options = null
	  }

	  if (options && options.sync) {
	    if (cb)
	      throw new TypeError('callback provided to sync glob')
	    return new GlobSync(pattern, options)
	  }

	  if (!(this instanceof Glob))
	    return new Glob(pattern, options, cb)

	  setopts(this, pattern, options)
	  this._didRealPath = false

	  // process each pattern in the minimatch set
	  var n = this.minimatch.set.length

	  // The matches are stored as {<filename>: true,...} so that
	  // duplicates are automagically pruned.
	  // Later, we do an Object.keys() on these.
	  // Keep them as a list so we can fill in when nonull is set.
	  this.matches = new Array(n)

	  if (typeof cb === 'function') {
	    cb = once(cb)
	    this.on('error', cb)
	    this.on('end', function (matches) {
	      cb(null, matches)
	    })
	  }

	  var self = this
	  var n = this.minimatch.set.length
	  this._processing = 0
	  this.matches = new Array(n)

	  this._emitQueue = []
	  this._processQueue = []
	  this.paused = false

	  if (this.noprocess)
	    return this

	  if (n === 0)
	    return done()

	  for (var i = 0; i < n; i ++) {
	    this._process(this.minimatch.set[i], i, false, done)
	  }

	  function done () {
	    --self._processing
	    if (self._processing <= 0)
	      self._finish()
	  }
	}

	Glob.prototype._finish = function () {
	  assert(this instanceof Glob)
	  if (this.aborted)
	    return

	  if (this.realpath && !this._didRealpath)
	    return this._realpath()

	  common.finish(this)
	  this.emit('end', this.found)
	}

	Glob.prototype._realpath = function () {
	  if (this._didRealpath)
	    return

	  this._didRealpath = true

	  var n = this.matches.length
	  if (n === 0)
	    return this._finish()

	  var self = this
	  for (var i = 0; i < this.matches.length; i++)
	    this._realpathSet(i, next)

	  function next () {
	    if (--n === 0)
	      self._finish()
	  }
	}

	Glob.prototype._realpathSet = function (index, cb) {
	  var matchset = this.matches[index]
	  if (!matchset)
	    return cb()

	  var found = Object.keys(matchset)
	  var self = this
	  var n = found.length

	  if (n === 0)
	    return cb()

	  var set = this.matches[index] = Object.create(null)
	  found.forEach(function (p, i) {
	    // If there's a problem with the stat, then it means that
	    // one or more of the links in the realpath couldn't be
	    // resolved.  just return the abs value in that case.
	    p = self._makeAbs(p)
	    fs.realpath(p, self.realpathCache, function (er, real) {
	      if (!er)
	        set[real] = true
	      else if (er.syscall === 'stat')
	        set[p] = true
	      else
	        self.emit('error', er) // srsly wtf right here

	      if (--n === 0) {
	        self.matches[index] = set
	        cb()
	      }
	    })
	  })
	}

	Glob.prototype._mark = function (p) {
	  return common.mark(this, p)
	}

	Glob.prototype._makeAbs = function (f) {
	  return common.makeAbs(this, f)
	}

	Glob.prototype.abort = function () {
	  this.aborted = true
	  this.emit('abort')
	}

	Glob.prototype.pause = function () {
	  if (!this.paused) {
	    this.paused = true
	    this.emit('pause')
	  }
	}

	Glob.prototype.resume = function () {
	  if (this.paused) {
	    this.emit('resume')
	    this.paused = false
	    if (this._emitQueue.length) {
	      var eq = this._emitQueue.slice(0)
	      this._emitQueue.length = 0
	      for (var i = 0; i < eq.length; i ++) {
	        var e = eq[i]
	        this._emitMatch(e[0], e[1])
	      }
	    }
	    if (this._processQueue.length) {
	      var pq = this._processQueue.slice(0)
	      this._processQueue.length = 0
	      for (var i = 0; i < pq.length; i ++) {
	        var p = pq[i]
	        this._processing--
	        this._process(p[0], p[1], p[2], p[3])
	      }
	    }
	  }
	}

	Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
	  assert(this instanceof Glob)
	  assert(typeof cb === 'function')

	  if (this.aborted)
	    return

	  this._processing++
	  if (this.paused) {
	    this._processQueue.push([pattern, index, inGlobStar, cb])
	    return
	  }

	  //console.error('PROCESS %d', this._processing, pattern)

	  // Get the first [n] parts of pattern that are all strings.
	  var n = 0
	  while (typeof pattern[n] === 'string') {
	    n ++
	  }
	  // now n is the index of the first one that is *not* a string.

	  // see if there's anything else
	  var prefix
	  switch (n) {
	    // if not, then this is rather simple
	    case pattern.length:
	      this._processSimple(pattern.join('/'), index, cb)
	      return

	    case 0:
	      // pattern *starts* with some non-trivial item.
	      // going to readdir(cwd), but not include the prefix in matches.
	      prefix = null
	      break

	    default:
	      // pattern has some string bits in the front.
	      // whatever it starts with, whether that's 'absolute' like /foo/bar,
	      // or 'relative' like '../baz'
	      prefix = pattern.slice(0, n).join('/')
	      break
	  }

	  var remain = pattern.slice(n)

	  // get the list of entries.
	  var read
	  if (prefix === null)
	    read = '.'
	  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
	    if (!prefix || !isAbsolute(prefix))
	      prefix = '/' + prefix
	    read = prefix
	  } else
	    read = prefix

	  var abs = this._makeAbs(read)

	  //if ignored, skip _processing
	  if (childrenIgnored(this, read))
	    return cb()

	  var isGlobStar = remain[0] === minimatch.GLOBSTAR
	  if (isGlobStar)
	    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)
	  else
	    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)
	}

	Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
	  var self = this
	  this._readdir(abs, inGlobStar, function (er, entries) {
	    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
	  })
	}

	Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {

	  // if the abs isn't a dir, then nothing can match!
	  if (!entries)
	    return cb()

	  // It will only match dot entries if it starts with a dot, or if
	  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
	  var pn = remain[0]
	  var negate = !!this.minimatch.negate
	  var rawGlob = pn._glob
	  var dotOk = this.dot || rawGlob.charAt(0) === '.'

	  var matchedEntries = []
	  for (var i = 0; i < entries.length; i++) {
	    var e = entries[i]
	    if (e.charAt(0) !== '.' || dotOk) {
	      var m
	      if (negate && !prefix) {
	        m = !e.match(pn)
	      } else {
	        m = e.match(pn)
	      }
	      if (m)
	        matchedEntries.push(e)
	    }
	  }

	  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)

	  var len = matchedEntries.length
	  // If there are no matched entries, then nothing matches.
	  if (len === 0)
	    return cb()

	  // if this is the last remaining pattern bit, then no need for
	  // an additional stat *unless* the user has specified mark or
	  // stat explicitly.  We know they exist, since readdir returned
	  // them.

	  if (remain.length === 1 && !this.mark && !this.stat) {
	    if (!this.matches[index])
	      this.matches[index] = Object.create(null)

	    for (var i = 0; i < len; i ++) {
	      var e = matchedEntries[i]
	      if (prefix) {
	        if (prefix !== '/')
	          e = prefix + '/' + e
	        else
	          e = prefix + e
	      }

	      if (e.charAt(0) === '/' && !this.nomount) {
	        e = path.join(this.root, e)
	      }
	      this._emitMatch(index, e)
	    }
	    // This was the last one, and no stats were needed
	    return cb()
	  }

	  // now test all matched entries as stand-ins for that part
	  // of the pattern.
	  remain.shift()
	  for (var i = 0; i < len; i ++) {
	    var e = matchedEntries[i]
	    var newPattern
	    if (prefix) {
	      if (prefix !== '/')
	        e = prefix + '/' + e
	      else
	        e = prefix + e
	    }
	    this._process([e].concat(remain), index, inGlobStar, cb)
	  }
	  cb()
	}

	Glob.prototype._emitMatch = function (index, e) {
	  if (this.aborted)
	    return

	  if (this.matches[index][e])
	    return

	  if (isIgnored(this, e))
	    return

	  if (this.paused) {
	    this._emitQueue.push([index, e])
	    return
	  }

	  var abs = this._makeAbs(e)

	  if (this.nodir) {
	    var c = this.cache[abs]
	    if (c === 'DIR' || Array.isArray(c))
	      return
	  }

	  if (this.mark)
	    e = this._mark(e)

	  this.matches[index][e] = true

	  var st = this.statCache[abs]
	  if (st)
	    this.emit('stat', e, st)

	  this.emit('match', e)
	}

	Glob.prototype._readdirInGlobStar = function (abs, cb) {
	  if (this.aborted)
	    return

	  // follow all symlinked directories forever
	  // just proceed as if this is a non-globstar situation
	  if (this.follow)
	    return this._readdir(abs, false, cb)

	  var lstatkey = 'lstat\0' + abs
	  var self = this
	  var lstatcb = inflight(lstatkey, lstatcb_)

	  if (lstatcb)
	    fs.lstat(abs, lstatcb)

	  function lstatcb_ (er, lstat) {
	    if (er)
	      return cb()

	    var isSym = lstat.isSymbolicLink()
	    self.symlinks[abs] = isSym

	    // If it's not a symlink or a dir, then it's definitely a regular file.
	    // don't bother doing a readdir in that case.
	    if (!isSym && !lstat.isDirectory()) {
	      self.cache[abs] = 'FILE'
	      cb()
	    } else
	      self._readdir(abs, false, cb)
	  }
	}

	Glob.prototype._readdir = function (abs, inGlobStar, cb) {
	  if (this.aborted)
	    return

	  cb = inflight('readdir\0'+abs+'\0'+inGlobStar, cb)
	  if (!cb)
	    return

	  //console.error('RD %j %j', +inGlobStar, abs)
	  if (inGlobStar && !ownProp(this.symlinks, abs))
	    return this._readdirInGlobStar(abs, cb)

	  if (ownProp(this.cache, abs)) {
	    var c = this.cache[abs]
	    if (!c || c === 'FILE')
	      return cb()

	    if (Array.isArray(c))
	      return cb(null, c)
	  }

	  var self = this
	  fs.readdir(abs, readdirCb(this, abs, cb))
	}

	function readdirCb (self, abs, cb) {
	  return function (er, entries) {
	    if (er)
	      self._readdirError(abs, er, cb)
	    else
	      self._readdirEntries(abs, entries, cb)
	  }
	}

	Glob.prototype._readdirEntries = function (abs, entries, cb) {
	  if (this.aborted)
	    return

	  // if we haven't asked to stat everything, then just
	  // assume that everything in there exists, so we can avoid
	  // having to stat it a second time.
	  if (!this.mark && !this.stat) {
	    for (var i = 0; i < entries.length; i ++) {
	      var e = entries[i]
	      if (abs === '/')
	        e = abs + e
	      else
	        e = abs + '/' + e
	      this.cache[e] = true
	    }
	  }

	  this.cache[abs] = entries
	  return cb(null, entries)
	}

	Glob.prototype._readdirError = function (f, er, cb) {
	  if (this.aborted)
	    return

	  // handle errors, and cache the information
	  switch (er.code) {
	    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
	    case 'ENOTDIR': // totally normal. means it *does* exist.
	      this.cache[this._makeAbs(f)] = 'FILE'
	      break

	    case 'ENOENT': // not terribly unusual
	    case 'ELOOP':
	    case 'ENAMETOOLONG':
	    case 'UNKNOWN':
	      this.cache[this._makeAbs(f)] = false
	      break

	    default: // some unusual error.  Treat as failure.
	      this.cache[this._makeAbs(f)] = false
	      if (this.strict) {
	        this.emit('error', er)
	        // If the error is handled, then we abort
	        // if not, we threw out of here
	        this.abort()
	      }
	      if (!this.silent)
	        console.error('glob error', er)
	      break
	  }

	  return cb()
	}

	Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
	  var self = this
	  this._readdir(abs, inGlobStar, function (er, entries) {
	    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
	  })
	}


	Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
	  //console.error('pgs2', prefix, remain[0], entries)

	  // no entries means not a dir, so it can never have matches
	  // foo.txt/** doesn't match foo.txt
	  if (!entries)
	    return cb()

	  // test without the globstar, and with every child both below
	  // and replacing the globstar.
	  var remainWithoutGlobStar = remain.slice(1)
	  var gspref = prefix ? [ prefix ] : []
	  var noGlobStar = gspref.concat(remainWithoutGlobStar)

	  // the noGlobStar pattern exits the inGlobStar state
	  this._process(noGlobStar, index, false, cb)

	  var isSym = this.symlinks[abs]
	  var len = entries.length

	  // If it's a symlink, and we're in a globstar, then stop
	  if (isSym && inGlobStar)
	    return cb()

	  for (var i = 0; i < len; i++) {
	    var e = entries[i]
	    if (e.charAt(0) === '.' && !this.dot)
	      continue

	    // these two cases enter the inGlobStar state
	    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
	    this._process(instead, index, true, cb)

	    var below = gspref.concat(entries[i], remain)
	    this._process(below, index, true, cb)
	  }

	  cb()
	}

	Glob.prototype._processSimple = function (prefix, index, cb) {
	  // XXX review this.  Shouldn't it be doing the mounting etc
	  // before doing stat?  kinda weird?
	  var self = this
	  this._stat(prefix, function (er, exists) {
	    self._processSimple2(prefix, index, er, exists, cb)
	  })
	}
	Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {

	  //console.error('ps2', prefix, exists)

	  if (!this.matches[index])
	    this.matches[index] = Object.create(null)

	  // If it doesn't exist, then just mark the lack of results
	  if (!exists)
	    return cb()

	  if (prefix && isAbsolute(prefix) && !this.nomount) {
	    var trail = /[\/\\]$/.test(prefix)
	    if (prefix.charAt(0) === '/') {
	      prefix = path.join(this.root, prefix)
	    } else {
	      prefix = path.resolve(this.root, prefix)
	      if (trail)
	        prefix += '/'
	    }
	  }

	  if (process.platform === 'win32')
	    prefix = prefix.replace(/\\/g, '/')

	  // Mark this as a match
	  this._emitMatch(index, prefix)
	  cb()
	}

	// Returns either 'DIR', 'FILE', or false
	Glob.prototype._stat = function (f, cb) {
	  var abs = this._makeAbs(f)
	  var needDir = f.slice(-1) === '/'

	  if (f.length > this.maxLength)
	    return cb()

	  if (!this.stat && ownProp(this.cache, abs)) {
	    var c = this.cache[abs]

	    if (Array.isArray(c))
	      c = 'DIR'

	    // It exists, but maybe not how we need it
	    if (!needDir || c === 'DIR')
	      return cb(null, c)

	    if (needDir && c === 'FILE')
	      return cb()

	    // otherwise we have to stat, because maybe c=true
	    // if we know it exists, but not what it is.
	  }

	  var exists
	  var stat = this.statCache[abs]
	  if (stat !== undefined) {
	    if (stat === false)
	      return cb(null, stat)
	    else {
	      var type = stat.isDirectory() ? 'DIR' : 'FILE'
	      if (needDir && type === 'FILE')
	        return cb()
	      else
	        return cb(null, type, stat)
	    }
	  }

	  var self = this
	  var statcb = inflight('stat\0' + abs, lstatcb_)
	  if (statcb)
	    fs.lstat(abs, statcb)

	  function lstatcb_ (er, lstat) {
	    if (lstat && lstat.isSymbolicLink()) {
	      // If it's a symlink, then treat it as the target, unless
	      // the target does not exist, then treat it as a file.
	      return fs.stat(abs, function (er, stat) {
	        if (er)
	          self._stat2(f, abs, null, lstat, cb)
	        else
	          self._stat2(f, abs, er, stat, cb)
	      })
	    } else {
	      self._stat2(f, abs, er, lstat, cb)
	    }
	  }
	}

	Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
	  if (er) {
	    this.statCache[abs] = false
	    return cb()
	  }

	  var needDir = f.slice(-1) === '/'
	  this.statCache[abs] = stat

	  if (abs.slice(-1) === '/' && !stat.isDirectory())
	    return cb(null, false, stat)

	  var c = stat.isDirectory() ? 'DIR' : 'FILE'
	  this.cache[abs] = this.cache[abs] || c

	  if (needDir && c !== 'DIR')
	    return cb()

	  return cb(null, c, stat)
	}


/***/ },
/* 186 */
/*!**********************************!*\
  !*** ./~/minimatch/minimatch.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = minimatch
	minimatch.Minimatch = Minimatch

	var path = { sep: '/' }
	try {
	  path = __webpack_require__(/*! path */ 11)
	} catch (er) {}

	var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
	var expand = __webpack_require__(/*! brace-expansion */ 187)

	var plTypes = {
	  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
	  '?': { open: '(?:', close: ')?' },
	  '+': { open: '(?:', close: ')+' },
	  '*': { open: '(?:', close: ')*' },
	  '@': { open: '(?:', close: ')' }
	}

	// any single thing other than /
	// don't need to escape / when using new RegExp()
	var qmark = '[^/]'

	// * => any number of characters
	var star = qmark + '*?'

	// ** when dots are allowed.  Anything goes, except .. and .
	// not (^ or / followed by one or two dots followed by $ or /),
	// followed by anything, any number of times.
	var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

	// not a ^ or / followed by a dot,
	// followed by anything, any number of times.
	var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

	// characters that need to be escaped in RegExp.
	var reSpecials = charSet('().*{}+?[]^$\\!')

	// "abc" -> { a:true, b:true, c:true }
	function charSet (s) {
	  return s.split('').reduce(function (set, c) {
	    set[c] = true
	    return set
	  }, {})
	}

	// normalizes slashes.
	var slashSplit = /\/+/

	minimatch.filter = filter
	function filter (pattern, options) {
	  options = options || {}
	  return function (p, i, list) {
	    return minimatch(p, pattern, options)
	  }
	}

	function ext (a, b) {
	  a = a || {}
	  b = b || {}
	  var t = {}
	  Object.keys(b).forEach(function (k) {
	    t[k] = b[k]
	  })
	  Object.keys(a).forEach(function (k) {
	    t[k] = a[k]
	  })
	  return t
	}

	minimatch.defaults = function (def) {
	  if (!def || !Object.keys(def).length) return minimatch

	  var orig = minimatch

	  var m = function minimatch (p, pattern, options) {
	    return orig.minimatch(p, pattern, ext(def, options))
	  }

	  m.Minimatch = function Minimatch (pattern, options) {
	    return new orig.Minimatch(pattern, ext(def, options))
	  }

	  return m
	}

	Minimatch.defaults = function (def) {
	  if (!def || !Object.keys(def).length) return Minimatch
	  return minimatch.defaults(def).Minimatch
	}

	function minimatch (p, pattern, options) {
	  if (typeof pattern !== 'string') {
	    throw new TypeError('glob pattern string required')
	  }

	  if (!options) options = {}

	  // shortcut: comments match nothing.
	  if (!options.nocomment && pattern.charAt(0) === '#') {
	    return false
	  }

	  // "" only matches ""
	  if (pattern.trim() === '') return p === ''

	  return new Minimatch(pattern, options).match(p)
	}

	function Minimatch (pattern, options) {
	  if (!(this instanceof Minimatch)) {
	    return new Minimatch(pattern, options)
	  }

	  if (typeof pattern !== 'string') {
	    throw new TypeError('glob pattern string required')
	  }

	  if (!options) options = {}
	  pattern = pattern.trim()

	  // windows support: need to use /, not \
	  if (path.sep !== '/') {
	    pattern = pattern.split(path.sep).join('/')
	  }

	  this.options = options
	  this.set = []
	  this.pattern = pattern
	  this.regexp = null
	  this.negate = false
	  this.comment = false
	  this.empty = false

	  // make the set of regexps etc.
	  this.make()
	}

	Minimatch.prototype.debug = function () {}

	Minimatch.prototype.make = make
	function make () {
	  // don't do it more than once.
	  if (this._made) return

	  var pattern = this.pattern
	  var options = this.options

	  // empty patterns and comments match nothing.
	  if (!options.nocomment && pattern.charAt(0) === '#') {
	    this.comment = true
	    return
	  }
	  if (!pattern) {
	    this.empty = true
	    return
	  }

	  // step 1: figure out negation, etc.
	  this.parseNegate()

	  // step 2: expand braces
	  var set = this.globSet = this.braceExpand()

	  if (options.debug) this.debug = console.error

	  this.debug(this.pattern, set)

	  // step 3: now we have a set, so turn each one into a series of path-portion
	  // matching patterns.
	  // These will be regexps, except in the case of "**", which is
	  // set to the GLOBSTAR object for globstar behavior,
	  // and will not contain any / characters
	  set = this.globParts = set.map(function (s) {
	    return s.split(slashSplit)
	  })

	  this.debug(this.pattern, set)

	  // glob --> regexps
	  set = set.map(function (s, si, set) {
	    return s.map(this.parse, this)
	  }, this)

	  this.debug(this.pattern, set)

	  // filter out everything that didn't compile properly.
	  set = set.filter(function (s) {
	    return s.indexOf(false) === -1
	  })

	  this.debug(this.pattern, set)

	  this.set = set
	}

	Minimatch.prototype.parseNegate = parseNegate
	function parseNegate () {
	  var pattern = this.pattern
	  var negate = false
	  var options = this.options
	  var negateOffset = 0

	  if (options.nonegate) return

	  for (var i = 0, l = pattern.length
	    ; i < l && pattern.charAt(i) === '!'
	    ; i++) {
	    negate = !negate
	    negateOffset++
	  }

	  if (negateOffset) this.pattern = pattern.substr(negateOffset)
	  this.negate = negate
	}

	// Brace expansion:
	// a{b,c}d -> abd acd
	// a{b,}c -> abc ac
	// a{0..3}d -> a0d a1d a2d a3d
	// a{b,c{d,e}f}g -> abg acdfg acefg
	// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
	//
	// Invalid sets are not expanded.
	// a{2..}b -> a{2..}b
	// a{b}c -> a{b}c
	minimatch.braceExpand = function (pattern, options) {
	  return braceExpand(pattern, options)
	}

	Minimatch.prototype.braceExpand = braceExpand

	function braceExpand (pattern, options) {
	  if (!options) {
	    if (this instanceof Minimatch) {
	      options = this.options
	    } else {
	      options = {}
	    }
	  }

	  pattern = typeof pattern === 'undefined'
	    ? this.pattern : pattern

	  if (typeof pattern === 'undefined') {
	    throw new TypeError('undefined pattern')
	  }

	  if (options.nobrace ||
	    !pattern.match(/\{.*\}/)) {
	    // shortcut. no need to expand.
	    return [pattern]
	  }

	  return expand(pattern)
	}

	// parse a component of the expanded set.
	// At this point, no pattern may contain "/" in it
	// so we're going to return a 2d array, where each entry is the full
	// pattern, split on '/', and then turned into a regular expression.
	// A regexp is made at the end which joins each array with an
	// escaped /, and another full one which joins each regexp with |.
	//
	// Following the lead of Bash 4.1, note that "**" only has special meaning
	// when it is the *only* thing in a path portion.  Otherwise, any series
	// of * is equivalent to a single *.  Globstar behavior is enabled by
	// default, and can be disabled by setting options.noglobstar.
	Minimatch.prototype.parse = parse
	var SUBPARSE = {}
	function parse (pattern, isSub) {
	  if (pattern.length > 1024 * 64) {
	    throw new TypeError('pattern is too long')
	  }

	  var options = this.options

	  // shortcuts
	  if (!options.noglobstar && pattern === '**') return GLOBSTAR
	  if (pattern === '') return ''

	  var re = ''
	  var hasMagic = !!options.nocase
	  var escaping = false
	  // ? => one single character
	  var patternListStack = []
	  var negativeLists = []
	  var stateChar
	  var inClass = false
	  var reClassStart = -1
	  var classStart = -1
	  // . and .. never match anything that doesn't start with .,
	  // even when options.dot is set.
	  var patternStart = pattern.charAt(0) === '.' ? '' // anything
	  // not (start or / followed by . or .. followed by / or end)
	  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
	  : '(?!\\.)'
	  var self = this

	  function clearStateChar () {
	    if (stateChar) {
	      // we had some state-tracking character
	      // that wasn't consumed by this pass.
	      switch (stateChar) {
	        case '*':
	          re += star
	          hasMagic = true
	        break
	        case '?':
	          re += qmark
	          hasMagic = true
	        break
	        default:
	          re += '\\' + stateChar
	        break
	      }
	      self.debug('clearStateChar %j %j', stateChar, re)
	      stateChar = false
	    }
	  }

	  for (var i = 0, len = pattern.length, c
	    ; (i < len) && (c = pattern.charAt(i))
	    ; i++) {
	    this.debug('%s\t%s %s %j', pattern, i, re, c)

	    // skip over any that are escaped.
	    if (escaping && reSpecials[c]) {
	      re += '\\' + c
	      escaping = false
	      continue
	    }

	    switch (c) {
	      case '/':
	        // completely not allowed, even escaped.
	        // Should already be path-split by now.
	        return false

	      case '\\':
	        clearStateChar()
	        escaping = true
	      continue

	      // the various stateChar values
	      // for the "extglob" stuff.
	      case '?':
	      case '*':
	      case '+':
	      case '@':
	      case '!':
	        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

	        // all of those are literals inside a class, except that
	        // the glob [!a] means [^a] in regexp
	        if (inClass) {
	          this.debug('  in class')
	          if (c === '!' && i === classStart + 1) c = '^'
	          re += c
	          continue
	        }

	        // if we already have a stateChar, then it means
	        // that there was something like ** or +? in there.
	        // Handle the stateChar, then proceed with this one.
	        self.debug('call clearStateChar %j', stateChar)
	        clearStateChar()
	        stateChar = c
	        // if extglob is disabled, then +(asdf|foo) isn't a thing.
	        // just clear the statechar *now*, rather than even diving into
	        // the patternList stuff.
	        if (options.noext) clearStateChar()
	      continue

	      case '(':
	        if (inClass) {
	          re += '('
	          continue
	        }

	        if (!stateChar) {
	          re += '\\('
	          continue
	        }

	        patternListStack.push({
	          type: stateChar,
	          start: i - 1,
	          reStart: re.length,
	          open: plTypes[stateChar].open,
	          close: plTypes[stateChar].close
	        })
	        // negation is (?:(?!js)[^/]*)
	        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
	        this.debug('plType %j %j', stateChar, re)
	        stateChar = false
	      continue

	      case ')':
	        if (inClass || !patternListStack.length) {
	          re += '\\)'
	          continue
	        }

	        clearStateChar()
	        hasMagic = true
	        var pl = patternListStack.pop()
	        // negation is (?:(?!js)[^/]*)
	        // The others are (?:<pattern>)<type>
	        re += pl.close
	        if (pl.type === '!') {
	          negativeLists.push(pl)
	        }
	        pl.reEnd = re.length
	      continue

	      case '|':
	        if (inClass || !patternListStack.length || escaping) {
	          re += '\\|'
	          escaping = false
	          continue
	        }

	        clearStateChar()
	        re += '|'
	      continue

	      // these are mostly the same in regexp and glob
	      case '[':
	        // swallow any state-tracking char before the [
	        clearStateChar()

	        if (inClass) {
	          re += '\\' + c
	          continue
	        }

	        inClass = true
	        classStart = i
	        reClassStart = re.length
	        re += c
	      continue

	      case ']':
	        //  a right bracket shall lose its special
	        //  meaning and represent itself in
	        //  a bracket expression if it occurs
	        //  first in the list.  -- POSIX.2 2.8.3.2
	        if (i === classStart + 1 || !inClass) {
	          re += '\\' + c
	          escaping = false
	          continue
	        }

	        // handle the case where we left a class open.
	        // "[z-a]" is valid, equivalent to "\[z-a\]"
	        if (inClass) {
	          // split where the last [ was, make sure we don't have
	          // an invalid re. if so, re-walk the contents of the
	          // would-be class to re-translate any characters that
	          // were passed through as-is
	          // TODO: It would probably be faster to determine this
	          // without a try/catch and a new RegExp, but it's tricky
	          // to do safely.  For now, this is safe and works.
	          var cs = pattern.substring(classStart + 1, i)
	          try {
	            RegExp('[' + cs + ']')
	          } catch (er) {
	            // not a valid class!
	            var sp = this.parse(cs, SUBPARSE)
	            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
	            hasMagic = hasMagic || sp[1]
	            inClass = false
	            continue
	          }
	        }

	        // finish up the class.
	        hasMagic = true
	        inClass = false
	        re += c
	      continue

	      default:
	        // swallow any state char that wasn't consumed
	        clearStateChar()

	        if (escaping) {
	          // no need
	          escaping = false
	        } else if (reSpecials[c]
	          && !(c === '^' && inClass)) {
	          re += '\\'
	        }

	        re += c

	    } // switch
	  } // for

	  // handle the case where we left a class open.
	  // "[abc" is valid, equivalent to "\[abc"
	  if (inClass) {
	    // split where the last [ was, and escape it
	    // this is a huge pita.  We now have to re-walk
	    // the contents of the would-be class to re-translate
	    // any characters that were passed through as-is
	    cs = pattern.substr(classStart + 1)
	    sp = this.parse(cs, SUBPARSE)
	    re = re.substr(0, reClassStart) + '\\[' + sp[0]
	    hasMagic = hasMagic || sp[1]
	  }

	  // handle the case where we had a +( thing at the *end*
	  // of the pattern.
	  // each pattern list stack adds 3 chars, and we need to go through
	  // and escape any | chars that were passed through as-is for the regexp.
	  // Go through and escape them, taking care not to double-escape any
	  // | chars that were already escaped.
	  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
	    var tail = re.slice(pl.reStart + pl.open.length)
	    this.debug('setting tail', re, pl)
	    // maybe some even number of \, then maybe 1 \, followed by a |
	    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
	      if (!$2) {
	        // the | isn't already escaped, so escape it.
	        $2 = '\\'
	      }

	      // need to escape all those slashes *again*, without escaping the
	      // one that we need for escaping the | character.  As it works out,
	      // escaping an even number of slashes can be done by simply repeating
	      // it exactly after itself.  That's why this trick works.
	      //
	      // I am sorry that you have to see this.
	      return $1 + $1 + $2 + '|'
	    })

	    this.debug('tail=%j\n   %s', tail, tail, pl, re)
	    var t = pl.type === '*' ? star
	      : pl.type === '?' ? qmark
	      : '\\' + pl.type

	    hasMagic = true
	    re = re.slice(0, pl.reStart) + t + '\\(' + tail
	  }

	  // handle trailing things that only matter at the very end.
	  clearStateChar()
	  if (escaping) {
	    // trailing \\
	    re += '\\\\'
	  }

	  // only need to apply the nodot start if the re starts with
	  // something that could conceivably capture a dot
	  var addPatternStart = false
	  switch (re.charAt(0)) {
	    case '.':
	    case '[':
	    case '(': addPatternStart = true
	  }

	  // Hack to work around lack of negative lookbehind in JS
	  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
	  // like 'a.xyz.yz' doesn't match.  So, the first negative
	  // lookahead, has to look ALL the way ahead, to the end of
	  // the pattern.
	  for (var n = negativeLists.length - 1; n > -1; n--) {
	    var nl = negativeLists[n]

	    var nlBefore = re.slice(0, nl.reStart)
	    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
	    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
	    var nlAfter = re.slice(nl.reEnd)

	    nlLast += nlAfter

	    // Handle nested stuff like *(*.js|!(*.json)), where open parens
	    // mean that we should *not* include the ) in the bit that is considered
	    // "after" the negated section.
	    var openParensBefore = nlBefore.split('(').length - 1
	    var cleanAfter = nlAfter
	    for (i = 0; i < openParensBefore; i++) {
	      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
	    }
	    nlAfter = cleanAfter

	    var dollar = ''
	    if (nlAfter === '' && isSub !== SUBPARSE) {
	      dollar = '$'
	    }
	    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
	    re = newRe
	  }

	  // if the re is not "" at this point, then we need to make sure
	  // it doesn't match against an empty path part.
	  // Otherwise a/* will match a/, which it should not.
	  if (re !== '' && hasMagic) {
	    re = '(?=.)' + re
	  }

	  if (addPatternStart) {
	    re = patternStart + re
	  }

	  // parsing just a piece of a larger pattern.
	  if (isSub === SUBPARSE) {
	    return [re, hasMagic]
	  }

	  // skip the regexp for non-magical patterns
	  // unescape anything in it, though, so that it'll be
	  // an exact match against a file etc.
	  if (!hasMagic) {
	    return globUnescape(pattern)
	  }

	  var flags = options.nocase ? 'i' : ''
	  try {
	    var regExp = new RegExp('^' + re + '$', flags)
	  } catch (er) {
	    // If it was an invalid regular expression, then it can't match
	    // anything.  This trick looks for a character after the end of
	    // the string, which is of course impossible, except in multi-line
	    // mode, but it's not a /m regex.
	    return new RegExp('$.')
	  }

	  regExp._glob = pattern
	  regExp._src = re

	  return regExp
	}

	minimatch.makeRe = function (pattern, options) {
	  return new Minimatch(pattern, options || {}).makeRe()
	}

	Minimatch.prototype.makeRe = makeRe
	function makeRe () {
	  if (this.regexp || this.regexp === false) return this.regexp

	  // at this point, this.set is a 2d array of partial
	  // pattern strings, or "**".
	  //
	  // It's better to use .match().  This function shouldn't
	  // be used, really, but it's pretty convenient sometimes,
	  // when you just want to work with a regex.
	  var set = this.set

	  if (!set.length) {
	    this.regexp = false
	    return this.regexp
	  }
	  var options = this.options

	  var twoStar = options.noglobstar ? star
	    : options.dot ? twoStarDot
	    : twoStarNoDot
	  var flags = options.nocase ? 'i' : ''

	  var re = set.map(function (pattern) {
	    return pattern.map(function (p) {
	      return (p === GLOBSTAR) ? twoStar
	      : (typeof p === 'string') ? regExpEscape(p)
	      : p._src
	    }).join('\\\/')
	  }).join('|')

	  // must match entire pattern
	  // ending in a * or ** will make it less strict.
	  re = '^(?:' + re + ')$'

	  // can match anything, as long as it's not this.
	  if (this.negate) re = '^(?!' + re + ').*$'

	  try {
	    this.regexp = new RegExp(re, flags)
	  } catch (ex) {
	    this.regexp = false
	  }
	  return this.regexp
	}

	minimatch.match = function (list, pattern, options) {
	  options = options || {}
	  var mm = new Minimatch(pattern, options)
	  list = list.filter(function (f) {
	    return mm.match(f)
	  })
	  if (mm.options.nonull && !list.length) {
	    list.push(pattern)
	  }
	  return list
	}

	Minimatch.prototype.match = match
	function match (f, partial) {
	  this.debug('match', f, this.pattern)
	  // short-circuit in the case of busted things.
	  // comments, etc.
	  if (this.comment) return false
	  if (this.empty) return f === ''

	  if (f === '/' && partial) return true

	  var options = this.options

	  // windows: need to use /, not \
	  if (path.sep !== '/') {
	    f = f.split(path.sep).join('/')
	  }

	  // treat the test path as a set of pathparts.
	  f = f.split(slashSplit)
	  this.debug(this.pattern, 'split', f)

	  // just ONE of the pattern sets in this.set needs to match
	  // in order for it to be valid.  If negating, then just one
	  // match means that we have failed.
	  // Either way, return on the first hit.

	  var set = this.set
	  this.debug(this.pattern, 'set', set)

	  // Find the basename of the path by looking for the last non-empty segment
	  var filename
	  var i
	  for (i = f.length - 1; i >= 0; i--) {
	    filename = f[i]
	    if (filename) break
	  }

	  for (i = 0; i < set.length; i++) {
	    var pattern = set[i]
	    var file = f
	    if (options.matchBase && pattern.length === 1) {
	      file = [filename]
	    }
	    var hit = this.matchOne(file, pattern, partial)
	    if (hit) {
	      if (options.flipNegate) return true
	      return !this.negate
	    }
	  }

	  // didn't get any hits.  this is success if it's a negative
	  // pattern, failure otherwise.
	  if (options.flipNegate) return false
	  return this.negate
	}

	// set partial to true to test if, for example,
	// "/a/b" matches the start of "/*/b/*/d"
	// Partial means, if you run out of file before you run
	// out of pattern, then that's fine, as long as all
	// the parts match.
	Minimatch.prototype.matchOne = function (file, pattern, partial) {
	  var options = this.options

	  this.debug('matchOne',
	    { 'this': this, file: file, pattern: pattern })

	  this.debug('matchOne', file.length, pattern.length)

	  for (var fi = 0,
	      pi = 0,
	      fl = file.length,
	      pl = pattern.length
	      ; (fi < fl) && (pi < pl)
	      ; fi++, pi++) {
	    this.debug('matchOne loop')
	    var p = pattern[pi]
	    var f = file[fi]

	    this.debug(pattern, p, f)

	    // should be impossible.
	    // some invalid regexp stuff in the set.
	    if (p === false) return false

	    if (p === GLOBSTAR) {
	      this.debug('GLOBSTAR', [pattern, p, f])

	      // "**"
	      // a/**/b/**/c would match the following:
	      // a/b/x/y/z/c
	      // a/x/y/z/b/c
	      // a/b/x/b/x/c
	      // a/b/c
	      // To do this, take the rest of the pattern after
	      // the **, and see if it would match the file remainder.
	      // If so, return success.
	      // If not, the ** "swallows" a segment, and try again.
	      // This is recursively awful.
	      //
	      // a/**/b/**/c matching a/b/x/y/z/c
	      // - a matches a
	      // - doublestar
	      //   - matchOne(b/x/y/z/c, b/**/c)
	      //     - b matches b
	      //     - doublestar
	      //       - matchOne(x/y/z/c, c) -> no
	      //       - matchOne(y/z/c, c) -> no
	      //       - matchOne(z/c, c) -> no
	      //       - matchOne(c, c) yes, hit
	      var fr = fi
	      var pr = pi + 1
	      if (pr === pl) {
	        this.debug('** at the end')
	        // a ** at the end will just swallow the rest.
	        // We have found a match.
	        // however, it will not swallow /.x, unless
	        // options.dot is set.
	        // . and .. are *never* matched by **, for explosively
	        // exponential reasons.
	        for (; fi < fl; fi++) {
	          if (file[fi] === '.' || file[fi] === '..' ||
	            (!options.dot && file[fi].charAt(0) === '.')) return false
	        }
	        return true
	      }

	      // ok, let's see if we can swallow whatever we can.
	      while (fr < fl) {
	        var swallowee = file[fr]

	        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

	        // XXX remove this slice.  Just pass the start index.
	        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
	          this.debug('globstar found match!', fr, fl, swallowee)
	          // found a match.
	          return true
	        } else {
	          // can't swallow "." or ".." ever.
	          // can only swallow ".foo" when explicitly asked.
	          if (swallowee === '.' || swallowee === '..' ||
	            (!options.dot && swallowee.charAt(0) === '.')) {
	            this.debug('dot detected!', file, fr, pattern, pr)
	            break
	          }

	          // ** swallows a segment, and continue.
	          this.debug('globstar swallow a segment, and continue')
	          fr++
	        }
	      }

	      // no match was found.
	      // However, in partial mode, we can't say this is necessarily over.
	      // If there's more *pattern* left, then
	      if (partial) {
	        // ran out of file
	        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
	        if (fr === fl) return true
	      }
	      return false
	    }

	    // something other than **
	    // non-magic patterns just have to match exactly
	    // patterns with magic have been turned into regexps.
	    var hit
	    if (typeof p === 'string') {
	      if (options.nocase) {
	        hit = f.toLowerCase() === p.toLowerCase()
	      } else {
	        hit = f === p
	      }
	      this.debug('string match', p, f, hit)
	    } else {
	      hit = f.match(p)
	      this.debug('pattern match', p, f, hit)
	    }

	    if (!hit) return false
	  }

	  // Note: ending in / means that we'll get a final ""
	  // at the end of the pattern.  This can only match a
	  // corresponding "" at the end of the file.
	  // If the file ends in /, then it can only match a
	  // a pattern that ends in /, unless the pattern just
	  // doesn't have any more for it. But, a/b/ should *not*
	  // match "a/b/*", even though "" matches against the
	  // [^/]*? pattern, except in partial mode, where it might
	  // simply not be reached yet.
	  // However, a/b/ should still satisfy a/*

	  // now either we fell off the end of the pattern, or we're done.
	  if (fi === fl && pi === pl) {
	    // ran out of pattern and filename at the same time.
	    // an exact hit!
	    return true
	  } else if (fi === fl) {
	    // ran out of file, but still had pattern left.
	    // this is ok if we're doing the match as part of
	    // a glob fs traversal.
	    return partial
	  } else if (pi === pl) {
	    // ran out of pattern, still have file left.
	    // this is only acceptable if we're on the very last
	    // empty segment of a file with a trailing slash.
	    // a/* should match a/b/
	    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')
	    return emptyFileEnd
	  }

	  // should be unreachable.
	  throw new Error('wtf?')
	}

	// replace stuff like \* with *
	function globUnescape (s) {
	  return s.replace(/\\(.)/g, '$1')
	}

	function regExpEscape (s) {
	  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
	}


/***/ },
/* 187 */
/*!************************************!*\
  !*** ./~/brace-expansion/index.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	var concatMap = __webpack_require__(/*! concat-map */ 188);
	var balanced = __webpack_require__(/*! balanced-match */ 189);

	module.exports = expandTop;

	var escSlash = '\0SLASH'+Math.random()+'\0';
	var escOpen = '\0OPEN'+Math.random()+'\0';
	var escClose = '\0CLOSE'+Math.random()+'\0';
	var escComma = '\0COMMA'+Math.random()+'\0';
	var escPeriod = '\0PERIOD'+Math.random()+'\0';

	function numeric(str) {
	  return parseInt(str, 10) == str
	    ? parseInt(str, 10)
	    : str.charCodeAt(0);
	}

	function escapeBraces(str) {
	  return str.split('\\\\').join(escSlash)
	            .split('\\{').join(escOpen)
	            .split('\\}').join(escClose)
	            .split('\\,').join(escComma)
	            .split('\\.').join(escPeriod);
	}

	function unescapeBraces(str) {
	  return str.split(escSlash).join('\\')
	            .split(escOpen).join('{')
	            .split(escClose).join('}')
	            .split(escComma).join(',')
	            .split(escPeriod).join('.');
	}


	// Basically just str.split(","), but handling cases
	// where we have nested braced sections, which should be
	// treated as individual members, like {a,{b,c},d}
	function parseCommaParts(str) {
	  if (!str)
	    return [''];

	  var parts = [];
	  var m = balanced('{', '}', str);

	  if (!m)
	    return str.split(',');

	  var pre = m.pre;
	  var body = m.body;
	  var post = m.post;
	  var p = pre.split(',');

	  p[p.length-1] += '{' + body + '}';
	  var postParts = parseCommaParts(post);
	  if (post.length) {
	    p[p.length-1] += postParts.shift();
	    p.push.apply(p, postParts);
	  }

	  parts.push.apply(parts, p);

	  return parts;
	}

	function expandTop(str) {
	  if (!str)
	    return [];

	  // I don't know why Bash 4.3 does this, but it does.
	  // Anything starting with {} will have the first two bytes preserved
	  // but *only* at the top level, so {},a}b will not expand to anything,
	  // but a{},b}c will be expanded to [a}c,abc].
	  // One could argue that this is a bug in Bash, but since the goal of
	  // this module is to match Bash's rules, we escape a leading {}
	  if (str.substr(0, 2) === '{}') {
	    str = '\\{\\}' + str.substr(2);
	  }

	  return expand(escapeBraces(str), true).map(unescapeBraces);
	}

	function identity(e) {
	  return e;
	}

	function embrace(str) {
	  return '{' + str + '}';
	}
	function isPadded(el) {
	  return /^-?0\d/.test(el);
	}

	function lte(i, y) {
	  return i <= y;
	}
	function gte(i, y) {
	  return i >= y;
	}

	function expand(str, isTop) {
	  var expansions = [];

	  var m = balanced('{', '}', str);
	  if (!m || /\$$/.test(m.pre)) return [str];

	  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
	  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
	  var isSequence = isNumericSequence || isAlphaSequence;
	  var isOptions = /^(.*,)+(.+)?$/.test(m.body);
	  if (!isSequence && !isOptions) {
	    // {a},b}
	    if (m.post.match(/,.*\}/)) {
	      str = m.pre + '{' + m.body + escClose + m.post;
	      return expand(str);
	    }
	    return [str];
	  }

	  var n;
	  if (isSequence) {
	    n = m.body.split(/\.\./);
	  } else {
	    n = parseCommaParts(m.body);
	    if (n.length === 1) {
	      // x{{a,b}}y ==> x{a}y x{b}y
	      n = expand(n[0], false).map(embrace);
	      if (n.length === 1) {
	        var post = m.post.length
	          ? expand(m.post, false)
	          : [''];
	        return post.map(function(p) {
	          return m.pre + n[0] + p;
	        });
	      }
	    }
	  }

	  // at this point, n is the parts, and we know it's not a comma set
	  // with a single entry.

	  // no need to expand pre, since it is guaranteed to be free of brace-sets
	  var pre = m.pre;
	  var post = m.post.length
	    ? expand(m.post, false)
	    : [''];

	  var N;

	  if (isSequence) {
	    var x = numeric(n[0]);
	    var y = numeric(n[1]);
	    var width = Math.max(n[0].length, n[1].length)
	    var incr = n.length == 3
	      ? Math.abs(numeric(n[2]))
	      : 1;
	    var test = lte;
	    var reverse = y < x;
	    if (reverse) {
	      incr *= -1;
	      test = gte;
	    }
	    var pad = n.some(isPadded);

	    N = [];

	    for (var i = x; test(i, y); i += incr) {
	      var c;
	      if (isAlphaSequence) {
	        c = String.fromCharCode(i);
	        if (c === '\\')
	          c = '';
	      } else {
	        c = String(i);
	        if (pad) {
	          var need = width - c.length;
	          if (need > 0) {
	            var z = new Array(need + 1).join('0');
	            if (i < 0)
	              c = '-' + z + c.slice(1);
	            else
	              c = z + c;
	          }
	        }
	      }
	      N.push(c);
	    }
	  } else {
	    N = concatMap(n, function(el) { return expand(el, false) });
	  }

	  for (var j = 0; j < N.length; j++) {
	    for (var k = 0; k < post.length; k++) {
	      var expansion = pre + N[j] + post[k];
	      if (!isTop || isSequence || expansion)
	        expansions.push(expansion);
	    }
	  }

	  return expansions;
	}



/***/ },
/* 188 */
/*!*******************************!*\
  !*** ./~/concat-map/index.js ***!
  \*******************************/
/***/ function(module, exports) {

	module.exports = function (xs, fn) {
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        var x = fn(xs[i], i);
	        if (isArray(x)) res.push.apply(res, x);
	        else res.push(x);
	    }
	    return res;
	};

	var isArray = Array.isArray || function (xs) {
	    return Object.prototype.toString.call(xs) === '[object Array]';
	};


/***/ },
/* 189 */
/*!***********************************!*\
  !*** ./~/balanced-match/index.js ***!
  \***********************************/
/***/ function(module, exports) {

	module.exports = balanced;
	function balanced(a, b, str) {
	  if (a instanceof RegExp) a = maybeMatch(a, str);
	  if (b instanceof RegExp) b = maybeMatch(b, str);

	  var r = range(a, b, str);

	  return r && {
	    start: r[0],
	    end: r[1],
	    pre: str.slice(0, r[0]),
	    body: str.slice(r[0] + a.length, r[1]),
	    post: str.slice(r[1] + b.length)
	  };
	}

	function maybeMatch(reg, str) {
	  var m = str.match(reg);
	  return m ? m[0] : null;
	}

	balanced.range = range;
	function range(a, b, str) {
	  var begs, beg, left, right, result;
	  var ai = str.indexOf(a);
	  var bi = str.indexOf(b, ai + 1);
	  var i = ai;

	  if (ai >= 0 && bi > 0) {
	    begs = [];
	    left = str.length;

	    while (i >= 0 && !result) {
	      if (i == ai) {
	        begs.push(i);
	        ai = str.indexOf(a, i + 1);
	      } else if (begs.length == 1) {
	        result = [ begs.pop(), bi ];
	      } else {
	        beg = begs.pop();
	        if (beg < left) {
	          left = beg;
	          right = bi;
	        }

	        bi = str.indexOf(b, i + 1);
	      }

	      i = ai < bi && ai >= 0 ? ai : bi;
	    }

	    if (begs.length) {
	      result = [ left, right ];
	    }
	  }

	  return result;
	}


/***/ },
/* 190 */
/*!********************************!*\
  !*** ./~/inherits/inherits.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	try {
	  var util = __webpack_require__(/*! util */ 16);
	  if (typeof util.inherits !== 'function') throw '';
	  module.exports = util.inherits;
	} catch (e) {
	  module.exports = __webpack_require__(/*! ./inherits_browser.js */ 191);
	}


/***/ },
/* 191 */
/*!****************************************!*\
  !*** ./~/inherits/inherits_browser.js ***!
  \****************************************/
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 192 */
/*!*************************************!*\
  !*** ./~/path-is-absolute/index.js ***!
  \*************************************/
/***/ function(module, exports) {

	'use strict';

	function posix(path) {
		return path.charAt(0) === '/';
	}

	function win32(path) {
		// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
		var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
		var result = splitDeviceRe.exec(path);
		var device = result[1] || '';
		var isUnc = Boolean(device && device.charAt(1) !== ':');

		// UNC paths are always absolute
		return Boolean(result[2] || isUnc);
	}

	module.exports = process.platform === 'win32' ? win32 : posix;
	module.exports.posix = posix;
	module.exports.win32 = win32;


/***/ },
/* 193 */
/*!*****************************!*\
  !*** ./~/mv/~/glob/sync.js ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = globSync
	globSync.GlobSync = GlobSync

	var fs = __webpack_require__(/*! fs */ 19)
	var minimatch = __webpack_require__(/*! minimatch */ 186)
	var Minimatch = minimatch.Minimatch
	var Glob = __webpack_require__(/*! ./glob.js */ 185).Glob
	var util = __webpack_require__(/*! util */ 16)
	var path = __webpack_require__(/*! path */ 11)
	var assert = __webpack_require__(/*! assert */ 161)
	var isAbsolute = __webpack_require__(/*! path-is-absolute */ 192)
	var common = __webpack_require__(/*! ./common.js */ 194)
	var alphasort = common.alphasort
	var alphasorti = common.alphasorti
	var setopts = common.setopts
	var ownProp = common.ownProp
	var childrenIgnored = common.childrenIgnored

	function globSync (pattern, options) {
	  if (typeof options === 'function' || arguments.length === 3)
	    throw new TypeError('callback provided to sync glob\n'+
	                        'See: https://github.com/isaacs/node-glob/issues/167')

	  return new GlobSync(pattern, options).found
	}

	function GlobSync (pattern, options) {
	  if (!pattern)
	    throw new Error('must provide pattern')

	  if (typeof options === 'function' || arguments.length === 3)
	    throw new TypeError('callback provided to sync glob\n'+
	                        'See: https://github.com/isaacs/node-glob/issues/167')

	  if (!(this instanceof GlobSync))
	    return new GlobSync(pattern, options)

	  setopts(this, pattern, options)

	  if (this.noprocess)
	    return this

	  var n = this.minimatch.set.length
	  this.matches = new Array(n)
	  for (var i = 0; i < n; i ++) {
	    this._process(this.minimatch.set[i], i, false)
	  }
	  this._finish()
	}

	GlobSync.prototype._finish = function () {
	  assert(this instanceof GlobSync)
	  if (this.realpath) {
	    var self = this
	    this.matches.forEach(function (matchset, index) {
	      var set = self.matches[index] = Object.create(null)
	      for (var p in matchset) {
	        try {
	          p = self._makeAbs(p)
	          var real = fs.realpathSync(p, self.realpathCache)
	          set[real] = true
	        } catch (er) {
	          if (er.syscall === 'stat')
	            set[self._makeAbs(p)] = true
	          else
	            throw er
	        }
	      }
	    })
	  }
	  common.finish(this)
	}


	GlobSync.prototype._process = function (pattern, index, inGlobStar) {
	  assert(this instanceof GlobSync)

	  // Get the first [n] parts of pattern that are all strings.
	  var n = 0
	  while (typeof pattern[n] === 'string') {
	    n ++
	  }
	  // now n is the index of the first one that is *not* a string.

	  // See if there's anything else
	  var prefix
	  switch (n) {
	    // if not, then this is rather simple
	    case pattern.length:
	      this._processSimple(pattern.join('/'), index)
	      return

	    case 0:
	      // pattern *starts* with some non-trivial item.
	      // going to readdir(cwd), but not include the prefix in matches.
	      prefix = null
	      break

	    default:
	      // pattern has some string bits in the front.
	      // whatever it starts with, whether that's 'absolute' like /foo/bar,
	      // or 'relative' like '../baz'
	      prefix = pattern.slice(0, n).join('/')
	      break
	  }

	  var remain = pattern.slice(n)

	  // get the list of entries.
	  var read
	  if (prefix === null)
	    read = '.'
	  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
	    if (!prefix || !isAbsolute(prefix))
	      prefix = '/' + prefix
	    read = prefix
	  } else
	    read = prefix

	  var abs = this._makeAbs(read)

	  //if ignored, skip processing
	  if (childrenIgnored(this, read))
	    return

	  var isGlobStar = remain[0] === minimatch.GLOBSTAR
	  if (isGlobStar)
	    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)
	  else
	    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)
	}


	GlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
	  var entries = this._readdir(abs, inGlobStar)

	  // if the abs isn't a dir, then nothing can match!
	  if (!entries)
	    return

	  // It will only match dot entries if it starts with a dot, or if
	  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
	  var pn = remain[0]
	  var negate = !!this.minimatch.negate
	  var rawGlob = pn._glob
	  var dotOk = this.dot || rawGlob.charAt(0) === '.'

	  var matchedEntries = []
	  for (var i = 0; i < entries.length; i++) {
	    var e = entries[i]
	    if (e.charAt(0) !== '.' || dotOk) {
	      var m
	      if (negate && !prefix) {
	        m = !e.match(pn)
	      } else {
	        m = e.match(pn)
	      }
	      if (m)
	        matchedEntries.push(e)
	    }
	  }

	  var len = matchedEntries.length
	  // If there are no matched entries, then nothing matches.
	  if (len === 0)
	    return

	  // if this is the last remaining pattern bit, then no need for
	  // an additional stat *unless* the user has specified mark or
	  // stat explicitly.  We know they exist, since readdir returned
	  // them.

	  if (remain.length === 1 && !this.mark && !this.stat) {
	    if (!this.matches[index])
	      this.matches[index] = Object.create(null)

	    for (var i = 0; i < len; i ++) {
	      var e = matchedEntries[i]
	      if (prefix) {
	        if (prefix.slice(-1) !== '/')
	          e = prefix + '/' + e
	        else
	          e = prefix + e
	      }

	      if (e.charAt(0) === '/' && !this.nomount) {
	        e = path.join(this.root, e)
	      }
	      this.matches[index][e] = true
	    }
	    // This was the last one, and no stats were needed
	    return
	  }

	  // now test all matched entries as stand-ins for that part
	  // of the pattern.
	  remain.shift()
	  for (var i = 0; i < len; i ++) {
	    var e = matchedEntries[i]
	    var newPattern
	    if (prefix)
	      newPattern = [prefix, e]
	    else
	      newPattern = [e]
	    this._process(newPattern.concat(remain), index, inGlobStar)
	  }
	}


	GlobSync.prototype._emitMatch = function (index, e) {
	  var abs = this._makeAbs(e)
	  if (this.mark)
	    e = this._mark(e)

	  if (this.matches[index][e])
	    return

	  if (this.nodir) {
	    var c = this.cache[this._makeAbs(e)]
	    if (c === 'DIR' || Array.isArray(c))
	      return
	  }

	  this.matches[index][e] = true
	  if (this.stat)
	    this._stat(e)
	}


	GlobSync.prototype._readdirInGlobStar = function (abs) {
	  // follow all symlinked directories forever
	  // just proceed as if this is a non-globstar situation
	  if (this.follow)
	    return this._readdir(abs, false)

	  var entries
	  var lstat
	  var stat
	  try {
	    lstat = fs.lstatSync(abs)
	  } catch (er) {
	    // lstat failed, doesn't exist
	    return null
	  }

	  var isSym = lstat.isSymbolicLink()
	  this.symlinks[abs] = isSym

	  // If it's not a symlink or a dir, then it's definitely a regular file.
	  // don't bother doing a readdir in that case.
	  if (!isSym && !lstat.isDirectory())
	    this.cache[abs] = 'FILE'
	  else
	    entries = this._readdir(abs, false)

	  return entries
	}

	GlobSync.prototype._readdir = function (abs, inGlobStar) {
	  var entries

	  if (inGlobStar && !ownProp(this.symlinks, abs))
	    return this._readdirInGlobStar(abs)

	  if (ownProp(this.cache, abs)) {
	    var c = this.cache[abs]
	    if (!c || c === 'FILE')
	      return null

	    if (Array.isArray(c))
	      return c
	  }

	  try {
	    return this._readdirEntries(abs, fs.readdirSync(abs))
	  } catch (er) {
	    this._readdirError(abs, er)
	    return null
	  }
	}

	GlobSync.prototype._readdirEntries = function (abs, entries) {
	  // if we haven't asked to stat everything, then just
	  // assume that everything in there exists, so we can avoid
	  // having to stat it a second time.
	  if (!this.mark && !this.stat) {
	    for (var i = 0; i < entries.length; i ++) {
	      var e = entries[i]
	      if (abs === '/')
	        e = abs + e
	      else
	        e = abs + '/' + e
	      this.cache[e] = true
	    }
	  }

	  this.cache[abs] = entries

	  // mark and cache dir-ness
	  return entries
	}

	GlobSync.prototype._readdirError = function (f, er) {
	  // handle errors, and cache the information
	  switch (er.code) {
	    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
	    case 'ENOTDIR': // totally normal. means it *does* exist.
	      this.cache[this._makeAbs(f)] = 'FILE'
	      break

	    case 'ENOENT': // not terribly unusual
	    case 'ELOOP':
	    case 'ENAMETOOLONG':
	    case 'UNKNOWN':
	      this.cache[this._makeAbs(f)] = false
	      break

	    default: // some unusual error.  Treat as failure.
	      this.cache[this._makeAbs(f)] = false
	      if (this.strict)
	        throw er
	      if (!this.silent)
	        console.error('glob error', er)
	      break
	  }
	}

	GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {

	  var entries = this._readdir(abs, inGlobStar)

	  // no entries means not a dir, so it can never have matches
	  // foo.txt/** doesn't match foo.txt
	  if (!entries)
	    return

	  // test without the globstar, and with every child both below
	  // and replacing the globstar.
	  var remainWithoutGlobStar = remain.slice(1)
	  var gspref = prefix ? [ prefix ] : []
	  var noGlobStar = gspref.concat(remainWithoutGlobStar)

	  // the noGlobStar pattern exits the inGlobStar state
	  this._process(noGlobStar, index, false)

	  var len = entries.length
	  var isSym = this.symlinks[abs]

	  // If it's a symlink, and we're in a globstar, then stop
	  if (isSym && inGlobStar)
	    return

	  for (var i = 0; i < len; i++) {
	    var e = entries[i]
	    if (e.charAt(0) === '.' && !this.dot)
	      continue

	    // these two cases enter the inGlobStar state
	    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
	    this._process(instead, index, true)

	    var below = gspref.concat(entries[i], remain)
	    this._process(below, index, true)
	  }
	}

	GlobSync.prototype._processSimple = function (prefix, index) {
	  // XXX review this.  Shouldn't it be doing the mounting etc
	  // before doing stat?  kinda weird?
	  var exists = this._stat(prefix)

	  if (!this.matches[index])
	    this.matches[index] = Object.create(null)

	  // If it doesn't exist, then just mark the lack of results
	  if (!exists)
	    return

	  if (prefix && isAbsolute(prefix) && !this.nomount) {
	    var trail = /[\/\\]$/.test(prefix)
	    if (prefix.charAt(0) === '/') {
	      prefix = path.join(this.root, prefix)
	    } else {
	      prefix = path.resolve(this.root, prefix)
	      if (trail)
	        prefix += '/'
	    }
	  }

	  if (process.platform === 'win32')
	    prefix = prefix.replace(/\\/g, '/')

	  // Mark this as a match
	  this.matches[index][prefix] = true
	}

	// Returns either 'DIR', 'FILE', or false
	GlobSync.prototype._stat = function (f) {
	  var abs = this._makeAbs(f)
	  var needDir = f.slice(-1) === '/'

	  if (f.length > this.maxLength)
	    return false

	  if (!this.stat && ownProp(this.cache, abs)) {
	    var c = this.cache[abs]

	    if (Array.isArray(c))
	      c = 'DIR'

	    // It exists, but maybe not how we need it
	    if (!needDir || c === 'DIR')
	      return c

	    if (needDir && c === 'FILE')
	      return false

	    // otherwise we have to stat, because maybe c=true
	    // if we know it exists, but not what it is.
	  }

	  var exists
	  var stat = this.statCache[abs]
	  if (!stat) {
	    var lstat
	    try {
	      lstat = fs.lstatSync(abs)
	    } catch (er) {
	      return false
	    }

	    if (lstat.isSymbolicLink()) {
	      try {
	        stat = fs.statSync(abs)
	      } catch (er) {
	        stat = lstat
	      }
	    } else {
	      stat = lstat
	    }
	  }

	  this.statCache[abs] = stat

	  var c = stat.isDirectory() ? 'DIR' : 'FILE'
	  this.cache[abs] = this.cache[abs] || c

	  if (needDir && c !== 'DIR')
	    return false

	  return c
	}

	GlobSync.prototype._mark = function (p) {
	  return common.mark(this, p)
	}

	GlobSync.prototype._makeAbs = function (f) {
	  return common.makeAbs(this, f)
	}


/***/ },
/* 194 */
/*!*******************************!*\
  !*** ./~/mv/~/glob/common.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	exports.alphasort = alphasort
	exports.alphasorti = alphasorti
	exports.setopts = setopts
	exports.ownProp = ownProp
	exports.makeAbs = makeAbs
	exports.finish = finish
	exports.mark = mark
	exports.isIgnored = isIgnored
	exports.childrenIgnored = childrenIgnored

	function ownProp (obj, field) {
	  return Object.prototype.hasOwnProperty.call(obj, field)
	}

	var path = __webpack_require__(/*! path */ 11)
	var minimatch = __webpack_require__(/*! minimatch */ 186)
	var isAbsolute = __webpack_require__(/*! path-is-absolute */ 192)
	var Minimatch = minimatch.Minimatch

	function alphasorti (a, b) {
	  return a.toLowerCase().localeCompare(b.toLowerCase())
	}

	function alphasort (a, b) {
	  return a.localeCompare(b)
	}

	function setupIgnores (self, options) {
	  self.ignore = options.ignore || []

	  if (!Array.isArray(self.ignore))
	    self.ignore = [self.ignore]

	  if (self.ignore.length) {
	    self.ignore = self.ignore.map(ignoreMap)
	  }
	}

	// ignore patterns are always in dot:true mode.
	function ignoreMap (pattern) {
	  var gmatcher = null
	  if (pattern.slice(-3) === '/**') {
	    var gpattern = pattern.replace(/(\/\*\*)+$/, '')
	    gmatcher = new Minimatch(gpattern, { dot: true })
	  }

	  return {
	    matcher: new Minimatch(pattern, { dot: true }),
	    gmatcher: gmatcher
	  }
	}

	function setopts (self, pattern, options) {
	  if (!options)
	    options = {}

	  // base-matching: just use globstar for that.
	  if (options.matchBase && -1 === pattern.indexOf("/")) {
	    if (options.noglobstar) {
	      throw new Error("base matching requires globstar")
	    }
	    pattern = "**/" + pattern
	  }

	  self.silent = !!options.silent
	  self.pattern = pattern
	  self.strict = options.strict !== false
	  self.realpath = !!options.realpath
	  self.realpathCache = options.realpathCache || Object.create(null)
	  self.follow = !!options.follow
	  self.dot = !!options.dot
	  self.mark = !!options.mark
	  self.nodir = !!options.nodir
	  if (self.nodir)
	    self.mark = true
	  self.sync = !!options.sync
	  self.nounique = !!options.nounique
	  self.nonull = !!options.nonull
	  self.nosort = !!options.nosort
	  self.nocase = !!options.nocase
	  self.stat = !!options.stat
	  self.noprocess = !!options.noprocess

	  self.maxLength = options.maxLength || Infinity
	  self.cache = options.cache || Object.create(null)
	  self.statCache = options.statCache || Object.create(null)
	  self.symlinks = options.symlinks || Object.create(null)

	  setupIgnores(self, options)

	  self.changedCwd = false
	  var cwd = process.cwd()
	  if (!ownProp(options, "cwd"))
	    self.cwd = cwd
	  else {
	    self.cwd = options.cwd
	    self.changedCwd = path.resolve(options.cwd) !== cwd
	  }

	  self.root = options.root || path.resolve(self.cwd, "/")
	  self.root = path.resolve(self.root)
	  if (process.platform === "win32")
	    self.root = self.root.replace(/\\/g, "/")

	  self.nomount = !!options.nomount

	  // disable comments and negation in Minimatch.
	  // Note that they are not supported in Glob itself anyway.
	  options.nonegate = true
	  options.nocomment = true

	  self.minimatch = new Minimatch(pattern, options)
	  self.options = self.minimatch.options
	}

	function finish (self) {
	  var nou = self.nounique
	  var all = nou ? [] : Object.create(null)

	  for (var i = 0, l = self.matches.length; i < l; i ++) {
	    var matches = self.matches[i]
	    if (!matches || Object.keys(matches).length === 0) {
	      if (self.nonull) {
	        // do like the shell, and spit out the literal glob
	        var literal = self.minimatch.globSet[i]
	        if (nou)
	          all.push(literal)
	        else
	          all[literal] = true
	      }
	    } else {
	      // had matches
	      var m = Object.keys(matches)
	      if (nou)
	        all.push.apply(all, m)
	      else
	        m.forEach(function (m) {
	          all[m] = true
	        })
	    }
	  }

	  if (!nou)
	    all = Object.keys(all)

	  if (!self.nosort)
	    all = all.sort(self.nocase ? alphasorti : alphasort)

	  // at *some* point we statted all of these
	  if (self.mark) {
	    for (var i = 0; i < all.length; i++) {
	      all[i] = self._mark(all[i])
	    }
	    if (self.nodir) {
	      all = all.filter(function (e) {
	        return !(/\/$/.test(e))
	      })
	    }
	  }

	  if (self.ignore.length)
	    all = all.filter(function(m) {
	      return !isIgnored(self, m)
	    })

	  self.found = all
	}

	function mark (self, p) {
	  var abs = makeAbs(self, p)
	  var c = self.cache[abs]
	  var m = p
	  if (c) {
	    var isDir = c === 'DIR' || Array.isArray(c)
	    var slash = p.slice(-1) === '/'

	    if (isDir && !slash)
	      m += '/'
	    else if (!isDir && slash)
	      m = m.slice(0, -1)

	    if (m !== p) {
	      var mabs = makeAbs(self, m)
	      self.statCache[mabs] = self.statCache[abs]
	      self.cache[mabs] = self.cache[abs]
	    }
	  }

	  return m
	}

	// lotta situps...
	function makeAbs (self, f) {
	  var abs = f
	  if (f.charAt(0) === '/') {
	    abs = path.join(self.root, f)
	  } else if (isAbsolute(f) || f === '') {
	    abs = f
	  } else if (self.changedCwd) {
	    abs = path.resolve(self.cwd, f)
	  } else {
	    abs = path.resolve(f)
	  }
	  return abs
	}


	// Return true, if pattern ends with globstar '**', for the accompanying parent directory.
	// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
	function isIgnored (self, path) {
	  if (!self.ignore.length)
	    return false

	  return self.ignore.some(function(item) {
	    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))
	  })
	}

	function childrenIgnored (self, path) {
	  if (!self.ignore.length)
	    return false

	  return self.ignore.some(function(item) {
	    return !!(item.gmatcher && item.gmatcher.match(path))
	  })
	}


/***/ },
/* 195 */
/*!********************************!*\
  !*** ./~/inflight/inflight.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	var wrappy = __webpack_require__(/*! wrappy */ 196)
	var reqs = Object.create(null)
	var once = __webpack_require__(/*! once */ 197)

	module.exports = wrappy(inflight)

	function inflight (key, cb) {
	  if (reqs[key]) {
	    reqs[key].push(cb)
	    return null
	  } else {
	    reqs[key] = [cb]
	    return makeres(key)
	  }
	}

	function makeres (key) {
	  return once(function RES () {
	    var cbs = reqs[key]
	    var len = cbs.length
	    var args = slice(arguments)

	    // XXX It's somewhat ambiguous whether a new callback added in this
	    // pass should be queued for later execution if something in the
	    // list of callbacks throws, or if it should just be discarded.
	    // However, it's such an edge case that it hardly matters, and either
	    // choice is likely as surprising as the other.
	    // As it happens, we do go ahead and schedule it for later execution.
	    try {
	      for (var i = 0; i < len; i++) {
	        cbs[i].apply(null, args)
	      }
	    } finally {
	      if (cbs.length > len) {
	        // added more in the interim.
	        // de-zalgo, just in case, but don't call again.
	        cbs.splice(0, len)
	        process.nextTick(function () {
	          RES.apply(null, args)
	        })
	      } else {
	        delete reqs[key]
	      }
	    }
	  })
	}

	function slice (args) {
	  var length = args.length
	  var array = []

	  for (var i = 0; i < length; i++) array[i] = args[i]
	  return array
	}


/***/ },
/* 196 */
/*!****************************!*\
  !*** ./~/wrappy/wrappy.js ***!
  \****************************/
/***/ function(module, exports) {

	// Returns a wrapper function that returns a wrapped callback
	// The wrapper function should do some stuff, and return a
	// presumably different callback function.
	// This makes sure that own properties are retained, so that
	// decorations and such are not lost along the way.
	module.exports = wrappy
	function wrappy (fn, cb) {
	  if (fn && cb) return wrappy(fn)(cb)

	  if (typeof fn !== 'function')
	    throw new TypeError('need wrapper function')

	  Object.keys(fn).forEach(function (k) {
	    wrapper[k] = fn[k]
	  })

	  return wrapper

	  function wrapper() {
	    var args = new Array(arguments.length)
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i]
	    }
	    var ret = fn.apply(this, args)
	    var cb = args[args.length-1]
	    if (typeof ret === 'function' && ret !== cb) {
	      Object.keys(cb).forEach(function (k) {
	        ret[k] = cb[k]
	      })
	    }
	    return ret
	  }
	}


/***/ },
/* 197 */
/*!************************!*\
  !*** ./~/once/once.js ***!
  \************************/
/***/ function(module, exports, __webpack_require__) {

	var wrappy = __webpack_require__(/*! wrappy */ 196)
	module.exports = wrappy(once)
	module.exports.strict = wrappy(onceStrict)

	once.proto = once(function () {
	  Object.defineProperty(Function.prototype, 'once', {
	    value: function () {
	      return once(this)
	    },
	    configurable: true
	  })

	  Object.defineProperty(Function.prototype, 'onceStrict', {
	    value: function () {
	      return onceStrict(this)
	    },
	    configurable: true
	  })
	})

	function once (fn) {
	  var f = function () {
	    if (f.called) return f.value
	    f.called = true
	    return f.value = fn.apply(this, arguments)
	  }
	  f.called = false
	  return f
	}

	function onceStrict (fn) {
	  var f = function () {
	    if (f.called)
	      throw new Error(f.onceError)
	    f.called = true
	    return f.value = fn.apply(this, arguments)
	  }
	  var name = fn.name || 'Function wrapped with `once`'
	  f.onceError = name + " shouldn't be called more than once"
	  f.called = false
	  return f
	}


/***/ },
/* 198 */
/*!***************************!*\
  !*** ./~/mkdirp/index.js ***!
  \***************************/
/***/ function(module, exports, __webpack_require__) {

	var path = __webpack_require__(/*! path */ 11);
	var fs = __webpack_require__(/*! fs */ 19);
	var _0777 = parseInt('0777', 8);

	module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;

	function mkdirP (p, opts, f, made) {
	    if (typeof opts === 'function') {
	        f = opts;
	        opts = {};
	    }
	    else if (!opts || typeof opts !== 'object') {
	        opts = { mode: opts };
	    }
	    
	    var mode = opts.mode;
	    var xfs = opts.fs || fs;
	    
	    if (mode === undefined) {
	        mode = _0777 & (~process.umask());
	    }
	    if (!made) made = null;
	    
	    var cb = f || function () {};
	    p = path.resolve(p);
	    
	    xfs.mkdir(p, mode, function (er) {
	        if (!er) {
	            made = made || p;
	            return cb(null, made);
	        }
	        switch (er.code) {
	            case 'ENOENT':
	                mkdirP(path.dirname(p), opts, function (er, made) {
	                    if (er) cb(er, made);
	                    else mkdirP(p, opts, cb, made);
	                });
	                break;

	            // In the case of any other error, just see if there's a dir
	            // there already.  If so, then hooray!  If not, then something
	            // is borked.
	            default:
	                xfs.stat(p, function (er2, stat) {
	                    // if the stat fails, then that's super weird.
	                    // let the original error be the failure reason.
	                    if (er2 || !stat.isDirectory()) cb(er, made)
	                    else cb(null, made);
	                });
	                break;
	        }
	    });
	}

	mkdirP.sync = function sync (p, opts, made) {
	    if (!opts || typeof opts !== 'object') {
	        opts = { mode: opts };
	    }
	    
	    var mode = opts.mode;
	    var xfs = opts.fs || fs;
	    
	    if (mode === undefined) {
	        mode = _0777 & (~process.umask());
	    }
	    if (!made) made = null;

	    p = path.resolve(p);

	    try {
	        xfs.mkdirSync(p, mode);
	        made = made || p;
	    }
	    catch (err0) {
	        switch (err0.code) {
	            case 'ENOENT' :
	                made = sync(path.dirname(p), opts, made);
	                sync(p, opts, made);
	                break;

	            // In the case of any other error, just see if there's a dir
	            // there already.  If so, then hooray!  If not, then something
	            // is borked.
	            default:
	                var stat;
	                try {
	                    stat = xfs.statSync(p);
	                }
	                catch (err1) {
	                    throw err0;
	                }
	                if (!stat.isDirectory()) throw err0;
	                break;
	        }
	    }

	    return made;
	};


/***/ },
/* 199 */
/*!*************************************************************!*\
  !*** ./~/bunyan/~/source-map-support/source-map-support.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var SourceMapConsumer = __webpack_require__(/*! source-map */ 200).SourceMapConsumer;
	var path = __webpack_require__(/*! path */ 11);
	var fs = __webpack_require__(/*! fs */ 19);

	// Only install once if called multiple times
	var alreadyInstalled = false;

	// If true, the caches are reset before a stack trace formatting operation
	var emptyCacheBetweenOperations = false;

	// Maps a file path to a string containing the file contents
	var fileContentsCache = {};

	// Maps a file path to a source map for that file
	var sourceMapCache = {};

	function isInBrowser() {
	  return ((typeof window !== 'undefined') && (typeof XMLHttpRequest === 'function'));
	}

	function retrieveFile(path) {
	  if (path in fileContentsCache) {
	    return fileContentsCache[path];
	  }

	  try {
	    // Use SJAX if we are in the browser
	    if (isInBrowser()) {
	      var xhr = new XMLHttpRequest();
	      xhr.open('GET', path, false);
	      xhr.send(null);
	      var contents = xhr.readyState === 4 ? xhr.responseText : null;
	    }

	    // Otherwise, use the filesystem
	    else {
	      var contents = fs.readFileSync(path, 'utf8');
	    }
	  } catch (e) {
	    var contents = null;
	  }

	  return fileContentsCache[path] = contents;
	}

	// Support URLs relative to a directory, but be careful about a protocol prefix
	// in case we are in the browser (i.e. directories may start with "http://")
	function supportRelativeURL(file, url) {
	  if (!file) return url;
	  var dir = path.dirname(file);
	  var match = /^\w+:\/\/[^\/]*/.exec(dir);
	  var protocol = match ? match[0] : '';
	  return protocol + path.resolve(dir.slice(protocol.length), url);
	}

	function retrieveSourceMapURL(source) {
	  var fileData;

	  if (isInBrowser()) {
	    var xhr = new XMLHttpRequest();
	    xhr.open('GET', source, false);
	    xhr.send(null);
	    fileData = xhr.readyState === 4 ? xhr.responseText : null;

	    // Support providing a sourceMappingURL via the SourceMap header
	    var sourceMapHeader = xhr.getResponseHeader("SourceMap") ||
	                          xhr.getResponseHeader("X-SourceMap");
	    if (sourceMapHeader) {
	      return sourceMapHeader;
	    }
	  }

	  // Get the URL of the source map
	  fileData = retrieveFile(source);
	  var match = /\/\/[#@]\s*sourceMappingURL=(.*)\s*$/m.exec(fileData);
	  if (!match) return null;
	  return match[1];
	};

	// Can be overridden by the retrieveSourceMap option to install. Takes a
	// generated source filename; returns a {map, optional url} object, or null if
	// there is no source map.  The map field may be either a string or the parsed
	// JSON object (ie, it must be a valid argument to the SourceMapConsumer
	// constructor).
	function retrieveSourceMap(source) {
	  var sourceMappingURL = retrieveSourceMapURL(source);
	  if (!sourceMappingURL) return null;

	  // Read the contents of the source map
	  var sourceMapData;
	  var dataUrlPrefix = "data:application/json;base64,";
	  if (sourceMappingURL.slice(0, dataUrlPrefix.length).toLowerCase() == dataUrlPrefix) {
	    // Support source map URL as a data url
	    sourceMapData = new Buffer(sourceMappingURL.slice(dataUrlPrefix.length), "base64").toString();
	    sourceMappingURL = null;
	  } else {
	    // Support source map URLs relative to the source URL
	    sourceMappingURL = supportRelativeURL(source, sourceMappingURL);
	    sourceMapData = retrieveFile(sourceMappingURL, 'utf8');
	  }

	  if (!sourceMapData) {
	    return null;
	  }

	  return {
	    url: sourceMappingURL,
	    map: sourceMapData
	  };
	}

	function mapSourcePosition(position) {
	  var sourceMap = sourceMapCache[position.source];
	  if (!sourceMap) {
	    // Call the (overrideable) retrieveSourceMap function to get the source map.
	    var urlAndMap = retrieveSourceMap(position.source);
	    if (urlAndMap) {
	      sourceMap = sourceMapCache[position.source] = {
	        url: urlAndMap.url,
	        map: new SourceMapConsumer(urlAndMap.map)
	      };

	      // Load all sources stored inline with the source map into the file cache
	      // to pretend like they are already loaded. They may not exist on disk.
	      if (sourceMap.map.sourcesContent) {
	        sourceMap.map.sources.forEach(function(source, i) {
	          var contents = sourceMap.map.sourcesContent[i];
	          if (contents) {
	            var url = supportRelativeURL(sourceMap.url, source);
	            fileContentsCache[url] = contents;
	          }
	        });
	      }
	    } else {
	      sourceMap = sourceMapCache[position.source] = {
	        url: null,
	        map: null
	      };
	    }
	  }

	  // Resolve the source URL relative to the URL of the source map
	  if (sourceMap && sourceMap.map) {
	    var originalPosition = sourceMap.map.originalPositionFor(position);

	    // Only return the original position if a matching line was found. If no
	    // matching line is found then we return position instead, which will cause
	    // the stack trace to print the path and line for the compiled file. It is
	    // better to give a precise location in the compiled file than a vague
	    // location in the original file.
	    if (originalPosition.source !== null) {
	      originalPosition.source = supportRelativeURL(
	        sourceMap.url, originalPosition.source);
	      return originalPosition;
	    }
	  }

	  return position;
	}

	// Parses code generated by FormatEvalOrigin(), a function inside V8:
	// https://code.google.com/p/v8/source/browse/trunk/src/messages.js
	function mapEvalOrigin(origin) {
	  // Most eval() calls are in this format
	  var match = /^eval at ([^(]+) \((.+):(\d+):(\d+)\)$/.exec(origin);
	  if (match) {
	    var position = mapSourcePosition({
	      source: match[2],
	      line: match[3],
	      column: match[4] - 1
	    });
	    return 'eval at ' + match[1] + ' (' + position.source + ':' +
	      position.line + ':' + (position.column + 1) + ')';
	  }

	  // Parse nested eval() calls using recursion
	  match = /^eval at ([^(]+) \((.+)\)$/.exec(origin);
	  if (match) {
	    return 'eval at ' + match[1] + ' (' + mapEvalOrigin(match[2]) + ')';
	  }

	  // Make sure we still return useful information if we didn't find anything
	  return origin;
	}

	// This is copied almost verbatim from the V8 source code at
	// https://code.google.com/p/v8/source/browse/trunk/src/messages.js. The
	// implementation of wrapCallSite() used to just forward to the actual source
	// code of CallSite.prototype.toString but unfortunately a new release of V8
	// did something to the prototype chain and broke the shim. The only fix I
	// could find was copy/paste.
	function CallSiteToString() {
	  var fileName;
	  var fileLocation = "";
	  if (this.isNative()) {
	    fileLocation = "native";
	  } else {
	    fileName = this.getScriptNameOrSourceURL();
	    if (!fileName && this.isEval()) {
	      fileLocation = this.getEvalOrigin();
	      fileLocation += ", ";  // Expecting source position to follow.
	    }

	    if (fileName) {
	      fileLocation += fileName;
	    } else {
	      // Source code does not originate from a file and is not native, but we
	      // can still get the source position inside the source string, e.g. in
	      // an eval string.
	      fileLocation += "<anonymous>";
	    }
	    var lineNumber = this.getLineNumber();
	    if (lineNumber != null) {
	      fileLocation += ":" + lineNumber;
	      var columnNumber = this.getColumnNumber();
	      if (columnNumber) {
	        fileLocation += ":" + columnNumber;
	      }
	    }
	  }

	  var line = "";
	  var functionName = this.getFunctionName();
	  var addSuffix = true;
	  var isConstructor = this.isConstructor();
	  var isMethodCall = !(this.isToplevel() || isConstructor);
	  if (isMethodCall) {
	    var typeName = this.getTypeName();
	    var methodName = this.getMethodName();
	    if (functionName) {
	      if (typeName && functionName.indexOf(typeName) != 0) {
	        line += typeName + ".";
	      }
	      line += functionName;
	      if (methodName && functionName.indexOf("." + methodName) != functionName.length - methodName.length - 1) {
	        line += " [as " + methodName + "]";
	      }
	    } else {
	      line += typeName + "." + (methodName || "<anonymous>");
	    }
	  } else if (isConstructor) {
	    line += "new " + (functionName || "<anonymous>");
	  } else if (functionName) {
	    line += functionName;
	  } else {
	    line += fileLocation;
	    addSuffix = false;
	  }
	  if (addSuffix) {
	    line += " (" + fileLocation + ")";
	  }
	  return line;
	}

	function cloneCallSite(frame) {
	  var object = {};
	  Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach(function(name) {
	    object[name] = /^(?:is|get)/.test(name) ? function() { return frame[name].call(frame); } : frame[name];
	  });
	  object.toString = CallSiteToString;
	  return object;
	}

	function wrapCallSite(frame) {
	  // Most call sites will return the source file from getFileName(), but code
	  // passed to eval() ending in "//# sourceURL=..." will return the source file
	  // from getScriptNameOrSourceURL() instead
	  var source = frame.getFileName() || frame.getScriptNameOrSourceURL();
	  if (source) {
	    var position = mapSourcePosition({
	      source: source,
	      line: frame.getLineNumber(),
	      column: frame.getColumnNumber() - 1
	    });
	    frame = cloneCallSite(frame);
	    frame.getFileName = function() { return position.source; };
	    frame.getLineNumber = function() { return position.line; };
	    frame.getColumnNumber = function() { return position.column + 1; };
	    frame.getScriptNameOrSourceURL = function() { return position.source; };
	    return frame;
	  }

	  // Code called using eval() needs special handling
	  var origin = frame.isEval() && frame.getEvalOrigin();
	  if (origin) {
	    origin = mapEvalOrigin(origin);
	    frame = cloneCallSite(frame);
	    frame.getEvalOrigin = function() { return origin; };
	    return frame;
	  }

	  // If we get here then we were unable to change the source position
	  return frame;
	}

	// This function is part of the V8 stack trace API, for more info see:
	// http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
	function prepareStackTrace(error, stack) {
	  if (emptyCacheBetweenOperations) {
	    fileContentsCache = {};
	    sourceMapCache = {};
	  }
	  return error + stack.map(function(frame) {
	    return '\n    at ' + wrapCallSite(frame);
	  }).join('');
	}

	// Generate position and snippet of original source with pointer
	function getErrorSource(error) {
	  var match = /\n    at [^(]+ \((.*):(\d+):(\d+)\)/.exec(error.stack);
	  if (match) {
	    var source = match[1];
	    var line = +match[2];
	    var column = +match[3];

	    // Support the inline sourceContents inside the source map
	    var contents = fileContentsCache[source];

	    // Support files on disk
	    if (!contents && fs.existsSync(source)) {
	      contents = fs.readFileSync(source, 'utf8');
	    }

	    // Format the line from the original source code like node does
	    if (contents) {
	      var code = contents.split(/(?:\r\n|\r|\n)/)[line - 1];
	      if (code) {
	        return '\n' + source + ':' + line + '\n' + code + '\n' +
	          new Array(column).join(' ') + '^';
	      }
	    }
	  }
	  return null;
	}

	// Mimic node's stack trace printing when an exception escapes the process
	function handleUncaughtExceptions(error) {
	  if (!error || !error.stack) {
	    console.log('Uncaught exception:', error);
	  } else {
	    var source = getErrorSource(error);
	    if (source !== null) console.log(source);
	    console.log(error.stack);
	  }
	  process.exit(1);
	}

	exports.wrapCallSite = wrapCallSite;
	exports.getErrorSource = getErrorSource;
	exports.mapSourcePosition = mapSourcePosition;
	exports.retrieveSourceMap = retrieveSourceMap;

	exports.install = function(options) {
	  if (!alreadyInstalled) {
	    alreadyInstalled = true;
	    Error.prepareStackTrace = prepareStackTrace;

	    // Configure options
	    options = options || {};
	    var installHandler = 'handleUncaughtExceptions' in options ?
	      options.handleUncaughtExceptions : true;
	    emptyCacheBetweenOperations = 'emptyCacheBetweenOperations' in options ?
	      options.emptyCacheBetweenOperations : false;

	    // Allow sources to be found by methods other than reading the files
	    // directly from disk.
	    if (options.retrieveFile)
	      retrieveFile = options.retrieveFile;

	    // Allow source maps to be found by methods other than reading the files
	    // directly from disk.
	    if (options.retrieveSourceMap)
	      retrieveSourceMap = options.retrieveSourceMap;

	    // Provide the option to not install the uncaught exception handler. This is
	    // to support other uncaught exception handlers (in test frameworks, for
	    // example). If this handler is not installed and there are no other uncaught
	    // exception handlers, uncaught exceptions will be caught by node's built-in
	    // exception handler and the process will still be terminated. However, the
	    // generated JavaScript code will be shown above the stack trace instead of
	    // the original source code.
	    if (installHandler && !isInBrowser()) {
	      process.on('uncaughtException', handleUncaughtExceptions);
	    }
	  }
	};


/***/ },
/* 200 */
/*!*************************************************!*\
  !*** ./~/bunyan/~/source-map/lib/source-map.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright 2009-2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE.txt or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	exports.SourceMapGenerator = __webpack_require__(/*! ./source-map/source-map-generator */ 201).SourceMapGenerator;
	exports.SourceMapConsumer = __webpack_require__(/*! ./source-map/source-map-consumer */ 206).SourceMapConsumer;
	exports.SourceNode = __webpack_require__(/*! ./source-map/source-node */ 208).SourceNode;


/***/ },
/* 201 */
/*!**********************************************************************!*\
  !*** ./~/bunyan/~/source-map/lib/source-map/source-map-generator.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {

	  var base64VLQ = __webpack_require__(/*! ./base64-vlq */ 202);
	  var util = __webpack_require__(/*! ./util */ 204);
	  var ArraySet = __webpack_require__(/*! ./array-set */ 205).ArraySet;

	  /**
	   * An instance of the SourceMapGenerator represents a source map which is
	   * being built incrementally. To create a new one, you must pass an object
	   * with the following properties:
	   *
	   *   - file: The filename of the generated source.
	   *   - sourceRoot: An optional root for all URLs in this source map.
	   */
	  function SourceMapGenerator(aArgs) {
	    this._file = util.getArg(aArgs, 'file');
	    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	    this._sources = new ArraySet();
	    this._names = new ArraySet();
	    this._mappings = [];
	    this._sourcesContents = null;
	  }

	  SourceMapGenerator.prototype._version = 3;

	  /**
	   * Creates a new SourceMapGenerator based on a SourceMapConsumer
	   *
	   * @param aSourceMapConsumer The SourceMap.
	   */
	  SourceMapGenerator.fromSourceMap =
	    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	      var sourceRoot = aSourceMapConsumer.sourceRoot;
	      var generator = new SourceMapGenerator({
	        file: aSourceMapConsumer.file,
	        sourceRoot: sourceRoot
	      });
	      aSourceMapConsumer.eachMapping(function (mapping) {
	        var newMapping = {
	          generated: {
	            line: mapping.generatedLine,
	            column: mapping.generatedColumn
	          }
	        };

	        if (mapping.source) {
	          newMapping.source = mapping.source;
	          if (sourceRoot) {
	            newMapping.source = util.relative(sourceRoot, newMapping.source);
	          }

	          newMapping.original = {
	            line: mapping.originalLine,
	            column: mapping.originalColumn
	          };

	          if (mapping.name) {
	            newMapping.name = mapping.name;
	          }
	        }

	        generator.addMapping(newMapping);
	      });
	      aSourceMapConsumer.sources.forEach(function (sourceFile) {
	        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	        if (content) {
	          generator.setSourceContent(sourceFile, content);
	        }
	      });
	      return generator;
	    };

	  /**
	   * Add a single mapping from original source line and column to the generated
	   * source's line and column for this source map being created. The mapping
	   * object should have the following properties:
	   *
	   *   - generated: An object with the generated line and column positions.
	   *   - original: An object with the original line and column positions.
	   *   - source: The original source file (relative to the sourceRoot).
	   *   - name: An optional original token name for this mapping.
	   */
	  SourceMapGenerator.prototype.addMapping =
	    function SourceMapGenerator_addMapping(aArgs) {
	      var generated = util.getArg(aArgs, 'generated');
	      var original = util.getArg(aArgs, 'original', null);
	      var source = util.getArg(aArgs, 'source', null);
	      var name = util.getArg(aArgs, 'name', null);

	      this._validateMapping(generated, original, source, name);

	      if (source && !this._sources.has(source)) {
	        this._sources.add(source);
	      }

	      if (name && !this._names.has(name)) {
	        this._names.add(name);
	      }

	      this._mappings.push({
	        generatedLine: generated.line,
	        generatedColumn: generated.column,
	        originalLine: original != null && original.line,
	        originalColumn: original != null && original.column,
	        source: source,
	        name: name
	      });
	    };

	  /**
	   * Set the source content for a source file.
	   */
	  SourceMapGenerator.prototype.setSourceContent =
	    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	      var source = aSourceFile;
	      if (this._sourceRoot) {
	        source = util.relative(this._sourceRoot, source);
	      }

	      if (aSourceContent !== null) {
	        // Add the source content to the _sourcesContents map.
	        // Create a new _sourcesContents map if the property is null.
	        if (!this._sourcesContents) {
	          this._sourcesContents = {};
	        }
	        this._sourcesContents[util.toSetString(source)] = aSourceContent;
	      } else {
	        // Remove the source file from the _sourcesContents map.
	        // If the _sourcesContents map is empty, set the property to null.
	        delete this._sourcesContents[util.toSetString(source)];
	        if (Object.keys(this._sourcesContents).length === 0) {
	          this._sourcesContents = null;
	        }
	      }
	    };

	  /**
	   * Applies the mappings of a sub-source-map for a specific source file to the
	   * source map being generated. Each mapping to the supplied source file is
	   * rewritten using the supplied source map. Note: The resolution for the
	   * resulting mappings is the minimium of this map and the supplied map.
	   *
	   * @param aSourceMapConsumer The source map to be applied.
	   * @param aSourceFile Optional. The filename of the source file.
	   *        If omitted, SourceMapConsumer's file property will be used.
	   */
	  SourceMapGenerator.prototype.applySourceMap =
	    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile) {
	      // If aSourceFile is omitted, we will use the file property of the SourceMap
	      if (!aSourceFile) {
	        aSourceFile = aSourceMapConsumer.file;
	      }
	      var sourceRoot = this._sourceRoot;
	      // Make "aSourceFile" relative if an absolute Url is passed.
	      if (sourceRoot) {
	        aSourceFile = util.relative(sourceRoot, aSourceFile);
	      }
	      // Applying the SourceMap can add and remove items from the sources and
	      // the names array.
	      var newSources = new ArraySet();
	      var newNames = new ArraySet();

	      // Find mappings for the "aSourceFile"
	      this._mappings.forEach(function (mapping) {
	        if (mapping.source === aSourceFile && mapping.originalLine) {
	          // Check if it can be mapped by the source map, then update the mapping.
	          var original = aSourceMapConsumer.originalPositionFor({
	            line: mapping.originalLine,
	            column: mapping.originalColumn
	          });
	          if (original.source !== null) {
	            // Copy mapping
	            if (sourceRoot) {
	              mapping.source = util.relative(sourceRoot, original.source);
	            } else {
	              mapping.source = original.source;
	            }
	            mapping.originalLine = original.line;
	            mapping.originalColumn = original.column;
	            if (original.name !== null && mapping.name !== null) {
	              // Only use the identifier name if it's an identifier
	              // in both SourceMaps
	              mapping.name = original.name;
	            }
	          }
	        }

	        var source = mapping.source;
	        if (source && !newSources.has(source)) {
	          newSources.add(source);
	        }

	        var name = mapping.name;
	        if (name && !newNames.has(name)) {
	          newNames.add(name);
	        }

	      }, this);
	      this._sources = newSources;
	      this._names = newNames;

	      // Copy sourcesContents of applied map.
	      aSourceMapConsumer.sources.forEach(function (sourceFile) {
	        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	        if (content) {
	          if (sourceRoot) {
	            sourceFile = util.relative(sourceRoot, sourceFile);
	          }
	          this.setSourceContent(sourceFile, content);
	        }
	      }, this);
	    };

	  /**
	   * A mapping can have one of the three levels of data:
	   *
	   *   1. Just the generated position.
	   *   2. The Generated position, original position, and original source.
	   *   3. Generated and original position, original source, as well as a name
	   *      token.
	   *
	   * To maintain consistency, we validate that any new mapping being added falls
	   * in to one of these categories.
	   */
	  SourceMapGenerator.prototype._validateMapping =
	    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                                aName) {
	      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	          && aGenerated.line > 0 && aGenerated.column >= 0
	          && !aOriginal && !aSource && !aName) {
	        // Case 1.
	        return;
	      }
	      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	               && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	               && aGenerated.line > 0 && aGenerated.column >= 0
	               && aOriginal.line > 0 && aOriginal.column >= 0
	               && aSource) {
	        // Cases 2 and 3.
	        return;
	      }
	      else {
	        throw new Error('Invalid mapping: ' + JSON.stringify({
	          generated: aGenerated,
	          source: aSource,
	          original: aOriginal,
	          name: aName
	        }));
	      }
	    };

	  /**
	   * Serialize the accumulated mappings in to the stream of base 64 VLQs
	   * specified by the source map format.
	   */
	  SourceMapGenerator.prototype._serializeMappings =
	    function SourceMapGenerator_serializeMappings() {
	      var previousGeneratedColumn = 0;
	      var previousGeneratedLine = 1;
	      var previousOriginalColumn = 0;
	      var previousOriginalLine = 0;
	      var previousName = 0;
	      var previousSource = 0;
	      var result = '';
	      var mapping;

	      // The mappings must be guaranteed to be in sorted order before we start
	      // serializing them or else the generated line numbers (which are defined
	      // via the ';' separators) will be all messed up. Note: it might be more
	      // performant to maintain the sorting as we insert them, rather than as we
	      // serialize them, but the big O is the same either way.
	      this._mappings.sort(util.compareByGeneratedPositions);

	      for (var i = 0, len = this._mappings.length; i < len; i++) {
	        mapping = this._mappings[i];

	        if (mapping.generatedLine !== previousGeneratedLine) {
	          previousGeneratedColumn = 0;
	          while (mapping.generatedLine !== previousGeneratedLine) {
	            result += ';';
	            previousGeneratedLine++;
	          }
	        }
	        else {
	          if (i > 0) {
	            if (!util.compareByGeneratedPositions(mapping, this._mappings[i - 1])) {
	              continue;
	            }
	            result += ',';
	          }
	        }

	        result += base64VLQ.encode(mapping.generatedColumn
	                                   - previousGeneratedColumn);
	        previousGeneratedColumn = mapping.generatedColumn;

	        if (mapping.source) {
	          result += base64VLQ.encode(this._sources.indexOf(mapping.source)
	                                     - previousSource);
	          previousSource = this._sources.indexOf(mapping.source);

	          // lines are stored 0-based in SourceMap spec version 3
	          result += base64VLQ.encode(mapping.originalLine - 1
	                                     - previousOriginalLine);
	          previousOriginalLine = mapping.originalLine - 1;

	          result += base64VLQ.encode(mapping.originalColumn
	                                     - previousOriginalColumn);
	          previousOriginalColumn = mapping.originalColumn;

	          if (mapping.name) {
	            result += base64VLQ.encode(this._names.indexOf(mapping.name)
	                                       - previousName);
	            previousName = this._names.indexOf(mapping.name);
	          }
	        }
	      }

	      return result;
	    };

	  SourceMapGenerator.prototype._generateSourcesContent =
	    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	      return aSources.map(function (source) {
	        if (!this._sourcesContents) {
	          return null;
	        }
	        if (aSourceRoot) {
	          source = util.relative(aSourceRoot, source);
	        }
	        var key = util.toSetString(source);
	        return Object.prototype.hasOwnProperty.call(this._sourcesContents,
	                                                    key)
	          ? this._sourcesContents[key]
	          : null;
	      }, this);
	    };

	  /**
	   * Externalize the source map.
	   */
	  SourceMapGenerator.prototype.toJSON =
	    function SourceMapGenerator_toJSON() {
	      var map = {
	        version: this._version,
	        file: this._file,
	        sources: this._sources.toArray(),
	        names: this._names.toArray(),
	        mappings: this._serializeMappings()
	      };
	      if (this._sourceRoot) {
	        map.sourceRoot = this._sourceRoot;
	      }
	      if (this._sourcesContents) {
	        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	      }

	      return map;
	    };

	  /**
	   * Render the source map being generated to a string.
	   */
	  SourceMapGenerator.prototype.toString =
	    function SourceMapGenerator_toString() {
	      return JSON.stringify(this);
	    };

	  exports.SourceMapGenerator = SourceMapGenerator;

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 202 */
/*!************************************************************!*\
  !*** ./~/bunyan/~/source-map/lib/source-map/base64-vlq.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {

	  var base64 = __webpack_require__(/*! ./base64 */ 203);

	  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
	  // length quantities we use in the source map spec, the first bit is the sign,
	  // the next four bits are the actual value, and the 6th bit is the
	  // continuation bit. The continuation bit tells us whether there are more
	  // digits in this value following this digit.
	  //
	  //   Continuation
	  //   |    Sign
	  //   |    |
	  //   V    V
	  //   101011

	  var VLQ_BASE_SHIFT = 5;

	  // binary: 100000
	  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	  // binary: 011111
	  var VLQ_BASE_MASK = VLQ_BASE - 1;

	  // binary: 100000
	  var VLQ_CONTINUATION_BIT = VLQ_BASE;

	  /**
	   * Converts from a two-complement value to a value where the sign bit is
	   * is placed in the least significant bit.  For example, as decimals:
	   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	   */
	  function toVLQSigned(aValue) {
	    return aValue < 0
	      ? ((-aValue) << 1) + 1
	      : (aValue << 1) + 0;
	  }

	  /**
	   * Converts to a two-complement value from a value where the sign bit is
	   * is placed in the least significant bit.  For example, as decimals:
	   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	   */
	  function fromVLQSigned(aValue) {
	    var isNegative = (aValue & 1) === 1;
	    var shifted = aValue >> 1;
	    return isNegative
	      ? -shifted
	      : shifted;
	  }

	  /**
	   * Returns the base 64 VLQ encoded value.
	   */
	  exports.encode = function base64VLQ_encode(aValue) {
	    var encoded = "";
	    var digit;

	    var vlq = toVLQSigned(aValue);

	    do {
	      digit = vlq & VLQ_BASE_MASK;
	      vlq >>>= VLQ_BASE_SHIFT;
	      if (vlq > 0) {
	        // There are still more digits in this value, so we must make sure the
	        // continuation bit is marked.
	        digit |= VLQ_CONTINUATION_BIT;
	      }
	      encoded += base64.encode(digit);
	    } while (vlq > 0);

	    return encoded;
	  };

	  /**
	   * Decodes the next base 64 VLQ value from the given string and returns the
	   * value and the rest of the string.
	   */
	  exports.decode = function base64VLQ_decode(aStr) {
	    var i = 0;
	    var strLen = aStr.length;
	    var result = 0;
	    var shift = 0;
	    var continuation, digit;

	    do {
	      if (i >= strLen) {
	        throw new Error("Expected more digits in base 64 VLQ value.");
	      }
	      digit = base64.decode(aStr.charAt(i++));
	      continuation = !!(digit & VLQ_CONTINUATION_BIT);
	      digit &= VLQ_BASE_MASK;
	      result = result + (digit << shift);
	      shift += VLQ_BASE_SHIFT;
	    } while (continuation);

	    return {
	      value: fromVLQSigned(result),
	      rest: aStr.slice(i)
	    };
	  };

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 203 */
/*!********************************************************!*\
  !*** ./~/bunyan/~/source-map/lib/source-map/base64.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {

	  var charToIntMap = {};
	  var intToCharMap = {};

	  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
	    .split('')
	    .forEach(function (ch, index) {
	      charToIntMap[ch] = index;
	      intToCharMap[index] = ch;
	    });

	  /**
	   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	   */
	  exports.encode = function base64_encode(aNumber) {
	    if (aNumber in intToCharMap) {
	      return intToCharMap[aNumber];
	    }
	    throw new TypeError("Must be between 0 and 63: " + aNumber);
	  };

	  /**
	   * Decode a single base 64 digit to an integer.
	   */
	  exports.decode = function base64_decode(aChar) {
	    if (aChar in charToIntMap) {
	      return charToIntMap[aChar];
	    }
	    throw new TypeError("Not a valid base 64 digit: " + aChar);
	  };

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 204 */
/*!******************************************************!*\
  !*** ./~/bunyan/~/source-map/lib/source-map/util.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {

	  /**
	   * This is a helper function for getting values from parameter/options
	   * objects.
	   *
	   * @param args The object we are extracting values from
	   * @param name The name of the property we are getting.
	   * @param defaultValue An optional value to return if the property is missing
	   * from the object. If this is not specified and the property is missing, an
	   * error will be thrown.
	   */
	  function getArg(aArgs, aName, aDefaultValue) {
	    if (aName in aArgs) {
	      return aArgs[aName];
	    } else if (arguments.length === 3) {
	      return aDefaultValue;
	    } else {
	      throw new Error('"' + aName + '" is a required argument.');
	    }
	  }
	  exports.getArg = getArg;

	  var urlRegexp = /([\w+\-.]+):\/\/((\w+:\w+)@)?([\w.]+)?(:(\d+))?(\S+)?/;
	  var dataUrlRegexp = /^data:.+\,.+/;

	  function urlParse(aUrl) {
	    var match = aUrl.match(urlRegexp);
	    if (!match) {
	      return null;
	    }
	    return {
	      scheme: match[1],
	      auth: match[3],
	      host: match[4],
	      port: match[6],
	      path: match[7]
	    };
	  }
	  exports.urlParse = urlParse;

	  function urlGenerate(aParsedUrl) {
	    var url = aParsedUrl.scheme + "://";
	    if (aParsedUrl.auth) {
	      url += aParsedUrl.auth + "@"
	    }
	    if (aParsedUrl.host) {
	      url += aParsedUrl.host;
	    }
	    if (aParsedUrl.port) {
	      url += ":" + aParsedUrl.port
	    }
	    if (aParsedUrl.path) {
	      url += aParsedUrl.path;
	    }
	    return url;
	  }
	  exports.urlGenerate = urlGenerate;

	  function join(aRoot, aPath) {
	    var url;

	    if (aPath.match(urlRegexp) || aPath.match(dataUrlRegexp)) {
	      return aPath;
	    }

	    if (aPath.charAt(0) === '/' && (url = urlParse(aRoot))) {
	      url.path = aPath;
	      return urlGenerate(url);
	    }

	    return aRoot.replace(/\/$/, '') + '/' + aPath;
	  }
	  exports.join = join;

	  /**
	   * Because behavior goes wacky when you set `__proto__` on objects, we
	   * have to prefix all the strings in our set with an arbitrary character.
	   *
	   * See https://github.com/mozilla/source-map/pull/31 and
	   * https://github.com/mozilla/source-map/issues/30
	   *
	   * @param String aStr
	   */
	  function toSetString(aStr) {
	    return '$' + aStr;
	  }
	  exports.toSetString = toSetString;

	  function fromSetString(aStr) {
	    return aStr.substr(1);
	  }
	  exports.fromSetString = fromSetString;

	  function relative(aRoot, aPath) {
	    aRoot = aRoot.replace(/\/$/, '');

	    var url = urlParse(aRoot);
	    if (aPath.charAt(0) == "/" && url && url.path == "/") {
	      return aPath.slice(1);
	    }

	    return aPath.indexOf(aRoot + '/') === 0
	      ? aPath.substr(aRoot.length + 1)
	      : aPath;
	  }
	  exports.relative = relative;

	  function strcmp(aStr1, aStr2) {
	    var s1 = aStr1 || "";
	    var s2 = aStr2 || "";
	    return (s1 > s2) - (s1 < s2);
	  }

	  /**
	   * Comparator between two mappings where the original positions are compared.
	   *
	   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	   * mappings with the same original source/line/column, but different generated
	   * line and column the same. Useful when searching for a mapping with a
	   * stubbed out mapping.
	   */
	  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	    var cmp;

	    cmp = strcmp(mappingA.source, mappingB.source);
	    if (cmp) {
	      return cmp;
	    }

	    cmp = mappingA.originalLine - mappingB.originalLine;
	    if (cmp) {
	      return cmp;
	    }

	    cmp = mappingA.originalColumn - mappingB.originalColumn;
	    if (cmp || onlyCompareOriginal) {
	      return cmp;
	    }

	    cmp = strcmp(mappingA.name, mappingB.name);
	    if (cmp) {
	      return cmp;
	    }

	    cmp = mappingA.generatedLine - mappingB.generatedLine;
	    if (cmp) {
	      return cmp;
	    }

	    return mappingA.generatedColumn - mappingB.generatedColumn;
	  };
	  exports.compareByOriginalPositions = compareByOriginalPositions;

	  /**
	   * Comparator between two mappings where the generated positions are
	   * compared.
	   *
	   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	   * mappings with the same generated line and column, but different
	   * source/name/original line and column the same. Useful when searching for a
	   * mapping with a stubbed out mapping.
	   */
	  function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated) {
	    var cmp;

	    cmp = mappingA.generatedLine - mappingB.generatedLine;
	    if (cmp) {
	      return cmp;
	    }

	    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	    if (cmp || onlyCompareGenerated) {
	      return cmp;
	    }

	    cmp = strcmp(mappingA.source, mappingB.source);
	    if (cmp) {
	      return cmp;
	    }

	    cmp = mappingA.originalLine - mappingB.originalLine;
	    if (cmp) {
	      return cmp;
	    }

	    cmp = mappingA.originalColumn - mappingB.originalColumn;
	    if (cmp) {
	      return cmp;
	    }

	    return strcmp(mappingA.name, mappingB.name);
	  };
	  exports.compareByGeneratedPositions = compareByGeneratedPositions;

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 205 */
/*!***********************************************************!*\
  !*** ./~/bunyan/~/source-map/lib/source-map/array-set.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {

	  var util = __webpack_require__(/*! ./util */ 204);

	  /**
	   * A data structure which is a combination of an array and a set. Adding a new
	   * member is O(1), testing for membership is O(1), and finding the index of an
	   * element is O(1). Removing elements from the set is not supported. Only
	   * strings are supported for membership.
	   */
	  function ArraySet() {
	    this._array = [];
	    this._set = {};
	  }

	  /**
	   * Static method for creating ArraySet instances from an existing array.
	   */
	  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	    var set = new ArraySet();
	    for (var i = 0, len = aArray.length; i < len; i++) {
	      set.add(aArray[i], aAllowDuplicates);
	    }
	    return set;
	  };

	  /**
	   * Add the given string to this set.
	   *
	   * @param String aStr
	   */
	  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	    var isDuplicate = this.has(aStr);
	    var idx = this._array.length;
	    if (!isDuplicate || aAllowDuplicates) {
	      this._array.push(aStr);
	    }
	    if (!isDuplicate) {
	      this._set[util.toSetString(aStr)] = idx;
	    }
	  };

	  /**
	   * Is the given string a member of this set?
	   *
	   * @param String aStr
	   */
	  ArraySet.prototype.has = function ArraySet_has(aStr) {
	    return Object.prototype.hasOwnProperty.call(this._set,
	                                                util.toSetString(aStr));
	  };

	  /**
	   * What is the index of the given string in the array?
	   *
	   * @param String aStr
	   */
	  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	    if (this.has(aStr)) {
	      return this._set[util.toSetString(aStr)];
	    }
	    throw new Error('"' + aStr + '" is not in the set.');
	  };

	  /**
	   * What is the element at the given index?
	   *
	   * @param Number aIdx
	   */
	  ArraySet.prototype.at = function ArraySet_at(aIdx) {
	    if (aIdx >= 0 && aIdx < this._array.length) {
	      return this._array[aIdx];
	    }
	    throw new Error('No element indexed by ' + aIdx);
	  };

	  /**
	   * Returns the array representation of this set (which has the proper indices
	   * indicated by indexOf). Note that this is a copy of the internal array used
	   * for storing the members so that no one can mess with internal state.
	   */
	  ArraySet.prototype.toArray = function ArraySet_toArray() {
	    return this._array.slice();
	  };

	  exports.ArraySet = ArraySet;

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 206 */
/*!*********************************************************************!*\
  !*** ./~/bunyan/~/source-map/lib/source-map/source-map-consumer.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {

	  var util = __webpack_require__(/*! ./util */ 204);
	  var binarySearch = __webpack_require__(/*! ./binary-search */ 207);
	  var ArraySet = __webpack_require__(/*! ./array-set */ 205).ArraySet;
	  var base64VLQ = __webpack_require__(/*! ./base64-vlq */ 202);

	  /**
	   * A SourceMapConsumer instance represents a parsed source map which we can
	   * query for information about the original file positions by giving it a file
	   * position in the generated source.
	   *
	   * The only parameter is the raw source map (either as a JSON string, or
	   * already parsed to an object). According to the spec, source maps have the
	   * following attributes:
	   *
	   *   - version: Which version of the source map spec this map is following.
	   *   - sources: An array of URLs to the original source files.
	   *   - names: An array of identifiers which can be referrenced by individual mappings.
	   *   - sourceRoot: Optional. The URL root from which all sources are relative.
	   *   - sourcesContent: Optional. An array of contents of the original source files.
	   *   - mappings: A string of base64 VLQs which contain the actual mappings.
	   *   - file: The generated file this source map is associated with.
	   *
	   * Here is an example source map, taken from the source map spec[0]:
	   *
	   *     {
	   *       version : 3,
	   *       file: "out.js",
	   *       sourceRoot : "",
	   *       sources: ["foo.js", "bar.js"],
	   *       names: ["src", "maps", "are", "fun"],
	   *       mappings: "AA,AB;;ABCDE;"
	   *     }
	   *
	   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
	   */
	  function SourceMapConsumer(aSourceMap) {
	    var sourceMap = aSourceMap;
	    if (typeof aSourceMap === 'string') {
	      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	    }

	    var version = util.getArg(sourceMap, 'version');
	    var sources = util.getArg(sourceMap, 'sources');
	    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
	    // requires the array) to play nice here.
	    var names = util.getArg(sourceMap, 'names', []);
	    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
	    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
	    var mappings = util.getArg(sourceMap, 'mappings');
	    var file = util.getArg(sourceMap, 'file', null);

	    // Once again, Sass deviates from the spec and supplies the version as a
	    // string rather than a number, so we use loose equality checking here.
	    if (version != this._version) {
	      throw new Error('Unsupported version: ' + version);
	    }

	    // Pass `true` below to allow duplicate names and sources. While source maps
	    // are intended to be compressed and deduplicated, the TypeScript compiler
	    // sometimes generates source maps with duplicates in them. See Github issue
	    // #72 and bugzil.la/889492.
	    this._names = ArraySet.fromArray(names, true);
	    this._sources = ArraySet.fromArray(sources, true);

	    this.sourceRoot = sourceRoot;
	    this.sourcesContent = sourcesContent;
	    this._mappings = mappings;
	    this.file = file;
	  }

	  /**
	   * Create a SourceMapConsumer from a SourceMapGenerator.
	   *
	   * @param SourceMapGenerator aSourceMap
	   *        The source map that will be consumed.
	   * @returns SourceMapConsumer
	   */
	  SourceMapConsumer.fromSourceMap =
	    function SourceMapConsumer_fromSourceMap(aSourceMap) {
	      var smc = Object.create(SourceMapConsumer.prototype);

	      smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
	      smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
	      smc.sourceRoot = aSourceMap._sourceRoot;
	      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
	                                                              smc.sourceRoot);
	      smc.file = aSourceMap._file;

	      smc.__generatedMappings = aSourceMap._mappings.slice()
	        .sort(util.compareByGeneratedPositions);
	      smc.__originalMappings = aSourceMap._mappings.slice()
	        .sort(util.compareByOriginalPositions);

	      return smc;
	    };

	  /**
	   * The version of the source mapping spec that we are consuming.
	   */
	  SourceMapConsumer.prototype._version = 3;

	  /**
	   * The list of original sources.
	   */
	  Object.defineProperty(SourceMapConsumer.prototype, 'sources', {
	    get: function () {
	      return this._sources.toArray().map(function (s) {
	        return this.sourceRoot ? util.join(this.sourceRoot, s) : s;
	      }, this);
	    }
	  });

	  // `__generatedMappings` and `__originalMappings` are arrays that hold the
	  // parsed mapping coordinates from the source map's "mappings" attribute. They
	  // are lazily instantiated, accessed via the `_generatedMappings` and
	  // `_originalMappings` getters respectively, and we only parse the mappings
	  // and create these arrays once queried for a source location. We jump through
	  // these hoops because there can be many thousands of mappings, and parsing
	  // them is expensive, so we only want to do it if we must.
	  //
	  // Each object in the arrays is of the form:
	  //
	  //     {
	  //       generatedLine: The line number in the generated code,
	  //       generatedColumn: The column number in the generated code,
	  //       source: The path to the original source file that generated this
	  //               chunk of code,
	  //       originalLine: The line number in the original source that
	  //                     corresponds to this chunk of generated code,
	  //       originalColumn: The column number in the original source that
	  //                       corresponds to this chunk of generated code,
	  //       name: The name of the original symbol which generated this chunk of
	  //             code.
	  //     }
	  //
	  // All properties except for `generatedLine` and `generatedColumn` can be
	  // `null`.
	  //
	  // `_generatedMappings` is ordered by the generated positions.
	  //
	  // `_originalMappings` is ordered by the original positions.

	  SourceMapConsumer.prototype.__generatedMappings = null;
	  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
	    get: function () {
	      if (!this.__generatedMappings) {
	        this.__generatedMappings = [];
	        this.__originalMappings = [];
	        this._parseMappings(this._mappings, this.sourceRoot);
	      }

	      return this.__generatedMappings;
	    }
	  });

	  SourceMapConsumer.prototype.__originalMappings = null;
	  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
	    get: function () {
	      if (!this.__originalMappings) {
	        this.__generatedMappings = [];
	        this.__originalMappings = [];
	        this._parseMappings(this._mappings, this.sourceRoot);
	      }

	      return this.__originalMappings;
	    }
	  });

	  /**
	   * Parse the mappings in a string in to a data structure which we can easily
	   * query (the ordered arrays in the `this.__generatedMappings` and
	   * `this.__originalMappings` properties).
	   */
	  SourceMapConsumer.prototype._parseMappings =
	    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	      var generatedLine = 1;
	      var previousGeneratedColumn = 0;
	      var previousOriginalLine = 0;
	      var previousOriginalColumn = 0;
	      var previousSource = 0;
	      var previousName = 0;
	      var mappingSeparator = /^[,;]/;
	      var str = aStr;
	      var mapping;
	      var temp;

	      while (str.length > 0) {
	        if (str.charAt(0) === ';') {
	          generatedLine++;
	          str = str.slice(1);
	          previousGeneratedColumn = 0;
	        }
	        else if (str.charAt(0) === ',') {
	          str = str.slice(1);
	        }
	        else {
	          mapping = {};
	          mapping.generatedLine = generatedLine;

	          // Generated column.
	          temp = base64VLQ.decode(str);
	          mapping.generatedColumn = previousGeneratedColumn + temp.value;
	          previousGeneratedColumn = mapping.generatedColumn;
	          str = temp.rest;

	          if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {
	            // Original source.
	            temp = base64VLQ.decode(str);
	            mapping.source = this._sources.at(previousSource + temp.value);
	            previousSource += temp.value;
	            str = temp.rest;
	            if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
	              throw new Error('Found a source, but no line and column');
	            }

	            // Original line.
	            temp = base64VLQ.decode(str);
	            mapping.originalLine = previousOriginalLine + temp.value;
	            previousOriginalLine = mapping.originalLine;
	            // Lines are stored 0-based
	            mapping.originalLine += 1;
	            str = temp.rest;
	            if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
	              throw new Error('Found a source and line, but no column');
	            }

	            // Original column.
	            temp = base64VLQ.decode(str);
	            mapping.originalColumn = previousOriginalColumn + temp.value;
	            previousOriginalColumn = mapping.originalColumn;
	            str = temp.rest;

	            if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {
	              // Original name.
	              temp = base64VLQ.decode(str);
	              mapping.name = this._names.at(previousName + temp.value);
	              previousName += temp.value;
	              str = temp.rest;
	            }
	          }

	          this.__generatedMappings.push(mapping);
	          if (typeof mapping.originalLine === 'number') {
	            this.__originalMappings.push(mapping);
	          }
	        }
	      }

	      this.__generatedMappings.sort(util.compareByGeneratedPositions);
	      this.__originalMappings.sort(util.compareByOriginalPositions);
	    };

	  /**
	   * Find the mapping that best matches the hypothetical "needle" mapping that
	   * we are searching for in the given "haystack" of mappings.
	   */
	  SourceMapConsumer.prototype._findMapping =
	    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
	                                           aColumnName, aComparator) {
	      // To return the position we are searching for, we must first find the
	      // mapping for the given position and then return the opposite position it
	      // points to. Because the mappings are sorted, we can use binary search to
	      // find the best mapping.

	      if (aNeedle[aLineName] <= 0) {
	        throw new TypeError('Line must be greater than or equal to 1, got '
	                            + aNeedle[aLineName]);
	      }
	      if (aNeedle[aColumnName] < 0) {
	        throw new TypeError('Column must be greater than or equal to 0, got '
	                            + aNeedle[aColumnName]);
	      }

	      return binarySearch.search(aNeedle, aMappings, aComparator);
	    };

	  /**
	   * Returns the original source, line, and column information for the generated
	   * source's line and column positions provided. The only argument is an object
	   * with the following properties:
	   *
	   *   - line: The line number in the generated source.
	   *   - column: The column number in the generated source.
	   *
	   * and an object is returned with the following properties:
	   *
	   *   - source: The original source file, or null.
	   *   - line: The line number in the original source, or null.
	   *   - column: The column number in the original source, or null.
	   *   - name: The original identifier, or null.
	   */
	  SourceMapConsumer.prototype.originalPositionFor =
	    function SourceMapConsumer_originalPositionFor(aArgs) {
	      var needle = {
	        generatedLine: util.getArg(aArgs, 'line'),
	        generatedColumn: util.getArg(aArgs, 'column')
	      };

	      var mapping = this._findMapping(needle,
	                                      this._generatedMappings,
	                                      "generatedLine",
	                                      "generatedColumn",
	                                      util.compareByGeneratedPositions);

	      if (mapping) {
	        var source = util.getArg(mapping, 'source', null);
	        if (source && this.sourceRoot) {
	          source = util.join(this.sourceRoot, source);
	        }
	        return {
	          source: source,
	          line: util.getArg(mapping, 'originalLine', null),
	          column: util.getArg(mapping, 'originalColumn', null),
	          name: util.getArg(mapping, 'name', null)
	        };
	      }

	      return {
	        source: null,
	        line: null,
	        column: null,
	        name: null
	      };
	    };

	  /**
	   * Returns the original source content. The only argument is the url of the
	   * original source file. Returns null if no original source content is
	   * availible.
	   */
	  SourceMapConsumer.prototype.sourceContentFor =
	    function SourceMapConsumer_sourceContentFor(aSource) {
	      if (!this.sourcesContent) {
	        return null;
	      }

	      if (this.sourceRoot) {
	        aSource = util.relative(this.sourceRoot, aSource);
	      }

	      if (this._sources.has(aSource)) {
	        return this.sourcesContent[this._sources.indexOf(aSource)];
	      }

	      var url;
	      if (this.sourceRoot
	          && (url = util.urlParse(this.sourceRoot))) {
	        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
	        // many users. We can help them out when they expect file:// URIs to
	        // behave like it would if they were running a local HTTP server. See
	        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
	        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
	        if (url.scheme == "file"
	            && this._sources.has(fileUriAbsPath)) {
	          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
	        }

	        if ((!url.path || url.path == "/")
	            && this._sources.has("/" + aSource)) {
	          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
	        }
	      }

	      throw new Error('"' + aSource + '" is not in the SourceMap.');
	    };

	  /**
	   * Returns the generated line and column information for the original source,
	   * line, and column positions provided. The only argument is an object with
	   * the following properties:
	   *
	   *   - source: The filename of the original source.
	   *   - line: The line number in the original source.
	   *   - column: The column number in the original source.
	   *
	   * and an object is returned with the following properties:
	   *
	   *   - line: The line number in the generated source, or null.
	   *   - column: The column number in the generated source, or null.
	   */
	  SourceMapConsumer.prototype.generatedPositionFor =
	    function SourceMapConsumer_generatedPositionFor(aArgs) {
	      var needle = {
	        source: util.getArg(aArgs, 'source'),
	        originalLine: util.getArg(aArgs, 'line'),
	        originalColumn: util.getArg(aArgs, 'column')
	      };

	      if (this.sourceRoot) {
	        needle.source = util.relative(this.sourceRoot, needle.source);
	      }

	      var mapping = this._findMapping(needle,
	                                      this._originalMappings,
	                                      "originalLine",
	                                      "originalColumn",
	                                      util.compareByOriginalPositions);

	      if (mapping) {
	        return {
	          line: util.getArg(mapping, 'generatedLine', null),
	          column: util.getArg(mapping, 'generatedColumn', null)
	        };
	      }

	      return {
	        line: null,
	        column: null
	      };
	    };

	  SourceMapConsumer.GENERATED_ORDER = 1;
	  SourceMapConsumer.ORIGINAL_ORDER = 2;

	  /**
	   * Iterate over each mapping between an original source/line/column and a
	   * generated line/column in this source map.
	   *
	   * @param Function aCallback
	   *        The function that is called with each mapping.
	   * @param Object aContext
	   *        Optional. If specified, this object will be the value of `this` every
	   *        time that `aCallback` is called.
	   * @param aOrder
	   *        Either `SourceMapConsumer.GENERATED_ORDER` or
	   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
	   *        iterate over the mappings sorted by the generated file's line/column
	   *        order or the original's source/line/column order, respectively. Defaults to
	   *        `SourceMapConsumer.GENERATED_ORDER`.
	   */
	  SourceMapConsumer.prototype.eachMapping =
	    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
	      var context = aContext || null;
	      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

	      var mappings;
	      switch (order) {
	      case SourceMapConsumer.GENERATED_ORDER:
	        mappings = this._generatedMappings;
	        break;
	      case SourceMapConsumer.ORIGINAL_ORDER:
	        mappings = this._originalMappings;
	        break;
	      default:
	        throw new Error("Unknown order of iteration.");
	      }

	      var sourceRoot = this.sourceRoot;
	      mappings.map(function (mapping) {
	        var source = mapping.source;
	        if (source && sourceRoot) {
	          source = util.join(sourceRoot, source);
	        }
	        return {
	          source: source,
	          generatedLine: mapping.generatedLine,
	          generatedColumn: mapping.generatedColumn,
	          originalLine: mapping.originalLine,
	          originalColumn: mapping.originalColumn,
	          name: mapping.name
	        };
	      }).forEach(aCallback, context);
	    };

	  exports.SourceMapConsumer = SourceMapConsumer;

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 207 */
/*!***************************************************************!*\
  !*** ./~/bunyan/~/source-map/lib/source-map/binary-search.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {

	  /**
	   * Recursive implementation of binary search.
	   *
	   * @param aLow Indices here and lower do not contain the needle.
	   * @param aHigh Indices here and higher do not contain the needle.
	   * @param aNeedle The element being searched for.
	   * @param aHaystack The non-empty array being searched.
	   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
	   */
	  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {
	    // This function terminates when one of the following is true:
	    //
	    //   1. We find the exact element we are looking for.
	    //
	    //   2. We did not find the exact element, but we can return the next
	    //      closest element that is less than that element.
	    //
	    //   3. We did not find the exact element, and there is no next-closest
	    //      element which is less than the one we are searching for, so we
	    //      return null.
	    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
	    var cmp = aCompare(aNeedle, aHaystack[mid], true);
	    if (cmp === 0) {
	      // Found the element we are looking for.
	      return aHaystack[mid];
	    }
	    else if (cmp > 0) {
	      // aHaystack[mid] is greater than our needle.
	      if (aHigh - mid > 1) {
	        // The element is in the upper half.
	        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);
	      }
	      // We did not find an exact match, return the next closest one
	      // (termination case 2).
	      return aHaystack[mid];
	    }
	    else {
	      // aHaystack[mid] is less than our needle.
	      if (mid - aLow > 1) {
	        // The element is in the lower half.
	        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);
	      }
	      // The exact needle element was not found in this haystack. Determine if
	      // we are in termination case (2) or (3) and return the appropriate thing.
	      return aLow < 0
	        ? null
	        : aHaystack[aLow];
	    }
	  }

	  /**
	   * This is an implementation of binary search which will always try and return
	   * the next lowest value checked if there is no exact hit. This is because
	   * mappings between original and generated line/col pairs are single points,
	   * and there is an implicit region between each of them, so a miss just means
	   * that you aren't on the very start of a region.
	   *
	   * @param aNeedle The element you are looking for.
	   * @param aHaystack The array that is being searched.
	   * @param aCompare A function which takes the needle and an element in the
	   *     array and returns -1, 0, or 1 depending on whether the needle is less
	   *     than, equal to, or greater than the element, respectively.
	   */
	  exports.search = function search(aNeedle, aHaystack, aCompare) {
	    return aHaystack.length > 0
	      ? recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare)
	      : null;
	  };

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 208 */
/*!*************************************************************!*\
  !*** ./~/bunyan/~/source-map/lib/source-map/source-node.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {

	  var SourceMapGenerator = __webpack_require__(/*! ./source-map-generator */ 201).SourceMapGenerator;
	  var util = __webpack_require__(/*! ./util */ 204);

	  /**
	   * SourceNodes provide a way to abstract over interpolating/concatenating
	   * snippets of generated JavaScript source code while maintaining the line and
	   * column information associated with the original source code.
	   *
	   * @param aLine The original line number.
	   * @param aColumn The original column number.
	   * @param aSource The original source's filename.
	   * @param aChunks Optional. An array of strings which are snippets of
	   *        generated JS, or other SourceNodes.
	   * @param aName The original identifier.
	   */
	  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
	    this.children = [];
	    this.sourceContents = {};
	    this.line = aLine === undefined ? null : aLine;
	    this.column = aColumn === undefined ? null : aColumn;
	    this.source = aSource === undefined ? null : aSource;
	    this.name = aName === undefined ? null : aName;
	    if (aChunks != null) this.add(aChunks);
	  }

	  /**
	   * Creates a SourceNode from generated code and a SourceMapConsumer.
	   *
	   * @param aGeneratedCode The generated code
	   * @param aSourceMapConsumer The SourceMap for the generated code
	   */
	  SourceNode.fromStringWithSourceMap =
	    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer) {
	      // The SourceNode we want to fill with the generated code
	      // and the SourceMap
	      var node = new SourceNode();

	      // The generated code
	      // Processed fragments are removed from this array.
	      var remainingLines = aGeneratedCode.split('\n');

	      // We need to remember the position of "remainingLines"
	      var lastGeneratedLine = 1, lastGeneratedColumn = 0;

	      // The generate SourceNodes we need a code range.
	      // To extract it current and last mapping is used.
	      // Here we store the last mapping.
	      var lastMapping = null;

	      aSourceMapConsumer.eachMapping(function (mapping) {
	        if (lastMapping === null) {
	          // We add the generated code until the first mapping
	          // to the SourceNode without any mapping.
	          // Each line is added as separate string.
	          while (lastGeneratedLine < mapping.generatedLine) {
	            node.add(remainingLines.shift() + "\n");
	            lastGeneratedLine++;
	          }
	          if (lastGeneratedColumn < mapping.generatedColumn) {
	            var nextLine = remainingLines[0];
	            node.add(nextLine.substr(0, mapping.generatedColumn));
	            remainingLines[0] = nextLine.substr(mapping.generatedColumn);
	            lastGeneratedColumn = mapping.generatedColumn;
	          }
	        } else {
	          // We add the code from "lastMapping" to "mapping":
	          // First check if there is a new line in between.
	          if (lastGeneratedLine < mapping.generatedLine) {
	            var code = "";
	            // Associate full lines with "lastMapping"
	            do {
	              code += remainingLines.shift() + "\n";
	              lastGeneratedLine++;
	              lastGeneratedColumn = 0;
	            } while (lastGeneratedLine < mapping.generatedLine);
	            // When we reached the correct line, we add code until we
	            // reach the correct column too.
	            if (lastGeneratedColumn < mapping.generatedColumn) {
	              var nextLine = remainingLines[0];
	              code += nextLine.substr(0, mapping.generatedColumn);
	              remainingLines[0] = nextLine.substr(mapping.generatedColumn);
	              lastGeneratedColumn = mapping.generatedColumn;
	            }
	            // Create the SourceNode.
	            addMappingWithCode(lastMapping, code);
	          } else {
	            // There is no new line in between.
	            // Associate the code between "lastGeneratedColumn" and
	            // "mapping.generatedColumn" with "lastMapping"
	            var nextLine = remainingLines[0];
	            var code = nextLine.substr(0, mapping.generatedColumn -
	                                          lastGeneratedColumn);
	            remainingLines[0] = nextLine.substr(mapping.generatedColumn -
	                                                lastGeneratedColumn);
	            lastGeneratedColumn = mapping.generatedColumn;
	            addMappingWithCode(lastMapping, code);
	          }
	        }
	        lastMapping = mapping;
	      }, this);
	      // We have processed all mappings.
	      // Associate the remaining code in the current line with "lastMapping"
	      // and add the remaining lines without any mapping
	      addMappingWithCode(lastMapping, remainingLines.join("\n"));

	      // Copy sourcesContent into SourceNode
	      aSourceMapConsumer.sources.forEach(function (sourceFile) {
	        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	        if (content) {
	          node.setSourceContent(sourceFile, content);
	        }
	      });

	      return node;

	      function addMappingWithCode(mapping, code) {
	        if (mapping === null || mapping.source === undefined) {
	          node.add(code);
	        } else {
	          node.add(new SourceNode(mapping.originalLine,
	                                  mapping.originalColumn,
	                                  mapping.source,
	                                  code,
	                                  mapping.name));
	        }
	      }
	    };

	  /**
	   * Add a chunk of generated JS to this source node.
	   *
	   * @param aChunk A string snippet of generated JS code, another instance of
	   *        SourceNode, or an array where each member is one of those things.
	   */
	  SourceNode.prototype.add = function SourceNode_add(aChunk) {
	    if (Array.isArray(aChunk)) {
	      aChunk.forEach(function (chunk) {
	        this.add(chunk);
	      }, this);
	    }
	    else if (aChunk instanceof SourceNode || typeof aChunk === "string") {
	      if (aChunk) {
	        this.children.push(aChunk);
	      }
	    }
	    else {
	      throw new TypeError(
	        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	      );
	    }
	    return this;
	  };

	  /**
	   * Add a chunk of generated JS to the beginning of this source node.
	   *
	   * @param aChunk A string snippet of generated JS code, another instance of
	   *        SourceNode, or an array where each member is one of those things.
	   */
	  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
	    if (Array.isArray(aChunk)) {
	      for (var i = aChunk.length-1; i >= 0; i--) {
	        this.prepend(aChunk[i]);
	      }
	    }
	    else if (aChunk instanceof SourceNode || typeof aChunk === "string") {
	      this.children.unshift(aChunk);
	    }
	    else {
	      throw new TypeError(
	        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	      );
	    }
	    return this;
	  };

	  /**
	   * Walk over the tree of JS snippets in this node and its children. The
	   * walking function is called once for each snippet of JS and is passed that
	   * snippet and the its original associated source's line/column location.
	   *
	   * @param aFn The traversal function.
	   */
	  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
	    var chunk;
	    for (var i = 0, len = this.children.length; i < len; i++) {
	      chunk = this.children[i];
	      if (chunk instanceof SourceNode) {
	        chunk.walk(aFn);
	      }
	      else {
	        if (chunk !== '') {
	          aFn(chunk, { source: this.source,
	                       line: this.line,
	                       column: this.column,
	                       name: this.name });
	        }
	      }
	    }
	  };

	  /**
	   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
	   * each of `this.children`.
	   *
	   * @param aSep The separator.
	   */
	  SourceNode.prototype.join = function SourceNode_join(aSep) {
	    var newChildren;
	    var i;
	    var len = this.children.length;
	    if (len > 0) {
	      newChildren = [];
	      for (i = 0; i < len-1; i++) {
	        newChildren.push(this.children[i]);
	        newChildren.push(aSep);
	      }
	      newChildren.push(this.children[i]);
	      this.children = newChildren;
	    }
	    return this;
	  };

	  /**
	   * Call String.prototype.replace on the very right-most source snippet. Useful
	   * for trimming whitespace from the end of a source node, etc.
	   *
	   * @param aPattern The pattern to replace.
	   * @param aReplacement The thing to replace the pattern with.
	   */
	  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
	    var lastChild = this.children[this.children.length - 1];
	    if (lastChild instanceof SourceNode) {
	      lastChild.replaceRight(aPattern, aReplacement);
	    }
	    else if (typeof lastChild === 'string') {
	      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
	    }
	    else {
	      this.children.push(''.replace(aPattern, aReplacement));
	    }
	    return this;
	  };

	  /**
	   * Set the source content for a source file. This will be added to the SourceMapGenerator
	   * in the sourcesContent field.
	   *
	   * @param aSourceFile The filename of the source file
	   * @param aSourceContent The content of the source file
	   */
	  SourceNode.prototype.setSourceContent =
	    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
	      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
	    };

	  /**
	   * Walk over the tree of SourceNodes. The walking function is called for each
	   * source file content and is passed the filename and source content.
	   *
	   * @param aFn The traversal function.
	   */
	  SourceNode.prototype.walkSourceContents =
	    function SourceNode_walkSourceContents(aFn) {
	      for (var i = 0, len = this.children.length; i < len; i++) {
	        if (this.children[i] instanceof SourceNode) {
	          this.children[i].walkSourceContents(aFn);
	        }
	      }

	      var sources = Object.keys(this.sourceContents);
	      for (var i = 0, len = sources.length; i < len; i++) {
	        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
	      }
	    };

	  /**
	   * Return the string representation of this source node. Walks over the tree
	   * and concatenates all the various snippets together to one string.
	   */
	  SourceNode.prototype.toString = function SourceNode_toString() {
	    var str = "";
	    this.walk(function (chunk) {
	      str += chunk;
	    });
	    return str;
	  };

	  /**
	   * Returns the string representation of this source node along with a source
	   * map.
	   */
	  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
	    var generated = {
	      code: "",
	      line: 1,
	      column: 0
	    };
	    var map = new SourceMapGenerator(aArgs);
	    var sourceMappingActive = false;
	    var lastOriginalSource = null;
	    var lastOriginalLine = null;
	    var lastOriginalColumn = null;
	    var lastOriginalName = null;
	    this.walk(function (chunk, original) {
	      generated.code += chunk;
	      if (original.source !== null
	          && original.line !== null
	          && original.column !== null) {
	        if(lastOriginalSource !== original.source
	           || lastOriginalLine !== original.line
	           || lastOriginalColumn !== original.column
	           || lastOriginalName !== original.name) {
	          map.addMapping({
	            source: original.source,
	            original: {
	              line: original.line,
	              column: original.column
	            },
	            generated: {
	              line: generated.line,
	              column: generated.column
	            },
	            name: original.name
	          });
	        }
	        lastOriginalSource = original.source;
	        lastOriginalLine = original.line;
	        lastOriginalColumn = original.column;
	        lastOriginalName = original.name;
	        sourceMappingActive = true;
	      } else if (sourceMappingActive) {
	        map.addMapping({
	          generated: {
	            line: generated.line,
	            column: generated.column
	          }
	        });
	        lastOriginalSource = null;
	        sourceMappingActive = false;
	      }
	      chunk.split('').forEach(function (ch) {
	        if (ch === '\n') {
	          generated.line++;
	          generated.column = 0;
	        } else {
	          generated.column++;
	        }
	      });
	    });
	    this.walkSourceContents(function (sourceFile, sourceContent) {
	      map.setSourceContent(sourceFile, sourceContent);
	    });

	    return { code: generated.code, map: map };
	  };

	  exports.SourceNode = SourceNode;

	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 209 */
/*!****************************!*\
  !*** ./~/moment/moment.js ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {//! moment.js
	//! version : 2.15.2
	//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
	//! license : MIT
	//! momentjs.com

	;(function (global, factory) {
	     true ? module.exports = factory() :
	    typeof define === 'function' && define.amd ? define(factory) :
	    global.moment = factory()
	}(this, function () { 'use strict';

	    var hookCallback;

	    function utils_hooks__hooks () {
	        return hookCallback.apply(null, arguments);
	    }

	    // This is done to register the method called with moment()
	    // without creating circular dependencies.
	    function setHookCallback (callback) {
	        hookCallback = callback;
	    }

	    function isArray(input) {
	        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
	    }

	    function isObject(input) {
	        // IE8 will treat undefined and null as object if it wasn't for
	        // input != null
	        return input != null && Object.prototype.toString.call(input) === '[object Object]';
	    }

	    function isObjectEmpty(obj) {
	        var k;
	        for (k in obj) {
	            // even if its not own property I'd still call it non-empty
	            return false;
	        }
	        return true;
	    }

	    function isDate(input) {
	        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
	    }

	    function map(arr, fn) {
	        var res = [], i;
	        for (i = 0; i < arr.length; ++i) {
	            res.push(fn(arr[i], i));
	        }
	        return res;
	    }

	    function hasOwnProp(a, b) {
	        return Object.prototype.hasOwnProperty.call(a, b);
	    }

	    function extend(a, b) {
	        for (var i in b) {
	            if (hasOwnProp(b, i)) {
	                a[i] = b[i];
	            }
	        }

	        if (hasOwnProp(b, 'toString')) {
	            a.toString = b.toString;
	        }

	        if (hasOwnProp(b, 'valueOf')) {
	            a.valueOf = b.valueOf;
	        }

	        return a;
	    }

	    function create_utc__createUTC (input, format, locale, strict) {
	        return createLocalOrUTC(input, format, locale, strict, true).utc();
	    }

	    function defaultParsingFlags() {
	        // We need to deep clone this object.
	        return {
	            empty           : false,
	            unusedTokens    : [],
	            unusedInput     : [],
	            overflow        : -2,
	            charsLeftOver   : 0,
	            nullInput       : false,
	            invalidMonth    : null,
	            invalidFormat   : false,
	            userInvalidated : false,
	            iso             : false,
	            parsedDateParts : [],
	            meridiem        : null
	        };
	    }

	    function getParsingFlags(m) {
	        if (m._pf == null) {
	            m._pf = defaultParsingFlags();
	        }
	        return m._pf;
	    }

	    var some;
	    if (Array.prototype.some) {
	        some = Array.prototype.some;
	    } else {
	        some = function (fun) {
	            var t = Object(this);
	            var len = t.length >>> 0;

	            for (var i = 0; i < len; i++) {
	                if (i in t && fun.call(this, t[i], i, t)) {
	                    return true;
	                }
	            }

	            return false;
	        };
	    }

	    function valid__isValid(m) {
	        if (m._isValid == null) {
	            var flags = getParsingFlags(m);
	            var parsedParts = some.call(flags.parsedDateParts, function (i) {
	                return i != null;
	            });
	            var isNowValid = !isNaN(m._d.getTime()) &&
	                flags.overflow < 0 &&
	                !flags.empty &&
	                !flags.invalidMonth &&
	                !flags.invalidWeekday &&
	                !flags.nullInput &&
	                !flags.invalidFormat &&
	                !flags.userInvalidated &&
	                (!flags.meridiem || (flags.meridiem && parsedParts));

	            if (m._strict) {
	                isNowValid = isNowValid &&
	                    flags.charsLeftOver === 0 &&
	                    flags.unusedTokens.length === 0 &&
	                    flags.bigHour === undefined;
	            }

	            if (Object.isFrozen == null || !Object.isFrozen(m)) {
	                m._isValid = isNowValid;
	            }
	            else {
	                return isNowValid;
	            }
	        }
	        return m._isValid;
	    }

	    function valid__createInvalid (flags) {
	        var m = create_utc__createUTC(NaN);
	        if (flags != null) {
	            extend(getParsingFlags(m), flags);
	        }
	        else {
	            getParsingFlags(m).userInvalidated = true;
	        }

	        return m;
	    }

	    function isUndefined(input) {
	        return input === void 0;
	    }

	    // Plugins that add properties should also add the key here (null value),
	    // so we can properly clone ourselves.
	    var momentProperties = utils_hooks__hooks.momentProperties = [];

	    function copyConfig(to, from) {
	        var i, prop, val;

	        if (!isUndefined(from._isAMomentObject)) {
	            to._isAMomentObject = from._isAMomentObject;
	        }
	        if (!isUndefined(from._i)) {
	            to._i = from._i;
	        }
	        if (!isUndefined(from._f)) {
	            to._f = from._f;
	        }
	        if (!isUndefined(from._l)) {
	            to._l = from._l;
	        }
	        if (!isUndefined(from._strict)) {
	            to._strict = from._strict;
	        }
	        if (!isUndefined(from._tzm)) {
	            to._tzm = from._tzm;
	        }
	        if (!isUndefined(from._isUTC)) {
	            to._isUTC = from._isUTC;
	        }
	        if (!isUndefined(from._offset)) {
	            to._offset = from._offset;
	        }
	        if (!isUndefined(from._pf)) {
	            to._pf = getParsingFlags(from);
	        }
	        if (!isUndefined(from._locale)) {
	            to._locale = from._locale;
	        }

	        if (momentProperties.length > 0) {
	            for (i in momentProperties) {
	                prop = momentProperties[i];
	                val = from[prop];
	                if (!isUndefined(val)) {
	                    to[prop] = val;
	                }
	            }
	        }

	        return to;
	    }

	    var updateInProgress = false;

	    // Moment prototype object
	    function Moment(config) {
	        copyConfig(this, config);
	        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
	        // Prevent infinite loop in case updateOffset creates new moment
	        // objects.
	        if (updateInProgress === false) {
	            updateInProgress = true;
	            utils_hooks__hooks.updateOffset(this);
	            updateInProgress = false;
	        }
	    }

	    function isMoment (obj) {
	        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
	    }

	    function absFloor (number) {
	        if (number < 0) {
	            // -0 -> 0
	            return Math.ceil(number) || 0;
	        } else {
	            return Math.floor(number);
	        }
	    }

	    function toInt(argumentForCoercion) {
	        var coercedNumber = +argumentForCoercion,
	            value = 0;

	        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
	            value = absFloor(coercedNumber);
	        }

	        return value;
	    }

	    // compare two arrays, return the number of differences
	    function compareArrays(array1, array2, dontConvert) {
	        var len = Math.min(array1.length, array2.length),
	            lengthDiff = Math.abs(array1.length - array2.length),
	            diffs = 0,
	            i;
	        for (i = 0; i < len; i++) {
	            if ((dontConvert && array1[i] !== array2[i]) ||
	                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
	                diffs++;
	            }
	        }
	        return diffs + lengthDiff;
	    }

	    function warn(msg) {
	        if (utils_hooks__hooks.suppressDeprecationWarnings === false &&
	                (typeof console !==  'undefined') && console.warn) {
	            console.warn('Deprecation warning: ' + msg);
	        }
	    }

	    function deprecate(msg, fn) {
	        var firstTime = true;

	        return extend(function () {
	            if (utils_hooks__hooks.deprecationHandler != null) {
	                utils_hooks__hooks.deprecationHandler(null, msg);
	            }
	            if (firstTime) {
	                var args = [];
	                var arg;
	                for (var i = 0; i < arguments.length; i++) {
	                    arg = '';
	                    if (typeof arguments[i] === 'object') {
	                        arg += '\n[' + i + '] ';
	                        for (var key in arguments[0]) {
	                            arg += key + ': ' + arguments[0][key] + ', ';
	                        }
	                        arg = arg.slice(0, -2); // Remove trailing comma and space
	                    } else {
	                        arg = arguments[i];
	                    }
	                    args.push(arg);
	                }
	                warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
	                firstTime = false;
	            }
	            return fn.apply(this, arguments);
	        }, fn);
	    }

	    var deprecations = {};

	    function deprecateSimple(name, msg) {
	        if (utils_hooks__hooks.deprecationHandler != null) {
	            utils_hooks__hooks.deprecationHandler(name, msg);
	        }
	        if (!deprecations[name]) {
	            warn(msg);
	            deprecations[name] = true;
	        }
	    }

	    utils_hooks__hooks.suppressDeprecationWarnings = false;
	    utils_hooks__hooks.deprecationHandler = null;

	    function isFunction(input) {
	        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
	    }

	    function locale_set__set (config) {
	        var prop, i;
	        for (i in config) {
	            prop = config[i];
	            if (isFunction(prop)) {
	                this[i] = prop;
	            } else {
	                this['_' + i] = prop;
	            }
	        }
	        this._config = config;
	        // Lenient ordinal parsing accepts just a number in addition to
	        // number + (possibly) stuff coming from _ordinalParseLenient.
	        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
	    }

	    function mergeConfigs(parentConfig, childConfig) {
	        var res = extend({}, parentConfig), prop;
	        for (prop in childConfig) {
	            if (hasOwnProp(childConfig, prop)) {
	                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
	                    res[prop] = {};
	                    extend(res[prop], parentConfig[prop]);
	                    extend(res[prop], childConfig[prop]);
	                } else if (childConfig[prop] != null) {
	                    res[prop] = childConfig[prop];
	                } else {
	                    delete res[prop];
	                }
	            }
	        }
	        for (prop in parentConfig) {
	            if (hasOwnProp(parentConfig, prop) &&
	                    !hasOwnProp(childConfig, prop) &&
	                    isObject(parentConfig[prop])) {
	                // make sure changes to properties don't modify parent config
	                res[prop] = extend({}, res[prop]);
	            }
	        }
	        return res;
	    }

	    function Locale(config) {
	        if (config != null) {
	            this.set(config);
	        }
	    }

	    var keys;

	    if (Object.keys) {
	        keys = Object.keys;
	    } else {
	        keys = function (obj) {
	            var i, res = [];
	            for (i in obj) {
	                if (hasOwnProp(obj, i)) {
	                    res.push(i);
	                }
	            }
	            return res;
	        };
	    }

	    var defaultCalendar = {
	        sameDay : '[Today at] LT',
	        nextDay : '[Tomorrow at] LT',
	        nextWeek : 'dddd [at] LT',
	        lastDay : '[Yesterday at] LT',
	        lastWeek : '[Last] dddd [at] LT',
	        sameElse : 'L'
	    };

	    function locale_calendar__calendar (key, mom, now) {
	        var output = this._calendar[key] || this._calendar['sameElse'];
	        return isFunction(output) ? output.call(mom, now) : output;
	    }

	    var defaultLongDateFormat = {
	        LTS  : 'h:mm:ss A',
	        LT   : 'h:mm A',
	        L    : 'MM/DD/YYYY',
	        LL   : 'MMMM D, YYYY',
	        LLL  : 'MMMM D, YYYY h:mm A',
	        LLLL : 'dddd, MMMM D, YYYY h:mm A'
	    };

	    function longDateFormat (key) {
	        var format = this._longDateFormat[key],
	            formatUpper = this._longDateFormat[key.toUpperCase()];

	        if (format || !formatUpper) {
	            return format;
	        }

	        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
	            return val.slice(1);
	        });

	        return this._longDateFormat[key];
	    }

	    var defaultInvalidDate = 'Invalid date';

	    function invalidDate () {
	        return this._invalidDate;
	    }

	    var defaultOrdinal = '%d';
	    var defaultOrdinalParse = /\d{1,2}/;

	    function ordinal (number) {
	        return this._ordinal.replace('%d', number);
	    }

	    var defaultRelativeTime = {
	        future : 'in %s',
	        past   : '%s ago',
	        s  : 'a few seconds',
	        m  : 'a minute',
	        mm : '%d minutes',
	        h  : 'an hour',
	        hh : '%d hours',
	        d  : 'a day',
	        dd : '%d days',
	        M  : 'a month',
	        MM : '%d months',
	        y  : 'a year',
	        yy : '%d years'
	    };

	    function relative__relativeTime (number, withoutSuffix, string, isFuture) {
	        var output = this._relativeTime[string];
	        return (isFunction(output)) ?
	            output(number, withoutSuffix, string, isFuture) :
	            output.replace(/%d/i, number);
	    }

	    function pastFuture (diff, output) {
	        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
	        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
	    }

	    var aliases = {};

	    function addUnitAlias (unit, shorthand) {
	        var lowerCase = unit.toLowerCase();
	        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
	    }

	    function normalizeUnits(units) {
	        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
	    }

	    function normalizeObjectUnits(inputObject) {
	        var normalizedInput = {},
	            normalizedProp,
	            prop;

	        for (prop in inputObject) {
	            if (hasOwnProp(inputObject, prop)) {
	                normalizedProp = normalizeUnits(prop);
	                if (normalizedProp) {
	                    normalizedInput[normalizedProp] = inputObject[prop];
	                }
	            }
	        }

	        return normalizedInput;
	    }

	    var priorities = {};

	    function addUnitPriority(unit, priority) {
	        priorities[unit] = priority;
	    }

	    function getPrioritizedUnits(unitsObj) {
	        var units = [];
	        for (var u in unitsObj) {
	            units.push({unit: u, priority: priorities[u]});
	        }
	        units.sort(function (a, b) {
	            return a.priority - b.priority;
	        });
	        return units;
	    }

	    function makeGetSet (unit, keepTime) {
	        return function (value) {
	            if (value != null) {
	                get_set__set(this, unit, value);
	                utils_hooks__hooks.updateOffset(this, keepTime);
	                return this;
	            } else {
	                return get_set__get(this, unit);
	            }
	        };
	    }

	    function get_set__get (mom, unit) {
	        return mom.isValid() ?
	            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
	    }

	    function get_set__set (mom, unit, value) {
	        if (mom.isValid()) {
	            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
	        }
	    }

	    // MOMENTS

	    function stringGet (units) {
	        units = normalizeUnits(units);
	        if (isFunction(this[units])) {
	            return this[units]();
	        }
	        return this;
	    }


	    function stringSet (units, value) {
	        if (typeof units === 'object') {
	            units = normalizeObjectUnits(units);
	            var prioritized = getPrioritizedUnits(units);
	            for (var i = 0; i < prioritized.length; i++) {
	                this[prioritized[i].unit](units[prioritized[i].unit]);
	            }
	        } else {
	            units = normalizeUnits(units);
	            if (isFunction(this[units])) {
	                return this[units](value);
	            }
	        }
	        return this;
	    }

	    function zeroFill(number, targetLength, forceSign) {
	        var absNumber = '' + Math.abs(number),
	            zerosToFill = targetLength - absNumber.length,
	            sign = number >= 0;
	        return (sign ? (forceSign ? '+' : '') : '-') +
	            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
	    }

	    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

	    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

	    var formatFunctions = {};

	    var formatTokenFunctions = {};

	    // token:    'M'
	    // padded:   ['MM', 2]
	    // ordinal:  'Mo'
	    // callback: function () { this.month() + 1 }
	    function addFormatToken (token, padded, ordinal, callback) {
	        var func = callback;
	        if (typeof callback === 'string') {
	            func = function () {
	                return this[callback]();
	            };
	        }
	        if (token) {
	            formatTokenFunctions[token] = func;
	        }
	        if (padded) {
	            formatTokenFunctions[padded[0]] = function () {
	                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
	            };
	        }
	        if (ordinal) {
	            formatTokenFunctions[ordinal] = function () {
	                return this.localeData().ordinal(func.apply(this, arguments), token);
	            };
	        }
	    }

	    function removeFormattingTokens(input) {
	        if (input.match(/\[[\s\S]/)) {
	            return input.replace(/^\[|\]$/g, '');
	        }
	        return input.replace(/\\/g, '');
	    }

	    function makeFormatFunction(format) {
	        var array = format.match(formattingTokens), i, length;

	        for (i = 0, length = array.length; i < length; i++) {
	            if (formatTokenFunctions[array[i]]) {
	                array[i] = formatTokenFunctions[array[i]];
	            } else {
	                array[i] = removeFormattingTokens(array[i]);
	            }
	        }

	        return function (mom) {
	            var output = '', i;
	            for (i = 0; i < length; i++) {
	                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
	            }
	            return output;
	        };
	    }

	    // format date using native date object
	    function formatMoment(m, format) {
	        if (!m.isValid()) {
	            return m.localeData().invalidDate();
	        }

	        format = expandFormat(format, m.localeData());
	        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

	        return formatFunctions[format](m);
	    }

	    function expandFormat(format, locale) {
	        var i = 5;

	        function replaceLongDateFormatTokens(input) {
	            return locale.longDateFormat(input) || input;
	        }

	        localFormattingTokens.lastIndex = 0;
	        while (i >= 0 && localFormattingTokens.test(format)) {
	            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
	            localFormattingTokens.lastIndex = 0;
	            i -= 1;
	        }

	        return format;
	    }

	    var match1         = /\d/;            //       0 - 9
	    var match2         = /\d\d/;          //      00 - 99
	    var match3         = /\d{3}/;         //     000 - 999
	    var match4         = /\d{4}/;         //    0000 - 9999
	    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
	    var match1to2      = /\d\d?/;         //       0 - 99
	    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
	    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
	    var match1to3      = /\d{1,3}/;       //       0 - 999
	    var match1to4      = /\d{1,4}/;       //       0 - 9999
	    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

	    var matchUnsigned  = /\d+/;           //       0 - inf
	    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

	    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
	    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

	    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

	    // any word (or two) characters or numbers including two/three word month in arabic.
	    // includes scottish gaelic two word and hyphenated months
	    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


	    var regexes = {};

	    function addRegexToken (token, regex, strictRegex) {
	        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
	            return (isStrict && strictRegex) ? strictRegex : regex;
	        };
	    }

	    function getParseRegexForToken (token, config) {
	        if (!hasOwnProp(regexes, token)) {
	            return new RegExp(unescapeFormat(token));
	        }

	        return regexes[token](config._strict, config._locale);
	    }

	    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
	    function unescapeFormat(s) {
	        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
	            return p1 || p2 || p3 || p4;
	        }));
	    }

	    function regexEscape(s) {
	        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
	    }

	    var tokens = {};

	    function addParseToken (token, callback) {
	        var i, func = callback;
	        if (typeof token === 'string') {
	            token = [token];
	        }
	        if (typeof callback === 'number') {
	            func = function (input, array) {
	                array[callback] = toInt(input);
	            };
	        }
	        for (i = 0; i < token.length; i++) {
	            tokens[token[i]] = func;
	        }
	    }

	    function addWeekParseToken (token, callback) {
	        addParseToken(token, function (input, array, config, token) {
	            config._w = config._w || {};
	            callback(input, config._w, config, token);
	        });
	    }

	    function addTimeToArrayFromToken(token, input, config) {
	        if (input != null && hasOwnProp(tokens, token)) {
	            tokens[token](input, config._a, config, token);
	        }
	    }

	    var YEAR = 0;
	    var MONTH = 1;
	    var DATE = 2;
	    var HOUR = 3;
	    var MINUTE = 4;
	    var SECOND = 5;
	    var MILLISECOND = 6;
	    var WEEK = 7;
	    var WEEKDAY = 8;

	    var indexOf;

	    if (Array.prototype.indexOf) {
	        indexOf = Array.prototype.indexOf;
	    } else {
	        indexOf = function (o) {
	            // I know
	            var i;
	            for (i = 0; i < this.length; ++i) {
	                if (this[i] === o) {
	                    return i;
	                }
	            }
	            return -1;
	        };
	    }

	    function daysInMonth(year, month) {
	        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
	    }

	    // FORMATTING

	    addFormatToken('M', ['MM', 2], 'Mo', function () {
	        return this.month() + 1;
	    });

	    addFormatToken('MMM', 0, 0, function (format) {
	        return this.localeData().monthsShort(this, format);
	    });

	    addFormatToken('MMMM', 0, 0, function (format) {
	        return this.localeData().months(this, format);
	    });

	    // ALIASES

	    addUnitAlias('month', 'M');

	    // PRIORITY

	    addUnitPriority('month', 8);

	    // PARSING

	    addRegexToken('M',    match1to2);
	    addRegexToken('MM',   match1to2, match2);
	    addRegexToken('MMM',  function (isStrict, locale) {
	        return locale.monthsShortRegex(isStrict);
	    });
	    addRegexToken('MMMM', function (isStrict, locale) {
	        return locale.monthsRegex(isStrict);
	    });

	    addParseToken(['M', 'MM'], function (input, array) {
	        array[MONTH] = toInt(input) - 1;
	    });

	    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
	        var month = config._locale.monthsParse(input, token, config._strict);
	        // if we didn't find a month name, mark the date as invalid.
	        if (month != null) {
	            array[MONTH] = month;
	        } else {
	            getParsingFlags(config).invalidMonth = input;
	        }
	    });

	    // LOCALES

	    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
	    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
	    function localeMonths (m, format) {
	        if (!m) {
	            return this._months;
	        }
	        return isArray(this._months) ? this._months[m.month()] :
	            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
	    }

	    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
	    function localeMonthsShort (m, format) {
	        if (!m) {
	            return this._monthsShort;
	        }
	        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
	            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
	    }

	    function units_month__handleStrictParse(monthName, format, strict) {
	        var i, ii, mom, llc = monthName.toLocaleLowerCase();
	        if (!this._monthsParse) {
	            // this is not used
	            this._monthsParse = [];
	            this._longMonthsParse = [];
	            this._shortMonthsParse = [];
	            for (i = 0; i < 12; ++i) {
	                mom = create_utc__createUTC([2000, i]);
	                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
	                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
	            }
	        }

	        if (strict) {
	            if (format === 'MMM') {
	                ii = indexOf.call(this._shortMonthsParse, llc);
	                return ii !== -1 ? ii : null;
	            } else {
	                ii = indexOf.call(this._longMonthsParse, llc);
	                return ii !== -1 ? ii : null;
	            }
	        } else {
	            if (format === 'MMM') {
	                ii = indexOf.call(this._shortMonthsParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._longMonthsParse, llc);
	                return ii !== -1 ? ii : null;
	            } else {
	                ii = indexOf.call(this._longMonthsParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._shortMonthsParse, llc);
	                return ii !== -1 ? ii : null;
	            }
	        }
	    }

	    function localeMonthsParse (monthName, format, strict) {
	        var i, mom, regex;

	        if (this._monthsParseExact) {
	            return units_month__handleStrictParse.call(this, monthName, format, strict);
	        }

	        if (!this._monthsParse) {
	            this._monthsParse = [];
	            this._longMonthsParse = [];
	            this._shortMonthsParse = [];
	        }

	        // TODO: add sorting
	        // Sorting makes sure if one month (or abbr) is a prefix of another
	        // see sorting in computeMonthsParse
	        for (i = 0; i < 12; i++) {
	            // make the regex if we don't have it already
	            mom = create_utc__createUTC([2000, i]);
	            if (strict && !this._longMonthsParse[i]) {
	                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
	                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
	            }
	            if (!strict && !this._monthsParse[i]) {
	                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
	                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
	            }
	            // test the regex
	            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
	                return i;
	            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
	                return i;
	            } else if (!strict && this._monthsParse[i].test(monthName)) {
	                return i;
	            }
	        }
	    }

	    // MOMENTS

	    function setMonth (mom, value) {
	        var dayOfMonth;

	        if (!mom.isValid()) {
	            // No op
	            return mom;
	        }

	        if (typeof value === 'string') {
	            if (/^\d+$/.test(value)) {
	                value = toInt(value);
	            } else {
	                value = mom.localeData().monthsParse(value);
	                // TODO: Another silent failure?
	                if (typeof value !== 'number') {
	                    return mom;
	                }
	            }
	        }

	        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
	        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
	        return mom;
	    }

	    function getSetMonth (value) {
	        if (value != null) {
	            setMonth(this, value);
	            utils_hooks__hooks.updateOffset(this, true);
	            return this;
	        } else {
	            return get_set__get(this, 'Month');
	        }
	    }

	    function getDaysInMonth () {
	        return daysInMonth(this.year(), this.month());
	    }

	    var defaultMonthsShortRegex = matchWord;
	    function monthsShortRegex (isStrict) {
	        if (this._monthsParseExact) {
	            if (!hasOwnProp(this, '_monthsRegex')) {
	                computeMonthsParse.call(this);
	            }
	            if (isStrict) {
	                return this._monthsShortStrictRegex;
	            } else {
	                return this._monthsShortRegex;
	            }
	        } else {
	            if (!hasOwnProp(this, '_monthsShortRegex')) {
	                this._monthsShortRegex = defaultMonthsShortRegex;
	            }
	            return this._monthsShortStrictRegex && isStrict ?
	                this._monthsShortStrictRegex : this._monthsShortRegex;
	        }
	    }

	    var defaultMonthsRegex = matchWord;
	    function monthsRegex (isStrict) {
	        if (this._monthsParseExact) {
	            if (!hasOwnProp(this, '_monthsRegex')) {
	                computeMonthsParse.call(this);
	            }
	            if (isStrict) {
	                return this._monthsStrictRegex;
	            } else {
	                return this._monthsRegex;
	            }
	        } else {
	            if (!hasOwnProp(this, '_monthsRegex')) {
	                this._monthsRegex = defaultMonthsRegex;
	            }
	            return this._monthsStrictRegex && isStrict ?
	                this._monthsStrictRegex : this._monthsRegex;
	        }
	    }

	    function computeMonthsParse () {
	        function cmpLenRev(a, b) {
	            return b.length - a.length;
	        }

	        var shortPieces = [], longPieces = [], mixedPieces = [],
	            i, mom;
	        for (i = 0; i < 12; i++) {
	            // make the regex if we don't have it already
	            mom = create_utc__createUTC([2000, i]);
	            shortPieces.push(this.monthsShort(mom, ''));
	            longPieces.push(this.months(mom, ''));
	            mixedPieces.push(this.months(mom, ''));
	            mixedPieces.push(this.monthsShort(mom, ''));
	        }
	        // Sorting makes sure if one month (or abbr) is a prefix of another it
	        // will match the longer piece.
	        shortPieces.sort(cmpLenRev);
	        longPieces.sort(cmpLenRev);
	        mixedPieces.sort(cmpLenRev);
	        for (i = 0; i < 12; i++) {
	            shortPieces[i] = regexEscape(shortPieces[i]);
	            longPieces[i] = regexEscape(longPieces[i]);
	        }
	        for (i = 0; i < 24; i++) {
	            mixedPieces[i] = regexEscape(mixedPieces[i]);
	        }

	        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
	        this._monthsShortRegex = this._monthsRegex;
	        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
	        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
	    }

	    // FORMATTING

	    addFormatToken('Y', 0, 0, function () {
	        var y = this.year();
	        return y <= 9999 ? '' + y : '+' + y;
	    });

	    addFormatToken(0, ['YY', 2], 0, function () {
	        return this.year() % 100;
	    });

	    addFormatToken(0, ['YYYY',   4],       0, 'year');
	    addFormatToken(0, ['YYYYY',  5],       0, 'year');
	    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

	    // ALIASES

	    addUnitAlias('year', 'y');

	    // PRIORITIES

	    addUnitPriority('year', 1);

	    // PARSING

	    addRegexToken('Y',      matchSigned);
	    addRegexToken('YY',     match1to2, match2);
	    addRegexToken('YYYY',   match1to4, match4);
	    addRegexToken('YYYYY',  match1to6, match6);
	    addRegexToken('YYYYYY', match1to6, match6);

	    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
	    addParseToken('YYYY', function (input, array) {
	        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
	    });
	    addParseToken('YY', function (input, array) {
	        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
	    });
	    addParseToken('Y', function (input, array) {
	        array[YEAR] = parseInt(input, 10);
	    });

	    // HELPERS

	    function daysInYear(year) {
	        return isLeapYear(year) ? 366 : 365;
	    }

	    function isLeapYear(year) {
	        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
	    }

	    // HOOKS

	    utils_hooks__hooks.parseTwoDigitYear = function (input) {
	        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
	    };

	    // MOMENTS

	    var getSetYear = makeGetSet('FullYear', true);

	    function getIsLeapYear () {
	        return isLeapYear(this.year());
	    }

	    function createDate (y, m, d, h, M, s, ms) {
	        //can't just apply() to create a date:
	        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
	        var date = new Date(y, m, d, h, M, s, ms);

	        //the date constructor remaps years 0-99 to 1900-1999
	        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
	            date.setFullYear(y);
	        }
	        return date;
	    }

	    function createUTCDate (y) {
	        var date = new Date(Date.UTC.apply(null, arguments));

	        //the Date.UTC function remaps years 0-99 to 1900-1999
	        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
	            date.setUTCFullYear(y);
	        }
	        return date;
	    }

	    // start-of-first-week - start-of-year
	    function firstWeekOffset(year, dow, doy) {
	        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
	            fwd = 7 + dow - doy,
	            // first-week day local weekday -- which local weekday is fwd
	            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

	        return -fwdlw + fwd - 1;
	    }

	    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
	    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
	        var localWeekday = (7 + weekday - dow) % 7,
	            weekOffset = firstWeekOffset(year, dow, doy),
	            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
	            resYear, resDayOfYear;

	        if (dayOfYear <= 0) {
	            resYear = year - 1;
	            resDayOfYear = daysInYear(resYear) + dayOfYear;
	        } else if (dayOfYear > daysInYear(year)) {
	            resYear = year + 1;
	            resDayOfYear = dayOfYear - daysInYear(year);
	        } else {
	            resYear = year;
	            resDayOfYear = dayOfYear;
	        }

	        return {
	            year: resYear,
	            dayOfYear: resDayOfYear
	        };
	    }

	    function weekOfYear(mom, dow, doy) {
	        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
	            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
	            resWeek, resYear;

	        if (week < 1) {
	            resYear = mom.year() - 1;
	            resWeek = week + weeksInYear(resYear, dow, doy);
	        } else if (week > weeksInYear(mom.year(), dow, doy)) {
	            resWeek = week - weeksInYear(mom.year(), dow, doy);
	            resYear = mom.year() + 1;
	        } else {
	            resYear = mom.year();
	            resWeek = week;
	        }

	        return {
	            week: resWeek,
	            year: resYear
	        };
	    }

	    function weeksInYear(year, dow, doy) {
	        var weekOffset = firstWeekOffset(year, dow, doy),
	            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
	        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
	    }

	    // FORMATTING

	    addFormatToken('w', ['ww', 2], 'wo', 'week');
	    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

	    // ALIASES

	    addUnitAlias('week', 'w');
	    addUnitAlias('isoWeek', 'W');

	    // PRIORITIES

	    addUnitPriority('week', 5);
	    addUnitPriority('isoWeek', 5);

	    // PARSING

	    addRegexToken('w',  match1to2);
	    addRegexToken('ww', match1to2, match2);
	    addRegexToken('W',  match1to2);
	    addRegexToken('WW', match1to2, match2);

	    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
	        week[token.substr(0, 1)] = toInt(input);
	    });

	    // HELPERS

	    // LOCALES

	    function localeWeek (mom) {
	        return weekOfYear(mom, this._week.dow, this._week.doy).week;
	    }

	    var defaultLocaleWeek = {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    };

	    function localeFirstDayOfWeek () {
	        return this._week.dow;
	    }

	    function localeFirstDayOfYear () {
	        return this._week.doy;
	    }

	    // MOMENTS

	    function getSetWeek (input) {
	        var week = this.localeData().week(this);
	        return input == null ? week : this.add((input - week) * 7, 'd');
	    }

	    function getSetISOWeek (input) {
	        var week = weekOfYear(this, 1, 4).week;
	        return input == null ? week : this.add((input - week) * 7, 'd');
	    }

	    // FORMATTING

	    addFormatToken('d', 0, 'do', 'day');

	    addFormatToken('dd', 0, 0, function (format) {
	        return this.localeData().weekdaysMin(this, format);
	    });

	    addFormatToken('ddd', 0, 0, function (format) {
	        return this.localeData().weekdaysShort(this, format);
	    });

	    addFormatToken('dddd', 0, 0, function (format) {
	        return this.localeData().weekdays(this, format);
	    });

	    addFormatToken('e', 0, 0, 'weekday');
	    addFormatToken('E', 0, 0, 'isoWeekday');

	    // ALIASES

	    addUnitAlias('day', 'd');
	    addUnitAlias('weekday', 'e');
	    addUnitAlias('isoWeekday', 'E');

	    // PRIORITY
	    addUnitPriority('day', 11);
	    addUnitPriority('weekday', 11);
	    addUnitPriority('isoWeekday', 11);

	    // PARSING

	    addRegexToken('d',    match1to2);
	    addRegexToken('e',    match1to2);
	    addRegexToken('E',    match1to2);
	    addRegexToken('dd',   function (isStrict, locale) {
	        return locale.weekdaysMinRegex(isStrict);
	    });
	    addRegexToken('ddd',   function (isStrict, locale) {
	        return locale.weekdaysShortRegex(isStrict);
	    });
	    addRegexToken('dddd',   function (isStrict, locale) {
	        return locale.weekdaysRegex(isStrict);
	    });

	    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
	        var weekday = config._locale.weekdaysParse(input, token, config._strict);
	        // if we didn't get a weekday name, mark the date as invalid
	        if (weekday != null) {
	            week.d = weekday;
	        } else {
	            getParsingFlags(config).invalidWeekday = input;
	        }
	    });

	    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
	        week[token] = toInt(input);
	    });

	    // HELPERS

	    function parseWeekday(input, locale) {
	        if (typeof input !== 'string') {
	            return input;
	        }

	        if (!isNaN(input)) {
	            return parseInt(input, 10);
	        }

	        input = locale.weekdaysParse(input);
	        if (typeof input === 'number') {
	            return input;
	        }

	        return null;
	    }

	    function parseIsoWeekday(input, locale) {
	        if (typeof input === 'string') {
	            return locale.weekdaysParse(input) % 7 || 7;
	        }
	        return isNaN(input) ? null : input;
	    }

	    // LOCALES

	    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
	    function localeWeekdays (m, format) {
	        if (!m) {
	            return this._weekdays;
	        }
	        return isArray(this._weekdays) ? this._weekdays[m.day()] :
	            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
	    }

	    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
	    function localeWeekdaysShort (m) {
	        return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
	    }

	    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
	    function localeWeekdaysMin (m) {
	        return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
	    }

	    function day_of_week__handleStrictParse(weekdayName, format, strict) {
	        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
	        if (!this._weekdaysParse) {
	            this._weekdaysParse = [];
	            this._shortWeekdaysParse = [];
	            this._minWeekdaysParse = [];

	            for (i = 0; i < 7; ++i) {
	                mom = create_utc__createUTC([2000, 1]).day(i);
	                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
	                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
	                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
	            }
	        }

	        if (strict) {
	            if (format === 'dddd') {
	                ii = indexOf.call(this._weekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            } else if (format === 'ddd') {
	                ii = indexOf.call(this._shortWeekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            } else {
	                ii = indexOf.call(this._minWeekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            }
	        } else {
	            if (format === 'dddd') {
	                ii = indexOf.call(this._weekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._shortWeekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._minWeekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            } else if (format === 'ddd') {
	                ii = indexOf.call(this._shortWeekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._weekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._minWeekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            } else {
	                ii = indexOf.call(this._minWeekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._weekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._shortWeekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            }
	        }
	    }

	    function localeWeekdaysParse (weekdayName, format, strict) {
	        var i, mom, regex;

	        if (this._weekdaysParseExact) {
	            return day_of_week__handleStrictParse.call(this, weekdayName, format, strict);
	        }

	        if (!this._weekdaysParse) {
	            this._weekdaysParse = [];
	            this._minWeekdaysParse = [];
	            this._shortWeekdaysParse = [];
	            this._fullWeekdaysParse = [];
	        }

	        for (i = 0; i < 7; i++) {
	            // make the regex if we don't have it already

	            mom = create_utc__createUTC([2000, 1]).day(i);
	            if (strict && !this._fullWeekdaysParse[i]) {
	                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
	                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
	                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
	            }
	            if (!this._weekdaysParse[i]) {
	                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
	                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
	            }
	            // test the regex
	            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
	                return i;
	            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
	                return i;
	            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
	                return i;
	            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
	                return i;
	            }
	        }
	    }

	    // MOMENTS

	    function getSetDayOfWeek (input) {
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }
	        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
	        if (input != null) {
	            input = parseWeekday(input, this.localeData());
	            return this.add(input - day, 'd');
	        } else {
	            return day;
	        }
	    }

	    function getSetLocaleDayOfWeek (input) {
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }
	        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
	        return input == null ? weekday : this.add(input - weekday, 'd');
	    }

	    function getSetISODayOfWeek (input) {
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }

	        // behaves the same as moment#day except
	        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
	        // as a setter, sunday should belong to the previous week.

	        if (input != null) {
	            var weekday = parseIsoWeekday(input, this.localeData());
	            return this.day(this.day() % 7 ? weekday : weekday - 7);
	        } else {
	            return this.day() || 7;
	        }
	    }

	    var defaultWeekdaysRegex = matchWord;
	    function weekdaysRegex (isStrict) {
	        if (this._weekdaysParseExact) {
	            if (!hasOwnProp(this, '_weekdaysRegex')) {
	                computeWeekdaysParse.call(this);
	            }
	            if (isStrict) {
	                return this._weekdaysStrictRegex;
	            } else {
	                return this._weekdaysRegex;
	            }
	        } else {
	            if (!hasOwnProp(this, '_weekdaysRegex')) {
	                this._weekdaysRegex = defaultWeekdaysRegex;
	            }
	            return this._weekdaysStrictRegex && isStrict ?
	                this._weekdaysStrictRegex : this._weekdaysRegex;
	        }
	    }

	    var defaultWeekdaysShortRegex = matchWord;
	    function weekdaysShortRegex (isStrict) {
	        if (this._weekdaysParseExact) {
	            if (!hasOwnProp(this, '_weekdaysRegex')) {
	                computeWeekdaysParse.call(this);
	            }
	            if (isStrict) {
	                return this._weekdaysShortStrictRegex;
	            } else {
	                return this._weekdaysShortRegex;
	            }
	        } else {
	            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
	                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
	            }
	            return this._weekdaysShortStrictRegex && isStrict ?
	                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
	        }
	    }

	    var defaultWeekdaysMinRegex = matchWord;
	    function weekdaysMinRegex (isStrict) {
	        if (this._weekdaysParseExact) {
	            if (!hasOwnProp(this, '_weekdaysRegex')) {
	                computeWeekdaysParse.call(this);
	            }
	            if (isStrict) {
	                return this._weekdaysMinStrictRegex;
	            } else {
	                return this._weekdaysMinRegex;
	            }
	        } else {
	            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
	                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
	            }
	            return this._weekdaysMinStrictRegex && isStrict ?
	                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
	        }
	    }


	    function computeWeekdaysParse () {
	        function cmpLenRev(a, b) {
	            return b.length - a.length;
	        }

	        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
	            i, mom, minp, shortp, longp;
	        for (i = 0; i < 7; i++) {
	            // make the regex if we don't have it already
	            mom = create_utc__createUTC([2000, 1]).day(i);
	            minp = this.weekdaysMin(mom, '');
	            shortp = this.weekdaysShort(mom, '');
	            longp = this.weekdays(mom, '');
	            minPieces.push(minp);
	            shortPieces.push(shortp);
	            longPieces.push(longp);
	            mixedPieces.push(minp);
	            mixedPieces.push(shortp);
	            mixedPieces.push(longp);
	        }
	        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
	        // will match the longer piece.
	        minPieces.sort(cmpLenRev);
	        shortPieces.sort(cmpLenRev);
	        longPieces.sort(cmpLenRev);
	        mixedPieces.sort(cmpLenRev);
	        for (i = 0; i < 7; i++) {
	            shortPieces[i] = regexEscape(shortPieces[i]);
	            longPieces[i] = regexEscape(longPieces[i]);
	            mixedPieces[i] = regexEscape(mixedPieces[i]);
	        }

	        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
	        this._weekdaysShortRegex = this._weekdaysRegex;
	        this._weekdaysMinRegex = this._weekdaysRegex;

	        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
	        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
	        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
	    }

	    // FORMATTING

	    function hFormat() {
	        return this.hours() % 12 || 12;
	    }

	    function kFormat() {
	        return this.hours() || 24;
	    }

	    addFormatToken('H', ['HH', 2], 0, 'hour');
	    addFormatToken('h', ['hh', 2], 0, hFormat);
	    addFormatToken('k', ['kk', 2], 0, kFormat);

	    addFormatToken('hmm', 0, 0, function () {
	        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
	    });

	    addFormatToken('hmmss', 0, 0, function () {
	        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
	            zeroFill(this.seconds(), 2);
	    });

	    addFormatToken('Hmm', 0, 0, function () {
	        return '' + this.hours() + zeroFill(this.minutes(), 2);
	    });

	    addFormatToken('Hmmss', 0, 0, function () {
	        return '' + this.hours() + zeroFill(this.minutes(), 2) +
	            zeroFill(this.seconds(), 2);
	    });

	    function meridiem (token, lowercase) {
	        addFormatToken(token, 0, 0, function () {
	            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
	        });
	    }

	    meridiem('a', true);
	    meridiem('A', false);

	    // ALIASES

	    addUnitAlias('hour', 'h');

	    // PRIORITY
	    addUnitPriority('hour', 13);

	    // PARSING

	    function matchMeridiem (isStrict, locale) {
	        return locale._meridiemParse;
	    }

	    addRegexToken('a',  matchMeridiem);
	    addRegexToken('A',  matchMeridiem);
	    addRegexToken('H',  match1to2);
	    addRegexToken('h',  match1to2);
	    addRegexToken('HH', match1to2, match2);
	    addRegexToken('hh', match1to2, match2);

	    addRegexToken('hmm', match3to4);
	    addRegexToken('hmmss', match5to6);
	    addRegexToken('Hmm', match3to4);
	    addRegexToken('Hmmss', match5to6);

	    addParseToken(['H', 'HH'], HOUR);
	    addParseToken(['a', 'A'], function (input, array, config) {
	        config._isPm = config._locale.isPM(input);
	        config._meridiem = input;
	    });
	    addParseToken(['h', 'hh'], function (input, array, config) {
	        array[HOUR] = toInt(input);
	        getParsingFlags(config).bigHour = true;
	    });
	    addParseToken('hmm', function (input, array, config) {
	        var pos = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos));
	        array[MINUTE] = toInt(input.substr(pos));
	        getParsingFlags(config).bigHour = true;
	    });
	    addParseToken('hmmss', function (input, array, config) {
	        var pos1 = input.length - 4;
	        var pos2 = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos1));
	        array[MINUTE] = toInt(input.substr(pos1, 2));
	        array[SECOND] = toInt(input.substr(pos2));
	        getParsingFlags(config).bigHour = true;
	    });
	    addParseToken('Hmm', function (input, array, config) {
	        var pos = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos));
	        array[MINUTE] = toInt(input.substr(pos));
	    });
	    addParseToken('Hmmss', function (input, array, config) {
	        var pos1 = input.length - 4;
	        var pos2 = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos1));
	        array[MINUTE] = toInt(input.substr(pos1, 2));
	        array[SECOND] = toInt(input.substr(pos2));
	    });

	    // LOCALES

	    function localeIsPM (input) {
	        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
	        // Using charAt should be more compatible.
	        return ((input + '').toLowerCase().charAt(0) === 'p');
	    }

	    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
	    function localeMeridiem (hours, minutes, isLower) {
	        if (hours > 11) {
	            return isLower ? 'pm' : 'PM';
	        } else {
	            return isLower ? 'am' : 'AM';
	        }
	    }


	    // MOMENTS

	    // Setting the hour should keep the time, because the user explicitly
	    // specified which hour he wants. So trying to maintain the same hour (in
	    // a new timezone) makes sense. Adding/subtracting hours does not follow
	    // this rule.
	    var getSetHour = makeGetSet('Hours', true);

	    var baseConfig = {
	        calendar: defaultCalendar,
	        longDateFormat: defaultLongDateFormat,
	        invalidDate: defaultInvalidDate,
	        ordinal: defaultOrdinal,
	        ordinalParse: defaultOrdinalParse,
	        relativeTime: defaultRelativeTime,

	        months: defaultLocaleMonths,
	        monthsShort: defaultLocaleMonthsShort,

	        week: defaultLocaleWeek,

	        weekdays: defaultLocaleWeekdays,
	        weekdaysMin: defaultLocaleWeekdaysMin,
	        weekdaysShort: defaultLocaleWeekdaysShort,

	        meridiemParse: defaultLocaleMeridiemParse
	    };

	    // internal storage for locale config files
	    var locales = {};
	    var globalLocale;

	    function normalizeLocale(key) {
	        return key ? key.toLowerCase().replace('_', '-') : key;
	    }

	    // pick the locale from the array
	    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
	    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
	    function chooseLocale(names) {
	        var i = 0, j, next, locale, split;

	        while (i < names.length) {
	            split = normalizeLocale(names[i]).split('-');
	            j = split.length;
	            next = normalizeLocale(names[i + 1]);
	            next = next ? next.split('-') : null;
	            while (j > 0) {
	                locale = loadLocale(split.slice(0, j).join('-'));
	                if (locale) {
	                    return locale;
	                }
	                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
	                    //the next array item is better than a shallower substring of this one
	                    break;
	                }
	                j--;
	            }
	            i++;
	        }
	        return null;
	    }

	    function loadLocale(name) {
	        var oldLocale = null;
	        // TODO: Find a better way to register and load all the locales in Node
	        if (!locales[name] && (typeof module !== 'undefined') &&
	                module && module.exports) {
	            try {
	                oldLocale = globalLocale._abbr;
	                __webpack_require__(/*! ./locale */ 210)("./" + name);
	                // because defineLocale currently also sets the global locale, we
	                // want to undo that for lazy loaded locales
	                locale_locales__getSetGlobalLocale(oldLocale);
	            } catch (e) { }
	        }
	        return locales[name];
	    }

	    // This function will load locale and then set the global locale.  If
	    // no arguments are passed in, it will simply return the current global
	    // locale key.
	    function locale_locales__getSetGlobalLocale (key, values) {
	        var data;
	        if (key) {
	            if (isUndefined(values)) {
	                data = locale_locales__getLocale(key);
	            }
	            else {
	                data = defineLocale(key, values);
	            }

	            if (data) {
	                // moment.duration._locale = moment._locale = data;
	                globalLocale = data;
	            }
	        }

	        return globalLocale._abbr;
	    }

	    function defineLocale (name, config) {
	        if (config !== null) {
	            var parentConfig = baseConfig;
	            config.abbr = name;
	            if (locales[name] != null) {
	                deprecateSimple('defineLocaleOverride',
	                        'use moment.updateLocale(localeName, config) to change ' +
	                        'an existing locale. moment.defineLocale(localeName, ' +
	                        'config) should only be used for creating a new locale ' +
	                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
	                parentConfig = locales[name]._config;
	            } else if (config.parentLocale != null) {
	                if (locales[config.parentLocale] != null) {
	                    parentConfig = locales[config.parentLocale]._config;
	                } else {
	                    // treat as if there is no base config
	                    deprecateSimple('parentLocaleUndefined',
	                            'specified parentLocale is not defined yet. See http://momentjs.com/guides/#/warnings/parent-locale/');
	                }
	            }
	            locales[name] = new Locale(mergeConfigs(parentConfig, config));

	            // backwards compat for now: also set the locale
	            locale_locales__getSetGlobalLocale(name);

	            return locales[name];
	        } else {
	            // useful for testing
	            delete locales[name];
	            return null;
	        }
	    }

	    function updateLocale(name, config) {
	        if (config != null) {
	            var locale, parentConfig = baseConfig;
	            // MERGE
	            if (locales[name] != null) {
	                parentConfig = locales[name]._config;
	            }
	            config = mergeConfigs(parentConfig, config);
	            locale = new Locale(config);
	            locale.parentLocale = locales[name];
	            locales[name] = locale;

	            // backwards compat for now: also set the locale
	            locale_locales__getSetGlobalLocale(name);
	        } else {
	            // pass null for config to unupdate, useful for tests
	            if (locales[name] != null) {
	                if (locales[name].parentLocale != null) {
	                    locales[name] = locales[name].parentLocale;
	                } else if (locales[name] != null) {
	                    delete locales[name];
	                }
	            }
	        }
	        return locales[name];
	    }

	    // returns locale data
	    function locale_locales__getLocale (key) {
	        var locale;

	        if (key && key._locale && key._locale._abbr) {
	            key = key._locale._abbr;
	        }

	        if (!key) {
	            return globalLocale;
	        }

	        if (!isArray(key)) {
	            //short-circuit everything else
	            locale = loadLocale(key);
	            if (locale) {
	                return locale;
	            }
	            key = [key];
	        }

	        return chooseLocale(key);
	    }

	    function locale_locales__listLocales() {
	        return keys(locales);
	    }

	    function checkOverflow (m) {
	        var overflow;
	        var a = m._a;

	        if (a && getParsingFlags(m).overflow === -2) {
	            overflow =
	                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
	                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
	                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
	                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
	                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
	                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
	                -1;

	            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
	                overflow = DATE;
	            }
	            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
	                overflow = WEEK;
	            }
	            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
	                overflow = WEEKDAY;
	            }

	            getParsingFlags(m).overflow = overflow;
	        }

	        return m;
	    }

	    // iso 8601 regex
	    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
	    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
	    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;

	    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

	    var isoDates = [
	        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
	        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
	        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
	        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
	        ['YYYY-DDD', /\d{4}-\d{3}/],
	        ['YYYY-MM', /\d{4}-\d\d/, false],
	        ['YYYYYYMMDD', /[+-]\d{10}/],
	        ['YYYYMMDD', /\d{8}/],
	        // YYYYMM is NOT allowed by the standard
	        ['GGGG[W]WWE', /\d{4}W\d{3}/],
	        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
	        ['YYYYDDD', /\d{7}/]
	    ];

	    // iso time formats and regexes
	    var isoTimes = [
	        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
	        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
	        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
	        ['HH:mm', /\d\d:\d\d/],
	        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
	        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
	        ['HHmmss', /\d\d\d\d\d\d/],
	        ['HHmm', /\d\d\d\d/],
	        ['HH', /\d\d/]
	    ];

	    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

	    // date from iso format
	    function configFromISO(config) {
	        var i, l,
	            string = config._i,
	            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
	            allowTime, dateFormat, timeFormat, tzFormat;

	        if (match) {
	            getParsingFlags(config).iso = true;

	            for (i = 0, l = isoDates.length; i < l; i++) {
	                if (isoDates[i][1].exec(match[1])) {
	                    dateFormat = isoDates[i][0];
	                    allowTime = isoDates[i][2] !== false;
	                    break;
	                }
	            }
	            if (dateFormat == null) {
	                config._isValid = false;
	                return;
	            }
	            if (match[3]) {
	                for (i = 0, l = isoTimes.length; i < l; i++) {
	                    if (isoTimes[i][1].exec(match[3])) {
	                        // match[2] should be 'T' or space
	                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
	                        break;
	                    }
	                }
	                if (timeFormat == null) {
	                    config._isValid = false;
	                    return;
	                }
	            }
	            if (!allowTime && timeFormat != null) {
	                config._isValid = false;
	                return;
	            }
	            if (match[4]) {
	                if (tzRegex.exec(match[4])) {
	                    tzFormat = 'Z';
	                } else {
	                    config._isValid = false;
	                    return;
	                }
	            }
	            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
	            configFromStringAndFormat(config);
	        } else {
	            config._isValid = false;
	        }
	    }

	    // date from iso format or fallback
	    function configFromString(config) {
	        var matched = aspNetJsonRegex.exec(config._i);

	        if (matched !== null) {
	            config._d = new Date(+matched[1]);
	            return;
	        }

	        configFromISO(config);
	        if (config._isValid === false) {
	            delete config._isValid;
	            utils_hooks__hooks.createFromInputFallback(config);
	        }
	    }

	    utils_hooks__hooks.createFromInputFallback = deprecate(
	        'value provided is not in a recognized ISO format. moment construction falls back to js Date(), ' +
	        'which is not reliable across all browsers and versions. Non ISO date formats are ' +
	        'discouraged and will be removed in an upcoming major release. Please refer to ' +
	        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
	        function (config) {
	            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
	        }
	    );

	    // Pick the first defined of two or three arguments.
	    function defaults(a, b, c) {
	        if (a != null) {
	            return a;
	        }
	        if (b != null) {
	            return b;
	        }
	        return c;
	    }

	    function currentDateArray(config) {
	        // hooks is actually the exported moment object
	        var nowValue = new Date(utils_hooks__hooks.now());
	        if (config._useUTC) {
	            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
	        }
	        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
	    }

	    // convert an array to a date.
	    // the array should mirror the parameters below
	    // note: all values past the year are optional and will default to the lowest possible value.
	    // [year, month, day , hour, minute, second, millisecond]
	    function configFromArray (config) {
	        var i, date, input = [], currentDate, yearToUse;

	        if (config._d) {
	            return;
	        }

	        currentDate = currentDateArray(config);

	        //compute day of the year from weeks and weekdays
	        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
	            dayOfYearFromWeekInfo(config);
	        }

	        //if the day of the year is set, figure out what it is
	        if (config._dayOfYear) {
	            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

	            if (config._dayOfYear > daysInYear(yearToUse)) {
	                getParsingFlags(config)._overflowDayOfYear = true;
	            }

	            date = createUTCDate(yearToUse, 0, config._dayOfYear);
	            config._a[MONTH] = date.getUTCMonth();
	            config._a[DATE] = date.getUTCDate();
	        }

	        // Default to current date.
	        // * if no year, month, day of month are given, default to today
	        // * if day of month is given, default month and year
	        // * if month is given, default only year
	        // * if year is given, don't default anything
	        for (i = 0; i < 3 && config._a[i] == null; ++i) {
	            config._a[i] = input[i] = currentDate[i];
	        }

	        // Zero out whatever was not defaulted, including time
	        for (; i < 7; i++) {
	            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
	        }

	        // Check for 24:00:00.000
	        if (config._a[HOUR] === 24 &&
	                config._a[MINUTE] === 0 &&
	                config._a[SECOND] === 0 &&
	                config._a[MILLISECOND] === 0) {
	            config._nextDay = true;
	            config._a[HOUR] = 0;
	        }

	        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
	        // Apply timezone offset from input. The actual utcOffset can be changed
	        // with parseZone.
	        if (config._tzm != null) {
	            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
	        }

	        if (config._nextDay) {
	            config._a[HOUR] = 24;
	        }
	    }

	    function dayOfYearFromWeekInfo(config) {
	        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

	        w = config._w;
	        if (w.GG != null || w.W != null || w.E != null) {
	            dow = 1;
	            doy = 4;

	            // TODO: We need to take the current isoWeekYear, but that depends on
	            // how we interpret now (local, utc, fixed offset). So create
	            // a now version of current config (take local/utc/offset flags, and
	            // create now).
	            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
	            week = defaults(w.W, 1);
	            weekday = defaults(w.E, 1);
	            if (weekday < 1 || weekday > 7) {
	                weekdayOverflow = true;
	            }
	        } else {
	            dow = config._locale._week.dow;
	            doy = config._locale._week.doy;

	            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
	            week = defaults(w.w, 1);

	            if (w.d != null) {
	                // weekday -- low day numbers are considered next week
	                weekday = w.d;
	                if (weekday < 0 || weekday > 6) {
	                    weekdayOverflow = true;
	                }
	            } else if (w.e != null) {
	                // local weekday -- counting starts from begining of week
	                weekday = w.e + dow;
	                if (w.e < 0 || w.e > 6) {
	                    weekdayOverflow = true;
	                }
	            } else {
	                // default to begining of week
	                weekday = dow;
	            }
	        }
	        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
	            getParsingFlags(config)._overflowWeeks = true;
	        } else if (weekdayOverflow != null) {
	            getParsingFlags(config)._overflowWeekday = true;
	        } else {
	            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
	            config._a[YEAR] = temp.year;
	            config._dayOfYear = temp.dayOfYear;
	        }
	    }

	    // constant that refers to the ISO standard
	    utils_hooks__hooks.ISO_8601 = function () {};

	    // date from string and format string
	    function configFromStringAndFormat(config) {
	        // TODO: Move this to another part of the creation flow to prevent circular deps
	        if (config._f === utils_hooks__hooks.ISO_8601) {
	            configFromISO(config);
	            return;
	        }

	        config._a = [];
	        getParsingFlags(config).empty = true;

	        // This array is used to make a Date, either with `new Date` or `Date.UTC`
	        var string = '' + config._i,
	            i, parsedInput, tokens, token, skipped,
	            stringLength = string.length,
	            totalParsedInputLength = 0;

	        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

	        for (i = 0; i < tokens.length; i++) {
	            token = tokens[i];
	            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
	            // console.log('token', token, 'parsedInput', parsedInput,
	            //         'regex', getParseRegexForToken(token, config));
	            if (parsedInput) {
	                skipped = string.substr(0, string.indexOf(parsedInput));
	                if (skipped.length > 0) {
	                    getParsingFlags(config).unusedInput.push(skipped);
	                }
	                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
	                totalParsedInputLength += parsedInput.length;
	            }
	            // don't parse if it's not a known token
	            if (formatTokenFunctions[token]) {
	                if (parsedInput) {
	                    getParsingFlags(config).empty = false;
	                }
	                else {
	                    getParsingFlags(config).unusedTokens.push(token);
	                }
	                addTimeToArrayFromToken(token, parsedInput, config);
	            }
	            else if (config._strict && !parsedInput) {
	                getParsingFlags(config).unusedTokens.push(token);
	            }
	        }

	        // add remaining unparsed input length to the string
	        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
	        if (string.length > 0) {
	            getParsingFlags(config).unusedInput.push(string);
	        }

	        // clear _12h flag if hour is <= 12
	        if (config._a[HOUR] <= 12 &&
	            getParsingFlags(config).bigHour === true &&
	            config._a[HOUR] > 0) {
	            getParsingFlags(config).bigHour = undefined;
	        }

	        getParsingFlags(config).parsedDateParts = config._a.slice(0);
	        getParsingFlags(config).meridiem = config._meridiem;
	        // handle meridiem
	        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

	        configFromArray(config);
	        checkOverflow(config);
	    }


	    function meridiemFixWrap (locale, hour, meridiem) {
	        var isPm;

	        if (meridiem == null) {
	            // nothing to do
	            return hour;
	        }
	        if (locale.meridiemHour != null) {
	            return locale.meridiemHour(hour, meridiem);
	        } else if (locale.isPM != null) {
	            // Fallback
	            isPm = locale.isPM(meridiem);
	            if (isPm && hour < 12) {
	                hour += 12;
	            }
	            if (!isPm && hour === 12) {
	                hour = 0;
	            }
	            return hour;
	        } else {
	            // this is not supposed to happen
	            return hour;
	        }
	    }

	    // date from string and array of format strings
	    function configFromStringAndArray(config) {
	        var tempConfig,
	            bestMoment,

	            scoreToBeat,
	            i,
	            currentScore;

	        if (config._f.length === 0) {
	            getParsingFlags(config).invalidFormat = true;
	            config._d = new Date(NaN);
	            return;
	        }

	        for (i = 0; i < config._f.length; i++) {
	            currentScore = 0;
	            tempConfig = copyConfig({}, config);
	            if (config._useUTC != null) {
	                tempConfig._useUTC = config._useUTC;
	            }
	            tempConfig._f = config._f[i];
	            configFromStringAndFormat(tempConfig);

	            if (!valid__isValid(tempConfig)) {
	                continue;
	            }

	            // if there is any input that was not parsed add a penalty for that format
	            currentScore += getParsingFlags(tempConfig).charsLeftOver;

	            //or tokens
	            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

	            getParsingFlags(tempConfig).score = currentScore;

	            if (scoreToBeat == null || currentScore < scoreToBeat) {
	                scoreToBeat = currentScore;
	                bestMoment = tempConfig;
	            }
	        }

	        extend(config, bestMoment || tempConfig);
	    }

	    function configFromObject(config) {
	        if (config._d) {
	            return;
	        }

	        var i = normalizeObjectUnits(config._i);
	        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
	            return obj && parseInt(obj, 10);
	        });

	        configFromArray(config);
	    }

	    function createFromConfig (config) {
	        var res = new Moment(checkOverflow(prepareConfig(config)));
	        if (res._nextDay) {
	            // Adding is smart enough around DST
	            res.add(1, 'd');
	            res._nextDay = undefined;
	        }

	        return res;
	    }

	    function prepareConfig (config) {
	        var input = config._i,
	            format = config._f;

	        config._locale = config._locale || locale_locales__getLocale(config._l);

	        if (input === null || (format === undefined && input === '')) {
	            return valid__createInvalid({nullInput: true});
	        }

	        if (typeof input === 'string') {
	            config._i = input = config._locale.preparse(input);
	        }

	        if (isMoment(input)) {
	            return new Moment(checkOverflow(input));
	        } else if (isArray(format)) {
	            configFromStringAndArray(config);
	        } else if (isDate(input)) {
	            config._d = input;
	        } else if (format) {
	            configFromStringAndFormat(config);
	        }  else {
	            configFromInput(config);
	        }

	        if (!valid__isValid(config)) {
	            config._d = null;
	        }

	        return config;
	    }

	    function configFromInput(config) {
	        var input = config._i;
	        if (input === undefined) {
	            config._d = new Date(utils_hooks__hooks.now());
	        } else if (isDate(input)) {
	            config._d = new Date(input.valueOf());
	        } else if (typeof input === 'string') {
	            configFromString(config);
	        } else if (isArray(input)) {
	            config._a = map(input.slice(0), function (obj) {
	                return parseInt(obj, 10);
	            });
	            configFromArray(config);
	        } else if (typeof(input) === 'object') {
	            configFromObject(config);
	        } else if (typeof(input) === 'number') {
	            // from milliseconds
	            config._d = new Date(input);
	        } else {
	            utils_hooks__hooks.createFromInputFallback(config);
	        }
	    }

	    function createLocalOrUTC (input, format, locale, strict, isUTC) {
	        var c = {};

	        if (typeof(locale) === 'boolean') {
	            strict = locale;
	            locale = undefined;
	        }

	        if ((isObject(input) && isObjectEmpty(input)) ||
	                (isArray(input) && input.length === 0)) {
	            input = undefined;
	        }
	        // object construction must be done this way.
	        // https://github.com/moment/moment/issues/1423
	        c._isAMomentObject = true;
	        c._useUTC = c._isUTC = isUTC;
	        c._l = locale;
	        c._i = input;
	        c._f = format;
	        c._strict = strict;

	        return createFromConfig(c);
	    }

	    function local__createLocal (input, format, locale, strict) {
	        return createLocalOrUTC(input, format, locale, strict, false);
	    }

	    var prototypeMin = deprecate(
	        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
	        function () {
	            var other = local__createLocal.apply(null, arguments);
	            if (this.isValid() && other.isValid()) {
	                return other < this ? this : other;
	            } else {
	                return valid__createInvalid();
	            }
	        }
	    );

	    var prototypeMax = deprecate(
	        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
	        function () {
	            var other = local__createLocal.apply(null, arguments);
	            if (this.isValid() && other.isValid()) {
	                return other > this ? this : other;
	            } else {
	                return valid__createInvalid();
	            }
	        }
	    );

	    // Pick a moment m from moments so that m[fn](other) is true for all
	    // other. This relies on the function fn to be transitive.
	    //
	    // moments should either be an array of moment objects or an array, whose
	    // first element is an array of moment objects.
	    function pickBy(fn, moments) {
	        var res, i;
	        if (moments.length === 1 && isArray(moments[0])) {
	            moments = moments[0];
	        }
	        if (!moments.length) {
	            return local__createLocal();
	        }
	        res = moments[0];
	        for (i = 1; i < moments.length; ++i) {
	            if (!moments[i].isValid() || moments[i][fn](res)) {
	                res = moments[i];
	            }
	        }
	        return res;
	    }

	    // TODO: Use [].sort instead?
	    function min () {
	        var args = [].slice.call(arguments, 0);

	        return pickBy('isBefore', args);
	    }

	    function max () {
	        var args = [].slice.call(arguments, 0);

	        return pickBy('isAfter', args);
	    }

	    var now = function () {
	        return Date.now ? Date.now() : +(new Date());
	    };

	    function Duration (duration) {
	        var normalizedInput = normalizeObjectUnits(duration),
	            years = normalizedInput.year || 0,
	            quarters = normalizedInput.quarter || 0,
	            months = normalizedInput.month || 0,
	            weeks = normalizedInput.week || 0,
	            days = normalizedInput.day || 0,
	            hours = normalizedInput.hour || 0,
	            minutes = normalizedInput.minute || 0,
	            seconds = normalizedInput.second || 0,
	            milliseconds = normalizedInput.millisecond || 0;

	        // representation for dateAddRemove
	        this._milliseconds = +milliseconds +
	            seconds * 1e3 + // 1000
	            minutes * 6e4 + // 1000 * 60
	            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
	        // Because of dateAddRemove treats 24 hours as different from a
	        // day when working around DST, we need to store them separately
	        this._days = +days +
	            weeks * 7;
	        // It is impossible translate months into days without knowing
	        // which months you are are talking about, so we have to store
	        // it separately.
	        this._months = +months +
	            quarters * 3 +
	            years * 12;

	        this._data = {};

	        this._locale = locale_locales__getLocale();

	        this._bubble();
	    }

	    function isDuration (obj) {
	        return obj instanceof Duration;
	    }

	    function absRound (number) {
	        if (number < 0) {
	            return Math.round(-1 * number) * -1;
	        } else {
	            return Math.round(number);
	        }
	    }

	    // FORMATTING

	    function offset (token, separator) {
	        addFormatToken(token, 0, 0, function () {
	            var offset = this.utcOffset();
	            var sign = '+';
	            if (offset < 0) {
	                offset = -offset;
	                sign = '-';
	            }
	            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
	        });
	    }

	    offset('Z', ':');
	    offset('ZZ', '');

	    // PARSING

	    addRegexToken('Z',  matchShortOffset);
	    addRegexToken('ZZ', matchShortOffset);
	    addParseToken(['Z', 'ZZ'], function (input, array, config) {
	        config._useUTC = true;
	        config._tzm = offsetFromString(matchShortOffset, input);
	    });

	    // HELPERS

	    // timezone chunker
	    // '+10:00' > ['10',  '00']
	    // '-1530'  > ['-15', '30']
	    var chunkOffset = /([\+\-]|\d\d)/gi;

	    function offsetFromString(matcher, string) {
	        var matches = ((string || '').match(matcher) || []);
	        var chunk   = matches[matches.length - 1] || [];
	        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
	        var minutes = +(parts[1] * 60) + toInt(parts[2]);

	        return parts[0] === '+' ? minutes : -minutes;
	    }

	    // Return a moment from input, that is local/utc/zone equivalent to model.
	    function cloneWithOffset(input, model) {
	        var res, diff;
	        if (model._isUTC) {
	            res = model.clone();
	            diff = (isMoment(input) || isDate(input) ? input.valueOf() : local__createLocal(input).valueOf()) - res.valueOf();
	            // Use low-level api, because this fn is low-level api.
	            res._d.setTime(res._d.valueOf() + diff);
	            utils_hooks__hooks.updateOffset(res, false);
	            return res;
	        } else {
	            return local__createLocal(input).local();
	        }
	    }

	    function getDateOffset (m) {
	        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
	        // https://github.com/moment/moment/pull/1871
	        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
	    }

	    // HOOKS

	    // This function will be called whenever a moment is mutated.
	    // It is intended to keep the offset in sync with the timezone.
	    utils_hooks__hooks.updateOffset = function () {};

	    // MOMENTS

	    // keepLocalTime = true means only change the timezone, without
	    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
	    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
	    // +0200, so we adjust the time as needed, to be valid.
	    //
	    // Keeping the time actually adds/subtracts (one hour)
	    // from the actual represented time. That is why we call updateOffset
	    // a second time. In case it wants us to change the offset again
	    // _changeInProgress == true case, then we have to adjust, because
	    // there is no such time in the given timezone.
	    function getSetOffset (input, keepLocalTime) {
	        var offset = this._offset || 0,
	            localAdjust;
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }
	        if (input != null) {
	            if (typeof input === 'string') {
	                input = offsetFromString(matchShortOffset, input);
	            } else if (Math.abs(input) < 16) {
	                input = input * 60;
	            }
	            if (!this._isUTC && keepLocalTime) {
	                localAdjust = getDateOffset(this);
	            }
	            this._offset = input;
	            this._isUTC = true;
	            if (localAdjust != null) {
	                this.add(localAdjust, 'm');
	            }
	            if (offset !== input) {
	                if (!keepLocalTime || this._changeInProgress) {
	                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
	                } else if (!this._changeInProgress) {
	                    this._changeInProgress = true;
	                    utils_hooks__hooks.updateOffset(this, true);
	                    this._changeInProgress = null;
	                }
	            }
	            return this;
	        } else {
	            return this._isUTC ? offset : getDateOffset(this);
	        }
	    }

	    function getSetZone (input, keepLocalTime) {
	        if (input != null) {
	            if (typeof input !== 'string') {
	                input = -input;
	            }

	            this.utcOffset(input, keepLocalTime);

	            return this;
	        } else {
	            return -this.utcOffset();
	        }
	    }

	    function setOffsetToUTC (keepLocalTime) {
	        return this.utcOffset(0, keepLocalTime);
	    }

	    function setOffsetToLocal (keepLocalTime) {
	        if (this._isUTC) {
	            this.utcOffset(0, keepLocalTime);
	            this._isUTC = false;

	            if (keepLocalTime) {
	                this.subtract(getDateOffset(this), 'm');
	            }
	        }
	        return this;
	    }

	    function setOffsetToParsedOffset () {
	        if (this._tzm) {
	            this.utcOffset(this._tzm);
	        } else if (typeof this._i === 'string') {
	            var tZone = offsetFromString(matchOffset, this._i);

	            if (tZone === 0) {
	                this.utcOffset(0, true);
	            } else {
	                this.utcOffset(offsetFromString(matchOffset, this._i));
	            }
	        }
	        return this;
	    }

	    function hasAlignedHourOffset (input) {
	        if (!this.isValid()) {
	            return false;
	        }
	        input = input ? local__createLocal(input).utcOffset() : 0;

	        return (this.utcOffset() - input) % 60 === 0;
	    }

	    function isDaylightSavingTime () {
	        return (
	            this.utcOffset() > this.clone().month(0).utcOffset() ||
	            this.utcOffset() > this.clone().month(5).utcOffset()
	        );
	    }

	    function isDaylightSavingTimeShifted () {
	        if (!isUndefined(this._isDSTShifted)) {
	            return this._isDSTShifted;
	        }

	        var c = {};

	        copyConfig(c, this);
	        c = prepareConfig(c);

	        if (c._a) {
	            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
	            this._isDSTShifted = this.isValid() &&
	                compareArrays(c._a, other.toArray()) > 0;
	        } else {
	            this._isDSTShifted = false;
	        }

	        return this._isDSTShifted;
	    }

	    function isLocal () {
	        return this.isValid() ? !this._isUTC : false;
	    }

	    function isUtcOffset () {
	        return this.isValid() ? this._isUTC : false;
	    }

	    function isUtc () {
	        return this.isValid() ? this._isUTC && this._offset === 0 : false;
	    }

	    // ASP.NET json date format regex
	    var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

	    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
	    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
	    // and further modified to allow for strings containing both week and day
	    var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

	    function create__createDuration (input, key) {
	        var duration = input,
	            // matching against regexp is expensive, do it on demand
	            match = null,
	            sign,
	            ret,
	            diffRes;

	        if (isDuration(input)) {
	            duration = {
	                ms : input._milliseconds,
	                d  : input._days,
	                M  : input._months
	            };
	        } else if (typeof input === 'number') {
	            duration = {};
	            if (key) {
	                duration[key] = input;
	            } else {
	                duration.milliseconds = input;
	            }
	        } else if (!!(match = aspNetRegex.exec(input))) {
	            sign = (match[1] === '-') ? -1 : 1;
	            duration = {
	                y  : 0,
	                d  : toInt(match[DATE])                         * sign,
	                h  : toInt(match[HOUR])                         * sign,
	                m  : toInt(match[MINUTE])                       * sign,
	                s  : toInt(match[SECOND])                       * sign,
	                ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
	            };
	        } else if (!!(match = isoRegex.exec(input))) {
	            sign = (match[1] === '-') ? -1 : 1;
	            duration = {
	                y : parseIso(match[2], sign),
	                M : parseIso(match[3], sign),
	                w : parseIso(match[4], sign),
	                d : parseIso(match[5], sign),
	                h : parseIso(match[6], sign),
	                m : parseIso(match[7], sign),
	                s : parseIso(match[8], sign)
	            };
	        } else if (duration == null) {// checks for null or undefined
	            duration = {};
	        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
	            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

	            duration = {};
	            duration.ms = diffRes.milliseconds;
	            duration.M = diffRes.months;
	        }

	        ret = new Duration(duration);

	        if (isDuration(input) && hasOwnProp(input, '_locale')) {
	            ret._locale = input._locale;
	        }

	        return ret;
	    }

	    create__createDuration.fn = Duration.prototype;

	    function parseIso (inp, sign) {
	        // We'd normally use ~~inp for this, but unfortunately it also
	        // converts floats to ints.
	        // inp may be undefined, so careful calling replace on it.
	        var res = inp && parseFloat(inp.replace(',', '.'));
	        // apply sign while we're at it
	        return (isNaN(res) ? 0 : res) * sign;
	    }

	    function positiveMomentsDifference(base, other) {
	        var res = {milliseconds: 0, months: 0};

	        res.months = other.month() - base.month() +
	            (other.year() - base.year()) * 12;
	        if (base.clone().add(res.months, 'M').isAfter(other)) {
	            --res.months;
	        }

	        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

	        return res;
	    }

	    function momentsDifference(base, other) {
	        var res;
	        if (!(base.isValid() && other.isValid())) {
	            return {milliseconds: 0, months: 0};
	        }

	        other = cloneWithOffset(other, base);
	        if (base.isBefore(other)) {
	            res = positiveMomentsDifference(base, other);
	        } else {
	            res = positiveMomentsDifference(other, base);
	            res.milliseconds = -res.milliseconds;
	            res.months = -res.months;
	        }

	        return res;
	    }

	    // TODO: remove 'name' arg after deprecation is removed
	    function createAdder(direction, name) {
	        return function (val, period) {
	            var dur, tmp;
	            //invert the arguments, but complain about it
	            if (period !== null && !isNaN(+period)) {
	                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
	                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
	                tmp = val; val = period; period = tmp;
	            }

	            val = typeof val === 'string' ? +val : val;
	            dur = create__createDuration(val, period);
	            add_subtract__addSubtract(this, dur, direction);
	            return this;
	        };
	    }

	    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
	        var milliseconds = duration._milliseconds,
	            days = absRound(duration._days),
	            months = absRound(duration._months);

	        if (!mom.isValid()) {
	            // No op
	            return;
	        }

	        updateOffset = updateOffset == null ? true : updateOffset;

	        if (milliseconds) {
	            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
	        }
	        if (days) {
	            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
	        }
	        if (months) {
	            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
	        }
	        if (updateOffset) {
	            utils_hooks__hooks.updateOffset(mom, days || months);
	        }
	    }

	    var add_subtract__add      = createAdder(1, 'add');
	    var add_subtract__subtract = createAdder(-1, 'subtract');

	    function getCalendarFormat(myMoment, now) {
	        var diff = myMoment.diff(now, 'days', true);
	        return diff < -6 ? 'sameElse' :
	                diff < -1 ? 'lastWeek' :
	                diff < 0 ? 'lastDay' :
	                diff < 1 ? 'sameDay' :
	                diff < 2 ? 'nextDay' :
	                diff < 7 ? 'nextWeek' : 'sameElse';
	    }

	    function moment_calendar__calendar (time, formats) {
	        // We want to compare the start of today, vs this.
	        // Getting start-of-today depends on whether we're local/utc/offset or not.
	        var now = time || local__createLocal(),
	            sod = cloneWithOffset(now, this).startOf('day'),
	            format = utils_hooks__hooks.calendarFormat(this, sod) || 'sameElse';

	        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

	        return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));
	    }

	    function clone () {
	        return new Moment(this);
	    }

	    function isAfter (input, units) {
	        var localInput = isMoment(input) ? input : local__createLocal(input);
	        if (!(this.isValid() && localInput.isValid())) {
	            return false;
	        }
	        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
	        if (units === 'millisecond') {
	            return this.valueOf() > localInput.valueOf();
	        } else {
	            return localInput.valueOf() < this.clone().startOf(units).valueOf();
	        }
	    }

	    function isBefore (input, units) {
	        var localInput = isMoment(input) ? input : local__createLocal(input);
	        if (!(this.isValid() && localInput.isValid())) {
	            return false;
	        }
	        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
	        if (units === 'millisecond') {
	            return this.valueOf() < localInput.valueOf();
	        } else {
	            return this.clone().endOf(units).valueOf() < localInput.valueOf();
	        }
	    }

	    function isBetween (from, to, units, inclusivity) {
	        inclusivity = inclusivity || '()';
	        return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
	            (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
	    }

	    function isSame (input, units) {
	        var localInput = isMoment(input) ? input : local__createLocal(input),
	            inputMs;
	        if (!(this.isValid() && localInput.isValid())) {
	            return false;
	        }
	        units = normalizeUnits(units || 'millisecond');
	        if (units === 'millisecond') {
	            return this.valueOf() === localInput.valueOf();
	        } else {
	            inputMs = localInput.valueOf();
	            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
	        }
	    }

	    function isSameOrAfter (input, units) {
	        return this.isSame(input, units) || this.isAfter(input,units);
	    }

	    function isSameOrBefore (input, units) {
	        return this.isSame(input, units) || this.isBefore(input,units);
	    }

	    function diff (input, units, asFloat) {
	        var that,
	            zoneDelta,
	            delta, output;

	        if (!this.isValid()) {
	            return NaN;
	        }

	        that = cloneWithOffset(input, this);

	        if (!that.isValid()) {
	            return NaN;
	        }

	        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

	        units = normalizeUnits(units);

	        if (units === 'year' || units === 'month' || units === 'quarter') {
	            output = monthDiff(this, that);
	            if (units === 'quarter') {
	                output = output / 3;
	            } else if (units === 'year') {
	                output = output / 12;
	            }
	        } else {
	            delta = this - that;
	            output = units === 'second' ? delta / 1e3 : // 1000
	                units === 'minute' ? delta / 6e4 : // 1000 * 60
	                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
	                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
	                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
	                delta;
	        }
	        return asFloat ? output : absFloor(output);
	    }

	    function monthDiff (a, b) {
	        // difference in months
	        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
	            // b is in (anchor - 1 month, anchor + 1 month)
	            anchor = a.clone().add(wholeMonthDiff, 'months'),
	            anchor2, adjust;

	        if (b - anchor < 0) {
	            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
	            // linear across the month
	            adjust = (b - anchor) / (anchor - anchor2);
	        } else {
	            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
	            // linear across the month
	            adjust = (b - anchor) / (anchor2 - anchor);
	        }

	        //check for negative zero, return zero if negative zero
	        return -(wholeMonthDiff + adjust) || 0;
	    }

	    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
	    utils_hooks__hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

	    function toString () {
	        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
	    }

	    function moment_format__toISOString () {
	        var m = this.clone().utc();
	        if (0 < m.year() && m.year() <= 9999) {
	            if (isFunction(Date.prototype.toISOString)) {
	                // native implementation is ~50x faster, use it when we can
	                return this.toDate().toISOString();
	            } else {
	                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	            }
	        } else {
	            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	        }
	    }

	    function format (inputString) {
	        if (!inputString) {
	            inputString = this.isUtc() ? utils_hooks__hooks.defaultFormatUtc : utils_hooks__hooks.defaultFormat;
	        }
	        var output = formatMoment(this, inputString);
	        return this.localeData().postformat(output);
	    }

	    function from (time, withoutSuffix) {
	        if (this.isValid() &&
	                ((isMoment(time) && time.isValid()) ||
	                 local__createLocal(time).isValid())) {
	            return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
	        } else {
	            return this.localeData().invalidDate();
	        }
	    }

	    function fromNow (withoutSuffix) {
	        return this.from(local__createLocal(), withoutSuffix);
	    }

	    function to (time, withoutSuffix) {
	        if (this.isValid() &&
	                ((isMoment(time) && time.isValid()) ||
	                 local__createLocal(time).isValid())) {
	            return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
	        } else {
	            return this.localeData().invalidDate();
	        }
	    }

	    function toNow (withoutSuffix) {
	        return this.to(local__createLocal(), withoutSuffix);
	    }

	    // If passed a locale key, it will set the locale for this
	    // instance.  Otherwise, it will return the locale configuration
	    // variables for this instance.
	    function locale (key) {
	        var newLocaleData;

	        if (key === undefined) {
	            return this._locale._abbr;
	        } else {
	            newLocaleData = locale_locales__getLocale(key);
	            if (newLocaleData != null) {
	                this._locale = newLocaleData;
	            }
	            return this;
	        }
	    }

	    var lang = deprecate(
	        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
	        function (key) {
	            if (key === undefined) {
	                return this.localeData();
	            } else {
	                return this.locale(key);
	            }
	        }
	    );

	    function localeData () {
	        return this._locale;
	    }

	    function startOf (units) {
	        units = normalizeUnits(units);
	        // the following switch intentionally omits break keywords
	        // to utilize falling through the cases.
	        switch (units) {
	            case 'year':
	                this.month(0);
	                /* falls through */
	            case 'quarter':
	            case 'month':
	                this.date(1);
	                /* falls through */
	            case 'week':
	            case 'isoWeek':
	            case 'day':
	            case 'date':
	                this.hours(0);
	                /* falls through */
	            case 'hour':
	                this.minutes(0);
	                /* falls through */
	            case 'minute':
	                this.seconds(0);
	                /* falls through */
	            case 'second':
	                this.milliseconds(0);
	        }

	        // weeks are a special case
	        if (units === 'week') {
	            this.weekday(0);
	        }
	        if (units === 'isoWeek') {
	            this.isoWeekday(1);
	        }

	        // quarters are also special
	        if (units === 'quarter') {
	            this.month(Math.floor(this.month() / 3) * 3);
	        }

	        return this;
	    }

	    function endOf (units) {
	        units = normalizeUnits(units);
	        if (units === undefined || units === 'millisecond') {
	            return this;
	        }

	        // 'date' is an alias for 'day', so it should be considered as such.
	        if (units === 'date') {
	            units = 'day';
	        }

	        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
	    }

	    function to_type__valueOf () {
	        return this._d.valueOf() - ((this._offset || 0) * 60000);
	    }

	    function unix () {
	        return Math.floor(this.valueOf() / 1000);
	    }

	    function toDate () {
	        return new Date(this.valueOf());
	    }

	    function toArray () {
	        var m = this;
	        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
	    }

	    function toObject () {
	        var m = this;
	        return {
	            years: m.year(),
	            months: m.month(),
	            date: m.date(),
	            hours: m.hours(),
	            minutes: m.minutes(),
	            seconds: m.seconds(),
	            milliseconds: m.milliseconds()
	        };
	    }

	    function toJSON () {
	        // new Date(NaN).toJSON() === null
	        return this.isValid() ? this.toISOString() : null;
	    }

	    function moment_valid__isValid () {
	        return valid__isValid(this);
	    }

	    function parsingFlags () {
	        return extend({}, getParsingFlags(this));
	    }

	    function invalidAt () {
	        return getParsingFlags(this).overflow;
	    }

	    function creationData() {
	        return {
	            input: this._i,
	            format: this._f,
	            locale: this._locale,
	            isUTC: this._isUTC,
	            strict: this._strict
	        };
	    }

	    // FORMATTING

	    addFormatToken(0, ['gg', 2], 0, function () {
	        return this.weekYear() % 100;
	    });

	    addFormatToken(0, ['GG', 2], 0, function () {
	        return this.isoWeekYear() % 100;
	    });

	    function addWeekYearFormatToken (token, getter) {
	        addFormatToken(0, [token, token.length], 0, getter);
	    }

	    addWeekYearFormatToken('gggg',     'weekYear');
	    addWeekYearFormatToken('ggggg',    'weekYear');
	    addWeekYearFormatToken('GGGG',  'isoWeekYear');
	    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

	    // ALIASES

	    addUnitAlias('weekYear', 'gg');
	    addUnitAlias('isoWeekYear', 'GG');

	    // PRIORITY

	    addUnitPriority('weekYear', 1);
	    addUnitPriority('isoWeekYear', 1);


	    // PARSING

	    addRegexToken('G',      matchSigned);
	    addRegexToken('g',      matchSigned);
	    addRegexToken('GG',     match1to2, match2);
	    addRegexToken('gg',     match1to2, match2);
	    addRegexToken('GGGG',   match1to4, match4);
	    addRegexToken('gggg',   match1to4, match4);
	    addRegexToken('GGGGG',  match1to6, match6);
	    addRegexToken('ggggg',  match1to6, match6);

	    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
	        week[token.substr(0, 2)] = toInt(input);
	    });

	    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
	        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
	    });

	    // MOMENTS

	    function getSetWeekYear (input) {
	        return getSetWeekYearHelper.call(this,
	                input,
	                this.week(),
	                this.weekday(),
	                this.localeData()._week.dow,
	                this.localeData()._week.doy);
	    }

	    function getSetISOWeekYear (input) {
	        return getSetWeekYearHelper.call(this,
	                input, this.isoWeek(), this.isoWeekday(), 1, 4);
	    }

	    function getISOWeeksInYear () {
	        return weeksInYear(this.year(), 1, 4);
	    }

	    function getWeeksInYear () {
	        var weekInfo = this.localeData()._week;
	        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
	    }

	    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
	        var weeksTarget;
	        if (input == null) {
	            return weekOfYear(this, dow, doy).year;
	        } else {
	            weeksTarget = weeksInYear(input, dow, doy);
	            if (week > weeksTarget) {
	                week = weeksTarget;
	            }
	            return setWeekAll.call(this, input, week, weekday, dow, doy);
	        }
	    }

	    function setWeekAll(weekYear, week, weekday, dow, doy) {
	        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
	            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

	        this.year(date.getUTCFullYear());
	        this.month(date.getUTCMonth());
	        this.date(date.getUTCDate());
	        return this;
	    }

	    // FORMATTING

	    addFormatToken('Q', 0, 'Qo', 'quarter');

	    // ALIASES

	    addUnitAlias('quarter', 'Q');

	    // PRIORITY

	    addUnitPriority('quarter', 7);

	    // PARSING

	    addRegexToken('Q', match1);
	    addParseToken('Q', function (input, array) {
	        array[MONTH] = (toInt(input) - 1) * 3;
	    });

	    // MOMENTS

	    function getSetQuarter (input) {
	        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
	    }

	    // FORMATTING

	    addFormatToken('D', ['DD', 2], 'Do', 'date');

	    // ALIASES

	    addUnitAlias('date', 'D');

	    // PRIOROITY
	    addUnitPriority('date', 9);

	    // PARSING

	    addRegexToken('D',  match1to2);
	    addRegexToken('DD', match1to2, match2);
	    addRegexToken('Do', function (isStrict, locale) {
	        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
	    });

	    addParseToken(['D', 'DD'], DATE);
	    addParseToken('Do', function (input, array) {
	        array[DATE] = toInt(input.match(match1to2)[0], 10);
	    });

	    // MOMENTS

	    var getSetDayOfMonth = makeGetSet('Date', true);

	    // FORMATTING

	    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

	    // ALIASES

	    addUnitAlias('dayOfYear', 'DDD');

	    // PRIORITY
	    addUnitPriority('dayOfYear', 4);

	    // PARSING

	    addRegexToken('DDD',  match1to3);
	    addRegexToken('DDDD', match3);
	    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
	        config._dayOfYear = toInt(input);
	    });

	    // HELPERS

	    // MOMENTS

	    function getSetDayOfYear (input) {
	        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
	        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
	    }

	    // FORMATTING

	    addFormatToken('m', ['mm', 2], 0, 'minute');

	    // ALIASES

	    addUnitAlias('minute', 'm');

	    // PRIORITY

	    addUnitPriority('minute', 14);

	    // PARSING

	    addRegexToken('m',  match1to2);
	    addRegexToken('mm', match1to2, match2);
	    addParseToken(['m', 'mm'], MINUTE);

	    // MOMENTS

	    var getSetMinute = makeGetSet('Minutes', false);

	    // FORMATTING

	    addFormatToken('s', ['ss', 2], 0, 'second');

	    // ALIASES

	    addUnitAlias('second', 's');

	    // PRIORITY

	    addUnitPriority('second', 15);

	    // PARSING

	    addRegexToken('s',  match1to2);
	    addRegexToken('ss', match1to2, match2);
	    addParseToken(['s', 'ss'], SECOND);

	    // MOMENTS

	    var getSetSecond = makeGetSet('Seconds', false);

	    // FORMATTING

	    addFormatToken('S', 0, 0, function () {
	        return ~~(this.millisecond() / 100);
	    });

	    addFormatToken(0, ['SS', 2], 0, function () {
	        return ~~(this.millisecond() / 10);
	    });

	    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
	    addFormatToken(0, ['SSSS', 4], 0, function () {
	        return this.millisecond() * 10;
	    });
	    addFormatToken(0, ['SSSSS', 5], 0, function () {
	        return this.millisecond() * 100;
	    });
	    addFormatToken(0, ['SSSSSS', 6], 0, function () {
	        return this.millisecond() * 1000;
	    });
	    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
	        return this.millisecond() * 10000;
	    });
	    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
	        return this.millisecond() * 100000;
	    });
	    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
	        return this.millisecond() * 1000000;
	    });


	    // ALIASES

	    addUnitAlias('millisecond', 'ms');

	    // PRIORITY

	    addUnitPriority('millisecond', 16);

	    // PARSING

	    addRegexToken('S',    match1to3, match1);
	    addRegexToken('SS',   match1to3, match2);
	    addRegexToken('SSS',  match1to3, match3);

	    var token;
	    for (token = 'SSSS'; token.length <= 9; token += 'S') {
	        addRegexToken(token, matchUnsigned);
	    }

	    function parseMs(input, array) {
	        array[MILLISECOND] = toInt(('0.' + input) * 1000);
	    }

	    for (token = 'S'; token.length <= 9; token += 'S') {
	        addParseToken(token, parseMs);
	    }
	    // MOMENTS

	    var getSetMillisecond = makeGetSet('Milliseconds', false);

	    // FORMATTING

	    addFormatToken('z',  0, 0, 'zoneAbbr');
	    addFormatToken('zz', 0, 0, 'zoneName');

	    // MOMENTS

	    function getZoneAbbr () {
	        return this._isUTC ? 'UTC' : '';
	    }

	    function getZoneName () {
	        return this._isUTC ? 'Coordinated Universal Time' : '';
	    }

	    var momentPrototype__proto = Moment.prototype;

	    momentPrototype__proto.add               = add_subtract__add;
	    momentPrototype__proto.calendar          = moment_calendar__calendar;
	    momentPrototype__proto.clone             = clone;
	    momentPrototype__proto.diff              = diff;
	    momentPrototype__proto.endOf             = endOf;
	    momentPrototype__proto.format            = format;
	    momentPrototype__proto.from              = from;
	    momentPrototype__proto.fromNow           = fromNow;
	    momentPrototype__proto.to                = to;
	    momentPrototype__proto.toNow             = toNow;
	    momentPrototype__proto.get               = stringGet;
	    momentPrototype__proto.invalidAt         = invalidAt;
	    momentPrototype__proto.isAfter           = isAfter;
	    momentPrototype__proto.isBefore          = isBefore;
	    momentPrototype__proto.isBetween         = isBetween;
	    momentPrototype__proto.isSame            = isSame;
	    momentPrototype__proto.isSameOrAfter     = isSameOrAfter;
	    momentPrototype__proto.isSameOrBefore    = isSameOrBefore;
	    momentPrototype__proto.isValid           = moment_valid__isValid;
	    momentPrototype__proto.lang              = lang;
	    momentPrototype__proto.locale            = locale;
	    momentPrototype__proto.localeData        = localeData;
	    momentPrototype__proto.max               = prototypeMax;
	    momentPrototype__proto.min               = prototypeMin;
	    momentPrototype__proto.parsingFlags      = parsingFlags;
	    momentPrototype__proto.set               = stringSet;
	    momentPrototype__proto.startOf           = startOf;
	    momentPrototype__proto.subtract          = add_subtract__subtract;
	    momentPrototype__proto.toArray           = toArray;
	    momentPrototype__proto.toObject          = toObject;
	    momentPrototype__proto.toDate            = toDate;
	    momentPrototype__proto.toISOString       = moment_format__toISOString;
	    momentPrototype__proto.toJSON            = toJSON;
	    momentPrototype__proto.toString          = toString;
	    momentPrototype__proto.unix              = unix;
	    momentPrototype__proto.valueOf           = to_type__valueOf;
	    momentPrototype__proto.creationData      = creationData;

	    // Year
	    momentPrototype__proto.year       = getSetYear;
	    momentPrototype__proto.isLeapYear = getIsLeapYear;

	    // Week Year
	    momentPrototype__proto.weekYear    = getSetWeekYear;
	    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

	    // Quarter
	    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

	    // Month
	    momentPrototype__proto.month       = getSetMonth;
	    momentPrototype__proto.daysInMonth = getDaysInMonth;

	    // Week
	    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
	    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
	    momentPrototype__proto.weeksInYear    = getWeeksInYear;
	    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

	    // Day
	    momentPrototype__proto.date       = getSetDayOfMonth;
	    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
	    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
	    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
	    momentPrototype__proto.dayOfYear  = getSetDayOfYear;

	    // Hour
	    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

	    // Minute
	    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

	    // Second
	    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

	    // Millisecond
	    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

	    // Offset
	    momentPrototype__proto.utcOffset            = getSetOffset;
	    momentPrototype__proto.utc                  = setOffsetToUTC;
	    momentPrototype__proto.local                = setOffsetToLocal;
	    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
	    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
	    momentPrototype__proto.isDST                = isDaylightSavingTime;
	    momentPrototype__proto.isLocal              = isLocal;
	    momentPrototype__proto.isUtcOffset          = isUtcOffset;
	    momentPrototype__proto.isUtc                = isUtc;
	    momentPrototype__proto.isUTC                = isUtc;

	    // Timezone
	    momentPrototype__proto.zoneAbbr = getZoneAbbr;
	    momentPrototype__proto.zoneName = getZoneName;

	    // Deprecations
	    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
	    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
	    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
	    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
	    momentPrototype__proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

	    var momentPrototype = momentPrototype__proto;

	    function moment__createUnix (input) {
	        return local__createLocal(input * 1000);
	    }

	    function moment__createInZone () {
	        return local__createLocal.apply(null, arguments).parseZone();
	    }

	    function preParsePostFormat (string) {
	        return string;
	    }

	    var prototype__proto = Locale.prototype;

	    prototype__proto.calendar        = locale_calendar__calendar;
	    prototype__proto.longDateFormat  = longDateFormat;
	    prototype__proto.invalidDate     = invalidDate;
	    prototype__proto.ordinal         = ordinal;
	    prototype__proto.preparse        = preParsePostFormat;
	    prototype__proto.postformat      = preParsePostFormat;
	    prototype__proto.relativeTime    = relative__relativeTime;
	    prototype__proto.pastFuture      = pastFuture;
	    prototype__proto.set             = locale_set__set;

	    // Month
	    prototype__proto.months            =        localeMonths;
	    prototype__proto.monthsShort       =        localeMonthsShort;
	    prototype__proto.monthsParse       =        localeMonthsParse;
	    prototype__proto.monthsRegex       = monthsRegex;
	    prototype__proto.monthsShortRegex  = monthsShortRegex;

	    // Week
	    prototype__proto.week = localeWeek;
	    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
	    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

	    // Day of Week
	    prototype__proto.weekdays       =        localeWeekdays;
	    prototype__proto.weekdaysMin    =        localeWeekdaysMin;
	    prototype__proto.weekdaysShort  =        localeWeekdaysShort;
	    prototype__proto.weekdaysParse  =        localeWeekdaysParse;

	    prototype__proto.weekdaysRegex       =        weekdaysRegex;
	    prototype__proto.weekdaysShortRegex  =        weekdaysShortRegex;
	    prototype__proto.weekdaysMinRegex    =        weekdaysMinRegex;

	    // Hours
	    prototype__proto.isPM = localeIsPM;
	    prototype__proto.meridiem = localeMeridiem;

	    function lists__get (format, index, field, setter) {
	        var locale = locale_locales__getLocale();
	        var utc = create_utc__createUTC().set(setter, index);
	        return locale[field](utc, format);
	    }

	    function listMonthsImpl (format, index, field) {
	        if (typeof format === 'number') {
	            index = format;
	            format = undefined;
	        }

	        format = format || '';

	        if (index != null) {
	            return lists__get(format, index, field, 'month');
	        }

	        var i;
	        var out = [];
	        for (i = 0; i < 12; i++) {
	            out[i] = lists__get(format, i, field, 'month');
	        }
	        return out;
	    }

	    // ()
	    // (5)
	    // (fmt, 5)
	    // (fmt)
	    // (true)
	    // (true, 5)
	    // (true, fmt, 5)
	    // (true, fmt)
	    function listWeekdaysImpl (localeSorted, format, index, field) {
	        if (typeof localeSorted === 'boolean') {
	            if (typeof format === 'number') {
	                index = format;
	                format = undefined;
	            }

	            format = format || '';
	        } else {
	            format = localeSorted;
	            index = format;
	            localeSorted = false;

	            if (typeof format === 'number') {
	                index = format;
	                format = undefined;
	            }

	            format = format || '';
	        }

	        var locale = locale_locales__getLocale(),
	            shift = localeSorted ? locale._week.dow : 0;

	        if (index != null) {
	            return lists__get(format, (index + shift) % 7, field, 'day');
	        }

	        var i;
	        var out = [];
	        for (i = 0; i < 7; i++) {
	            out[i] = lists__get(format, (i + shift) % 7, field, 'day');
	        }
	        return out;
	    }

	    function lists__listMonths (format, index) {
	        return listMonthsImpl(format, index, 'months');
	    }

	    function lists__listMonthsShort (format, index) {
	        return listMonthsImpl(format, index, 'monthsShort');
	    }

	    function lists__listWeekdays (localeSorted, format, index) {
	        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
	    }

	    function lists__listWeekdaysShort (localeSorted, format, index) {
	        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
	    }

	    function lists__listWeekdaysMin (localeSorted, format, index) {
	        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
	    }

	    locale_locales__getSetGlobalLocale('en', {
	        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (toInt(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        }
	    });

	    // Side effect imports
	    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
	    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

	    var mathAbs = Math.abs;

	    function duration_abs__abs () {
	        var data           = this._data;

	        this._milliseconds = mathAbs(this._milliseconds);
	        this._days         = mathAbs(this._days);
	        this._months       = mathAbs(this._months);

	        data.milliseconds  = mathAbs(data.milliseconds);
	        data.seconds       = mathAbs(data.seconds);
	        data.minutes       = mathAbs(data.minutes);
	        data.hours         = mathAbs(data.hours);
	        data.months        = mathAbs(data.months);
	        data.years         = mathAbs(data.years);

	        return this;
	    }

	    function duration_add_subtract__addSubtract (duration, input, value, direction) {
	        var other = create__createDuration(input, value);

	        duration._milliseconds += direction * other._milliseconds;
	        duration._days         += direction * other._days;
	        duration._months       += direction * other._months;

	        return duration._bubble();
	    }

	    // supports only 2.0-style add(1, 's') or add(duration)
	    function duration_add_subtract__add (input, value) {
	        return duration_add_subtract__addSubtract(this, input, value, 1);
	    }

	    // supports only 2.0-style subtract(1, 's') or subtract(duration)
	    function duration_add_subtract__subtract (input, value) {
	        return duration_add_subtract__addSubtract(this, input, value, -1);
	    }

	    function absCeil (number) {
	        if (number < 0) {
	            return Math.floor(number);
	        } else {
	            return Math.ceil(number);
	        }
	    }

	    function bubble () {
	        var milliseconds = this._milliseconds;
	        var days         = this._days;
	        var months       = this._months;
	        var data         = this._data;
	        var seconds, minutes, hours, years, monthsFromDays;

	        // if we have a mix of positive and negative values, bubble down first
	        // check: https://github.com/moment/moment/issues/2166
	        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
	                (milliseconds <= 0 && days <= 0 && months <= 0))) {
	            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
	            days = 0;
	            months = 0;
	        }

	        // The following code bubbles up values, see the tests for
	        // examples of what that means.
	        data.milliseconds = milliseconds % 1000;

	        seconds           = absFloor(milliseconds / 1000);
	        data.seconds      = seconds % 60;

	        minutes           = absFloor(seconds / 60);
	        data.minutes      = minutes % 60;

	        hours             = absFloor(minutes / 60);
	        data.hours        = hours % 24;

	        days += absFloor(hours / 24);

	        // convert days to months
	        monthsFromDays = absFloor(daysToMonths(days));
	        months += monthsFromDays;
	        days -= absCeil(monthsToDays(monthsFromDays));

	        // 12 months -> 1 year
	        years = absFloor(months / 12);
	        months %= 12;

	        data.days   = days;
	        data.months = months;
	        data.years  = years;

	        return this;
	    }

	    function daysToMonths (days) {
	        // 400 years have 146097 days (taking into account leap year rules)
	        // 400 years have 12 months === 4800
	        return days * 4800 / 146097;
	    }

	    function monthsToDays (months) {
	        // the reverse of daysToMonths
	        return months * 146097 / 4800;
	    }

	    function as (units) {
	        var days;
	        var months;
	        var milliseconds = this._milliseconds;

	        units = normalizeUnits(units);

	        if (units === 'month' || units === 'year') {
	            days   = this._days   + milliseconds / 864e5;
	            months = this._months + daysToMonths(days);
	            return units === 'month' ? months : months / 12;
	        } else {
	            // handle milliseconds separately because of floating point math errors (issue #1867)
	            days = this._days + Math.round(monthsToDays(this._months));
	            switch (units) {
	                case 'week'   : return days / 7     + milliseconds / 6048e5;
	                case 'day'    : return days         + milliseconds / 864e5;
	                case 'hour'   : return days * 24    + milliseconds / 36e5;
	                case 'minute' : return days * 1440  + milliseconds / 6e4;
	                case 'second' : return days * 86400 + milliseconds / 1000;
	                // Math.floor prevents floating point math errors here
	                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
	                default: throw new Error('Unknown unit ' + units);
	            }
	        }
	    }

	    // TODO: Use this.as('ms')?
	    function duration_as__valueOf () {
	        return (
	            this._milliseconds +
	            this._days * 864e5 +
	            (this._months % 12) * 2592e6 +
	            toInt(this._months / 12) * 31536e6
	        );
	    }

	    function makeAs (alias) {
	        return function () {
	            return this.as(alias);
	        };
	    }

	    var asMilliseconds = makeAs('ms');
	    var asSeconds      = makeAs('s');
	    var asMinutes      = makeAs('m');
	    var asHours        = makeAs('h');
	    var asDays         = makeAs('d');
	    var asWeeks        = makeAs('w');
	    var asMonths       = makeAs('M');
	    var asYears        = makeAs('y');

	    function duration_get__get (units) {
	        units = normalizeUnits(units);
	        return this[units + 's']();
	    }

	    function makeGetter(name) {
	        return function () {
	            return this._data[name];
	        };
	    }

	    var milliseconds = makeGetter('milliseconds');
	    var seconds      = makeGetter('seconds');
	    var minutes      = makeGetter('minutes');
	    var hours        = makeGetter('hours');
	    var days         = makeGetter('days');
	    var months       = makeGetter('months');
	    var years        = makeGetter('years');

	    function weeks () {
	        return absFloor(this.days() / 7);
	    }

	    var round = Math.round;
	    var thresholds = {
	        s: 45,  // seconds to minute
	        m: 45,  // minutes to hour
	        h: 22,  // hours to day
	        d: 26,  // days to month
	        M: 11   // months to year
	    };

	    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
	    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
	        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
	    }

	    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
	        var duration = create__createDuration(posNegDuration).abs();
	        var seconds  = round(duration.as('s'));
	        var minutes  = round(duration.as('m'));
	        var hours    = round(duration.as('h'));
	        var days     = round(duration.as('d'));
	        var months   = round(duration.as('M'));
	        var years    = round(duration.as('y'));

	        var a = seconds < thresholds.s && ['s', seconds]  ||
	                minutes <= 1           && ['m']           ||
	                minutes < thresholds.m && ['mm', minutes] ||
	                hours   <= 1           && ['h']           ||
	                hours   < thresholds.h && ['hh', hours]   ||
	                days    <= 1           && ['d']           ||
	                days    < thresholds.d && ['dd', days]    ||
	                months  <= 1           && ['M']           ||
	                months  < thresholds.M && ['MM', months]  ||
	                years   <= 1           && ['y']           || ['yy', years];

	        a[2] = withoutSuffix;
	        a[3] = +posNegDuration > 0;
	        a[4] = locale;
	        return substituteTimeAgo.apply(null, a);
	    }

	    // This function allows you to set the rounding function for relative time strings
	    function duration_humanize__getSetRelativeTimeRounding (roundingFunction) {
	        if (roundingFunction === undefined) {
	            return round;
	        }
	        if (typeof(roundingFunction) === 'function') {
	            round = roundingFunction;
	            return true;
	        }
	        return false;
	    }

	    // This function allows you to set a threshold for relative time strings
	    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
	        if (thresholds[threshold] === undefined) {
	            return false;
	        }
	        if (limit === undefined) {
	            return thresholds[threshold];
	        }
	        thresholds[threshold] = limit;
	        return true;
	    }

	    function humanize (withSuffix) {
	        var locale = this.localeData();
	        var output = duration_humanize__relativeTime(this, !withSuffix, locale);

	        if (withSuffix) {
	            output = locale.pastFuture(+this, output);
	        }

	        return locale.postformat(output);
	    }

	    var iso_string__abs = Math.abs;

	    function iso_string__toISOString() {
	        // for ISO strings we do not use the normal bubbling rules:
	        //  * milliseconds bubble up until they become hours
	        //  * days do not bubble at all
	        //  * months bubble up until they become years
	        // This is because there is no context-free conversion between hours and days
	        // (think of clock changes)
	        // and also not between days and months (28-31 days per month)
	        var seconds = iso_string__abs(this._milliseconds) / 1000;
	        var days         = iso_string__abs(this._days);
	        var months       = iso_string__abs(this._months);
	        var minutes, hours, years;

	        // 3600 seconds -> 60 minutes -> 1 hour
	        minutes           = absFloor(seconds / 60);
	        hours             = absFloor(minutes / 60);
	        seconds %= 60;
	        minutes %= 60;

	        // 12 months -> 1 year
	        years  = absFloor(months / 12);
	        months %= 12;


	        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
	        var Y = years;
	        var M = months;
	        var D = days;
	        var h = hours;
	        var m = minutes;
	        var s = seconds;
	        var total = this.asSeconds();

	        if (!total) {
	            // this is the same as C#'s (Noda) and python (isodate)...
	            // but not other JS (goog.date)
	            return 'P0D';
	        }

	        return (total < 0 ? '-' : '') +
	            'P' +
	            (Y ? Y + 'Y' : '') +
	            (M ? M + 'M' : '') +
	            (D ? D + 'D' : '') +
	            ((h || m || s) ? 'T' : '') +
	            (h ? h + 'H' : '') +
	            (m ? m + 'M' : '') +
	            (s ? s + 'S' : '');
	    }

	    var duration_prototype__proto = Duration.prototype;

	    duration_prototype__proto.abs            = duration_abs__abs;
	    duration_prototype__proto.add            = duration_add_subtract__add;
	    duration_prototype__proto.subtract       = duration_add_subtract__subtract;
	    duration_prototype__proto.as             = as;
	    duration_prototype__proto.asMilliseconds = asMilliseconds;
	    duration_prototype__proto.asSeconds      = asSeconds;
	    duration_prototype__proto.asMinutes      = asMinutes;
	    duration_prototype__proto.asHours        = asHours;
	    duration_prototype__proto.asDays         = asDays;
	    duration_prototype__proto.asWeeks        = asWeeks;
	    duration_prototype__proto.asMonths       = asMonths;
	    duration_prototype__proto.asYears        = asYears;
	    duration_prototype__proto.valueOf        = duration_as__valueOf;
	    duration_prototype__proto._bubble        = bubble;
	    duration_prototype__proto.get            = duration_get__get;
	    duration_prototype__proto.milliseconds   = milliseconds;
	    duration_prototype__proto.seconds        = seconds;
	    duration_prototype__proto.minutes        = minutes;
	    duration_prototype__proto.hours          = hours;
	    duration_prototype__proto.days           = days;
	    duration_prototype__proto.weeks          = weeks;
	    duration_prototype__proto.months         = months;
	    duration_prototype__proto.years          = years;
	    duration_prototype__proto.humanize       = humanize;
	    duration_prototype__proto.toISOString    = iso_string__toISOString;
	    duration_prototype__proto.toString       = iso_string__toISOString;
	    duration_prototype__proto.toJSON         = iso_string__toISOString;
	    duration_prototype__proto.locale         = locale;
	    duration_prototype__proto.localeData     = localeData;

	    // Deprecations
	    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
	    duration_prototype__proto.lang = lang;

	    // Side effect imports

	    // FORMATTING

	    addFormatToken('X', 0, 0, 'unix');
	    addFormatToken('x', 0, 0, 'valueOf');

	    // PARSING

	    addRegexToken('x', matchSigned);
	    addRegexToken('X', matchTimestamp);
	    addParseToken('X', function (input, array, config) {
	        config._d = new Date(parseFloat(input, 10) * 1000);
	    });
	    addParseToken('x', function (input, array, config) {
	        config._d = new Date(toInt(input));
	    });

	    // Side effect imports


	    utils_hooks__hooks.version = '2.15.2';

	    setHookCallback(local__createLocal);

	    utils_hooks__hooks.fn                    = momentPrototype;
	    utils_hooks__hooks.min                   = min;
	    utils_hooks__hooks.max                   = max;
	    utils_hooks__hooks.now                   = now;
	    utils_hooks__hooks.utc                   = create_utc__createUTC;
	    utils_hooks__hooks.unix                  = moment__createUnix;
	    utils_hooks__hooks.months                = lists__listMonths;
	    utils_hooks__hooks.isDate                = isDate;
	    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
	    utils_hooks__hooks.invalid               = valid__createInvalid;
	    utils_hooks__hooks.duration              = create__createDuration;
	    utils_hooks__hooks.isMoment              = isMoment;
	    utils_hooks__hooks.weekdays              = lists__listWeekdays;
	    utils_hooks__hooks.parseZone             = moment__createInZone;
	    utils_hooks__hooks.localeData            = locale_locales__getLocale;
	    utils_hooks__hooks.isDuration            = isDuration;
	    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
	    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
	    utils_hooks__hooks.defineLocale          = defineLocale;
	    utils_hooks__hooks.updateLocale          = updateLocale;
	    utils_hooks__hooks.locales               = locale_locales__listLocales;
	    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
	    utils_hooks__hooks.normalizeUnits        = normalizeUnits;
	    utils_hooks__hooks.relativeTimeRounding = duration_humanize__getSetRelativeTimeRounding;
	    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
	    utils_hooks__hooks.calendarFormat        = getCalendarFormat;
	    utils_hooks__hooks.prototype             = momentPrototype;

	    var _moment = utils_hooks__hooks;

	    return _moment;

	}));
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../webpack/buildin/module.js */ 78)(module)))

/***/ },
/* 210 */
/*!**********************************!*\
  !*** ./~/moment/locale ^\.\/.*$ ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./af": 211,
		"./af.js": 211,
		"./ar": 212,
		"./ar-ly": 213,
		"./ar-ly.js": 213,
		"./ar-ma": 214,
		"./ar-ma.js": 214,
		"./ar-sa": 215,
		"./ar-sa.js": 215,
		"./ar-tn": 216,
		"./ar-tn.js": 216,
		"./ar.js": 212,
		"./az": 217,
		"./az.js": 217,
		"./be": 218,
		"./be.js": 218,
		"./bg": 219,
		"./bg.js": 219,
		"./bn": 220,
		"./bn.js": 220,
		"./bo": 221,
		"./bo.js": 221,
		"./br": 222,
		"./br.js": 222,
		"./bs": 223,
		"./bs.js": 223,
		"./ca": 224,
		"./ca.js": 224,
		"./cs": 225,
		"./cs.js": 225,
		"./cv": 226,
		"./cv.js": 226,
		"./cy": 227,
		"./cy.js": 227,
		"./da": 228,
		"./da.js": 228,
		"./de": 229,
		"./de-at": 230,
		"./de-at.js": 230,
		"./de.js": 229,
		"./dv": 231,
		"./dv.js": 231,
		"./el": 232,
		"./el.js": 232,
		"./en-au": 233,
		"./en-au.js": 233,
		"./en-ca": 234,
		"./en-ca.js": 234,
		"./en-gb": 235,
		"./en-gb.js": 235,
		"./en-ie": 236,
		"./en-ie.js": 236,
		"./en-nz": 237,
		"./en-nz.js": 237,
		"./eo": 238,
		"./eo.js": 238,
		"./es": 239,
		"./es-do": 240,
		"./es-do.js": 240,
		"./es.js": 239,
		"./et": 241,
		"./et.js": 241,
		"./eu": 242,
		"./eu.js": 242,
		"./fa": 243,
		"./fa.js": 243,
		"./fi": 244,
		"./fi.js": 244,
		"./fo": 245,
		"./fo.js": 245,
		"./fr": 246,
		"./fr-ca": 247,
		"./fr-ca.js": 247,
		"./fr-ch": 248,
		"./fr-ch.js": 248,
		"./fr.js": 246,
		"./fy": 249,
		"./fy.js": 249,
		"./gd": 250,
		"./gd.js": 250,
		"./gl": 251,
		"./gl.js": 251,
		"./he": 252,
		"./he.js": 252,
		"./hi": 253,
		"./hi.js": 253,
		"./hr": 254,
		"./hr.js": 254,
		"./hu": 255,
		"./hu.js": 255,
		"./hy-am": 256,
		"./hy-am.js": 256,
		"./id": 257,
		"./id.js": 257,
		"./is": 258,
		"./is.js": 258,
		"./it": 259,
		"./it.js": 259,
		"./ja": 260,
		"./ja.js": 260,
		"./jv": 261,
		"./jv.js": 261,
		"./ka": 262,
		"./ka.js": 262,
		"./kk": 263,
		"./kk.js": 263,
		"./km": 264,
		"./km.js": 264,
		"./ko": 265,
		"./ko.js": 265,
		"./ky": 266,
		"./ky.js": 266,
		"./lb": 267,
		"./lb.js": 267,
		"./lo": 268,
		"./lo.js": 268,
		"./lt": 269,
		"./lt.js": 269,
		"./lv": 270,
		"./lv.js": 270,
		"./me": 271,
		"./me.js": 271,
		"./mi": 272,
		"./mi.js": 272,
		"./mk": 273,
		"./mk.js": 273,
		"./ml": 274,
		"./ml.js": 274,
		"./mr": 275,
		"./mr.js": 275,
		"./ms": 276,
		"./ms-my": 277,
		"./ms-my.js": 277,
		"./ms.js": 276,
		"./my": 278,
		"./my.js": 278,
		"./nb": 279,
		"./nb.js": 279,
		"./ne": 280,
		"./ne.js": 280,
		"./nl": 281,
		"./nl.js": 281,
		"./nn": 282,
		"./nn.js": 282,
		"./pa-in": 283,
		"./pa-in.js": 283,
		"./pl": 284,
		"./pl.js": 284,
		"./pt": 285,
		"./pt-br": 286,
		"./pt-br.js": 286,
		"./pt.js": 285,
		"./ro": 287,
		"./ro.js": 287,
		"./ru": 288,
		"./ru.js": 288,
		"./se": 289,
		"./se.js": 289,
		"./si": 290,
		"./si.js": 290,
		"./sk": 291,
		"./sk.js": 291,
		"./sl": 292,
		"./sl.js": 292,
		"./sq": 293,
		"./sq.js": 293,
		"./sr": 294,
		"./sr-cyrl": 295,
		"./sr-cyrl.js": 295,
		"./sr.js": 294,
		"./ss": 296,
		"./ss.js": 296,
		"./sv": 297,
		"./sv.js": 297,
		"./sw": 298,
		"./sw.js": 298,
		"./ta": 299,
		"./ta.js": 299,
		"./te": 300,
		"./te.js": 300,
		"./th": 301,
		"./th.js": 301,
		"./tl-ph": 302,
		"./tl-ph.js": 302,
		"./tlh": 303,
		"./tlh.js": 303,
		"./tr": 304,
		"./tr.js": 304,
		"./tzl": 305,
		"./tzl.js": 305,
		"./tzm": 306,
		"./tzm-latn": 307,
		"./tzm-latn.js": 307,
		"./tzm.js": 306,
		"./uk": 308,
		"./uk.js": 308,
		"./uz": 309,
		"./uz.js": 309,
		"./vi": 310,
		"./vi.js": 310,
		"./x-pseudo": 311,
		"./x-pseudo.js": 311,
		"./zh-cn": 312,
		"./zh-cn.js": 312,
		"./zh-hk": 313,
		"./zh-hk.js": 313,
		"./zh-tw": 314,
		"./zh-tw.js": 314
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 210;


/***/ },
/* 211 */
/*!*******************************!*\
  !*** ./~/moment/locale/af.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Afrikaans [af]
	//! author : Werner Mollentze : https://github.com/wernerm

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var af = moment.defineLocale('af', {
	        months : 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
	        monthsShort : 'Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
	        weekdays : 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
	        weekdaysShort : 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
	        weekdaysMin : 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
	        meridiemParse: /vm|nm/i,
	        isPM : function (input) {
	            return /^nm$/i.test(input);
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 12) {
	                return isLower ? 'vm' : 'VM';
	            } else {
	                return isLower ? 'nm' : 'NM';
	            }
	        },
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[Vandag om] LT',
	            nextDay : '[Mre om] LT',
	            nextWeek : 'dddd [om] LT',
	            lastDay : '[Gister om] LT',
	            lastWeek : '[Laas] dddd [om] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'oor %s',
	            past : '%s gelede',
	            s : '\'n paar sekondes',
	            m : '\'n minuut',
	            mm : '%d minute',
	            h : '\'n uur',
	            hh : '%d ure',
	            d : '\'n dag',
	            dd : '%d dae',
	            M : '\'n maand',
	            MM : '%d maande',
	            y : '\'n jaar',
	            yy : '%d jaar'
	        },
	        ordinalParse: /\d{1,2}(ste|de)/,
	        ordinal : function (number) {
	            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de'); // Thanks to Joris Rling : https://github.com/jjupiter
	        },
	        week : {
	            dow : 1, // Maandag is die eerste dag van die week.
	            doy : 4  // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
	        }
	    });

	    return af;

	}));

/***/ },
/* 212 */
/*!*******************************!*\
  !*** ./~/moment/locale/ar.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic [ar]
	//! author : Abdel Said: https://github.com/abdelsaid
	//! author : Ahmed Elkhatib
	//! author : forabi https://github.com/forabi

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var symbolMap = {
	        '1': '',
	        '2': '',
	        '3': '',
	        '4': '',
	        '5': '',
	        '6': '',
	        '7': '',
	        '8': '',
	        '9': '',
	        '0': ''
	    }, numberMap = {
	        '': '1',
	        '': '2',
	        '': '3',
	        '': '4',
	        '': '5',
	        '': '6',
	        '': '7',
	        '': '8',
	        '': '9',
	        '': '0'
	    }, pluralForm = function (n) {
	        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
	    }, plurals = {
	        s : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	        m : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	        h : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	        d : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	        M : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	        y : ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
	    }, pluralize = function (u) {
	        return function (number, withoutSuffix, string, isFuture) {
	            var f = pluralForm(number),
	                str = plurals[u][pluralForm(number)];
	            if (f === 2) {
	                str = str[withoutSuffix ? 0 : 1];
	            }
	            return str.replace(/%d/i, number);
	        };
	    }, months = [
	        '  ',
	        ' ',
	        ' ',
	        ' ',
	        ' ',
	        ' ',
	        ' ',
	        ' ',
	        ' ',
	        '  ',
	        '  ',
	        '  '
	    ];

	    var ar = moment.defineLocale('ar', {
	        months : months,
	        monthsShort : months,
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'D/\u200FM/\u200FYYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        meridiemParse: /|/,
	        isPM : function (input) {
	            return '' === input;
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        calendar : {
	            sameDay: '[  ] LT',
	            nextDay: '[  ] LT',
	            nextWeek: 'dddd [ ] LT',
	            lastDay: '[  ] LT',
	            lastWeek: 'dddd [ ] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : ' %s',
	            s : pluralize('s'),
	            m : pluralize('m'),
	            mm : pluralize('m'),
	            h : pluralize('h'),
	            hh : pluralize('h'),
	            d : pluralize('d'),
	            dd : pluralize('d'),
	            M : pluralize('M'),
	            MM : pluralize('M'),
	            y : pluralize('y'),
	            yy : pluralize('y')
	        },
	        preparse: function (string) {
	            return string.replace(/\u200f/g, '').replace(/[]/g, function (match) {
	                return numberMap[match];
	            }).replace(//g, ',');
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            }).replace(/,/g, '');
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return ar;

	}));

/***/ },
/* 213 */
/*!**********************************!*\
  !*** ./~/moment/locale/ar-ly.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic (Lybia) [ar-ly]
	//! author : Ali Hmer: https://github.com/kikoanis

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var symbolMap = {
	        '1': '1',
	        '2': '2',
	        '3': '3',
	        '4': '4',
	        '5': '5',
	        '6': '6',
	        '7': '7',
	        '8': '8',
	        '9': '9',
	        '0': '0'
	    }, pluralForm = function (n) {
	        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
	    }, plurals = {
	        s : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	        m : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	        h : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	        d : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	        M : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	        y : ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
	    }, pluralize = function (u) {
	        return function (number, withoutSuffix, string, isFuture) {
	            var f = pluralForm(number),
	                str = plurals[u][pluralForm(number)];
	            if (f === 2) {
	                str = str[withoutSuffix ? 0 : 1];
	            }
	            return str.replace(/%d/i, number);
	        };
	    }, months = [
	        '',
	        '',
	        '',
	        '',
	        '',
	        '',
	        '',
	        '',
	        '',
	        '',
	        '',
	        ''
	    ];

	    var ar_ly = moment.defineLocale('ar-ly', {
	        months : months,
	        monthsShort : months,
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'D/\u200FM/\u200FYYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        meridiemParse: /|/,
	        isPM : function (input) {
	            return '' === input;
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        calendar : {
	            sameDay: '[  ] LT',
	            nextDay: '[  ] LT',
	            nextWeek: 'dddd [ ] LT',
	            lastDay: '[  ] LT',
	            lastWeek: 'dddd [ ] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : ' %s',
	            s : pluralize('s'),
	            m : pluralize('m'),
	            mm : pluralize('m'),
	            h : pluralize('h'),
	            hh : pluralize('h'),
	            d : pluralize('d'),
	            dd : pluralize('d'),
	            M : pluralize('M'),
	            MM : pluralize('M'),
	            y : pluralize('y'),
	            yy : pluralize('y')
	        },
	        preparse: function (string) {
	            return string.replace(/\u200f/g, '').replace(//g, ',');
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            }).replace(/,/g, '');
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return ar_ly;

	}));

/***/ },
/* 214 */
/*!**********************************!*\
  !*** ./~/moment/locale/ar-ma.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic (Morocco) [ar-ma]
	//! author : ElFadili Yassine : https://github.com/ElFadiliY
	//! author : Abdel Said : https://github.com/abdelsaid

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var ar_ma = moment.defineLocale('ar-ma', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[  ] LT',
	            nextDay: '[  ] LT',
	            nextWeek: 'dddd [ ] LT',
	            lastDay: '[  ] LT',
	            lastWeek: 'dddd [ ] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : ' %s',
	            s : '',
	            m : '',
	            mm : '%d ',
	            h : '',
	            hh : '%d ',
	            d : '',
	            dd : '%d ',
	            M : '',
	            MM : '%d ',
	            y : '',
	            yy : '%d '
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return ar_ma;

	}));

/***/ },
/* 215 */
/*!**********************************!*\
  !*** ./~/moment/locale/ar-sa.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic (Saudi Arabia) [ar-sa]
	//! author : Suhail Alkowaileet : https://github.com/xsoh

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var symbolMap = {
	        '1': '',
	        '2': '',
	        '3': '',
	        '4': '',
	        '5': '',
	        '6': '',
	        '7': '',
	        '8': '',
	        '9': '',
	        '0': ''
	    }, numberMap = {
	        '': '1',
	        '': '2',
	        '': '3',
	        '': '4',
	        '': '5',
	        '': '6',
	        '': '7',
	        '': '8',
	        '': '9',
	        '': '0'
	    };

	    var ar_sa = moment.defineLocale('ar-sa', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        meridiemParse: /|/,
	        isPM : function (input) {
	            return '' === input;
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        calendar : {
	            sameDay: '[  ] LT',
	            nextDay: '[  ] LT',
	            nextWeek: 'dddd [ ] LT',
	            lastDay: '[  ] LT',
	            lastWeek: 'dddd [ ] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : ' %s',
	            s : '',
	            m : '',
	            mm : '%d ',
	            h : '',
	            hh : '%d ',
	            d : '',
	            dd : '%d ',
	            M : '',
	            MM : '%d ',
	            y : '',
	            yy : '%d '
	        },
	        preparse: function (string) {
	            return string.replace(/[]/g, function (match) {
	                return numberMap[match];
	            }).replace(//g, ',');
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            }).replace(/,/g, '');
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return ar_sa;

	}));

/***/ },
/* 216 */
/*!**********************************!*\
  !*** ./~/moment/locale/ar-tn.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale  :  Arabic (Tunisia) [ar-tn]
	//! author : Nader Toukabri : https://github.com/naderio

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var ar_tn = moment.defineLocale('ar-tn', {
	        months: '___________'.split('_'),
	        monthsShort: '___________'.split('_'),
	        weekdays: '______'.split('_'),
	        weekdaysShort: '______'.split('_'),
	        weekdaysMin: '______'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat: {
	            LT: 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L: 'DD/MM/YYYY',
	            LL: 'D MMMM YYYY',
	            LLL: 'D MMMM YYYY HH:mm',
	            LLLL: 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar: {
	            sameDay: '[  ] LT',
	            nextDay: '[  ] LT',
	            nextWeek: 'dddd [ ] LT',
	            lastDay: '[  ] LT',
	            lastWeek: 'dddd [ ] LT',
	            sameElse: 'L'
	        },
	        relativeTime: {
	            future: ' %s',
	            past: ' %s',
	            s: '',
	            m: '',
	            mm: '%d ',
	            h: '',
	            hh: '%d ',
	            d: '',
	            dd: '%d ',
	            M: '',
	            MM: '%d ',
	            y: '',
	            yy: '%d '
	        },
	        week: {
	            dow: 1, // Monday is the first day of the week.
	            doy: 4 // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return ar_tn;

	}));

/***/ },
/* 217 */
/*!*******************************!*\
  !*** ./~/moment/locale/az.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Azerbaijani [az]
	//! author : topchiyev : https://github.com/topchiyev

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var suffixes = {
	        1: '-inci',
	        5: '-inci',
	        8: '-inci',
	        70: '-inci',
	        80: '-inci',
	        2: '-nci',
	        7: '-nci',
	        20: '-nci',
	        50: '-nci',
	        3: '-nc',
	        4: '-nc',
	        100: '-nc',
	        6: '-nc',
	        9: '-uncu',
	        10: '-uncu',
	        30: '-uncu',
	        60: '-nc',
	        90: '-nc'
	    };

	    var az = moment.defineLocale('az', {
	        months : 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
	        monthsShort : 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
	        weekdays : 'Bazar_Bazar ertsi_rnb axam_rnb_Cm axam_Cm_nb'.split('_'),
	        weekdaysShort : 'Baz_BzE_Ax_r_CAx_Cm_n'.split('_'),
	        weekdaysMin : 'Bz_BE_A__CA_C_'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[bugn saat] LT',
	            nextDay : '[sabah saat] LT',
	            nextWeek : '[gln hft] dddd [saat] LT',
	            lastDay : '[dnn] LT',
	            lastWeek : '[ken hft] dddd [saat] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s sonra',
	            past : '%s vvl',
	            s : 'birne saniyy',
	            m : 'bir dqiq',
	            mm : '%d dqiq',
	            h : 'bir saat',
	            hh : '%d saat',
	            d : 'bir gn',
	            dd : '%d gn',
	            M : 'bir ay',
	            MM : '%d ay',
	            y : 'bir il',
	            yy : '%d il'
	        },
	        meridiemParse: /gec|shr|gndz|axam/,
	        isPM : function (input) {
	            return /^(gndz|axam)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'gec';
	            } else if (hour < 12) {
	                return 'shr';
	            } else if (hour < 17) {
	                return 'gndz';
	            } else {
	                return 'axam';
	            }
	        },
	        ordinalParse: /\d{1,2}-(nc|inci|nci|nc|nc|uncu)/,
	        ordinal : function (number) {
	            if (number === 0) {  // special case for zero
	                return number + '-nc';
	            }
	            var a = number % 10,
	                b = number % 100 - a,
	                c = number >= 100 ? 100 : null;
	            return number + (suffixes[a] || suffixes[b] || suffixes[c]);
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return az;

	}));

/***/ },
/* 218 */
/*!*******************************!*\
  !*** ./~/moment/locale/be.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Belarusian [be]
	//! author : Dmitry Demidov : https://github.com/demidov91
	//! author: Praleska: http://praleska.pro/
	//! Author : Menelion Elensle : https://github.com/Oire

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function plural(word, num) {
	        var forms = word.split('_');
	        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	    }
	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        var format = {
	            'mm': withoutSuffix ? '__' : '__',
	            'hh': withoutSuffix ? '__' : '__',
	            'dd': '__',
	            'MM': '__',
	            'yy': '__'
	        };
	        if (key === 'm') {
	            return withoutSuffix ? '' : '';
	        }
	        else if (key === 'h') {
	            return withoutSuffix ? '' : '';
	        }
	        else {
	            return number + ' ' + plural(format[key], +number);
	        }
	    }

	    var be = moment.defineLocale('be', {
	        months : {
	            format: '___________'.split('_'),
	            standalone: '___________'.split('_')
	        },
	        monthsShort : '___________'.split('_'),
	        weekdays : {
	            format: '______'.split('_'),
	            standalone: '______'.split('_'),
	            isFormat: /\[ ?[] ?(?:|)? ?\] ?dddd/
	        },
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY .',
	            LLL : 'D MMMM YYYY ., HH:mm',
	            LLLL : 'dddd, D MMMM YYYY ., HH:mm'
	        },
	        calendar : {
	            sameDay: '[ ] LT',
	            nextDay: '[ ] LT',
	            lastDay: '[ ] LT',
	            nextWeek: function () {
	                return '[] dddd [] LT';
	            },
	            lastWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                    case 3:
	                    case 5:
	                    case 6:
	                        return '[ ] dddd [] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                        return '[ ] dddd [] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : '%s ',
	            s : ' ',
	            m : relativeTimeWithPlural,
	            mm : relativeTimeWithPlural,
	            h : relativeTimeWithPlural,
	            hh : relativeTimeWithPlural,
	            d : '',
	            dd : relativeTimeWithPlural,
	            M : '',
	            MM : relativeTimeWithPlural,
	            y : '',
	            yy : relativeTimeWithPlural
	        },
	        meridiemParse: /|||/,
	        isPM : function (input) {
	            return /^(|)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return '';
	            } else if (hour < 12) {
	                return '';
	            } else if (hour < 17) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        ordinalParse: /\d{1,2}-(||)/,
	        ordinal: function (number, period) {
	            switch (period) {
	                case 'M':
	                case 'd':
	                case 'DDD':
	                case 'w':
	                case 'W':
	                    return (number % 10 === 2 || number % 10 === 3) && (number % 100 !== 12 && number % 100 !== 13) ? number + '-' : number + '-';
	                case 'D':
	                    return number + '-';
	                default:
	                    return number;
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return be;

	}));

/***/ },
/* 219 */
/*!*******************************!*\
  !*** ./~/moment/locale/bg.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bulgarian [bg]
	//! author : Krasen Borisov : https://github.com/kraz

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var bg = moment.defineLocale('bg', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'D.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY H:mm',
	            LLLL : 'dddd, D MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay : '[ ] LT',
	            nextDay : '[ ] LT',
	            nextWeek : 'dddd [] LT',
	            lastDay : '[ ] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                    case 0:
	                    case 3:
	                    case 6:
	                        return '[ ] dddd [] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                    case 5:
	                        return '[ ] dddd [] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : ' %s',
	            s : ' ',
	            m : '',
	            mm : '%d ',
	            h : '',
	            hh : '%d ',
	            d : '',
	            dd : '%d ',
	            M : '',
	            MM : '%d ',
	            y : '',
	            yy : '%d '
	        },
	        ordinalParse: /\d{1,2}-(|||||)/,
	        ordinal : function (number) {
	            var lastDigit = number % 10,
	                last2Digits = number % 100;
	            if (number === 0) {
	                return number + '-';
	            } else if (last2Digits === 0) {
	                return number + '-';
	            } else if (last2Digits > 10 && last2Digits < 20) {
	                return number + '-';
	            } else if (lastDigit === 1) {
	                return number + '-';
	            } else if (lastDigit === 2) {
	                return number + '-';
	            } else if (lastDigit === 7 || lastDigit === 8) {
	                return number + '-';
	            } else {
	                return number + '-';
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return bg;

	}));

/***/ },
/* 220 */
/*!*******************************!*\
  !*** ./~/moment/locale/bn.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bengali [bn]
	//! author : Kaushik Gandhi : https://github.com/kaushikgandhi

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var symbolMap = {
	        '1': '',
	        '2': '',
	        '3': '',
	        '4': '',
	        '5': '',
	        '6': '',
	        '7': '',
	        '8': '',
	        '9': '',
	        '0': ''
	    },
	    numberMap = {
	        '': '1',
	        '': '2',
	        '': '3',
	        '': '4',
	        '': '5',
	        '': '6',
	        '': '7',
	        '': '8',
	        '': '9',
	        '': '0'
	    };

	    var bn = moment.defineLocale('bn', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm ',
	            LTS : 'A h:mm:ss ',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm ',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm '
	        },
	        calendar : {
	            sameDay : '[] LT',
	            nextDay : '[] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[] LT',
	            lastWeek : '[] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ',
	            past : '%s ',
	            s : ' ',
	            m : ' ',
	            mm : '%d ',
	            h : ' ',
	            hh : '%d ',
	            d : ' ',
	            dd : '%d ',
	            M : ' ',
	            MM : '%d ',
	            y : ' ',
	            yy : '%d '
	        },
	        preparse: function (string) {
	            return string.replace(/[]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        meridiemParse: /||||/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if ((meridiem === '' && hour >= 4) ||
	                    (meridiem === '' && hour < 5) ||
	                    meridiem === '') {
	                return hour + 12;
	            } else {
	                return hour;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return '';
	            } else if (hour < 10) {
	                return '';
	            } else if (hour < 17) {
	                return '';
	            } else if (hour < 20) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return bn;

	}));

/***/ },
/* 221 */
/*!*******************************!*\
  !*** ./~/moment/locale/bo.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Tibetan [bo]
	//! author : Thupten N. Chakrishar : https://github.com/vajradog

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var symbolMap = {
	        '1': '',
	        '2': '',
	        '3': '',
	        '4': '',
	        '5': '',
	        '6': '',
	        '7': '',
	        '8': '',
	        '9': '',
	        '0': ''
	    },
	    numberMap = {
	        '': '1',
	        '': '2',
	        '': '3',
	        '': '4',
	        '': '5',
	        '': '6',
	        '': '7',
	        '': '8',
	        '': '9',
	        '': '0'
	    };

	    var bo = moment.defineLocale('bo', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm',
	            LTS : 'A h:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm'
	        },
	        calendar : {
	            sameDay : '[] LT',
	            nextDay : '[] LT',
	            nextWeek : '[], LT',
	            lastDay : '[] LT',
	            lastWeek : '[] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ',
	            past : '%s ',
	            s : '',
	            m : '',
	            mm : '%d ',
	            h : '',
	            hh : '%d ',
	            d : '',
	            dd : '%d ',
	            M : '',
	            MM : '%d ',
	            y : '',
	            yy : '%d '
	        },
	        preparse: function (string) {
	            return string.replace(/[]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        meridiemParse: /||||/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if ((meridiem === '' && hour >= 4) ||
	                    (meridiem === '' && hour < 5) ||
	                    meridiem === '') {
	                return hour + 12;
	            } else {
	                return hour;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return '';
	            } else if (hour < 10) {
	                return '';
	            } else if (hour < 17) {
	                return '';
	            } else if (hour < 20) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return bo;

	}));

/***/ },
/* 222 */
/*!*******************************!*\
  !*** ./~/moment/locale/br.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Breton [br]
	//! author : Jean-Baptiste Le Duigou : https://github.com/jbleduigou

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function relativeTimeWithMutation(number, withoutSuffix, key) {
	        var format = {
	            'mm': 'munutenn',
	            'MM': 'miz',
	            'dd': 'devezh'
	        };
	        return number + ' ' + mutation(format[key], number);
	    }
	    function specialMutationForYears(number) {
	        switch (lastNumber(number)) {
	            case 1:
	            case 3:
	            case 4:
	            case 5:
	            case 9:
	                return number + ' bloaz';
	            default:
	                return number + ' vloaz';
	        }
	    }
	    function lastNumber(number) {
	        if (number > 9) {
	            return lastNumber(number % 10);
	        }
	        return number;
	    }
	    function mutation(text, number) {
	        if (number === 2) {
	            return softMutation(text);
	        }
	        return text;
	    }
	    function softMutation(text) {
	        var mutationTable = {
	            'm': 'v',
	            'b': 'v',
	            'd': 'z'
	        };
	        if (mutationTable[text.charAt(0)] === undefined) {
	            return text;
	        }
	        return mutationTable[text.charAt(0)] + text.substring(1);
	    }

	    var br = moment.defineLocale('br', {
	        months : 'Genver_C\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
	        monthsShort : 'Gen_C\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
	        weekdays : 'Sul_Lun_Meurzh_Merc\'her_Yaou_Gwener_Sadorn'.split('_'),
	        weekdaysShort : 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
	        weekdaysMin : 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'h[e]mm A',
	            LTS : 'h[e]mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D [a viz] MMMM YYYY',
	            LLL : 'D [a viz] MMMM YYYY h[e]mm A',
	            LLLL : 'dddd, D [a viz] MMMM YYYY h[e]mm A'
	        },
	        calendar : {
	            sameDay : '[Hiziv da] LT',
	            nextDay : '[Warc\'hoazh da] LT',
	            nextWeek : 'dddd [da] LT',
	            lastDay : '[Dec\'h da] LT',
	            lastWeek : 'dddd [paset da] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'a-benn %s',
	            past : '%s \'zo',
	            s : 'un nebeud segondenno',
	            m : 'ur vunutenn',
	            mm : relativeTimeWithMutation,
	            h : 'un eur',
	            hh : '%d eur',
	            d : 'un devezh',
	            dd : relativeTimeWithMutation,
	            M : 'ur miz',
	            MM : relativeTimeWithMutation,
	            y : 'ur bloaz',
	            yy : specialMutationForYears
	        },
	        ordinalParse: /\d{1,2}(a|vet)/,
	        ordinal : function (number) {
	            var output = (number === 1) ? 'a' : 'vet';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return br;

	}));

/***/ },
/* 223 */
/*!*******************************!*\
  !*** ./~/moment/locale/bs.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bosnian [bs]
	//! author : Nedim Cholich : https://github.com/frontyard
	//! based on (hr) translation by Bojan Markovi

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function translate(number, withoutSuffix, key) {
	        var result = number + ' ';
	        switch (key) {
	            case 'm':
	                return withoutSuffix ? 'jedna minuta' : 'jedne minute';
	            case 'mm':
	                if (number === 1) {
	                    result += 'minuta';
	                } else if (number === 2 || number === 3 || number === 4) {
	                    result += 'minute';
	                } else {
	                    result += 'minuta';
	                }
	                return result;
	            case 'h':
	                return withoutSuffix ? 'jedan sat' : 'jednog sata';
	            case 'hh':
	                if (number === 1) {
	                    result += 'sat';
	                } else if (number === 2 || number === 3 || number === 4) {
	                    result += 'sata';
	                } else {
	                    result += 'sati';
	                }
	                return result;
	            case 'dd':
	                if (number === 1) {
	                    result += 'dan';
	                } else {
	                    result += 'dana';
	                }
	                return result;
	            case 'MM':
	                if (number === 1) {
	                    result += 'mjesec';
	                } else if (number === 2 || number === 3 || number === 4) {
	                    result += 'mjeseca';
	                } else {
	                    result += 'mjeseci';
	                }
	                return result;
	            case 'yy':
	                if (number === 1) {
	                    result += 'godina';
	                } else if (number === 2 || number === 3 || number === 4) {
	                    result += 'godine';
	                } else {
	                    result += 'godina';
	                }
	                return result;
	        }
	    }

	    var bs = moment.defineLocale('bs', {
	        months : 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
	        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
	        monthsParseExact: true,
	        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
	        weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
	        weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay  : '[danas u] LT',
	            nextDay  : '[sutra u] LT',
	            nextWeek : function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[u] [nedjelju] [u] LT';
	                    case 3:
	                        return '[u] [srijedu] [u] LT';
	                    case 6:
	                        return '[u] [subotu] [u] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                    case 5:
	                        return '[u] dddd [u] LT';
	                }
	            },
	            lastDay  : '[juer u] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                    case 0:
	                    case 3:
	                        return '[prolu] dddd [u] LT';
	                    case 6:
	                        return '[prole] [subote] [u] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                    case 5:
	                        return '[proli] dddd [u] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past   : 'prije %s',
	            s      : 'par sekundi',
	            m      : translate,
	            mm     : translate,
	            h      : translate,
	            hh     : translate,
	            d      : 'dan',
	            dd     : translate,
	            M      : 'mjesec',
	            MM     : translate,
	            y      : 'godinu',
	            yy     : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return bs;

	}));

/***/ },
/* 224 */
/*!*******************************!*\
  !*** ./~/moment/locale/ca.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Catalan [ca]
	//! author : Juan G. Hurtado : https://github.com/juanghurtado

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var ca = moment.defineLocale('ca', {
	        months : 'gener_febrer_mar_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
	        monthsShort : 'gen._febr._mar._abr._mai._jun._jul._ag._set._oct._nov._des.'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
	        weekdaysShort : 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
	        weekdaysMin : 'Dg_Dl_Dt_Dc_Dj_Dv_Ds'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY H:mm',
	            LLLL : 'dddd D MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay : function () {
	                return '[avui a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            nextDay : function () {
	                return '[dem a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            nextWeek : function () {
	                return 'dddd [a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            lastDay : function () {
	                return '[ahir a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            lastWeek : function () {
	                return '[el] dddd [passat a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'en %s',
	            past : 'fa %s',
	            s : 'uns segons',
	            m : 'un minut',
	            mm : '%d minuts',
	            h : 'una hora',
	            hh : '%d hores',
	            d : 'un dia',
	            dd : '%d dies',
	            M : 'un mes',
	            MM : '%d mesos',
	            y : 'un any',
	            yy : '%d anys'
	        },
	        ordinalParse: /\d{1,2}(r|n|t||a)/,
	        ordinal : function (number, period) {
	            var output = (number === 1) ? 'r' :
	                (number === 2) ? 'n' :
	                (number === 3) ? 'r' :
	                (number === 4) ? 't' : '';
	            if (period === 'w' || period === 'W') {
	                output = 'a';
	            }
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return ca;

	}));

/***/ },
/* 225 */
/*!*******************************!*\
  !*** ./~/moment/locale/cs.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Czech [cs]
	//! author : petrbela : https://github.com/petrbela

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var months = 'leden_nor_bezen_duben_kvten_erven_ervenec_srpen_z_jen_listopad_prosinec'.split('_'),
	        monthsShort = 'led_no_be_dub_kv_vn_vc_srp_z_j_lis_pro'.split('_');
	    function plural(n) {
	        return (n > 1) && (n < 5) && (~~(n / 10) !== 1);
	    }
	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        switch (key) {
	            case 's':  // a few seconds / in a few seconds / a few seconds ago
	                return (withoutSuffix || isFuture) ? 'pr sekund' : 'pr sekundami';
	            case 'm':  // a minute / in a minute / a minute ago
	                return withoutSuffix ? 'minuta' : (isFuture ? 'minutu' : 'minutou');
	            case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
	                if (withoutSuffix || isFuture) {
	                    return result + (plural(number) ? 'minuty' : 'minut');
	                } else {
	                    return result + 'minutami';
	                }
	                break;
	            case 'h':  // an hour / in an hour / an hour ago
	                return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
	            case 'hh': // 9 hours / in 9 hours / 9 hours ago
	                if (withoutSuffix || isFuture) {
	                    return result + (plural(number) ? 'hodiny' : 'hodin');
	                } else {
	                    return result + 'hodinami';
	                }
	                break;
	            case 'd':  // a day / in a day / a day ago
	                return (withoutSuffix || isFuture) ? 'den' : 'dnem';
	            case 'dd': // 9 days / in 9 days / 9 days ago
	                if (withoutSuffix || isFuture) {
	                    return result + (plural(number) ? 'dny' : 'dn');
	                } else {
	                    return result + 'dny';
	                }
	                break;
	            case 'M':  // a month / in a month / a month ago
	                return (withoutSuffix || isFuture) ? 'msc' : 'mscem';
	            case 'MM': // 9 months / in 9 months / 9 months ago
	                if (withoutSuffix || isFuture) {
	                    return result + (plural(number) ? 'msce' : 'msc');
	                } else {
	                    return result + 'msci';
	                }
	                break;
	            case 'y':  // a year / in a year / a year ago
	                return (withoutSuffix || isFuture) ? 'rok' : 'rokem';
	            case 'yy': // 9 years / in 9 years / 9 years ago
	                if (withoutSuffix || isFuture) {
	                    return result + (plural(number) ? 'roky' : 'let');
	                } else {
	                    return result + 'lety';
	                }
	                break;
	        }
	    }

	    var cs = moment.defineLocale('cs', {
	        months : months,
	        monthsShort : monthsShort,
	        monthsParse : (function (months, monthsShort) {
	            var i, _monthsParse = [];
	            for (i = 0; i < 12; i++) {
	                // use custom parser to solve problem with July (ervenec)
	                _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
	            }
	            return _monthsParse;
	        }(months, monthsShort)),
	        shortMonthsParse : (function (monthsShort) {
	            var i, _shortMonthsParse = [];
	            for (i = 0; i < 12; i++) {
	                _shortMonthsParse[i] = new RegExp('^' + monthsShort[i] + '$', 'i');
	            }
	            return _shortMonthsParse;
	        }(monthsShort)),
	        longMonthsParse : (function (months) {
	            var i, _longMonthsParse = [];
	            for (i = 0; i < 12; i++) {
	                _longMonthsParse[i] = new RegExp('^' + months[i] + '$', 'i');
	            }
	            return _longMonthsParse;
	        }(months)),
	        weekdays : 'nedle_pondl_ter_steda_tvrtek_ptek_sobota'.split('_'),
	        weekdaysShort : 'ne_po_t_st_t_p_so'.split('_'),
	        weekdaysMin : 'ne_po_t_st_t_p_so'.split('_'),
	        longDateFormat : {
	            LT: 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd D. MMMM YYYY H:mm',
	            l : 'D. M. YYYY'
	        },
	        calendar : {
	            sameDay: '[dnes v] LT',
	            nextDay: '[ztra v] LT',
	            nextWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[v nedli v] LT';
	                    case 1:
	                    case 2:
	                        return '[v] dddd [v] LT';
	                    case 3:
	                        return '[ve stedu v] LT';
	                    case 4:
	                        return '[ve tvrtek v] LT';
	                    case 5:
	                        return '[v ptek v] LT';
	                    case 6:
	                        return '[v sobotu v] LT';
	                }
	            },
	            lastDay: '[vera v] LT',
	            lastWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[minulou nedli v] LT';
	                    case 1:
	                    case 2:
	                        return '[minul] dddd [v] LT';
	                    case 3:
	                        return '[minulou stedu v] LT';
	                    case 4:
	                    case 5:
	                        return '[minul] dddd [v] LT';
	                    case 6:
	                        return '[minulou sobotu v] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past : 'ped %s',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse : /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return cs;

	}));

/***/ },
/* 226 */
/*!*******************************!*\
  !*** ./~/moment/locale/cv.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Chuvash [cv]
	//! author : Anatoly Mironov : https://github.com/mirontoli

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var cv = moment.defineLocale('cv', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD-MM-YYYY',
	            LL : 'YYYY [] MMMM [] D[-]',
	            LLL : 'YYYY [] MMMM [] D[-], HH:mm',
	            LLLL : 'dddd, YYYY [] MMMM [] D[-], HH:mm'
	        },
	        calendar : {
	            sameDay: '[] LT []',
	            nextDay: '[] LT []',
	            lastDay: '[] LT []',
	            nextWeek: '[] dddd LT []',
	            lastWeek: '[] dddd LT []',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : function (output) {
	                var affix = /$/i.exec(output) ? '' : /$/i.exec(output) ? '' : '';
	                return output + affix;
	            },
	            past : '%s ',
	            s : '- ',
	            m : ' ',
	            mm : '%d ',
	            h : ' ',
	            hh : '%d ',
	            d : ' ',
	            dd : '%d ',
	            M : ' ',
	            MM : '%d ',
	            y : ' ',
	            yy : '%d '
	        },
	        ordinalParse: /\d{1,2}-/,
	        ordinal : '%d-',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return cv;

	}));

/***/ },
/* 227 */
/*!*******************************!*\
  !*** ./~/moment/locale/cy.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Welsh [cy]
	//! author : Robert Allen : https://github.com/robgallen
	//! author : https://github.com/ryangreaves

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var cy = moment.defineLocale('cy', {
	        months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
	        monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
	        weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
	        weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
	        weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
	        weekdaysParseExact : true,
	        // time formats are the same as en-gb
	        longDateFormat: {
	            LT: 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L: 'DD/MM/YYYY',
	            LL: 'D MMMM YYYY',
	            LLL: 'D MMMM YYYY HH:mm',
	            LLLL: 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar: {
	            sameDay: '[Heddiw am] LT',
	            nextDay: '[Yfory am] LT',
	            nextWeek: 'dddd [am] LT',
	            lastDay: '[Ddoe am] LT',
	            lastWeek: 'dddd [diwethaf am] LT',
	            sameElse: 'L'
	        },
	        relativeTime: {
	            future: 'mewn %s',
	            past: '%s yn l',
	            s: 'ychydig eiliadau',
	            m: 'munud',
	            mm: '%d munud',
	            h: 'awr',
	            hh: '%d awr',
	            d: 'diwrnod',
	            dd: '%d diwrnod',
	            M: 'mis',
	            MM: '%d mis',
	            y: 'blwyddyn',
	            yy: '%d flynedd'
	        },
	        ordinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
	        // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
	        ordinal: function (number) {
	            var b = number,
	                output = '',
	                lookup = [
	                    '', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed
	                    'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
	                ];
	            if (b > 20) {
	                if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
	                    output = 'fed'; // not 30ain, 70ain or 90ain
	                } else {
	                    output = 'ain';
	                }
	            } else if (b > 0) {
	                output = lookup[b];
	            }
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return cy;

	}));

/***/ },
/* 228 */
/*!*******************************!*\
  !*** ./~/moment/locale/da.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Danish [da]
	//! author : Ulrik Nielsen : https://github.com/mrbase

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var da = moment.defineLocale('da', {
	        months : 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
	        weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
	        weekdaysShort : 'sn_man_tir_ons_tor_fre_lr'.split('_'),
	        weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY HH:mm',
	            LLLL : 'dddd [d.] D. MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[I dag kl.] LT',
	            nextDay : '[I morgen kl.] LT',
	            nextWeek : 'dddd [kl.] LT',
	            lastDay : '[I gr kl.] LT',
	            lastWeek : '[sidste] dddd [kl] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'om %s',
	            past : '%s siden',
	            s : 'f sekunder',
	            m : 'et minut',
	            mm : '%d minutter',
	            h : 'en time',
	            hh : '%d timer',
	            d : 'en dag',
	            dd : '%d dage',
	            M : 'en mned',
	            MM : '%d mneder',
	            y : 'et r',
	            yy : '%d r'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return da;

	}));

/***/ },
/* 229 */
/*!*******************************!*\
  !*** ./~/moment/locale/de.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : German [de]
	//! author : lluchs : https://github.com/lluchs
	//! author: Menelion Elensle: https://github.com/Oire
	//! author : Mikolaj Dadela : https://github.com/mik01aj

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            'm': ['eine Minute', 'einer Minute'],
	            'h': ['eine Stunde', 'einer Stunde'],
	            'd': ['ein Tag', 'einem Tag'],
	            'dd': [number + ' Tage', number + ' Tagen'],
	            'M': ['ein Monat', 'einem Monat'],
	            'MM': [number + ' Monate', number + ' Monaten'],
	            'y': ['ein Jahr', 'einem Jahr'],
	            'yy': [number + ' Jahre', number + ' Jahren']
	        };
	        return withoutSuffix ? format[key][0] : format[key][1];
	    }

	    var de = moment.defineLocale('de', {
	        months : 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	        monthsShort : 'Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
	        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
	        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT: 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY HH:mm',
	            LLLL : 'dddd, D. MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[heute um] LT [Uhr]',
	            sameElse: 'L',
	            nextDay: '[morgen um] LT [Uhr]',
	            nextWeek: 'dddd [um] LT [Uhr]',
	            lastDay: '[gestern um] LT [Uhr]',
	            lastWeek: '[letzten] dddd [um] LT [Uhr]'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : 'vor %s',
	            s : 'ein paar Sekunden',
	            m : processRelativeTime,
	            mm : '%d Minuten',
	            h : processRelativeTime,
	            hh : '%d Stunden',
	            d : processRelativeTime,
	            dd : processRelativeTime,
	            M : processRelativeTime,
	            MM : processRelativeTime,
	            y : processRelativeTime,
	            yy : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return de;

	}));

/***/ },
/* 230 */
/*!**********************************!*\
  !*** ./~/moment/locale/de-at.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : German (Austria) [de-at]
	//! author : lluchs : https://github.com/lluchs
	//! author: Menelion Elensle: https://github.com/Oire
	//! author : Martin Groller : https://github.com/MadMG
	//! author : Mikolaj Dadela : https://github.com/mik01aj

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            'm': ['eine Minute', 'einer Minute'],
	            'h': ['eine Stunde', 'einer Stunde'],
	            'd': ['ein Tag', 'einem Tag'],
	            'dd': [number + ' Tage', number + ' Tagen'],
	            'M': ['ein Monat', 'einem Monat'],
	            'MM': [number + ' Monate', number + ' Monaten'],
	            'y': ['ein Jahr', 'einem Jahr'],
	            'yy': [number + ' Jahre', number + ' Jahren']
	        };
	        return withoutSuffix ? format[key][0] : format[key][1];
	    }

	    var de_at = moment.defineLocale('de-at', {
	        months : 'Jnner_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	        monthsShort : 'Jn._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
	        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
	        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT: 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY HH:mm',
	            LLLL : 'dddd, D. MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[heute um] LT [Uhr]',
	            sameElse: 'L',
	            nextDay: '[morgen um] LT [Uhr]',
	            nextWeek: 'dddd [um] LT [Uhr]',
	            lastDay: '[gestern um] LT [Uhr]',
	            lastWeek: '[letzten] dddd [um] LT [Uhr]'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : 'vor %s',
	            s : 'ein paar Sekunden',
	            m : processRelativeTime,
	            mm : '%d Minuten',
	            h : processRelativeTime,
	            hh : '%d Stunden',
	            d : processRelativeTime,
	            dd : processRelativeTime,
	            M : processRelativeTime,
	            MM : processRelativeTime,
	            y : processRelativeTime,
	            yy : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return de_at;

	}));

/***/ },
/* 231 */
/*!*******************************!*\
  !*** ./~/moment/locale/dv.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Maldivian [dv]
	//! author : Jawish Hameed : https://github.com/jawish

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var months = [
	        '',
	        '',
	        '',
	        '',
	        '',
	        '',
	        '',
	        '',
	        '',
	        '',
	        '',
	        ''
	    ], weekdays = [
	        '',
	        '',
	        '',
	        '',
	        '',
	        '',
	        ''
	    ];

	    var dv = moment.defineLocale('dv', {
	        months : months,
	        monthsShort : months,
	        weekdays : weekdays,
	        weekdaysShort : weekdays,
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {

	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'D/M/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        meridiemParse: /|/,
	        isPM : function (input) {
	            return '' === input;
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        calendar : {
	            sameDay : '[] LT',
	            nextDay : '[] LT',
	            nextWeek : 'dddd LT',
	            lastDay : '[] LT',
	            lastWeek : '[] dddd LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : ' %s',
	            s : '',
	            m : '',
	            mm : ' %d',
	            h : '',
	            hh : ' %d',
	            d : '',
	            dd : ' %d',
	            M : '',
	            MM : ' %d',
	            y : '',
	            yy : ' %d'
	        },
	        preparse: function (string) {
	            return string.replace(//g, ',');
	        },
	        postformat: function (string) {
	            return string.replace(/,/g, '');
	        },
	        week : {
	            dow : 7,  // Sunday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return dv;

	}));

/***/ },
/* 232 */
/*!*******************************!*\
  !*** ./~/moment/locale/el.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Greek [el]
	//! author : Aggelos Karalias : https://github.com/mehiel

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';

	    function isFunction(input) {
	        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
	    }


	    var el = moment.defineLocale('el', {
	        monthsNominativeEl : '___________'.split('_'),
	        monthsGenitiveEl : '___________'.split('_'),
	        months : function (momentToFormat, format) {
	            if (/D/.test(format.substring(0, format.indexOf('MMMM')))) { // if there is a day number before 'MMMM'
	                return this._monthsGenitiveEl[momentToFormat.month()];
	            } else {
	                return this._monthsNominativeEl[momentToFormat.month()];
	            }
	        },
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        meridiem : function (hours, minutes, isLower) {
	            if (hours > 11) {
	                return isLower ? '' : '';
	            } else {
	                return isLower ? '' : '';
	            }
	        },
	        isPM : function (input) {
	            return ((input + '').toLowerCase()[0] === '');
	        },
	        meridiemParse : /[]\.??\.?/i,
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY h:mm A',
	            LLLL : 'dddd, D MMMM YYYY h:mm A'
	        },
	        calendarEl : {
	            sameDay : '[ {}] LT',
	            nextDay : '[ {}] LT',
	            nextWeek : 'dddd [{}] LT',
	            lastDay : '[ {}] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                    case 6:
	                        return '[ ] dddd [{}] LT';
	                    default:
	                        return '[ ] dddd [{}] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        calendar : function (key, mom) {
	            var output = this._calendarEl[key],
	                hours = mom && mom.hours();
	            if (isFunction(output)) {
	                output = output.apply(mom);
	            }
	            return output.replace('{}', (hours % 12 === 1 ? '' : ''));
	        },
	        relativeTime : {
	            future : ' %s',
	            past : '%s ',
	            s : ' ',
	            m : ' ',
	            mm : '%d ',
	            h : ' ',
	            hh : '%d ',
	            d : ' ',
	            dd : '%d ',
	            M : ' ',
	            MM : '%d ',
	            y : ' ',
	            yy : '%d '
	        },
	        ordinalParse: /\d{1,2}/,
	        ordinal: '%d',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4st is the first week of the year.
	        }
	    });

	    return el;

	}));

/***/ },
/* 233 */
/*!**********************************!*\
  !*** ./~/moment/locale/en-au.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (Australia) [en-au]
	//! author : Jared Morse : https://github.com/jarcoal

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var en_au = moment.defineLocale('en-au', {
	        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY h:mm A',
	            LLLL : 'dddd, D MMMM YYYY h:mm A'
	        },
	        calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : '%s ago',
	            s : 'a few seconds',
	            m : 'a minute',
	            mm : '%d minutes',
	            h : 'an hour',
	            hh : '%d hours',
	            d : 'a day',
	            dd : '%d days',
	            M : 'a month',
	            MM : '%d months',
	            y : 'a year',
	            yy : '%d years'
	        },
	        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return en_au;

	}));

/***/ },
/* 234 */
/*!**********************************!*\
  !*** ./~/moment/locale/en-ca.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (Canada) [en-ca]
	//! author : Jonathan Abourbih : https://github.com/jonbca

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var en_ca = moment.defineLocale('en-ca', {
	        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'YYYY-MM-DD',
	            LL : 'MMMM D, YYYY',
	            LLL : 'MMMM D, YYYY h:mm A',
	            LLLL : 'dddd, MMMM D, YYYY h:mm A'
	        },
	        calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : '%s ago',
	            s : 'a few seconds',
	            m : 'a minute',
	            mm : '%d minutes',
	            h : 'an hour',
	            hh : '%d hours',
	            d : 'a day',
	            dd : '%d days',
	            M : 'a month',
	            MM : '%d months',
	            y : 'a year',
	            yy : '%d years'
	        },
	        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        }
	    });

	    return en_ca;

	}));

/***/ },
/* 235 */
/*!**********************************!*\
  !*** ./~/moment/locale/en-gb.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (United Kingdom) [en-gb]
	//! author : Chris Gedrim : https://github.com/chrisgedrim

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var en_gb = moment.defineLocale('en-gb', {
	        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : '%s ago',
	            s : 'a few seconds',
	            m : 'a minute',
	            mm : '%d minutes',
	            h : 'an hour',
	            hh : '%d hours',
	            d : 'a day',
	            dd : '%d days',
	            M : 'a month',
	            MM : '%d months',
	            y : 'a year',
	            yy : '%d years'
	        },
	        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return en_gb;

	}));

/***/ },
/* 236 */
/*!**********************************!*\
  !*** ./~/moment/locale/en-ie.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (Ireland) [en-ie]
	//! author : Chris Cartlidge : https://github.com/chriscartlidge

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var en_ie = moment.defineLocale('en-ie', {
	        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD-MM-YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : '%s ago',
	            s : 'a few seconds',
	            m : 'a minute',
	            mm : '%d minutes',
	            h : 'an hour',
	            hh : '%d hours',
	            d : 'a day',
	            dd : '%d days',
	            M : 'a month',
	            MM : '%d months',
	            y : 'a year',
	            yy : '%d years'
	        },
	        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return en_ie;

	}));

/***/ },
/* 237 */
/*!**********************************!*\
  !*** ./~/moment/locale/en-nz.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (New Zealand) [en-nz]
	//! author : Luke McGregor : https://github.com/lukemcgregor

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var en_nz = moment.defineLocale('en-nz', {
	        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY h:mm A',
	            LLLL : 'dddd, D MMMM YYYY h:mm A'
	        },
	        calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : '%s ago',
	            s : 'a few seconds',
	            m : 'a minute',
	            mm : '%d minutes',
	            h : 'an hour',
	            hh : '%d hours',
	            d : 'a day',
	            dd : '%d days',
	            M : 'a month',
	            MM : '%d months',
	            y : 'a year',
	            yy : '%d years'
	        },
	        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return en_nz;

	}));

/***/ },
/* 238 */
/*!*******************************!*\
  !*** ./~/moment/locale/eo.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Esperanto [eo]
	//! author : Colin Dean : https://github.com/colindean
	//! komento: Mi estas malcerta se mi korekte traktis akuzativojn en tiu traduko.
	//!          Se ne, bonvolu korekti kaj avizi min por ke mi povas lerni!

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var eo = moment.defineLocale('eo', {
	        months : 'januaro_februaro_marto_aprilo_majo_junio_julio_agusto_septembro_oktobro_novembro_decembro'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_ag_sep_okt_nov_dec'.split('_'),
	        weekdays : 'Dimano_Lundo_Mardo_Merkredo_ado_Vendredo_Sabato'.split('_'),
	        weekdaysShort : 'Dim_Lun_Mard_Merk_a_Ven_Sab'.split('_'),
	        weekdaysMin : 'Di_Lu_Ma_Me_a_Ve_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'D[-an de] MMMM, YYYY',
	            LLL : 'D[-an de] MMMM, YYYY HH:mm',
	            LLLL : 'dddd, [la] D[-an de] MMMM, YYYY HH:mm'
	        },
	        meridiemParse: /[ap]\.t\.m/i,
	        isPM: function (input) {
	            return input.charAt(0).toLowerCase() === 'p';
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours > 11) {
	                return isLower ? 'p.t.m.' : 'P.T.M.';
	            } else {
	                return isLower ? 'a.t.m.' : 'A.T.M.';
	            }
	        },
	        calendar : {
	            sameDay : '[Hodia je] LT',
	            nextDay : '[Morga je] LT',
	            nextWeek : 'dddd [je] LT',
	            lastDay : '[Hiera je] LT',
	            lastWeek : '[pasinta] dddd [je] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'je %s',
	            past : 'anta %s',
	            s : 'sekundoj',
	            m : 'minuto',
	            mm : '%d minutoj',
	            h : 'horo',
	            hh : '%d horoj',
	            d : 'tago',//ne 'diurno', ar estas uzita por proksimumo
	            dd : '%d tagoj',
	            M : 'monato',
	            MM : '%d monatoj',
	            y : 'jaro',
	            yy : '%d jaroj'
	        },
	        ordinalParse: /\d{1,2}a/,
	        ordinal : '%da',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return eo;

	}));

/***/ },
/* 239 */
/*!*******************************!*\
  !*** ./~/moment/locale/es.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Spanish [es]
	//! author : Julio Napur : https://github.com/julionc

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
	        monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

	    var es = moment.defineLocale('es', {
	        months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
	        monthsShort : function (m, format) {
	            if (/-MMM-/.test(format)) {
	                return monthsShort[m.month()];
	            } else {
	                return monthsShortDot[m.month()];
	            }
	        },
	        monthsParseExact : true,
	        weekdays : 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
	        weekdaysShort : 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
	        weekdaysMin : 'do_lu_ma_mi_ju_vi_s'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D [de] MMMM [de] YYYY',
	            LLL : 'D [de] MMMM [de] YYYY H:mm',
	            LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
	        },
	        calendar : {
	            sameDay : function () {
	                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            nextDay : function () {
	                return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            nextWeek : function () {
	                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            lastDay : function () {
	                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            lastWeek : function () {
	                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'en %s',
	            past : 'hace %s',
	            s : 'unos segundos',
	            m : 'un minuto',
	            mm : '%d minutos',
	            h : 'una hora',
	            hh : '%d horas',
	            d : 'un da',
	            dd : '%d das',
	            M : 'un mes',
	            MM : '%d meses',
	            y : 'un ao',
	            yy : '%d aos'
	        },
	        ordinalParse : /\d{1,2}/,
	        ordinal : '%d',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return es;

	}));

/***/ },
/* 240 */
/*!**********************************!*\
  !*** ./~/moment/locale/es-do.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Spanish (Dominican Republic) [es-do]

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
	        monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

	    var es_do = moment.defineLocale('es-do', {
	        months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
	        monthsShort : function (m, format) {
	            if (/-MMM-/.test(format)) {
	                return monthsShort[m.month()];
	            } else {
	                return monthsShortDot[m.month()];
	            }
	        },
	        monthsParseExact : true,
	        weekdays : 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
	        weekdaysShort : 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
	        weekdaysMin : 'do_lu_ma_mi_ju_vi_s'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D [de] MMMM [de] YYYY',
	            LLL : 'D [de] MMMM [de] YYYY h:mm A',
	            LLLL : 'dddd, D [de] MMMM [de] YYYY h:mm A'
	        },
	        calendar : {
	            sameDay : function () {
	                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            nextDay : function () {
	                return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            nextWeek : function () {
	                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            lastDay : function () {
	                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            lastWeek : function () {
	                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'en %s',
	            past : 'hace %s',
	            s : 'unos segundos',
	            m : 'un minuto',
	            mm : '%d minutos',
	            h : 'una hora',
	            hh : '%d horas',
	            d : 'un da',
	            dd : '%d das',
	            M : 'un mes',
	            MM : '%d meses',
	            y : 'un ao',
	            yy : '%d aos'
	        },
	        ordinalParse : /\d{1,2}/,
	        ordinal : '%d',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return es_do;

	}));

/***/ },
/* 241 */
/*!*******************************!*\
  !*** ./~/moment/locale/et.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Estonian [et]
	//! author : Henry Kehlmann : https://github.com/madhenry
	//! improvements : Illimar Tambek : https://github.com/ragulka

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            's' : ['mne sekundi', 'mni sekund', 'paar sekundit'],
	            'm' : ['he minuti', 'ks minut'],
	            'mm': [number + ' minuti', number + ' minutit'],
	            'h' : ['he tunni', 'tund aega', 'ks tund'],
	            'hh': [number + ' tunni', number + ' tundi'],
	            'd' : ['he peva', 'ks pev'],
	            'M' : ['kuu aja', 'kuu aega', 'ks kuu'],
	            'MM': [number + ' kuu', number + ' kuud'],
	            'y' : ['he aasta', 'aasta', 'ks aasta'],
	            'yy': [number + ' aasta', number + ' aastat']
	        };
	        if (withoutSuffix) {
	            return format[key][2] ? format[key][2] : format[key][1];
	        }
	        return isFuture ? format[key][0] : format[key][1];
	    }

	    var et = moment.defineLocale('et', {
	        months        : 'jaanuar_veebruar_mrts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
	        monthsShort   : 'jaan_veebr_mrts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
	        weekdays      : 'phapev_esmaspev_teisipev_kolmapev_neljapev_reede_laupev'.split('_'),
	        weekdaysShort : 'P_E_T_K_N_R_L'.split('_'),
	        weekdaysMin   : 'P_E_T_K_N_R_L'.split('_'),
	        longDateFormat : {
	            LT   : 'H:mm',
	            LTS : 'H:mm:ss',
	            L    : 'DD.MM.YYYY',
	            LL   : 'D. MMMM YYYY',
	            LLL  : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay  : '[Tna,] LT',
	            nextDay  : '[Homme,] LT',
	            nextWeek : '[Jrgmine] dddd LT',
	            lastDay  : '[Eile,] LT',
	            lastWeek : '[Eelmine] dddd LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s prast',
	            past   : '%s tagasi',
	            s      : processRelativeTime,
	            m      : processRelativeTime,
	            mm     : processRelativeTime,
	            h      : processRelativeTime,
	            hh     : processRelativeTime,
	            d      : processRelativeTime,
	            dd     : '%d peva',
	            M      : processRelativeTime,
	            MM     : processRelativeTime,
	            y      : processRelativeTime,
	            yy     : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return et;

	}));

/***/ },
/* 242 */
/*!*******************************!*\
  !*** ./~/moment/locale/eu.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Basque [eu]
	//! author : Eneko Illarramendi : https://github.com/eillarra

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var eu = moment.defineLocale('eu', {
	        months : 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
	        monthsShort : 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
	        weekdaysShort : 'ig._al._ar._az._og._ol._lr.'.split('_'),
	        weekdaysMin : 'ig_al_ar_az_og_ol_lr'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'YYYY[ko] MMMM[ren] D[a]',
	            LLL : 'YYYY[ko] MMMM[ren] D[a] HH:mm',
	            LLLL : 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
	            l : 'YYYY-M-D',
	            ll : 'YYYY[ko] MMM D[a]',
	            lll : 'YYYY[ko] MMM D[a] HH:mm',
	            llll : 'ddd, YYYY[ko] MMM D[a] HH:mm'
	        },
	        calendar : {
	            sameDay : '[gaur] LT[etan]',
	            nextDay : '[bihar] LT[etan]',
	            nextWeek : 'dddd LT[etan]',
	            lastDay : '[atzo] LT[etan]',
	            lastWeek : '[aurreko] dddd LT[etan]',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s barru',
	            past : 'duela %s',
	            s : 'segundo batzuk',
	            m : 'minutu bat',
	            mm : '%d minutu',
	            h : 'ordu bat',
	            hh : '%d ordu',
	            d : 'egun bat',
	            dd : '%d egun',
	            M : 'hilabete bat',
	            MM : '%d hilabete',
	            y : 'urte bat',
	            yy : '%d urte'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return eu;

	}));

/***/ },
/* 243 */
/*!*******************************!*\
  !*** ./~/moment/locale/fa.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Persian [fa]
	//! author : Ebrahim Byagowi : https://github.com/ebraminio

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var symbolMap = {
	        '1': '',
	        '2': '',
	        '3': '',
	        '4': '',
	        '5': '',
	        '6': '',
	        '7': '',
	        '8': '',
	        '9': '',
	        '0': ''
	    }, numberMap = {
	        '': '1',
	        '': '2',
	        '': '3',
	        '': '4',
	        '': '5',
	        '': '6',
	        '': '7',
	        '': '8',
	        '': '9',
	        '': '0'
	    };

	    var fa = moment.defineLocale('fa', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '\u200c__\u200c__\u200c__'.split('_'),
	        weekdaysShort : '\u200c__\u200c__\u200c__'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        meridiemParse: /  |  /,
	        isPM: function (input) {
	            return /  /.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return '  ';
	            } else {
	                return '  ';
	            }
	        },
	        calendar : {
	            sameDay : '[ ] LT',
	            nextDay : '[ ] LT',
	            nextWeek : 'dddd [] LT',
	            lastDay : '[ ] LT',
	            lastWeek : 'dddd [] [] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : '%s ',
	            s : ' ',
	            m : ' ',
	            mm : '%d ',
	            h : ' ',
	            hh : '%d ',
	            d : ' ',
	            dd : '%d ',
	            M : ' ',
	            MM : '%d ',
	            y : ' ',
	            yy : '%d '
	        },
	        preparse: function (string) {
	            return string.replace(/[-]/g, function (match) {
	                return numberMap[match];
	            }).replace(//g, ',');
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            }).replace(/,/g, '');
	        },
	        ordinalParse: /\d{1,2}/,
	        ordinal : '%d',
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12 // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return fa;

	}));

/***/ },
/* 244 */
/*!*******************************!*\
  !*** ./~/moment/locale/fi.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Finnish [fi]
	//! author : Tarmo Aidantausta : https://github.com/bleadof

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var numbersPast = 'nolla yksi kaksi kolme nelj viisi kuusi seitsemn kahdeksan yhdeksn'.split(' '),
	        numbersFuture = [
	            'nolla', 'yhden', 'kahden', 'kolmen', 'neljn', 'viiden', 'kuuden',
	            numbersPast[7], numbersPast[8], numbersPast[9]
	        ];
	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = '';
	        switch (key) {
	            case 's':
	                return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
	            case 'm':
	                return isFuture ? 'minuutin' : 'minuutti';
	            case 'mm':
	                result = isFuture ? 'minuutin' : 'minuuttia';
	                break;
	            case 'h':
	                return isFuture ? 'tunnin' : 'tunti';
	            case 'hh':
	                result = isFuture ? 'tunnin' : 'tuntia';
	                break;
	            case 'd':
	                return isFuture ? 'pivn' : 'piv';
	            case 'dd':
	                result = isFuture ? 'pivn' : 'piv';
	                break;
	            case 'M':
	                return isFuture ? 'kuukauden' : 'kuukausi';
	            case 'MM':
	                result = isFuture ? 'kuukauden' : 'kuukautta';
	                break;
	            case 'y':
	                return isFuture ? 'vuoden' : 'vuosi';
	            case 'yy':
	                result = isFuture ? 'vuoden' : 'vuotta';
	                break;
	        }
	        result = verbalNumber(number, isFuture) + ' ' + result;
	        return result;
	    }
	    function verbalNumber(number, isFuture) {
	        return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;
	    }

	    var fi = moment.defineLocale('fi', {
	        months : 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_keskuu_heinkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
	        monthsShort : 'tammi_helmi_maalis_huhti_touko_kes_hein_elo_syys_loka_marras_joulu'.split('_'),
	        weekdays : 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
	        weekdaysShort : 'su_ma_ti_ke_to_pe_la'.split('_'),
	        weekdaysMin : 'su_ma_ti_ke_to_pe_la'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD.MM.YYYY',
	            LL : 'Do MMMM[ta] YYYY',
	            LLL : 'Do MMMM[ta] YYYY, [klo] HH.mm',
	            LLLL : 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
	            l : 'D.M.YYYY',
	            ll : 'Do MMM YYYY',
	            lll : 'Do MMM YYYY, [klo] HH.mm',
	            llll : 'ddd, Do MMM YYYY, [klo] HH.mm'
	        },
	        calendar : {
	            sameDay : '[tnn] [klo] LT',
	            nextDay : '[huomenna] [klo] LT',
	            nextWeek : 'dddd [klo] LT',
	            lastDay : '[eilen] [klo] LT',
	            lastWeek : '[viime] dddd[na] [klo] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s pst',
	            past : '%s sitten',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return fi;

	}));

/***/ },
/* 245 */
/*!*******************************!*\
  !*** ./~/moment/locale/fo.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Faroese [fo]
	//! author : Ragnar Johannesen : https://github.com/ragnar123

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var fo = moment.defineLocale('fo', {
	        months : 'januar_februar_mars_aprl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
	        weekdays : 'sunnudagur_mnadagur_tsdagur_mikudagur_hsdagur_frggjadagur_leygardagur'.split('_'),
	        weekdaysShort : 'sun_mn_ts_mik_hs_fr_ley'.split('_'),
	        weekdaysMin : 'su_m_t_mi_h_fr_le'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D. MMMM, YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[ dag kl.] LT',
	            nextDay : '[ morgin kl.] LT',
	            nextWeek : 'dddd [kl.] LT',
	            lastDay : '[ gjr kl.] LT',
	            lastWeek : '[sstu] dddd [kl] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'um %s',
	            past : '%s sani',
	            s : 'f sekund',
	            m : 'ein minutt',
	            mm : '%d minuttir',
	            h : 'ein tmi',
	            hh : '%d tmar',
	            d : 'ein dagur',
	            dd : '%d dagar',
	            M : 'ein mnai',
	            MM : '%d mnair',
	            y : 'eitt r',
	            yy : '%d r'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return fo;

	}));

/***/ },
/* 246 */
/*!*******************************!*\
  !*** ./~/moment/locale/fr.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : French [fr]
	//! author : John Fischer : https://github.com/jfroffice

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var fr = moment.defineLocale('fr', {
	        months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
	        monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
	        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
	        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Aujourd\'hui ] LT',
	            nextDay: '[Demain ] LT',
	            nextWeek: 'dddd [] LT',
	            lastDay: '[Hier ] LT',
	            lastWeek: 'dddd [dernier ] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'dans %s',
	            past : 'il y a %s',
	            s : 'quelques secondes',
	            m : 'une minute',
	            mm : '%d minutes',
	            h : 'une heure',
	            hh : '%d heures',
	            d : 'un jour',
	            dd : '%d jours',
	            M : 'un mois',
	            MM : '%d mois',
	            y : 'un an',
	            yy : '%d ans'
	        },
	        ordinalParse: /\d{1,2}(er|)/,
	        ordinal : function (number) {
	            return number + (number === 1 ? 'er' : '');
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return fr;

	}));

/***/ },
/* 247 */
/*!**********************************!*\
  !*** ./~/moment/locale/fr-ca.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : French (Canada) [fr-ca]
	//! author : Jonathan Abourbih : https://github.com/jonbca

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var fr_ca = moment.defineLocale('fr-ca', {
	        months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
	        monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
	        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
	        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Aujourd\'hui ] LT',
	            nextDay: '[Demain ] LT',
	            nextWeek: 'dddd [] LT',
	            lastDay: '[Hier ] LT',
	            lastWeek: 'dddd [dernier ] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'dans %s',
	            past : 'il y a %s',
	            s : 'quelques secondes',
	            m : 'une minute',
	            mm : '%d minutes',
	            h : 'une heure',
	            hh : '%d heures',
	            d : 'un jour',
	            dd : '%d jours',
	            M : 'un mois',
	            MM : '%d mois',
	            y : 'un an',
	            yy : '%d ans'
	        },
	        ordinalParse: /\d{1,2}(er|e)/,
	        ordinal : function (number) {
	            return number + (number === 1 ? 'er' : 'e');
	        }
	    });

	    return fr_ca;

	}));

/***/ },
/* 248 */
/*!**********************************!*\
  !*** ./~/moment/locale/fr-ch.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : French (Switzerland) [fr-ch]
	//! author : Gaspard Bucher : https://github.com/gaspard

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var fr_ch = moment.defineLocale('fr-ch', {
	        months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
	        monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
	        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
	        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Aujourd\'hui ] LT',
	            nextDay: '[Demain ] LT',
	            nextWeek: 'dddd [] LT',
	            lastDay: '[Hier ] LT',
	            lastWeek: 'dddd [dernier ] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'dans %s',
	            past : 'il y a %s',
	            s : 'quelques secondes',
	            m : 'une minute',
	            mm : '%d minutes',
	            h : 'une heure',
	            hh : '%d heures',
	            d : 'un jour',
	            dd : '%d jours',
	            M : 'un mois',
	            MM : '%d mois',
	            y : 'un an',
	            yy : '%d ans'
	        },
	        ordinalParse: /\d{1,2}(er|e)/,
	        ordinal : function (number) {
	            return number + (number === 1 ? 'er' : 'e');
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return fr_ch;

	}));

/***/ },
/* 249 */
/*!*******************************!*\
  !*** ./~/moment/locale/fy.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Frisian [fy]
	//! author : Robin van der Vliet : https://github.com/robin0van0der0v

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_'),
	        monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');

	    var fy = moment.defineLocale('fy', {
	        months : 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),
	        monthsShort : function (m, format) {
	            if (/-MMM-/.test(format)) {
	                return monthsShortWithoutDots[m.month()];
	            } else {
	                return monthsShortWithDots[m.month()];
	            }
	        },
	        monthsParseExact : true,
	        weekdays : 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
	        weekdaysShort : 'si._mo._ti._wo._to._fr._so.'.split('_'),
	        weekdaysMin : 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD-MM-YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[hjoed om] LT',
	            nextDay: '[moarn om] LT',
	            nextWeek: 'dddd [om] LT',
	            lastDay: '[juster om] LT',
	            lastWeek: '[frne] dddd [om] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'oer %s',
	            past : '%s lyn',
	            s : 'in pear sekonden',
	            m : 'ien mint',
	            mm : '%d minuten',
	            h : 'ien oere',
	            hh : '%d oeren',
	            d : 'ien dei',
	            dd : '%d dagen',
	            M : 'ien moanne',
	            MM : '%d moannen',
	            y : 'ien jier',
	            yy : '%d jierren'
	        },
	        ordinalParse: /\d{1,2}(ste|de)/,
	        ordinal : function (number) {
	            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return fy;

	}));

/***/ },
/* 250 */
/*!*******************************!*\
  !*** ./~/moment/locale/gd.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Scottish Gaelic [gd]
	//! author : Jon Ashdown : https://github.com/jonashdown

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var months = [
	        'Am Faoilleach', 'An Gearran', 'Am Mrt', 'An Giblean', 'An Citean', 'An t-gmhios', 'An t-Iuchar', 'An Lnastal', 'An t-Sultain', 'An Dmhair', 'An t-Samhain', 'An Dbhlachd'
	    ];

	    var monthsShort = ['Faoi', 'Gear', 'Mrt', 'Gibl', 'Cit', 'gmh', 'Iuch', 'Ln', 'Sult', 'Dmh', 'Samh', 'Dbh'];

	    var weekdays = ['Didmhnaich', 'Diluain', 'Dimirt', 'Diciadain', 'Diardaoin', 'Dihaoine', 'Disathairne'];

	    var weekdaysShort = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'];

	    var weekdaysMin = ['D', 'Lu', 'M', 'Ci', 'Ar', 'Ha', 'Sa'];

	    var gd = moment.defineLocale('gd', {
	        months : months,
	        monthsShort : monthsShort,
	        monthsParseExact : true,
	        weekdays : weekdays,
	        weekdaysShort : weekdaysShort,
	        weekdaysMin : weekdaysMin,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[An-diugh aig] LT',
	            nextDay : '[A-mireach aig] LT',
	            nextWeek : 'dddd [aig] LT',
	            lastDay : '[An-d aig] LT',
	            lastWeek : 'dddd [seo chaidh] [aig] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'ann an %s',
	            past : 'bho chionn %s',
	            s : 'beagan diogan',
	            m : 'mionaid',
	            mm : '%d mionaidean',
	            h : 'uair',
	            hh : '%d uairean',
	            d : 'latha',
	            dd : '%d latha',
	            M : 'mos',
	            MM : '%d mosan',
	            y : 'bliadhna',
	            yy : '%d bliadhna'
	        },
	        ordinalParse : /\d{1,2}(d|na|mh)/,
	        ordinal : function (number) {
	            var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return gd;

	}));

/***/ },
/* 251 */
/*!*******************************!*\
  !*** ./~/moment/locale/gl.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Galician [gl]
	//! author : Juan G. Hurtado : https://github.com/juanghurtado

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var gl = moment.defineLocale('gl', {
	        months : 'xaneiro_febreiro_marzo_abril_maio_xuo_xullo_agosto_setembro_outubro_novembro_decembro'.split('_'),
	        monthsShort : 'xan._feb._mar._abr._mai._xu._xul._ago._set._out._nov._dec.'.split('_'),
	        monthsParseExact: true,
	        weekdays : 'domingo_luns_martes_mrcores_xoves_venres_sbado'.split('_'),
	        weekdaysShort : 'dom._lun._mar._mr._xov._ven._sb.'.split('_'),
	        weekdaysMin : 'do_lu_ma_m_xo_ve_s'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D [de] MMMM [de] YYYY',
	            LLL : 'D [de] MMMM [de] YYYY H:mm',
	            LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
	        },
	        calendar : {
	            sameDay : function () {
	                return '[hoxe ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            nextDay : function () {
	                return '[ma ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            nextWeek : function () {
	                return 'dddd [' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
	            },
	            lastDay : function () {
	                return '[onte ' + ((this.hours() !== 1) ? '' : 'a') + '] LT';
	            },
	            lastWeek : function () {
	                return '[o] dddd [pasado ' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : function (str) {
	                if (str.indexOf('un') === 0) {
	                    return 'n' + str;
	                }
	                return 'en ' + str;
	            },
	            past : 'hai %s',
	            s : 'uns segundos',
	            m : 'un minuto',
	            mm : '%d minutos',
	            h : 'unha hora',
	            hh : '%d horas',
	            d : 'un da',
	            dd : '%d das',
	            M : 'un mes',
	            MM : '%d meses',
	            y : 'un ano',
	            yy : '%d anos'
	        },
	        ordinalParse : /\d{1,2}/,
	        ordinal : '%d',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return gl;

	}));

/***/ },
/* 252 */
/*!*******************************!*\
  !*** ./~/moment/locale/he.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Hebrew [he]
	//! author : Tomer Cohen : https://github.com/tomer
	//! author : Moshe Simantov : https://github.com/DevelopmentIL
	//! author : Tal Ater : https://github.com/TalAter

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var he = moment.defineLocale('he', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D []MMMM YYYY',
	            LLL : 'D []MMMM YYYY HH:mm',
	            LLLL : 'dddd, D []MMMM YYYY HH:mm',
	            l : 'D/M/YYYY',
	            ll : 'D MMM YYYY',
	            lll : 'D MMM YYYY HH:mm',
	            llll : 'ddd, D MMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[ ]LT',
	            nextDay : '[ ]LT',
	            nextWeek : 'dddd [] LT',
	            lastDay : '[ ]LT',
	            lastWeek : '[] dddd [ ] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : ' %s',
	            s : ' ',
	            m : '',
	            mm : '%d ',
	            h : '',
	            hh : function (number) {
	                if (number === 2) {
	                    return '';
	                }
	                return number + ' ';
	            },
	            d : '',
	            dd : function (number) {
	                if (number === 2) {
	                    return '';
	                }
	                return number + ' ';
	            },
	            M : '',
	            MM : function (number) {
	                if (number === 2) {
	                    return '';
	                }
	                return number + ' ';
	            },
	            y : '',
	            yy : function (number) {
	                if (number === 2) {
	                    return '';
	                } else if (number % 10 === 0 && number !== 10) {
	                    return number + ' ';
	                }
	                return number + ' ';
	            }
	        },
	        meridiemParse: /"|"| | | ||/i,
	        isPM : function (input) {
	            return /^("| |)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 5) {
	                return ' ';
	            } else if (hour < 10) {
	                return '';
	            } else if (hour < 12) {
	                return isLower ? '"' : ' ';
	            } else if (hour < 18) {
	                return isLower ? '"' : ' ';
	            } else {
	                return '';
	            }
	        }
	    });

	    return he;

	}));

/***/ },
/* 253 */
/*!*******************************!*\
  !*** ./~/moment/locale/hi.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Hindi [hi]
	//! author : Mayank Singhal : https://github.com/mayanksinghal

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var symbolMap = {
	        '1': '',
	        '2': '',
	        '3': '',
	        '4': '',
	        '5': '',
	        '6': '',
	        '7': '',
	        '8': '',
	        '9': '',
	        '0': ''
	    },
	    numberMap = {
	        '': '1',
	        '': '2',
	        '': '3',
	        '': '4',
	        '': '5',
	        '': '6',
	        '': '7',
	        '': '8',
	        '': '9',
	        '': '0'
	    };

	    var hi = moment.defineLocale('hi', {
	        months : '___________'.split('_'),
	        monthsShort : '._.__.___._._._._._.'.split('_'),
	        monthsParseExact: true,
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm ',
	            LTS : 'A h:mm:ss ',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm ',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm '
	        },
	        calendar : {
	            sameDay : '[] LT',
	            nextDay : '[] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[] LT',
	            lastWeek : '[] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ',
	            past : '%s ',
	            s : '  ',
	            m : ' ',
	            mm : '%d ',
	            h : ' ',
	            hh : '%d ',
	            d : ' ',
	            dd : '%d ',
	            M : ' ',
	            MM : '%d ',
	            y : ' ',
	            yy : '%d '
	        },
	        preparse: function (string) {
	            return string.replace(/[]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        // Hindi notation for meridiems are quite fuzzy in practice. While there exists
	        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
	        meridiemParse: /|||/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === '') {
	                return hour < 4 ? hour : hour + 12;
	            } else if (meridiem === '') {
	                return hour;
	            } else if (meridiem === '') {
	                return hour >= 10 ? hour : hour + 12;
	            } else if (meridiem === '') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return '';
	            } else if (hour < 10) {
	                return '';
	            } else if (hour < 17) {
	                return '';
	            } else if (hour < 20) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return hi;

	}));

/***/ },
/* 254 */
/*!*******************************!*\
  !*** ./~/moment/locale/hr.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Croatian [hr]
	//! author : Bojan Markovi : https://github.com/bmarkovic

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function translate(number, withoutSuffix, key) {
	        var result = number + ' ';
	        switch (key) {
	            case 'm':
	                return withoutSuffix ? 'jedna minuta' : 'jedne minute';
	            case 'mm':
	                if (number === 1) {
	                    result += 'minuta';
	                } else if (number === 2 || number === 3 || number === 4) {
	                    result += 'minute';
	                } else {
	                    result += 'minuta';
	                }
	                return result;
	            case 'h':
	                return withoutSuffix ? 'jedan sat' : 'jednog sata';
	            case 'hh':
	                if (number === 1) {
	                    result += 'sat';
	                } else if (number === 2 || number === 3 || number === 4) {
	                    result += 'sata';
	                } else {
	                    result += 'sati';
	                }
	                return result;
	            case 'dd':
	                if (number === 1) {
	                    result += 'dan';
	                } else {
	                    result += 'dana';
	                }
	                return result;
	            case 'MM':
	                if (number === 1) {
	                    result += 'mjesec';
	                } else if (number === 2 || number === 3 || number === 4) {
	                    result += 'mjeseca';
	                } else {
	                    result += 'mjeseci';
	                }
	                return result;
	            case 'yy':
	                if (number === 1) {
	                    result += 'godina';
	                } else if (number === 2 || number === 3 || number === 4) {
	                    result += 'godine';
	                } else {
	                    result += 'godina';
	                }
	                return result;
	        }
	    }

	    var hr = moment.defineLocale('hr', {
	        months : {
	            format: 'sijenja_veljae_oujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split('_'),
	            standalone: 'sijeanj_veljaa_oujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_')
	        },
	        monthsShort : 'sij._velj._ou._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
	        monthsParseExact: true,
	        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
	        weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
	        weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay  : '[danas u] LT',
	            nextDay  : '[sutra u] LT',
	            nextWeek : function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[u] [nedjelju] [u] LT';
	                    case 3:
	                        return '[u] [srijedu] [u] LT';
	                    case 6:
	                        return '[u] [subotu] [u] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                    case 5:
	                        return '[u] dddd [u] LT';
	                }
	            },
	            lastDay  : '[juer u] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                    case 0:
	                    case 3:
	                        return '[prolu] dddd [u] LT';
	                    case 6:
	                        return '[prole] [subote] [u] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                    case 5:
	                        return '[proli] dddd [u] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past   : 'prije %s',
	            s      : 'par sekundi',
	            m      : translate,
	            mm     : translate,
	            h      : translate,
	            hh     : translate,
	            d      : 'dan',
	            dd     : translate,
	            M      : 'mjesec',
	            MM     : translate,
	            y      : 'godinu',
	            yy     : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return hr;

	}));

/***/ },
/* 255 */
/*!*******************************!*\
  !*** ./~/moment/locale/hu.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Hungarian [hu]
	//! author : Adam Brunner : https://github.com/adambrunner

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var weekEndings = 'vasrnap htfn kedden szerdn cstrtkn pnteken szombaton'.split(' ');
	    function translate(number, withoutSuffix, key, isFuture) {
	        var num = number,
	            suffix;
	        switch (key) {
	            case 's':
	                return (isFuture || withoutSuffix) ? 'nhny msodperc' : 'nhny msodperce';
	            case 'm':
	                return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
	            case 'mm':
	                return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
	            case 'h':
	                return 'egy' + (isFuture || withoutSuffix ? ' ra' : ' rja');
	            case 'hh':
	                return num + (isFuture || withoutSuffix ? ' ra' : ' rja');
	            case 'd':
	                return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
	            case 'dd':
	                return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
	            case 'M':
	                return 'egy' + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
	            case 'MM':
	                return num + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
	            case 'y':
	                return 'egy' + (isFuture || withoutSuffix ? ' v' : ' ve');
	            case 'yy':
	                return num + (isFuture || withoutSuffix ? ' v' : ' ve');
	        }
	        return '';
	    }
	    function week(isFuture) {
	        return (isFuture ? '' : '[mlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
	    }

	    var hu = moment.defineLocale('hu', {
	        months : 'janur_februr_mrcius_prilis_mjus_jnius_jlius_augusztus_szeptember_oktber_november_december'.split('_'),
	        monthsShort : 'jan_feb_mrc_pr_mj_jn_jl_aug_szept_okt_nov_dec'.split('_'),
	        weekdays : 'vasrnap_htf_kedd_szerda_cstrtk_pntek_szombat'.split('_'),
	        weekdaysShort : 'vas_ht_kedd_sze_cst_pn_szo'.split('_'),
	        weekdaysMin : 'v_h_k_sze_cs_p_szo'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'YYYY.MM.DD.',
	            LL : 'YYYY. MMMM D.',
	            LLL : 'YYYY. MMMM D. H:mm',
	            LLLL : 'YYYY. MMMM D., dddd H:mm'
	        },
	        meridiemParse: /de|du/i,
	        isPM: function (input) {
	            return input.charAt(1).toLowerCase() === 'u';
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 12) {
	                return isLower === true ? 'de' : 'DE';
	            } else {
	                return isLower === true ? 'du' : 'DU';
	            }
	        },
	        calendar : {
	            sameDay : '[ma] LT[-kor]',
	            nextDay : '[holnap] LT[-kor]',
	            nextWeek : function () {
	                return week.call(this, true);
	            },
	            lastDay : '[tegnap] LT[-kor]',
	            lastWeek : function () {
	                return week.call(this, false);
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s mlva',
	            past : '%s',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return hu;

	}));

/***/ },
/* 256 */
/*!**********************************!*\
  !*** ./~/moment/locale/hy-am.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Armenian [hy-am]
	//! author : Armendarabyan : https://github.com/armendarabyan

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var hy_am = moment.defineLocale('hy-am', {
	        months : {
	            format: '___________'.split('_'),
	            standalone: '___________'.split('_')
	        },
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY .',
	            LLL : 'D MMMM YYYY ., HH:mm',
	            LLLL : 'dddd, D MMMM YYYY ., HH:mm'
	        },
	        calendar : {
	            sameDay: '[] LT',
	            nextDay: '[] LT',
	            lastDay: '[] LT',
	            nextWeek: function () {
	                return 'dddd [ ] LT';
	            },
	            lastWeek: function () {
	                return '[] dddd [ ] LT';
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : '%s ',
	            past : '%s ',
	            s : '  ',
	            m : '',
	            mm : '%d ',
	            h : '',
	            hh : '%d ',
	            d : '',
	            dd : '%d ',
	            M : '',
	            MM : '%d ',
	            y : '',
	            yy : '%d '
	        },
	        meridiemParse: /|||/,
	        isPM: function (input) {
	            return /^(|)$/.test(input);
	        },
	        meridiem : function (hour) {
	            if (hour < 4) {
	                return '';
	            } else if (hour < 12) {
	                return '';
	            } else if (hour < 17) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        ordinalParse: /\d{1,2}|\d{1,2}-(|)/,
	        ordinal: function (number, period) {
	            switch (period) {
	                case 'DDD':
	                case 'w':
	                case 'W':
	                case 'DDDo':
	                    if (number === 1) {
	                        return number + '-';
	                    }
	                    return number + '-';
	                default:
	                    return number;
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return hy_am;

	}));

/***/ },
/* 257 */
/*!*******************************!*\
  !*** ./~/moment/locale/id.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Indonesian [id]
	//! author : Mohammad Satrio Utomo : https://github.com/tyok
	//! reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var id = moment.defineLocale('id', {
	        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des'.split('_'),
	        weekdays : 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
	        weekdaysShort : 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
	        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY [pukul] HH.mm',
	            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	        },
	        meridiemParse: /pagi|siang|sore|malam/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'pagi') {
	                return hour;
	            } else if (meridiem === 'siang') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === 'sore' || meridiem === 'malam') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 11) {
	                return 'pagi';
	            } else if (hours < 15) {
	                return 'siang';
	            } else if (hours < 19) {
	                return 'sore';
	            } else {
	                return 'malam';
	            }
	        },
	        calendar : {
	            sameDay : '[Hari ini pukul] LT',
	            nextDay : '[Besok pukul] LT',
	            nextWeek : 'dddd [pukul] LT',
	            lastDay : '[Kemarin pukul] LT',
	            lastWeek : 'dddd [lalu pukul] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'dalam %s',
	            past : '%s yang lalu',
	            s : 'beberapa detik',
	            m : 'semenit',
	            mm : '%d menit',
	            h : 'sejam',
	            hh : '%d jam',
	            d : 'sehari',
	            dd : '%d hari',
	            M : 'sebulan',
	            MM : '%d bulan',
	            y : 'setahun',
	            yy : '%d tahun'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return id;

	}));

/***/ },
/* 258 */
/*!*******************************!*\
  !*** ./~/moment/locale/is.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Icelandic [is]
	//! author : Hinrik rn Sigursson : https://github.com/hinrik

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function plural(n) {
	        if (n % 100 === 11) {
	            return true;
	        } else if (n % 10 === 1) {
	            return false;
	        }
	        return true;
	    }
	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        switch (key) {
	            case 's':
	                return withoutSuffix || isFuture ? 'nokkrar sekndur' : 'nokkrum sekndum';
	            case 'm':
	                return withoutSuffix ? 'mnta' : 'mntu';
	            case 'mm':
	                if (plural(number)) {
	                    return result + (withoutSuffix || isFuture ? 'mntur' : 'mntum');
	                } else if (withoutSuffix) {
	                    return result + 'mnta';
	                }
	                return result + 'mntu';
	            case 'hh':
	                if (plural(number)) {
	                    return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
	                }
	                return result + 'klukkustund';
	            case 'd':
	                if (withoutSuffix) {
	                    return 'dagur';
	                }
	                return isFuture ? 'dag' : 'degi';
	            case 'dd':
	                if (plural(number)) {
	                    if (withoutSuffix) {
	                        return result + 'dagar';
	                    }
	                    return result + (isFuture ? 'daga' : 'dgum');
	                } else if (withoutSuffix) {
	                    return result + 'dagur';
	                }
	                return result + (isFuture ? 'dag' : 'degi');
	            case 'M':
	                if (withoutSuffix) {
	                    return 'mnuur';
	                }
	                return isFuture ? 'mnu' : 'mnui';
	            case 'MM':
	                if (plural(number)) {
	                    if (withoutSuffix) {
	                        return result + 'mnuir';
	                    }
	                    return result + (isFuture ? 'mnui' : 'mnuum');
	                } else if (withoutSuffix) {
	                    return result + 'mnuur';
	                }
	                return result + (isFuture ? 'mnu' : 'mnui');
	            case 'y':
	                return withoutSuffix || isFuture ? 'r' : 'ri';
	            case 'yy':
	                if (plural(number)) {
	                    return result + (withoutSuffix || isFuture ? 'r' : 'rum');
	                }
	                return result + (withoutSuffix || isFuture ? 'r' : 'ri');
	        }
	    }

	    var is = moment.defineLocale('is', {
	        months : 'janar_febrar_mars_aprl_ma_jn_jl_gst_september_oktber_nvember_desember'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_ma_jn_jl_g_sep_okt_nv_des'.split('_'),
	        weekdays : 'sunnudagur_mnudagur_rijudagur_mivikudagur_fimmtudagur_fstudagur_laugardagur'.split('_'),
	        weekdaysShort : 'sun_mn_ri_mi_fim_fs_lau'.split('_'),
	        weekdaysMin : 'Su_M_r_Mi_Fi_F_La'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY [kl.] H:mm',
	            LLLL : 'dddd, D. MMMM YYYY [kl.] H:mm'
	        },
	        calendar : {
	            sameDay : '[ dag kl.] LT',
	            nextDay : '[ morgun kl.] LT',
	            nextWeek : 'dddd [kl.] LT',
	            lastDay : '[ gr kl.] LT',
	            lastWeek : '[sasta] dddd [kl.] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'eftir %s',
	            past : 'fyrir %s san',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : 'klukkustund',
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return is;

	}));

/***/ },
/* 259 */
/*!*******************************!*\
  !*** ./~/moment/locale/it.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Italian [it]
	//! author : Lorenzo : https://github.com/aliem
	//! author: Mattia Larentis: https://github.com/nostalgiaz

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var it = moment.defineLocale('it', {
	        months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
	        monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
	        weekdays : 'Domenica_Luned_Marted_Mercoled_Gioved_Venerd_Sabato'.split('_'),
	        weekdaysShort : 'Dom_Lun_Mar_Mer_Gio_Ven_Sab'.split('_'),
	        weekdaysMin : 'Do_Lu_Ma_Me_Gi_Ve_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Oggi alle] LT',
	            nextDay: '[Domani alle] LT',
	            nextWeek: 'dddd [alle] LT',
	            lastDay: '[Ieri alle] LT',
	            lastWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[la scorsa] dddd [alle] LT';
	                    default:
	                        return '[lo scorso] dddd [alle] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : function (s) {
	                return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
	            },
	            past : '%s fa',
	            s : 'alcuni secondi',
	            m : 'un minuto',
	            mm : '%d minuti',
	            h : 'un\'ora',
	            hh : '%d ore',
	            d : 'un giorno',
	            dd : '%d giorni',
	            M : 'un mese',
	            MM : '%d mesi',
	            y : 'un anno',
	            yy : '%d anni'
	        },
	        ordinalParse : /\d{1,2}/,
	        ordinal: '%d',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return it;

	}));

/***/ },
/* 260 */
/*!*******************************!*\
  !*** ./~/moment/locale/ja.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Japanese [ja]
	//! author : LI Long : https://github.com/baryon

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var ja = moment.defineLocale('ja', {
	        months : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'Ahm',
	            LTS : 'Ahms',
	            L : 'YYYY/MM/DD',
	            LL : 'YYYYMD',
	            LLL : 'YYYYMDAhm',
	            LLLL : 'YYYYMDAhm dddd'
	        },
	        meridiemParse: /|/i,
	        isPM : function (input) {
	            return input === '';
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        calendar : {
	            sameDay : '[] LT',
	            nextDay : '[] LT',
	            nextWeek : '[]dddd LT',
	            lastDay : '[] LT',
	            lastWeek : '[]dddd LT',
	            sameElse : 'L'
	        },
	        ordinalParse : /\d{1,2}/,
	        ordinal : function (number, period) {
	            switch (period) {
	                case 'd':
	                case 'D':
	                case 'DDD':
	                    return number + '';
	                default:
	                    return number;
	            }
	        },
	        relativeTime : {
	            future : '%s',
	            past : '%s',
	            s : '',
	            m : '1',
	            mm : '%d',
	            h : '1',
	            hh : '%d',
	            d : '1',
	            dd : '%d',
	            M : '1',
	            MM : '%d',
	            y : '1',
	            yy : '%d'
	        }
	    });

	    return ja;

	}));

/***/ },
/* 261 */
/*!*******************************!*\
  !*** ./~/moment/locale/jv.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Javanese [jv]
	//! author : Rony Lantip : https://github.com/lantip
	//! reference: http://jv.wikipedia.org/wiki/Basa_Jawa

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var jv = moment.defineLocale('jv', {
	        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
	        weekdays : 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
	        weekdaysShort : 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
	        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY [pukul] HH.mm',
	            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	        },
	        meridiemParse: /enjing|siyang|sonten|ndalu/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'enjing') {
	                return hour;
	            } else if (meridiem === 'siyang') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 11) {
	                return 'enjing';
	            } else if (hours < 15) {
	                return 'siyang';
	            } else if (hours < 19) {
	                return 'sonten';
	            } else {
	                return 'ndalu';
	            }
	        },
	        calendar : {
	            sameDay : '[Dinten puniko pukul] LT',
	            nextDay : '[Mbenjang pukul] LT',
	            nextWeek : 'dddd [pukul] LT',
	            lastDay : '[Kala wingi pukul] LT',
	            lastWeek : 'dddd [kepengker pukul] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'wonten ing %s',
	            past : '%s ingkang kepengker',
	            s : 'sawetawis detik',
	            m : 'setunggal menit',
	            mm : '%d menit',
	            h : 'setunggal jam',
	            hh : '%d jam',
	            d : 'sedinten',
	            dd : '%d dinten',
	            M : 'sewulan',
	            MM : '%d wulan',
	            y : 'setaun',
	            yy : '%d taun'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return jv;

	}));

/***/ },
/* 262 */
/*!*******************************!*\
  !*** ./~/moment/locale/ka.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Georgian [ka]
	//! author : Irakli Janiashvili : https://github.com/irakli-janiashvili

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var ka = moment.defineLocale('ka', {
	        months : {
	            standalone: '___________'.split('_'),
	            format: '___________'.split('_')
	        },
	        monthsShort : '___________'.split('_'),
	        weekdays : {
	            standalone: '______'.split('_'),
	            format: '______'.split('_'),
	            isFormat: /(|)/
	        },
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY h:mm A',
	            LLLL : 'dddd, D MMMM YYYY h:mm A'
	        },
	        calendar : {
	            sameDay : '[] LT[-]',
	            nextDay : '[] LT[-]',
	            lastDay : '[] LT[-]',
	            nextWeek : '[] dddd LT[-]',
	            lastWeek : '[] dddd LT-',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : function (s) {
	                return (/(|||)/).test(s) ?
	                    s.replace(/$/, '') :
	                    s + '';
	            },
	            past : function (s) {
	                if ((/(||||)/).test(s)) {
	                    return s.replace(/(|)$/, ' ');
	                }
	                if ((//).test(s)) {
	                    return s.replace(/$/, ' ');
	                }
	            },
	            s : ' ',
	            m : '',
	            mm : '%d ',
	            h : '',
	            hh : '%d ',
	            d : '',
	            dd : '%d ',
	            M : '',
	            MM : '%d ',
	            y : '',
	            yy : '%d '
	        },
	        ordinalParse: /0|1-|-\d{1,2}|\d{1,2}-/,
	        ordinal : function (number) {
	            if (number === 0) {
	                return number;
	            }
	            if (number === 1) {
	                return number + '-';
	            }
	            if ((number < 20) || (number <= 100 && (number % 20 === 0)) || (number % 100 === 0)) {
	                return '-' + number;
	            }
	            return number + '-';
	        },
	        week : {
	            dow : 1,
	            doy : 7
	        }
	    });

	    return ka;

	}));

/***/ },
/* 263 */
/*!*******************************!*\
  !*** ./~/moment/locale/kk.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Kazakh [kk]
	//! authors : Nurlan Rakhimzhanov : https://github.com/nurlan

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var suffixes = {
	        0: '-',
	        1: '-',
	        2: '-',
	        3: '-',
	        4: '-',
	        5: '-',
	        6: '-',
	        7: '-',
	        8: '-',
	        9: '-',
	        10: '-',
	        20: '-',
	        30: '-',
	        40: '-',
	        50: '-',
	        60: '-',
	        70: '-',
	        80: '-',
	        90: '-',
	        100: '-'
	    };

	    var kk = moment.defineLocale('kk', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[ ] LT',
	            nextDay : '[ ] LT',
	            nextWeek : 'dddd [] LT',
	            lastDay : '[ ] LT',
	            lastWeek : '[ ] dddd [] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ',
	            past : '%s ',
	            s : ' ',
	            m : ' ',
	            mm : '%d ',
	            h : ' ',
	            hh : '%d ',
	            d : ' ',
	            dd : '%d ',
	            M : ' ',
	            MM : '%d ',
	            y : ' ',
	            yy : '%d '
	        },
	        ordinalParse: /\d{1,2}-(|)/,
	        ordinal : function (number) {
	            var a = number % 10,
	                b = number >= 100 ? 100 : null;
	            return number + (suffixes[number] || suffixes[a] || suffixes[b]);
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return kk;

	}));

/***/ },
/* 264 */
/*!*******************************!*\
  !*** ./~/moment/locale/km.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Cambodian [km]
	//! author : Kruy Vanna : https://github.com/kruyvanna

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var km = moment.defineLocale('km', {
	        months: '___________'.split('_'),
	        monthsShort: '___________'.split('_'),
	        weekdays: '______'.split('_'),
	        weekdaysShort: '______'.split('_'),
	        weekdaysMin: '______'.split('_'),
	        longDateFormat: {
	            LT: 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L: 'DD/MM/YYYY',
	            LL: 'D MMMM YYYY',
	            LLL: 'D MMMM YYYY HH:mm',
	            LLLL: 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar: {
	            sameDay: '[ ] LT',
	            nextDay: '[ ] LT',
	            nextWeek: 'dddd [] LT',
	            lastDay: '[ ] LT',
	            lastWeek: 'dddd [] [] LT',
	            sameElse: 'L'
	        },
	        relativeTime: {
	            future: '%s',
	            past: '%s',
	            s: '',
	            m: '',
	            mm: '%d ',
	            h: '',
	            hh: '%d ',
	            d: '',
	            dd: '%d ',
	            M: '',
	            MM: '%d ',
	            y: '',
	            yy: '%d '
	        },
	        week: {
	            dow: 1, // Monday is the first day of the week.
	            doy: 4 // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return km;

	}));

/***/ },
/* 265 */
/*!*******************************!*\
  !*** ./~/moment/locale/ko.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Korean [ko]
	//! author : Kyungwook, Park : https://github.com/kyungw00k
	//! author : Jeeeyul Lee <jeeeyul@gmail.com>

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var ko = moment.defineLocale('ko', {
	        months : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'A h m',
	            LTS : 'A h m s',
	            L : 'YYYY.MM.DD',
	            LL : 'YYYY MMMM D',
	            LLL : 'YYYY MMMM D A h m',
	            LLLL : 'YYYY MMMM D dddd A h m'
	        },
	        calendar : {
	            sameDay : ' LT',
	            nextDay : ' LT',
	            nextWeek : 'dddd LT',
	            lastDay : ' LT',
	            lastWeek : ' dddd LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ',
	            past : '%s ',
	            s : ' ',
	            ss : '%d',
	            m : '',
	            mm : '%d',
	            h : ' ',
	            hh : '%d',
	            d : '',
	            dd : '%d',
	            M : ' ',
	            MM : '%d',
	            y : ' ',
	            yy : '%d'
	        },
	        ordinalParse : /\d{1,2}/,
	        ordinal : '%d',
	        meridiemParse : /|/,
	        isPM : function (token) {
	            return token === '';
	        },
	        meridiem : function (hour, minute, isUpper) {
	            return hour < 12 ? '' : '';
	        }
	    });

	    return ko;

	}));

/***/ },
/* 266 */
/*!*******************************!*\
  !*** ./~/moment/locale/ky.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Kyrgyz [ky]
	//! author : Chyngyz Arystan uulu : https://github.com/chyngyz

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';



	    var suffixes = {
	        0: '-',
	        1: '-',
	        2: '-',
	        3: '-',
	        4: '-',
	        5: '-',
	        6: '-',
	        7: '-',
	        8: '-',
	        9: '-',
	        10: '-',
	        20: '-',
	        30: '-',
	        40: '-',
	        50: '-',
	        60: '-',
	        70: '-',
	        80: '-',
	        90: '-',
	        100: '-'
	    };

	    var ky = moment.defineLocale('ky', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[ ] LT',
	            nextDay : '[ ] LT',
	            nextWeek : 'dddd [] LT',
	            lastDay : '[ ] LT',
	            lastWeek : '[ ] dddd [] [] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ',
	            past : '%s ',
	            s : ' ',
	            m : ' ',
	            mm : '%d ',
	            h : ' ',
	            hh : '%d ',
	            d : ' ',
	            dd : '%d ',
	            M : ' ',
	            MM : '%d ',
	            y : ' ',
	            yy : '%d '
	        },
	        ordinalParse: /\d{1,2}-(|||)/,
	        ordinal : function (number) {
	            var a = number % 10,
	                b = number >= 100 ? 100 : null;
	            return number + (suffixes[number] || suffixes[a] || suffixes[b]);
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return ky;

	}));

/***/ },
/* 267 */
/*!*******************************!*\
  !*** ./~/moment/locale/lb.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Luxembourgish [lb]
	//! author : mweimerskirch : https://github.com/mweimerskirch
	//! author : David Raison : https://github.com/kwisatz

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            'm': ['eng Minutt', 'enger Minutt'],
	            'h': ['eng Stonn', 'enger Stonn'],
	            'd': ['een Dag', 'engem Dag'],
	            'M': ['ee Mount', 'engem Mount'],
	            'y': ['ee Joer', 'engem Joer']
	        };
	        return withoutSuffix ? format[key][0] : format[key][1];
	    }
	    function processFutureTime(string) {
	        var number = string.substr(0, string.indexOf(' '));
	        if (eifelerRegelAppliesToNumber(number)) {
	            return 'a ' + string;
	        }
	        return 'an ' + string;
	    }
	    function processPastTime(string) {
	        var number = string.substr(0, string.indexOf(' '));
	        if (eifelerRegelAppliesToNumber(number)) {
	            return 'viru ' + string;
	        }
	        return 'virun ' + string;
	    }
	    /**
	     * Returns true if the word before the given number loses the '-n' ending.
	     * e.g. 'an 10 Deeg' but 'a 5 Deeg'
	     *
	     * @param number {integer}
	     * @returns {boolean}
	     */
	    function eifelerRegelAppliesToNumber(number) {
	        number = parseInt(number, 10);
	        if (isNaN(number)) {
	            return false;
	        }
	        if (number < 0) {
	            // Negative Number --> always true
	            return true;
	        } else if (number < 10) {
	            // Only 1 digit
	            if (4 <= number && number <= 7) {
	                return true;
	            }
	            return false;
	        } else if (number < 100) {
	            // 2 digits
	            var lastDigit = number % 10, firstDigit = number / 10;
	            if (lastDigit === 0) {
	                return eifelerRegelAppliesToNumber(firstDigit);
	            }
	            return eifelerRegelAppliesToNumber(lastDigit);
	        } else if (number < 10000) {
	            // 3 or 4 digits --> recursively check first digit
	            while (number >= 10) {
	                number = number / 10;
	            }
	            return eifelerRegelAppliesToNumber(number);
	        } else {
	            // Anything larger than 4 digits: recursively check first n-3 digits
	            number = number / 1000;
	            return eifelerRegelAppliesToNumber(number);
	        }
	    }

	    var lb = moment.defineLocale('lb', {
	        months: 'Januar_Februar_Merz_Abrll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	        monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	        monthsParseExact : true,
	        weekdays: 'Sonndeg_Mindeg_Dnschdeg_Mttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
	        weekdaysShort: 'So._M._D._M._Do._Fr._Sa.'.split('_'),
	        weekdaysMin: 'So_M_D_M_Do_Fr_Sa'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat: {
	            LT: 'H:mm [Auer]',
	            LTS: 'H:mm:ss [Auer]',
	            L: 'DD.MM.YYYY',
	            LL: 'D. MMMM YYYY',
	            LLL: 'D. MMMM YYYY H:mm [Auer]',
	            LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'
	        },
	        calendar: {
	            sameDay: '[Haut um] LT',
	            sameElse: 'L',
	            nextDay: '[Muer um] LT',
	            nextWeek: 'dddd [um] LT',
	            lastDay: '[Gschter um] LT',
	            lastWeek: function () {
	                // Different date string for 'Dnschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
	                switch (this.day()) {
	                    case 2:
	                    case 4:
	                        return '[Leschten] dddd [um] LT';
	                    default:
	                        return '[Leschte] dddd [um] LT';
	                }
	            }
	        },
	        relativeTime : {
	            future : processFutureTime,
	            past : processPastTime,
	            s : 'e puer Sekonnen',
	            m : processRelativeTime,
	            mm : '%d Minutten',
	            h : processRelativeTime,
	            hh : '%d Stonnen',
	            d : processRelativeTime,
	            dd : '%d Deeg',
	            M : processRelativeTime,
	            MM : '%d Mint',
	            y : processRelativeTime,
	            yy : '%d Joer'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal: '%d.',
	        week: {
	            dow: 1, // Monday is the first day of the week.
	            doy: 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return lb;

	}));

/***/ },
/* 268 */
/*!*******************************!*\
  !*** ./~/moment/locale/lo.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Lao [lo]
	//! author : Ryan Hart : https://github.com/ryanhart2

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var lo = moment.defineLocale('lo', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        meridiemParse: /|/,
	        isPM: function (input) {
	            return input === '';
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        calendar : {
	            sameDay : '[] LT',
	            nextDay : '[] LT',
	            nextWeek : '[]dddd[] LT',
	            lastDay : '[] LT',
	            lastWeek : '[]dddd[] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : '%s',
	            s : '',
	            m : '1 ',
	            mm : '%d ',
	            h : '1 ',
	            hh : '%d ',
	            d : '1 ',
	            dd : '%d ',
	            M : '1 ',
	            MM : '%d ',
	            y : '1 ',
	            yy : '%d '
	        },
	        ordinalParse: /()\d{1,2}/,
	        ordinal : function (number) {
	            return '' + number;
	        }
	    });

	    return lo;

	}));

/***/ },
/* 269 */
/*!*******************************!*\
  !*** ./~/moment/locale/lt.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Lithuanian [lt]
	//! author : Mindaugas Mozras : https://github.com/mmozuras

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var units = {
	        'm' : 'minut_minuts_minut',
	        'mm': 'minuts_minui_minutes',
	        'h' : 'valanda_valandos_valand',
	        'hh': 'valandos_valand_valandas',
	        'd' : 'diena_dienos_dien',
	        'dd': 'dienos_dien_dienas',
	        'M' : 'mnuo_mnesio_mnes',
	        'MM': 'mnesiai_mnesi_mnesius',
	        'y' : 'metai_met_metus',
	        'yy': 'metai_met_metus'
	    };
	    function translateSeconds(number, withoutSuffix, key, isFuture) {
	        if (withoutSuffix) {
	            return 'kelios sekunds';
	        } else {
	            return isFuture ? 'keli sekundi' : 'kelias sekundes';
	        }
	    }
	    function translateSingular(number, withoutSuffix, key, isFuture) {
	        return withoutSuffix ? forms(key)[0] : (isFuture ? forms(key)[1] : forms(key)[2]);
	    }
	    function special(number) {
	        return number % 10 === 0 || (number > 10 && number < 20);
	    }
	    function forms(key) {
	        return units[key].split('_');
	    }
	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        if (number === 1) {
	            return result + translateSingular(number, withoutSuffix, key[0], isFuture);
	        } else if (withoutSuffix) {
	            return result + (special(number) ? forms(key)[1] : forms(key)[0]);
	        } else {
	            if (isFuture) {
	                return result + forms(key)[1];
	            } else {
	                return result + (special(number) ? forms(key)[1] : forms(key)[2]);
	            }
	        }
	    }
	    var lt = moment.defineLocale('lt', {
	        months : {
	            format: 'sausio_vasario_kovo_balandio_gegus_birelio_liepos_rugpjio_rugsjo_spalio_lapkriio_gruodio'.split('_'),
	            standalone: 'sausis_vasaris_kovas_balandis_gegu_birelis_liepa_rugpjtis_rugsjis_spalis_lapkritis_gruodis'.split('_'),
	            isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/
	        },
	        monthsShort : 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
	        weekdays : {
	            format: 'sekmadien_pirmadien_antradien_treiadien_ketvirtadien_penktadien_etadien'.split('_'),
	            standalone: 'sekmadienis_pirmadienis_antradienis_treiadienis_ketvirtadienis_penktadienis_etadienis'.split('_'),
	            isFormat: /dddd HH:mm/
	        },
	        weekdaysShort : 'Sek_Pir_Ant_Tre_Ket_Pen_e'.split('_'),
	        weekdaysMin : 'S_P_A_T_K_Pn_'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'YYYY [m.] MMMM D [d.]',
	            LLL : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
	            LLLL : 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
	            l : 'YYYY-MM-DD',
	            ll : 'YYYY [m.] MMMM D [d.]',
	            lll : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
	            llll : 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'
	        },
	        calendar : {
	            sameDay : '[iandien] LT',
	            nextDay : '[Rytoj] LT',
	            nextWeek : 'dddd LT',
	            lastDay : '[Vakar] LT',
	            lastWeek : '[Prajus] dddd LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'po %s',
	            past : 'prie %s',
	            s : translateSeconds,
	            m : translateSingular,
	            mm : translate,
	            h : translateSingular,
	            hh : translate,
	            d : translateSingular,
	            dd : translate,
	            M : translateSingular,
	            MM : translate,
	            y : translateSingular,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}-oji/,
	        ordinal : function (number) {
	            return number + '-oji';
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return lt;

	}));

/***/ },
/* 270 */
/*!*******************************!*\
  !*** ./~/moment/locale/lv.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Latvian [lv]
	//! author : Kristaps Karlsons : https://github.com/skakri
	//! author : Jnis Elmeris : https://github.com/JanisE

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var units = {
	        'm': 'mintes_mintm_minte_mintes'.split('_'),
	        'mm': 'mintes_mintm_minte_mintes'.split('_'),
	        'h': 'stundas_stundm_stunda_stundas'.split('_'),
	        'hh': 'stundas_stundm_stunda_stundas'.split('_'),
	        'd': 'dienas_dienm_diena_dienas'.split('_'),
	        'dd': 'dienas_dienm_diena_dienas'.split('_'),
	        'M': 'mnea_mneiem_mnesis_mnei'.split('_'),
	        'MM': 'mnea_mneiem_mnesis_mnei'.split('_'),
	        'y': 'gada_gadiem_gads_gadi'.split('_'),
	        'yy': 'gada_gadiem_gads_gadi'.split('_')
	    };
	    /**
	     * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
	     */
	    function format(forms, number, withoutSuffix) {
	        if (withoutSuffix) {
	            // E.g. "21 minte", "3 mintes".
	            return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3];
	        } else {
	            // E.g. "21 mintes" as in "pc 21 mintes".
	            // E.g. "3 mintm" as in "pc 3 mintm".
	            return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];
	        }
	    }
	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        return number + ' ' + format(units[key], number, withoutSuffix);
	    }
	    function relativeTimeWithSingular(number, withoutSuffix, key) {
	        return format(units[key], number, withoutSuffix);
	    }
	    function relativeSeconds(number, withoutSuffix) {
	        return withoutSuffix ? 'daas sekundes' : 'dam sekundm';
	    }

	    var lv = moment.defineLocale('lv', {
	        months : 'janvris_februris_marts_aprlis_maijs_jnijs_jlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_mai_jn_jl_aug_sep_okt_nov_dec'.split('_'),
	        weekdays : 'svtdiena_pirmdiena_otrdiena_trediena_ceturtdiena_piektdiena_sestdiena'.split('_'),
	        weekdaysShort : 'Sv_P_O_T_C_Pk_S'.split('_'),
	        weekdaysMin : 'Sv_P_O_T_C_Pk_S'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY.',
	            LL : 'YYYY. [gada] D. MMMM',
	            LLL : 'YYYY. [gada] D. MMMM, HH:mm',
	            LLLL : 'YYYY. [gada] D. MMMM, dddd, HH:mm'
	        },
	        calendar : {
	            sameDay : '[odien pulksten] LT',
	            nextDay : '[Rt pulksten] LT',
	            nextWeek : 'dddd [pulksten] LT',
	            lastDay : '[Vakar pulksten] LT',
	            lastWeek : '[Pagju] dddd [pulksten] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'pc %s',
	            past : 'pirms %s',
	            s : relativeSeconds,
	            m : relativeTimeWithSingular,
	            mm : relativeTimeWithPlural,
	            h : relativeTimeWithSingular,
	            hh : relativeTimeWithPlural,
	            d : relativeTimeWithSingular,
	            dd : relativeTimeWithPlural,
	            M : relativeTimeWithSingular,
	            MM : relativeTimeWithPlural,
	            y : relativeTimeWithSingular,
	            yy : relativeTimeWithPlural
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return lv;

	}));

/***/ },
/* 271 */
/*!*******************************!*\
  !*** ./~/moment/locale/me.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Montenegrin [me]
	//! author : Miodrag Nika <miodrag@restartit.me> : https://github.com/miodragnikac

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var translator = {
	        words: { //Different grammatical cases
	            m: ['jedan minut', 'jednog minuta'],
	            mm: ['minut', 'minuta', 'minuta'],
	            h: ['jedan sat', 'jednog sata'],
	            hh: ['sat', 'sata', 'sati'],
	            dd: ['dan', 'dana', 'dana'],
	            MM: ['mjesec', 'mjeseca', 'mjeseci'],
	            yy: ['godina', 'godine', 'godina']
	        },
	        correctGrammaticalCase: function (number, wordKey) {
	            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	        },
	        translate: function (number, withoutSuffix, key) {
	            var wordKey = translator.words[key];
	            if (key.length === 1) {
	                return withoutSuffix ? wordKey[0] : wordKey[1];
	            } else {
	                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	            }
	        }
	    };

	    var me = moment.defineLocale('me', {
	        months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
	        monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
	        monthsParseExact : true,
	        weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
	        weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
	        weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat: {
	            LT: 'H:mm',
	            LTS : 'H:mm:ss',
	            L: 'DD.MM.YYYY',
	            LL: 'D. MMMM YYYY',
	            LLL: 'D. MMMM YYYY H:mm',
	            LLLL: 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar: {
	            sameDay: '[danas u] LT',
	            nextDay: '[sjutra u] LT',

	            nextWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[u] [nedjelju] [u] LT';
	                    case 3:
	                        return '[u] [srijedu] [u] LT';
	                    case 6:
	                        return '[u] [subotu] [u] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                    case 5:
	                        return '[u] dddd [u] LT';
	                }
	            },
	            lastDay  : '[jue u] LT',
	            lastWeek : function () {
	                var lastWeekDays = [
	                    '[prole] [nedjelje] [u] LT',
	                    '[prolog] [ponedjeljka] [u] LT',
	                    '[prolog] [utorka] [u] LT',
	                    '[prole] [srijede] [u] LT',
	                    '[prolog] [etvrtka] [u] LT',
	                    '[prolog] [petka] [u] LT',
	                    '[prole] [subote] [u] LT'
	                ];
	                return lastWeekDays[this.day()];
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past   : 'prije %s',
	            s      : 'nekoliko sekundi',
	            m      : translator.translate,
	            mm     : translator.translate,
	            h      : translator.translate,
	            hh     : translator.translate,
	            d      : 'dan',
	            dd     : translator.translate,
	            M      : 'mjesec',
	            MM     : translator.translate,
	            y      : 'godinu',
	            yy     : translator.translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return me;

	}));

/***/ },
/* 272 */
/*!*******************************!*\
  !*** ./~/moment/locale/mi.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Maori [mi]
	//! author : John Corrigan <robbiecloset@gmail.com> : https://github.com/johnideal

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var mi = moment.defineLocale('mi', {
	        months: 'Kohi-tte_Hui-tanguru_Pout-te-rangi_Paenga-whwh_Haratua_Pipiri_Hngoingoi_Here-turi-kk_Mahuru_Whiringa--nuku_Whiringa--rangi_Hakihea'.split('_'),
	        monthsShort: 'Kohi_Hui_Pou_Pae_Hara_Pipi_Hngoi_Here_Mahu_Whi-nu_Whi-ra_Haki'.split('_'),
	        monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
	        monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
	        monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
	        monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
	        weekdays: 'Rtapu_Mane_Trei_Wenerei_Tite_Paraire_Htarei'.split('_'),
	        weekdaysShort: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
	        weekdaysMin: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
	        longDateFormat: {
	            LT: 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L: 'DD/MM/YYYY',
	            LL: 'D MMMM YYYY',
	            LLL: 'D MMMM YYYY [i] HH:mm',
	            LLLL: 'dddd, D MMMM YYYY [i] HH:mm'
	        },
	        calendar: {
	            sameDay: '[i teie mahana, i] LT',
	            nextDay: '[apopo i] LT',
	            nextWeek: 'dddd [i] LT',
	            lastDay: '[inanahi i] LT',
	            lastWeek: 'dddd [whakamutunga i] LT',
	            sameElse: 'L'
	        },
	        relativeTime: {
	            future: 'i roto i %s',
	            past: '%s i mua',
	            s: 'te hkona ruarua',
	            m: 'he meneti',
	            mm: '%d meneti',
	            h: 'te haora',
	            hh: '%d haora',
	            d: 'he ra',
	            dd: '%d ra',
	            M: 'he marama',
	            MM: '%d marama',
	            y: 'he tau',
	            yy: '%d tau'
	        },
	        ordinalParse: /\d{1,2}/,
	        ordinal: '%d',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return mi;

	}));

/***/ },
/* 273 */
/*!*******************************!*\
  !*** ./~/moment/locale/mk.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Macedonian [mk]
	//! author : Borislav Mickov : https://github.com/B0k0

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var mk = moment.defineLocale('mk', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : 'e_o_____a'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'D.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY H:mm',
	            LLLL : 'dddd, D MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay : '[ ] LT',
	            nextDay : '[ ] LT',
	            nextWeek : '[] dddd [] LT',
	            lastDay : '[ ] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                    case 0:
	                    case 3:
	                    case 6:
	                        return '[] dddd [] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                    case 5:
	                        return '[] dddd [] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : ' %s',
	            s : ' ',
	            m : '',
	            mm : '%d ',
	            h : '',
	            hh : '%d ',
	            d : '',
	            dd : '%d ',
	            M : '',
	            MM : '%d ',
	            y : '',
	            yy : '%d '
	        },
	        ordinalParse: /\d{1,2}-(|||||)/,
	        ordinal : function (number) {
	            var lastDigit = number % 10,
	                last2Digits = number % 100;
	            if (number === 0) {
	                return number + '-';
	            } else if (last2Digits === 0) {
	                return number + '-';
	            } else if (last2Digits > 10 && last2Digits < 20) {
	                return number + '-';
	            } else if (lastDigit === 1) {
	                return number + '-';
	            } else if (lastDigit === 2) {
	                return number + '-';
	            } else if (lastDigit === 7 || lastDigit === 8) {
	                return number + '-';
	            } else {
	                return number + '-';
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return mk;

	}));

/***/ },
/* 274 */
/*!*******************************!*\
  !*** ./~/moment/locale/ml.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Malayalam [ml]
	//! author : Floyd Pink : https://github.com/floydpink

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var ml = moment.defineLocale('ml', {
	        months : '___________'.split('_'),
	        monthsShort : '._._._.___._._._._._.'.split('_'),
	        monthsParseExact : true,
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm -',
	            LTS : 'A h:mm:ss -',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm -',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm -'
	        },
	        calendar : {
	            sameDay : '[] LT',
	            nextDay : '[] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[] LT',
	            lastWeek : '[] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ',
	            past : '%s ',
	            s : ' ',
	            m : ' ',
	            mm : '%d ',
	            h : ' ',
	            hh : '%d ',
	            d : ' ',
	            dd : '%d ',
	            M : ' ',
	            MM : '%d ',
	            y : ' ',
	            yy : '%d '
	        },
	        meridiemParse: /|| ||/i,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if ((meridiem === '' && hour >= 4) ||
	                    meridiem === ' ' ||
	                    meridiem === '') {
	                return hour + 12;
	            } else {
	                return hour;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return '';
	            } else if (hour < 12) {
	                return '';
	            } else if (hour < 17) {
	                return ' ';
	            } else if (hour < 20) {
	                return '';
	            } else {
	                return '';
	            }
	        }
	    });

	    return ml;

	}));

/***/ },
/* 275 */
/*!*******************************!*\
  !*** ./~/moment/locale/mr.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Marathi [mr]
	//! author : Harshad Kale : https://github.com/kalehv
	//! author : Vivek Athalye : https://github.com/vnathalye

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var symbolMap = {
	        '1': '',
	        '2': '',
	        '3': '',
	        '4': '',
	        '5': '',
	        '6': '',
	        '7': '',
	        '8': '',
	        '9': '',
	        '0': ''
	    },
	    numberMap = {
	        '': '1',
	        '': '2',
	        '': '3',
	        '': '4',
	        '': '5',
	        '': '6',
	        '': '7',
	        '': '8',
	        '': '9',
	        '': '0'
	    };

	    function relativeTimeMr(number, withoutSuffix, string, isFuture)
	    {
	        var output = '';
	        if (withoutSuffix) {
	            switch (string) {
	                case 's': output = ' '; break;
	                case 'm': output = ' '; break;
	                case 'mm': output = '%d '; break;
	                case 'h': output = ' '; break;
	                case 'hh': output = '%d '; break;
	                case 'd': output = ' '; break;
	                case 'dd': output = '%d '; break;
	                case 'M': output = ' '; break;
	                case 'MM': output = '%d '; break;
	                case 'y': output = ' '; break;
	                case 'yy': output = '%d '; break;
	            }
	        }
	        else {
	            switch (string) {
	                case 's': output = ' '; break;
	                case 'm': output = ' '; break;
	                case 'mm': output = '%d '; break;
	                case 'h': output = ' '; break;
	                case 'hh': output = '%d '; break;
	                case 'd': output = ' '; break;
	                case 'dd': output = '%d '; break;
	                case 'M': output = ' '; break;
	                case 'MM': output = '%d '; break;
	                case 'y': output = ' '; break;
	                case 'yy': output = '%d '; break;
	            }
	        }
	        return output.replace(/%d/i, number);
	    }

	    var mr = moment.defineLocale('mr', {
	        months : '___________'.split('_'),
	        monthsShort: '._._._._._._._._._._._.'.split('_'),
	        monthsParseExact : true,
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm ',
	            LTS : 'A h:mm:ss ',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm ',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm '
	        },
	        calendar : {
	            sameDay : '[] LT',
	            nextDay : '[] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[] LT',
	            lastWeek: '[] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future: '%s',
	            past: '%s',
	            s: relativeTimeMr,
	            m: relativeTimeMr,
	            mm: relativeTimeMr,
	            h: relativeTimeMr,
	            hh: relativeTimeMr,
	            d: relativeTimeMr,
	            dd: relativeTimeMr,
	            M: relativeTimeMr,
	            MM: relativeTimeMr,
	            y: relativeTimeMr,
	            yy: relativeTimeMr
	        },
	        preparse: function (string) {
	            return string.replace(/[]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        meridiemParse: /|||/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === '') {
	                return hour < 4 ? hour : hour + 12;
	            } else if (meridiem === '') {
	                return hour;
	            } else if (meridiem === '') {
	                return hour >= 10 ? hour : hour + 12;
	            } else if (meridiem === '') {
	                return hour + 12;
	            }
	        },
	        meridiem: function (hour, minute, isLower) {
	            if (hour < 4) {
	                return '';
	            } else if (hour < 10) {
	                return '';
	            } else if (hour < 17) {
	                return '';
	            } else if (hour < 20) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return mr;

	}));

/***/ },
/* 276 */
/*!*******************************!*\
  !*** ./~/moment/locale/ms.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Malay [ms]
	//! author : Weldan Jamili : https://github.com/weldan

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var ms = moment.defineLocale('ms', {
	        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
	        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
	        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
	        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
	        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY [pukul] HH.mm',
	            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	        },
	        meridiemParse: /pagi|tengahari|petang|malam/,
	        meridiemHour: function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'pagi') {
	                return hour;
	            } else if (meridiem === 'tengahari') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === 'petang' || meridiem === 'malam') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 11) {
	                return 'pagi';
	            } else if (hours < 15) {
	                return 'tengahari';
	            } else if (hours < 19) {
	                return 'petang';
	            } else {
	                return 'malam';
	            }
	        },
	        calendar : {
	            sameDay : '[Hari ini pukul] LT',
	            nextDay : '[Esok pukul] LT',
	            nextWeek : 'dddd [pukul] LT',
	            lastDay : '[Kelmarin pukul] LT',
	            lastWeek : 'dddd [lepas pukul] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'dalam %s',
	            past : '%s yang lepas',
	            s : 'beberapa saat',
	            m : 'seminit',
	            mm : '%d minit',
	            h : 'sejam',
	            hh : '%d jam',
	            d : 'sehari',
	            dd : '%d hari',
	            M : 'sebulan',
	            MM : '%d bulan',
	            y : 'setahun',
	            yy : '%d tahun'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return ms;

	}));

/***/ },
/* 277 */
/*!**********************************!*\
  !*** ./~/moment/locale/ms-my.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Malay [ms-my]
	//! note : DEPRECATED, the correct one is [ms]
	//! author : Weldan Jamili : https://github.com/weldan

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var ms_my = moment.defineLocale('ms-my', {
	        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
	        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
	        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
	        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
	        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY [pukul] HH.mm',
	            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	        },
	        meridiemParse: /pagi|tengahari|petang|malam/,
	        meridiemHour: function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'pagi') {
	                return hour;
	            } else if (meridiem === 'tengahari') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === 'petang' || meridiem === 'malam') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 11) {
	                return 'pagi';
	            } else if (hours < 15) {
	                return 'tengahari';
	            } else if (hours < 19) {
	                return 'petang';
	            } else {
	                return 'malam';
	            }
	        },
	        calendar : {
	            sameDay : '[Hari ini pukul] LT',
	            nextDay : '[Esok pukul] LT',
	            nextWeek : 'dddd [pukul] LT',
	            lastDay : '[Kelmarin pukul] LT',
	            lastWeek : 'dddd [lepas pukul] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'dalam %s',
	            past : '%s yang lepas',
	            s : 'beberapa saat',
	            m : 'seminit',
	            mm : '%d minit',
	            h : 'sejam',
	            hh : '%d jam',
	            d : 'sehari',
	            dd : '%d hari',
	            M : 'sebulan',
	            MM : '%d bulan',
	            y : 'setahun',
	            yy : '%d tahun'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return ms_my;

	}));

/***/ },
/* 278 */
/*!*******************************!*\
  !*** ./~/moment/locale/my.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Burmese [my]
	//! author : Squar team, mysquar.com
	//! author : David Rossellat : https://github.com/gholadr
	//! author : Tin Aung Lin : https://github.com/thanyawzinmin

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var symbolMap = {
	        '1': '',
	        '2': '',
	        '3': '',
	        '4': '',
	        '5': '',
	        '6': '',
	        '7': '',
	        '8': '',
	        '9': '',
	        '0': ''
	    }, numberMap = {
	        '': '1',
	        '': '2',
	        '': '3',
	        '': '4',
	        '': '5',
	        '': '6',
	        '': '7',
	        '': '8',
	        '': '9',
	        '': '0'
	    };

	    var my = moment.defineLocale('my', {
	        months: '___________'.split('_'),
	        monthsShort: '___________'.split('_'),
	        weekdays: '______'.split('_'),
	        weekdaysShort: '______'.split('_'),
	        weekdaysMin: '______'.split('_'),

	        longDateFormat: {
	            LT: 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L: 'DD/MM/YYYY',
	            LL: 'D MMMM YYYY',
	            LLL: 'D MMMM YYYY HH:mm',
	            LLLL: 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar: {
	            sameDay: '[.] LT []',
	            nextDay: '[] LT []',
	            nextWeek: 'dddd LT []',
	            lastDay: '[.] LT []',
	            lastWeek: '[] dddd LT []',
	            sameElse: 'L'
	        },
	        relativeTime: {
	            future: ' %s ',
	            past: ' %s ',
	            s: '.',
	            m: '',
	            mm: '%d ',
	            h: '',
	            hh: '%d ',
	            d: '',
	            dd: '%d ',
	            M: '',
	            MM: '%d ',
	            y: '',
	            yy: '%d '
	        },
	        preparse: function (string) {
	            return string.replace(/[]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        week: {
	            dow: 1, // Monday is the first day of the week.
	            doy: 4 // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return my;

	}));

/***/ },
/* 279 */
/*!*******************************!*\
  !*** ./~/moment/locale/nb.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Norwegian Bokml [nb]
	//! authors : Espen Hovlandsdal : https://github.com/rexxars
	//!           Sigurd Gartmann : https://github.com/sigurdga

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var nb = moment.defineLocale('nb', {
	        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	        monthsShort : 'jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
	        weekdaysShort : 's._ma._ti._on._to._fr._l.'.split('_'),
	        weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY [kl.] HH:mm',
	            LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
	        },
	        calendar : {
	            sameDay: '[i dag kl.] LT',
	            nextDay: '[i morgen kl.] LT',
	            nextWeek: 'dddd [kl.] LT',
	            lastDay: '[i gr kl.] LT',
	            lastWeek: '[forrige] dddd [kl.] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'om %s',
	            past : '%s siden',
	            s : 'noen sekunder',
	            m : 'ett minutt',
	            mm : '%d minutter',
	            h : 'en time',
	            hh : '%d timer',
	            d : 'en dag',
	            dd : '%d dager',
	            M : 'en mned',
	            MM : '%d mneder',
	            y : 'ett r',
	            yy : '%d r'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return nb;

	}));

/***/ },
/* 280 */
/*!*******************************!*\
  !*** ./~/moment/locale/ne.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Nepalese [ne]
	//! author : suvash : https://github.com/suvash

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var symbolMap = {
	        '1': '',
	        '2': '',
	        '3': '',
	        '4': '',
	        '5': '',
	        '6': '',
	        '7': '',
	        '8': '',
	        '9': '',
	        '0': ''
	    },
	    numberMap = {
	        '': '1',
	        '': '2',
	        '': '3',
	        '': '4',
	        '': '5',
	        '': '6',
	        '': '7',
	        '': '8',
	        '': '9',
	        '': '0'
	    };

	    var ne = moment.defineLocale('ne', {
	        months : '___________'.split('_'),
	        monthsShort : '._.__.___._._._._._.'.split('_'),
	        monthsParseExact : true,
	        weekdays : '______'.split('_'),
	        weekdaysShort : '._._._._._._.'.split('_'),
	        weekdaysMin : '._._._._._._.'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'A h:mm ',
	            LTS : 'A h:mm:ss ',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm ',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm '
	        },
	        preparse: function (string) {
	            return string.replace(/[]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        meridiemParse: /|||/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === '') {
	                return hour < 4 ? hour : hour + 12;
	            } else if (meridiem === '') {
	                return hour;
	            } else if (meridiem === '') {
	                return hour >= 10 ? hour : hour + 12;
	            } else if (meridiem === '') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 3) {
	                return '';
	            } else if (hour < 12) {
	                return '';
	            } else if (hour < 16) {
	                return '';
	            } else if (hour < 20) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        calendar : {
	            sameDay : '[] LT',
	            nextDay : '[] LT',
	            nextWeek : '[] dddd[,] LT',
	            lastDay : '[] LT',
	            lastWeek : '[] dddd[,] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s',
	            past : '%s ',
	            s : ' ',
	            m : ' ',
	            mm : '%d ',
	            h : ' ',
	            hh : '%d ',
	            d : ' ',
	            dd : '%d ',
	            M : ' ',
	            MM : '%d ',
	            y : ' ',
	            yy : '%d '
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return ne;

	}));

/***/ },
/* 281 */
/*!*******************************!*\
  !*** ./~/moment/locale/nl.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Dutch [nl]
	//! author : Joris Rling : https://github.com/jorisroling
	//! author : Jacob Middag : https://github.com/middagj

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
	        monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

	    var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
	    var monthsRegex = /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

	    var nl = moment.defineLocale('nl', {
	        months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
	        monthsShort : function (m, format) {
	            if (/-MMM-/.test(format)) {
	                return monthsShortWithoutDots[m.month()];
	            } else {
	                return monthsShortWithDots[m.month()];
	            }
	        },

	        monthsRegex: monthsRegex,
	        monthsShortRegex: monthsRegex,
	        monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,
	        monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

	        monthsParse : monthsParse,
	        longMonthsParse : monthsParse,
	        shortMonthsParse : monthsParse,

	        weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
	        weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
	        weekdaysMin : 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD-MM-YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[vandaag om] LT',
	            nextDay: '[morgen om] LT',
	            nextWeek: 'dddd [om] LT',
	            lastDay: '[gisteren om] LT',
	            lastWeek: '[afgelopen] dddd [om] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'over %s',
	            past : '%s geleden',
	            s : 'een paar seconden',
	            m : 'n minuut',
	            mm : '%d minuten',
	            h : 'n uur',
	            hh : '%d uur',
	            d : 'n dag',
	            dd : '%d dagen',
	            M : 'n maand',
	            MM : '%d maanden',
	            y : 'n jaar',
	            yy : '%d jaar'
	        },
	        ordinalParse: /\d{1,2}(ste|de)/,
	        ordinal : function (number) {
	            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return nl;

	}));

/***/ },
/* 282 */
/*!*******************************!*\
  !*** ./~/moment/locale/nn.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Nynorsk [nn]
	//! author : https://github.com/mechuwind

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var nn = moment.defineLocale('nn', {
	        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
	        weekdays : 'sundag_mndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
	        weekdaysShort : 'sun_mn_tys_ons_tor_fre_lau'.split('_'),
	        weekdaysMin : 'su_m_ty_on_to_fr_l'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY [kl.] H:mm',
	            LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
	        },
	        calendar : {
	            sameDay: '[I dag klokka] LT',
	            nextDay: '[I morgon klokka] LT',
	            nextWeek: 'dddd [klokka] LT',
	            lastDay: '[I gr klokka] LT',
	            lastWeek: '[Fregande] dddd [klokka] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'om %s',
	            past : '%s sidan',
	            s : 'nokre sekund',
	            m : 'eit minutt',
	            mm : '%d minutt',
	            h : 'ein time',
	            hh : '%d timar',
	            d : 'ein dag',
	            dd : '%d dagar',
	            M : 'ein mnad',
	            MM : '%d mnader',
	            y : 'eit r',
	            yy : '%d r'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return nn;

	}));

/***/ },
/* 283 */
/*!**********************************!*\
  !*** ./~/moment/locale/pa-in.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Punjabi (India) [pa-in]
	//! author : Harpreet Singh : https://github.com/harpreetkhalsagtbit

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var symbolMap = {
	        '1': '',
	        '2': '',
	        '3': '',
	        '4': '',
	        '5': '',
	        '6': '',
	        '7': '',
	        '8': '',
	        '9': '',
	        '0': ''
	    },
	    numberMap = {
	        '': '1',
	        '': '2',
	        '': '3',
	        '': '4',
	        '': '5',
	        '': '6',
	        '': '7',
	        '': '8',
	        '': '9',
	        '': '0'
	    };

	    var pa_in = moment.defineLocale('pa-in', {
	        // There are months name as per Nanakshahi Calender but they are not used as rigidly in modern Punjabi.
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm ',
	            LTS : 'A h:mm:ss ',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm ',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm '
	        },
	        calendar : {
	            sameDay : '[] LT',
	            nextDay : '[] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[] LT',
	            lastWeek : '[] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ',
	            past : '%s ',
	            s : ' ',
	            m : ' ',
	            mm : '%d ',
	            h : ' ',
	            hh : '%d ',
	            d : ' ',
	            dd : '%d ',
	            M : ' ',
	            MM : '%d ',
	            y : ' ',
	            yy : '%d '
	        },
	        preparse: function (string) {
	            return string.replace(/[]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        // Punjabi notation for meridiems are quite fuzzy in practice. While there exists
	        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
	        meridiemParse: /|||/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === '') {
	                return hour < 4 ? hour : hour + 12;
	            } else if (meridiem === '') {
	                return hour;
	            } else if (meridiem === '') {
	                return hour >= 10 ? hour : hour + 12;
	            } else if (meridiem === '') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return '';
	            } else if (hour < 10) {
	                return '';
	            } else if (hour < 17) {
	                return '';
	            } else if (hour < 20) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return pa_in;

	}));

/***/ },
/* 284 */
/*!*******************************!*\
  !*** ./~/moment/locale/pl.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Polish [pl]
	//! author : Rafal Hirsz : https://github.com/evoL

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var monthsNominative = 'stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie'.split('_'),
	        monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia'.split('_');
	    function plural(n) {
	        return (n % 10 < 5) && (n % 10 > 1) && ((~~(n / 10) % 10) !== 1);
	    }
	    function translate(number, withoutSuffix, key) {
	        var result = number + ' ';
	        switch (key) {
	            case 'm':
	                return withoutSuffix ? 'minuta' : 'minut';
	            case 'mm':
	                return result + (plural(number) ? 'minuty' : 'minut');
	            case 'h':
	                return withoutSuffix  ? 'godzina'  : 'godzin';
	            case 'hh':
	                return result + (plural(number) ? 'godziny' : 'godzin');
	            case 'MM':
	                return result + (plural(number) ? 'miesice' : 'miesicy');
	            case 'yy':
	                return result + (plural(number) ? 'lata' : 'lat');
	        }
	    }

	    var pl = moment.defineLocale('pl', {
	        months : function (momentToFormat, format) {
	            if (format === '') {
	                // Hack: if format empty we know this is used to generate
	                // RegExp by moment. Give then back both valid forms of months
	                // in RegExp ready format.
	                return '(' + monthsSubjective[momentToFormat.month()] + '|' + monthsNominative[momentToFormat.month()] + ')';
	            } else if (/D MMMM/.test(format)) {
	                return monthsSubjective[momentToFormat.month()];
	            } else {
	                return monthsNominative[momentToFormat.month()];
	            }
	        },
	        monthsShort : 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru'.split('_'),
	        weekdays : 'niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota'.split('_'),
	        weekdaysShort : 'nie_pon_wt_r_czw_pt_sb'.split('_'),
	        weekdaysMin : 'Nd_Pn_Wt_r_Cz_Pt_So'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Dzi o] LT',
	            nextDay: '[Jutro o] LT',
	            nextWeek: '[W] dddd [o] LT',
	            lastDay: '[Wczoraj o] LT',
	            lastWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[W zesz niedziel o] LT';
	                    case 3:
	                        return '[W zesz rod o] LT';
	                    case 6:
	                        return '[W zesz sobot o] LT';
	                    default:
	                        return '[W zeszy] dddd [o] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past : '%s temu',
	            s : 'kilka sekund',
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : '1 dzie',
	            dd : '%d dni',
	            M : 'miesic',
	            MM : translate,
	            y : 'rok',
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return pl;

	}));

/***/ },
/* 285 */
/*!*******************************!*\
  !*** ./~/moment/locale/pt.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Portuguese [pt]
	//! author : Jefferson : https://github.com/jalex79

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var pt = moment.defineLocale('pt', {
	        months : 'Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
	        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
	        weekdays : 'Domingo_Segunda-Feira_Tera-Feira_Quarta-Feira_Quinta-Feira_Sexta-Feira_Sbado'.split('_'),
	        weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
	        weekdaysMin : 'Dom_2_3_4_5_6_Sb'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D [de] MMMM [de] YYYY',
	            LLL : 'D [de] MMMM [de] YYYY HH:mm',
	            LLLL : 'dddd, D [de] MMMM [de] YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Hoje s] LT',
	            nextDay: '[Amanh s] LT',
	            nextWeek: 'dddd [s] LT',
	            lastDay: '[Ontem s] LT',
	            lastWeek: function () {
	                return (this.day() === 0 || this.day() === 6) ?
	                    '[ltimo] dddd [s] LT' : // Saturday + Sunday
	                    '[ltima] dddd [s] LT'; // Monday - Friday
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'em %s',
	            past : 'h %s',
	            s : 'segundos',
	            m : 'um minuto',
	            mm : '%d minutos',
	            h : 'uma hora',
	            hh : '%d horas',
	            d : 'um dia',
	            dd : '%d dias',
	            M : 'um ms',
	            MM : '%d meses',
	            y : 'um ano',
	            yy : '%d anos'
	        },
	        ordinalParse: /\d{1,2}/,
	        ordinal : '%d',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return pt;

	}));

/***/ },
/* 286 */
/*!**********************************!*\
  !*** ./~/moment/locale/pt-br.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Portuguese (Brazil) [pt-br]
	//! author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var pt_br = moment.defineLocale('pt-br', {
	        months : 'Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
	        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
	        weekdays : 'Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado'.split('_'),
	        weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
	        weekdaysMin : 'Dom_2_3_4_5_6_Sb'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D [de] MMMM [de] YYYY',
	            LLL : 'D [de] MMMM [de] YYYY [s] HH:mm',
	            LLLL : 'dddd, D [de] MMMM [de] YYYY [s] HH:mm'
	        },
	        calendar : {
	            sameDay: '[Hoje s] LT',
	            nextDay: '[Amanh s] LT',
	            nextWeek: 'dddd [s] LT',
	            lastDay: '[Ontem s] LT',
	            lastWeek: function () {
	                return (this.day() === 0 || this.day() === 6) ?
	                    '[ltimo] dddd [s] LT' : // Saturday + Sunday
	                    '[ltima] dddd [s] LT'; // Monday - Friday
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'em %s',
	            past : '%s atrs',
	            s : 'poucos segundos',
	            m : 'um minuto',
	            mm : '%d minutos',
	            h : 'uma hora',
	            hh : '%d horas',
	            d : 'um dia',
	            dd : '%d dias',
	            M : 'um ms',
	            MM : '%d meses',
	            y : 'um ano',
	            yy : '%d anos'
	        },
	        ordinalParse: /\d{1,2}/,
	        ordinal : '%d'
	    });

	    return pt_br;

	}));

/***/ },
/* 287 */
/*!*******************************!*\
  !*** ./~/moment/locale/ro.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Romanian [ro]
	//! author : Vlad Gurdiga : https://github.com/gurdiga
	//! author : Valentin Agachi : https://github.com/avaly

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        var format = {
	                'mm': 'minute',
	                'hh': 'ore',
	                'dd': 'zile',
	                'MM': 'luni',
	                'yy': 'ani'
	            },
	            separator = ' ';
	        if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
	            separator = ' de ';
	        }
	        return number + separator + format[key];
	    }

	    var ro = moment.defineLocale('ro', {
	        months : 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
	        monthsShort : 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
	        monthsParseExact: true,
	        weekdays : 'duminic_luni_mari_miercuri_joi_vineri_smbt'.split('_'),
	        weekdaysShort : 'Dum_Lun_Mar_Mie_Joi_Vin_Sm'.split('_'),
	        weekdaysMin : 'Du_Lu_Ma_Mi_Jo_Vi_S'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY H:mm',
	            LLLL : 'dddd, D MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay: '[azi la] LT',
	            nextDay: '[mine la] LT',
	            nextWeek: 'dddd [la] LT',
	            lastDay: '[ieri la] LT',
	            lastWeek: '[fosta] dddd [la] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'peste %s',
	            past : '%s n urm',
	            s : 'cteva secunde',
	            m : 'un minut',
	            mm : relativeTimeWithPlural,
	            h : 'o or',
	            hh : relativeTimeWithPlural,
	            d : 'o zi',
	            dd : relativeTimeWithPlural,
	            M : 'o lun',
	            MM : relativeTimeWithPlural,
	            y : 'un an',
	            yy : relativeTimeWithPlural
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return ro;

	}));

/***/ },
/* 288 */
/*!*******************************!*\
  !*** ./~/moment/locale/ru.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Russian [ru]
	//! author : Viktorminator : https://github.com/Viktorminator
	//! Author : Menelion Elensle : https://github.com/Oire
	//! author :   : https://github.com/socketpair

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function plural(word, num) {
	        var forms = word.split('_');
	        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	    }
	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        var format = {
	            'mm': withoutSuffix ? '__' : '__',
	            'hh': '__',
	            'dd': '__',
	            'MM': '__',
	            'yy': '__'
	        };
	        if (key === 'm') {
	            return withoutSuffix ? '' : '';
	        }
	        else {
	            return number + ' ' + plural(format[key], +number);
	        }
	    }
	    var monthsParse = [/^/i, /^/i, /^/i, /^/i, /^[]/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i];

	    // http://new.gramota.ru/spravka/rules/139-prop :  103
	    //  : http://new.gramota.ru/spravka/buro/search-answer?s=242637
	    // CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753
	    var ru = moment.defineLocale('ru', {
	        months : {
	            format: '___________'.split('_'),
	            standalone: '___________'.split('_')
	        },
	        monthsShort : {
	            //  CLDR  "."  ".",        ?
	            format: '._._._.____._._._._.'.split('_'),
	            standalone: '._.__.____._._._._.'.split('_')
	        },
	        weekdays : {
	            standalone: '______'.split('_'),
	            format: '______'.split('_'),
	            isFormat: /\[ ?[] ?(?:||)? ?\] ?dddd/
	        },
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        monthsParse : monthsParse,
	        longMonthsParse : monthsParse,
	        shortMonthsParse : monthsParse,

	        //    ,   ,  ,  4 ,      
	        monthsRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,

	        //  
	        monthsShortRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,

	        //    
	        monthsStrictRegex: /^([]|[]|?|[]|[]|[]|[]|?|[]|[]|[]|[])/i,

	        // ,     
	        monthsShortStrictRegex: /^(\.|?\.|[.]|\.|[]|[.]|[.]|\.|?\.|\.|?\.|\.)/i,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY .',
	            LLL : 'D MMMM YYYY ., HH:mm',
	            LLLL : 'dddd, D MMMM YYYY ., HH:mm'
	        },
	        calendar : {
	            sameDay: '[ ] LT',
	            nextDay: '[ ] LT',
	            lastDay: '[ ] LT',
	            nextWeek: function (now) {
	                if (now.week() !== this.week()) {
	                    switch (this.day()) {
	                        case 0:
	                            return '[ ] dddd [] LT';
	                        case 1:
	                        case 2:
	                        case 4:
	                            return '[ ] dddd [] LT';
	                        case 3:
	                        case 5:
	                        case 6:
	                            return '[ ] dddd [] LT';
	                    }
	                } else {
	                    if (this.day() === 2) {
	                        return '[] dddd [] LT';
	                    } else {
	                        return '[] dddd [] LT';
	                    }
	                }
	            },
	            lastWeek: function (now) {
	                if (now.week() !== this.week()) {
	                    switch (this.day()) {
	                        case 0:
	                            return '[ ] dddd [] LT';
	                        case 1:
	                        case 2:
	                        case 4:
	                            return '[ ] dddd [] LT';
	                        case 3:
	                        case 5:
	                        case 6:
	                            return '[ ] dddd [] LT';
	                    }
	                } else {
	                    if (this.day() === 2) {
	                        return '[] dddd [] LT';
	                    } else {
	                        return '[] dddd [] LT';
	                    }
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : '%s ',
	            s : ' ',
	            m : relativeTimeWithPlural,
	            mm : relativeTimeWithPlural,
	            h : '',
	            hh : relativeTimeWithPlural,
	            d : '',
	            dd : relativeTimeWithPlural,
	            M : '',
	            MM : relativeTimeWithPlural,
	            y : '',
	            yy : relativeTimeWithPlural
	        },
	        meridiemParse: /|||/i,
	        isPM : function (input) {
	            return /^(|)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return '';
	            } else if (hour < 12) {
	                return '';
	            } else if (hour < 17) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        ordinalParse: /\d{1,2}-(||)/,
	        ordinal: function (number, period) {
	            switch (period) {
	                case 'M':
	                case 'd':
	                case 'DDD':
	                    return number + '-';
	                case 'D':
	                    return number + '-';
	                case 'w':
	                case 'W':
	                    return number + '-';
	                default:
	                    return number;
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return ru;

	}));

/***/ },
/* 289 */
/*!*******************************!*\
  !*** ./~/moment/locale/se.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Northern Sami [se]
	//! authors : Brd Rolstad Henriksen : https://github.com/karamell

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';



	    var se = moment.defineLocale('se', {
	        months : 'oajagemnnu_guovvamnnu_njukamnnu_cuoomnnu_miessemnnu_geassemnnu_suoidnemnnu_borgemnnu_akamnnu_golggotmnnu_skbmamnnu_juovlamnnu'.split('_'),
	        monthsShort : 'oj_guov_njuk_cuo_mies_geas_suoi_borg_ak_golg_skb_juov'.split('_'),
	        weekdays : 'sotnabeaivi_vuossrga_maebrga_gaskavahkku_duorastat_bearjadat_lvvardat'.split('_'),
	        weekdaysShort : 'sotn_vuos_ma_gask_duor_bear_lv'.split('_'),
	        weekdaysMin : 's_v_m_g_d_b_L'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'MMMM D. [b.] YYYY',
	            LLL : 'MMMM D. [b.] YYYY [ti.] HH:mm',
	            LLLL : 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm'
	        },
	        calendar : {
	            sameDay: '[otne ti] LT',
	            nextDay: '[ihttin ti] LT',
	            nextWeek: 'dddd [ti] LT',
	            lastDay: '[ikte ti] LT',
	            lastWeek: '[ovddit] dddd [ti] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : '%s geaes',
	            past : 'mait %s',
	            s : 'moadde sekunddat',
	            m : 'okta minuhta',
	            mm : '%d minuhtat',
	            h : 'okta diimmu',
	            hh : '%d diimmut',
	            d : 'okta beaivi',
	            dd : '%d beaivvit',
	            M : 'okta mnnu',
	            MM : '%d mnut',
	            y : 'okta jahki',
	            yy : '%d jagit'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return se;

	}));

/***/ },
/* 290 */
/*!*******************************!*\
  !*** ./~/moment/locale/si.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Sinhalese [si]
	//! author : Sampath Sitinamaluwa : https://github.com/sampathsris

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    /*jshint -W100*/
	    var si = moment.defineLocale('si', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'a h:mm',
	            LTS : 'a h:mm:ss',
	            L : 'YYYY/MM/DD',
	            LL : 'YYYY MMMM D',
	            LLL : 'YYYY MMMM D, a h:mm',
	            LLLL : 'YYYY MMMM D [] dddd, a h:mm:ss'
	        },
	        calendar : {
	            sameDay : '[] LT[]',
	            nextDay : '[] LT[]',
	            nextWeek : 'dddd LT[]',
	            lastDay : '[] LT[]',
	            lastWeek : '[] dddd LT[]',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s',
	            past : '%s ',
	            s : ' ',
	            m : '',
	            mm : ' %d',
	            h : '',
	            hh : ' %d',
	            d : '',
	            dd : ' %d',
	            M : '',
	            MM : ' %d',
	            y : '',
	            yy : ' %d'
	        },
	        ordinalParse: /\d{1,2} /,
	        ordinal : function (number) {
	            return number + ' ';
	        },
	        meridiemParse : / | |.|../,
	        isPM : function (input) {
	            return input === '..' || input === ' ';
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours > 11) {
	                return isLower ? '..' : ' ';
	            } else {
	                return isLower ? '..' : ' ';
	            }
	        }
	    });

	    return si;

	}));

/***/ },
/* 291 */
/*!*******************************!*\
  !*** ./~/moment/locale/sk.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Slovak [sk]
	//! author : Martin Minka : https://github.com/k2s
	//! based on work of petrbela : https://github.com/petrbela

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var months = 'janur_februr_marec_aprl_mj_jn_jl_august_september_oktber_november_december'.split('_'),
	        monthsShort = 'jan_feb_mar_apr_mj_jn_jl_aug_sep_okt_nov_dec'.split('_');
	    function plural(n) {
	        return (n > 1) && (n < 5);
	    }
	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        switch (key) {
	            case 's':  // a few seconds / in a few seconds / a few seconds ago
	                return (withoutSuffix || isFuture) ? 'pr seknd' : 'pr sekundami';
	            case 'm':  // a minute / in a minute / a minute ago
	                return withoutSuffix ? 'minta' : (isFuture ? 'mintu' : 'mintou');
	            case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
	                if (withoutSuffix || isFuture) {
	                    return result + (plural(number) ? 'minty' : 'mint');
	                } else {
	                    return result + 'mintami';
	                }
	                break;
	            case 'h':  // an hour / in an hour / an hour ago
	                return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
	            case 'hh': // 9 hours / in 9 hours / 9 hours ago
	                if (withoutSuffix || isFuture) {
	                    return result + (plural(number) ? 'hodiny' : 'hodn');
	                } else {
	                    return result + 'hodinami';
	                }
	                break;
	            case 'd':  // a day / in a day / a day ago
	                return (withoutSuffix || isFuture) ? 'de' : 'dom';
	            case 'dd': // 9 days / in 9 days / 9 days ago
	                if (withoutSuffix || isFuture) {
	                    return result + (plural(number) ? 'dni' : 'dn');
	                } else {
	                    return result + 'dami';
	                }
	                break;
	            case 'M':  // a month / in a month / a month ago
	                return (withoutSuffix || isFuture) ? 'mesiac' : 'mesiacom';
	            case 'MM': // 9 months / in 9 months / 9 months ago
	                if (withoutSuffix || isFuture) {
	                    return result + (plural(number) ? 'mesiace' : 'mesiacov');
	                } else {
	                    return result + 'mesiacmi';
	                }
	                break;
	            case 'y':  // a year / in a year / a year ago
	                return (withoutSuffix || isFuture) ? 'rok' : 'rokom';
	            case 'yy': // 9 years / in 9 years / 9 years ago
	                if (withoutSuffix || isFuture) {
	                    return result + (plural(number) ? 'roky' : 'rokov');
	                } else {
	                    return result + 'rokmi';
	                }
	                break;
	        }
	    }

	    var sk = moment.defineLocale('sk', {
	        months : months,
	        monthsShort : monthsShort,
	        weekdays : 'nedea_pondelok_utorok_streda_tvrtok_piatok_sobota'.split('_'),
	        weekdaysShort : 'ne_po_ut_st_t_pi_so'.split('_'),
	        weekdaysMin : 'ne_po_ut_st_t_pi_so'.split('_'),
	        longDateFormat : {
	            LT: 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd D. MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay: '[dnes o] LT',
	            nextDay: '[zajtra o] LT',
	            nextWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[v nedeu o] LT';
	                    case 1:
	                    case 2:
	                        return '[v] dddd [o] LT';
	                    case 3:
	                        return '[v stredu o] LT';
	                    case 4:
	                        return '[vo tvrtok o] LT';
	                    case 5:
	                        return '[v piatok o] LT';
	                    case 6:
	                        return '[v sobotu o] LT';
	                }
	            },
	            lastDay: '[vera o] LT',
	            lastWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[minul nedeu o] LT';
	                    case 1:
	                    case 2:
	                        return '[minul] dddd [o] LT';
	                    case 3:
	                        return '[minul stredu o] LT';
	                    case 4:
	                    case 5:
	                        return '[minul] dddd [o] LT';
	                    case 6:
	                        return '[minul sobotu o] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past : 'pred %s',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return sk;

	}));

/***/ },
/* 292 */
/*!*******************************!*\
  !*** ./~/moment/locale/sl.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Slovenian [sl]
	//! author : Robert Sedovek : https://github.com/sedovsek

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        switch (key) {
	            case 's':
	                return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';
	            case 'm':
	                return withoutSuffix ? 'ena minuta' : 'eno minuto';
	            case 'mm':
	                if (number === 1) {
	                    result += withoutSuffix ? 'minuta' : 'minuto';
	                } else if (number === 2) {
	                    result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
	                } else if (number < 5) {
	                    result += withoutSuffix || isFuture ? 'minute' : 'minutami';
	                } else {
	                    result += withoutSuffix || isFuture ? 'minut' : 'minutami';
	                }
	                return result;
	            case 'h':
	                return withoutSuffix ? 'ena ura' : 'eno uro';
	            case 'hh':
	                if (number === 1) {
	                    result += withoutSuffix ? 'ura' : 'uro';
	                } else if (number === 2) {
	                    result += withoutSuffix || isFuture ? 'uri' : 'urama';
	                } else if (number < 5) {
	                    result += withoutSuffix || isFuture ? 'ure' : 'urami';
	                } else {
	                    result += withoutSuffix || isFuture ? 'ur' : 'urami';
	                }
	                return result;
	            case 'd':
	                return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';
	            case 'dd':
	                if (number === 1) {
	                    result += withoutSuffix || isFuture ? 'dan' : 'dnem';
	                } else if (number === 2) {
	                    result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
	                } else {
	                    result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
	                }
	                return result;
	            case 'M':
	                return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';
	            case 'MM':
	                if (number === 1) {
	                    result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
	                } else if (number === 2) {
	                    result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
	                } else if (number < 5) {
	                    result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
	                } else {
	                    result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
	                }
	                return result;
	            case 'y':
	                return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';
	            case 'yy':
	                if (number === 1) {
	                    result += withoutSuffix || isFuture ? 'leto' : 'letom';
	                } else if (number === 2) {
	                    result += withoutSuffix || isFuture ? 'leti' : 'letoma';
	                } else if (number < 5) {
	                    result += withoutSuffix || isFuture ? 'leta' : 'leti';
	                } else {
	                    result += withoutSuffix || isFuture ? 'let' : 'leti';
	                }
	                return result;
	        }
	    }

	    var sl = moment.defineLocale('sl', {
	        months : 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
	        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
	        monthsParseExact: true,
	        weekdays : 'nedelja_ponedeljek_torek_sreda_etrtek_petek_sobota'.split('_'),
	        weekdaysShort : 'ned._pon._tor._sre._et._pet._sob.'.split('_'),
	        weekdaysMin : 'ne_po_to_sr_e_pe_so'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY H:mm',
	            LLLL : 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay  : '[danes ob] LT',
	            nextDay  : '[jutri ob] LT',

	            nextWeek : function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[v] [nedeljo] [ob] LT';
	                    case 3:
	                        return '[v] [sredo] [ob] LT';
	                    case 6:
	                        return '[v] [soboto] [ob] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                    case 5:
	                        return '[v] dddd [ob] LT';
	                }
	            },
	            lastDay  : '[veraj ob] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[prejnjo] [nedeljo] [ob] LT';
	                    case 3:
	                        return '[prejnjo] [sredo] [ob] LT';
	                    case 6:
	                        return '[prejnjo] [soboto] [ob] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                    case 5:
	                        return '[prejnji] dddd [ob] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'ez %s',
	            past   : 'pred %s',
	            s      : processRelativeTime,
	            m      : processRelativeTime,
	            mm     : processRelativeTime,
	            h      : processRelativeTime,
	            hh     : processRelativeTime,
	            d      : processRelativeTime,
	            dd     : processRelativeTime,
	            M      : processRelativeTime,
	            MM     : processRelativeTime,
	            y      : processRelativeTime,
	            yy     : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return sl;

	}));

/***/ },
/* 293 */
/*!*******************************!*\
  !*** ./~/moment/locale/sq.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Albanian [sq]
	//! author : Flakrim Ismani : https://github.com/flakerimi
	//! author : Menelion Elensle : https://github.com/Oire
	//! author : Oerd Cukalla : https://github.com/oerd

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var sq = moment.defineLocale('sq', {
	        months : 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nntor_Dhjetor'.split('_'),
	        monthsShort : 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nn_Dhj'.split('_'),
	        weekdays : 'E Diel_E Hn_E Mart_E Mrkur_E Enjte_E Premte_E Shtun'.split('_'),
	        weekdaysShort : 'Die_Hn_Mar_Mr_Enj_Pre_Sht'.split('_'),
	        weekdaysMin : 'D_H_Ma_M_E_P_Sh'.split('_'),
	        weekdaysParseExact : true,
	        meridiemParse: /PD|MD/,
	        isPM: function (input) {
	            return input.charAt(0) === 'M';
	        },
	        meridiem : function (hours, minutes, isLower) {
	            return hours < 12 ? 'PD' : 'MD';
	        },
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[Sot n] LT',
	            nextDay : '[Nesr n] LT',
	            nextWeek : 'dddd [n] LT',
	            lastDay : '[Dje n] LT',
	            lastWeek : 'dddd [e kaluar n] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'n %s',
	            past : '%s m par',
	            s : 'disa sekonda',
	            m : 'nj minut',
	            mm : '%d minuta',
	            h : 'nj or',
	            hh : '%d or',
	            d : 'nj dit',
	            dd : '%d dit',
	            M : 'nj muaj',
	            MM : '%d muaj',
	            y : 'nj vit',
	            yy : '%d vite'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return sq;

	}));

/***/ },
/* 294 */
/*!*******************************!*\
  !*** ./~/moment/locale/sr.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Serbian [sr]
	//! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var translator = {
	        words: { //Different grammatical cases
	            m: ['jedan minut', 'jedne minute'],
	            mm: ['minut', 'minute', 'minuta'],
	            h: ['jedan sat', 'jednog sata'],
	            hh: ['sat', 'sata', 'sati'],
	            dd: ['dan', 'dana', 'dana'],
	            MM: ['mesec', 'meseca', 'meseci'],
	            yy: ['godina', 'godine', 'godina']
	        },
	        correctGrammaticalCase: function (number, wordKey) {
	            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	        },
	        translate: function (number, withoutSuffix, key) {
	            var wordKey = translator.words[key];
	            if (key.length === 1) {
	                return withoutSuffix ? wordKey[0] : wordKey[1];
	            } else {
	                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	            }
	        }
	    };

	    var sr = moment.defineLocale('sr', {
	        months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
	        monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
	        monthsParseExact: true,
	        weekdays: 'nedelja_ponedeljak_utorak_sreda_etvrtak_petak_subota'.split('_'),
	        weekdaysShort: 'ned._pon._uto._sre._et._pet._sub.'.split('_'),
	        weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat: {
	            LT: 'H:mm',
	            LTS : 'H:mm:ss',
	            L: 'DD.MM.YYYY',
	            LL: 'D. MMMM YYYY',
	            LLL: 'D. MMMM YYYY H:mm',
	            LLLL: 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar: {
	            sameDay: '[danas u] LT',
	            nextDay: '[sutra u] LT',
	            nextWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[u] [nedelju] [u] LT';
	                    case 3:
	                        return '[u] [sredu] [u] LT';
	                    case 6:
	                        return '[u] [subotu] [u] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                    case 5:
	                        return '[u] dddd [u] LT';
	                }
	            },
	            lastDay  : '[jue u] LT',
	            lastWeek : function () {
	                var lastWeekDays = [
	                    '[prole] [nedelje] [u] LT',
	                    '[prolog] [ponedeljka] [u] LT',
	                    '[prolog] [utorka] [u] LT',
	                    '[prole] [srede] [u] LT',
	                    '[prolog] [etvrtka] [u] LT',
	                    '[prolog] [petka] [u] LT',
	                    '[prole] [subote] [u] LT'
	                ];
	                return lastWeekDays[this.day()];
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past   : 'pre %s',
	            s      : 'nekoliko sekundi',
	            m      : translator.translate,
	            mm     : translator.translate,
	            h      : translator.translate,
	            hh     : translator.translate,
	            d      : 'dan',
	            dd     : translator.translate,
	            M      : 'mesec',
	            MM     : translator.translate,
	            y      : 'godinu',
	            yy     : translator.translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return sr;

	}));

/***/ },
/* 295 */
/*!************************************!*\
  !*** ./~/moment/locale/sr-cyrl.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Serbian Cyrillic [sr-cyrl]
	//! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var translator = {
	        words: { //Different grammatical cases
	            m: [' ', ' '],
	            mm: ['', '', ''],
	            h: [' ', ' '],
	            hh: ['', '', ''],
	            dd: ['', '', ''],
	            MM: ['', '', ''],
	            yy: ['', '', '']
	        },
	        correctGrammaticalCase: function (number, wordKey) {
	            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	        },
	        translate: function (number, withoutSuffix, key) {
	            var wordKey = translator.words[key];
	            if (key.length === 1) {
	                return withoutSuffix ? wordKey[0] : wordKey[1];
	            } else {
	                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	            }
	        }
	    };

	    var sr_cyrl = moment.defineLocale('sr-cyrl', {
	        months: '___________'.split('_'),
	        monthsShort: '._._._.____._._._._.'.split('_'),
	        monthsParseExact: true,
	        weekdays: '______'.split('_'),
	        weekdaysShort: '._._._._._._.'.split('_'),
	        weekdaysMin: '______'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat: {
	            LT: 'H:mm',
	            LTS : 'H:mm:ss',
	            L: 'DD.MM.YYYY',
	            LL: 'D. MMMM YYYY',
	            LLL: 'D. MMMM YYYY H:mm',
	            LLLL: 'dddd, D. MMMM YYYY H:mm'
	        },
	        calendar: {
	            sameDay: '[ ] LT',
	            nextDay: '[ ] LT',
	            nextWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[] [] [] LT';
	                    case 3:
	                        return '[] [] [] LT';
	                    case 6:
	                        return '[] [] [] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                    case 5:
	                        return '[] dddd [] LT';
	                }
	            },
	            lastDay  : '[ ] LT',
	            lastWeek : function () {
	                var lastWeekDays = [
	                    '[] [] [] LT',
	                    '[] [] [] LT',
	                    '[] [] [] LT',
	                    '[] [] [] LT',
	                    '[] [] [] LT',
	                    '[] [] [] LT',
	                    '[] [] [] LT'
	                ];
	                return lastWeekDays[this.day()];
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past   : ' %s',
	            s      : ' ',
	            m      : translator.translate,
	            mm     : translator.translate,
	            h      : translator.translate,
	            hh     : translator.translate,
	            d      : '',
	            dd     : translator.translate,
	            M      : '',
	            MM     : translator.translate,
	            y      : '',
	            yy     : translator.translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return sr_cyrl;

	}));

/***/ },
/* 296 */
/*!*******************************!*\
  !*** ./~/moment/locale/ss.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : siSwati [ss]
	//! author : Nicolai Davies<mail@nicolai.io> : https://github.com/nicolaidavies

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';



	    var ss = moment.defineLocale('ss', {
	        months : "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split('_'),
	        monthsShort : 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),
	        weekdays : 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split('_'),
	        weekdaysShort : 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),
	        weekdaysMin : 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY h:mm A',
	            LLLL : 'dddd, D MMMM YYYY h:mm A'
	        },
	        calendar : {
	            sameDay : '[Namuhla nga] LT',
	            nextDay : '[Kusasa nga] LT',
	            nextWeek : 'dddd [nga] LT',
	            lastDay : '[Itolo nga] LT',
	            lastWeek : 'dddd [leliphelile] [nga] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'nga %s',
	            past : 'wenteka nga %s',
	            s : 'emizuzwana lomcane',
	            m : 'umzuzu',
	            mm : '%d emizuzu',
	            h : 'lihora',
	            hh : '%d emahora',
	            d : 'lilanga',
	            dd : '%d emalanga',
	            M : 'inyanga',
	            MM : '%d tinyanga',
	            y : 'umnyaka',
	            yy : '%d iminyaka'
	        },
	        meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 11) {
	                return 'ekuseni';
	            } else if (hours < 15) {
	                return 'emini';
	            } else if (hours < 19) {
	                return 'entsambama';
	            } else {
	                return 'ebusuku';
	            }
	        },
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'ekuseni') {
	                return hour;
	            } else if (meridiem === 'emini') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === 'entsambama' || meridiem === 'ebusuku') {
	                if (hour === 0) {
	                    return 0;
	                }
	                return hour + 12;
	            }
	        },
	        ordinalParse: /\d{1,2}/,
	        ordinal : '%d',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return ss;

	}));

/***/ },
/* 297 */
/*!*******************************!*\
  !*** ./~/moment/locale/sv.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Swedish [sv]
	//! author : Jens Alm : https://github.com/ulmus

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var sv = moment.defineLocale('sv', {
	        months : 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
	        weekdays : 'sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag'.split('_'),
	        weekdaysShort : 'sn_mn_tis_ons_tor_fre_lr'.split('_'),
	        weekdaysMin : 's_m_ti_on_to_fr_l'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY [kl.] HH:mm',
	            LLLL : 'dddd D MMMM YYYY [kl.] HH:mm',
	            lll : 'D MMM YYYY HH:mm',
	            llll : 'ddd D MMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Idag] LT',
	            nextDay: '[Imorgon] LT',
	            lastDay: '[Igr] LT',
	            nextWeek: '[P] dddd LT',
	            lastWeek: '[I] dddd[s] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'om %s',
	            past : 'fr %s sedan',
	            s : 'ngra sekunder',
	            m : 'en minut',
	            mm : '%d minuter',
	            h : 'en timme',
	            hh : '%d timmar',
	            d : 'en dag',
	            dd : '%d dagar',
	            M : 'en mnad',
	            MM : '%d mnader',
	            y : 'ett r',
	            yy : '%d r'
	        },
	        ordinalParse: /\d{1,2}(e|a)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'e' :
	                (b === 1) ? 'a' :
	                (b === 2) ? 'a' :
	                (b === 3) ? 'e' : 'e';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return sv;

	}));

/***/ },
/* 298 */
/*!*******************************!*\
  !*** ./~/moment/locale/sw.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Swahili [sw]
	//! author : Fahad Kassim : https://github.com/fadsel

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var sw = moment.defineLocale('sw', {
	        months : 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split('_'),
	        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),
	        weekdays : 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split('_'),
	        weekdaysShort : 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),
	        weekdaysMin : 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[leo saa] LT',
	            nextDay : '[kesho saa] LT',
	            nextWeek : '[wiki ijayo] dddd [saat] LT',
	            lastDay : '[jana] LT',
	            lastWeek : '[wiki iliyopita] dddd [saat] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s baadaye',
	            past : 'tokea %s',
	            s : 'hivi punde',
	            m : 'dakika moja',
	            mm : 'dakika %d',
	            h : 'saa limoja',
	            hh : 'masaa %d',
	            d : 'siku moja',
	            dd : 'masiku %d',
	            M : 'mwezi mmoja',
	            MM : 'miezi %d',
	            y : 'mwaka mmoja',
	            yy : 'miaka %d'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return sw;

	}));

/***/ },
/* 299 */
/*!*******************************!*\
  !*** ./~/moment/locale/ta.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Tamil [ta]
	//! author : Arjunkumar Krishnamoorthy : https://github.com/tk120404

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var symbolMap = {
	        '1': '',
	        '2': '',
	        '3': '',
	        '4': '',
	        '5': '',
	        '6': '',
	        '7': '',
	        '8': '',
	        '9': '',
	        '0': ''
	    }, numberMap = {
	        '': '1',
	        '': '2',
	        '': '3',
	        '': '4',
	        '': '5',
	        '': '6',
	        '': '7',
	        '': '8',
	        '': '9',
	        '': '0'
	    };

	    var ta = moment.defineLocale('ta', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, HH:mm',
	            LLLL : 'dddd, D MMMM YYYY, HH:mm'
	        },
	        calendar : {
	            sameDay : '[] LT',
	            nextDay : '[] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[] LT',
	            lastWeek : '[ ] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ',
	            past : '%s ',
	            s : '  ',
	            m : ' ',
	            mm : '%d ',
	            h : '  ',
	            hh : '%d  ',
	            d : ' ',
	            dd : '%d ',
	            M : ' ',
	            MM : '%d ',
	            y : ' ',
	            yy : '%d '
	        },
	        ordinalParse: /\d{1,2}/,
	        ordinal : function (number) {
	            return number + '';
	        },
	        preparse: function (string) {
	            return string.replace(/[]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        // refer http://ta.wikipedia.org/s/1er1
	        meridiemParse: /|||||/,
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 2) {
	                return ' ';
	            } else if (hour < 6) {
	                return ' ';  // 
	            } else if (hour < 10) {
	                return ' '; // 
	            } else if (hour < 14) {
	                return ' '; // 
	            } else if (hour < 18) {
	                return ' '; // 
	            } else if (hour < 22) {
	                return ' '; // 
	            } else {
	                return ' ';
	            }
	        },
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === '') {
	                return hour < 2 ? hour : hour + 12;
	            } else if (meridiem === '' || meridiem === '') {
	                return hour;
	            } else if (meridiem === '') {
	                return hour >= 10 ? hour : hour + 12;
	            } else {
	                return hour + 12;
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return ta;

	}));

/***/ },
/* 300 */
/*!*******************************!*\
  !*** ./~/moment/locale/te.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Telugu [te]
	//! author : Krishna Chaitanya Thota : https://github.com/kcthota

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var te = moment.defineLocale('te', {
	        months : '___________'.split('_'),
	        monthsShort : '._.__.____._._._._.'.split('_'),
	        monthsParseExact : true,
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm',
	            LTS : 'A h:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, A h:mm',
	            LLLL : 'dddd, D MMMM YYYY, A h:mm'
	        },
	        calendar : {
	            sameDay : '[] LT',
	            nextDay : '[] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[] LT',
	            lastWeek : '[] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ',
	            past : '%s ',
	            s : ' ',
	            m : ' ',
	            mm : '%d ',
	            h : ' ',
	            hh : '%d ',
	            d : ' ',
	            dd : '%d ',
	            M : ' ',
	            MM : '%d ',
	            y : ' ',
	            yy : '%d '
	        },
	        ordinalParse : /\d{1,2}/,
	        ordinal : '%d',
	        meridiemParse: /|||/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === '') {
	                return hour < 4 ? hour : hour + 12;
	            } else if (meridiem === '') {
	                return hour;
	            } else if (meridiem === '') {
	                return hour >= 10 ? hour : hour + 12;
	            } else if (meridiem === '') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return '';
	            } else if (hour < 10) {
	                return '';
	            } else if (hour < 17) {
	                return '';
	            } else if (hour < 20) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return te;

	}));

/***/ },
/* 301 */
/*!*******************************!*\
  !*** ./~/moment/locale/th.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Thai [th]
	//! author : Kridsada Thanabulpong : https://github.com/sirn

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var th = moment.defineLocale('th', {
	        months : '___________'.split('_'),
	        monthsShort : '.._.._.._.._.._.._.._.._.._.._.._..'.split('_'),
	        monthsParseExact: true,
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'), // yes, three characters difference
	        weekdaysMin : '._._._._._._.'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'H:mm:ss',
	            L : 'YYYY/MM/DD',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY  H:mm',
	            LLLL : 'dddd D MMMM YYYY  H:mm'
	        },
	        meridiemParse: /|/,
	        isPM: function (input) {
	            return input === '';
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        calendar : {
	            sameDay : '[ ] LT',
	            nextDay : '[ ] LT',
	            nextWeek : 'dddd[ ] LT',
	            lastDay : '[ ] LT',
	            lastWeek : '[]dddd[ ] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : '%s',
	            s : '',
	            m : '1 ',
	            mm : '%d ',
	            h : '1 ',
	            hh : '%d ',
	            d : '1 ',
	            dd : '%d ',
	            M : '1 ',
	            MM : '%d ',
	            y : '1 ',
	            yy : '%d '
	        }
	    });

	    return th;

	}));

/***/ },
/* 302 */
/*!**********************************!*\
  !*** ./~/moment/locale/tl-ph.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Tagalog (Philippines) [tl-ph]
	//! author : Dan Hagman : https://github.com/hagmandan

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var tl_ph = moment.defineLocale('tl-ph', {
	        months : 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
	        monthsShort : 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
	        weekdays : 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
	        weekdaysShort : 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
	        weekdaysMin : 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'MM/D/YYYY',
	            LL : 'MMMM D, YYYY',
	            LLL : 'MMMM D, YYYY HH:mm',
	            LLLL : 'dddd, MMMM DD, YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Ngayon sa] LT',
	            nextDay: '[Bukas sa] LT',
	            nextWeek: 'dddd [sa] LT',
	            lastDay: '[Kahapon sa] LT',
	            lastWeek: 'dddd [huling linggo] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'sa loob ng %s',
	            past : '%s ang nakalipas',
	            s : 'ilang segundo',
	            m : 'isang minuto',
	            mm : '%d minuto',
	            h : 'isang oras',
	            hh : '%d oras',
	            d : 'isang araw',
	            dd : '%d araw',
	            M : 'isang buwan',
	            MM : '%d buwan',
	            y : 'isang taon',
	            yy : '%d taon'
	        },
	        ordinalParse: /\d{1,2}/,
	        ordinal : function (number) {
	            return number;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return tl_ph;

	}));

/***/ },
/* 303 */
/*!********************************!*\
  !*** ./~/moment/locale/tlh.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Klingon [tlh]
	//! author : Dominika Kruk : https://github.com/amaranthrose

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var numbersNouns = 'pagh_wa_cha_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');

	    function translateFuture(output) {
	        var time = output;
	        time = (output.indexOf('jaj') !== -1) ?
	        time.slice(0, -3) + 'leS' :
	        (output.indexOf('jar') !== -1) ?
	        time.slice(0, -3) + 'waQ' :
	        (output.indexOf('DIS') !== -1) ?
	        time.slice(0, -3) + 'nem' :
	        time + ' pIq';
	        return time;
	    }

	    function translatePast(output) {
	        var time = output;
	        time = (output.indexOf('jaj') !== -1) ?
	        time.slice(0, -3) + 'Hu' :
	        (output.indexOf('jar') !== -1) ?
	        time.slice(0, -3) + 'wen' :
	        (output.indexOf('DIS') !== -1) ?
	        time.slice(0, -3) + 'ben' :
	        time + ' ret';
	        return time;
	    }

	    function translate(number, withoutSuffix, string, isFuture) {
	        var numberNoun = numberAsNoun(number);
	        switch (string) {
	            case 'mm':
	                return numberNoun + ' tup';
	            case 'hh':
	                return numberNoun + ' rep';
	            case 'dd':
	                return numberNoun + ' jaj';
	            case 'MM':
	                return numberNoun + ' jar';
	            case 'yy':
	                return numberNoun + ' DIS';
	        }
	    }

	    function numberAsNoun(number) {
	        var hundred = Math.floor((number % 1000) / 100),
	        ten = Math.floor((number % 100) / 10),
	        one = number % 10,
	        word = '';
	        if (hundred > 0) {
	            word += numbersNouns[hundred] + 'vatlh';
	        }
	        if (ten > 0) {
	            word += ((word !== '') ? ' ' : '') + numbersNouns[ten] + 'maH';
	        }
	        if (one > 0) {
	            word += ((word !== '') ? ' ' : '') + numbersNouns[one];
	        }
	        return (word === '') ? 'pagh' : word;
	    }

	    var tlh = moment.defineLocale('tlh', {
	        months : 'tera jar wa_tera jar cha_tera jar wej_tera jar loS_tera jar vagh_tera jar jav_tera jar Soch_tera jar chorgh_tera jar Hut_tera jar wamaH_tera jar wamaH wa_tera jar wamaH cha'.split('_'),
	        monthsShort : 'jar wa_jar cha_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wamaH_jar wamaH wa_jar wamaH cha'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
	        weekdaysShort : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
	        weekdaysMin : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[DaHjaj] LT',
	            nextDay: '[waleS] LT',
	            nextWeek: 'LLL',
	            lastDay: '[waHu] LT',
	            lastWeek: 'LLL',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : translateFuture,
	            past : translatePast,
	            s : 'puS lup',
	            m : 'wa tup',
	            mm : translate,
	            h : 'wa rep',
	            hh : translate,
	            d : 'wa jaj',
	            dd : translate,
	            M : 'wa jar',
	            MM : translate,
	            y : 'wa DIS',
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return tlh;

	}));

/***/ },
/* 304 */
/*!*******************************!*\
  !*** ./~/moment/locale/tr.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Turkish [tr]
	//! authors : Erhan Gundogan : https://github.com/erhangundogan,
	//!           Burak Yiit Kaya: https://github.com/BYK

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var suffixes = {
	        1: '\'inci',
	        5: '\'inci',
	        8: '\'inci',
	        70: '\'inci',
	        80: '\'inci',
	        2: '\'nci',
	        7: '\'nci',
	        20: '\'nci',
	        50: '\'nci',
	        3: '\'nc',
	        4: '\'nc',
	        100: '\'nc',
	        6: '\'nc',
	        9: '\'uncu',
	        10: '\'uncu',
	        30: '\'uncu',
	        60: '\'nc',
	        90: '\'nc'
	    };

	    var tr = moment.defineLocale('tr', {
	        months : 'Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk'.split('_'),
	        monthsShort : 'Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara'.split('_'),
	        weekdays : 'Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi'.split('_'),
	        weekdaysShort : 'Paz_Pts_Sal_ar_Per_Cum_Cts'.split('_'),
	        weekdaysMin : 'Pz_Pt_Sa_a_Pe_Cu_Ct'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[bugn saat] LT',
	            nextDay : '[yarn saat] LT',
	            nextWeek : '[haftaya] dddd [saat] LT',
	            lastDay : '[dn] LT',
	            lastWeek : '[geen hafta] dddd [saat] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s sonra',
	            past : '%s nce',
	            s : 'birka saniye',
	            m : 'bir dakika',
	            mm : '%d dakika',
	            h : 'bir saat',
	            hh : '%d saat',
	            d : 'bir gn',
	            dd : '%d gn',
	            M : 'bir ay',
	            MM : '%d ay',
	            y : 'bir yl',
	            yy : '%d yl'
	        },
	        ordinalParse: /\d{1,2}'(inci|nci|nc|nc|uncu|nc)/,
	        ordinal : function (number) {
	            if (number === 0) {  // special case for zero
	                return number + '\'nc';
	            }
	            var a = number % 10,
	                b = number % 100 - a,
	                c = number >= 100 ? 100 : null;
	            return number + (suffixes[a] || suffixes[b] || suffixes[c]);
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return tr;

	}));

/***/ },
/* 305 */
/*!********************************!*\
  !*** ./~/moment/locale/tzl.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Talossan [tzl]
	//! author : Robin van der Vliet : https://github.com/robin0van0der0v
	//! author : Iust Canun

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    // After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
	    // This is currently too difficult (maybe even impossible) to add.
	    var tzl = moment.defineLocale('tzl', {
	        months : 'Januar_Fevraglh_Mar_Avru_Mai_Gn_Julia_Guscht_Setemvar_Listopts_Noemvar_Zecemvar'.split('_'),
	        monthsShort : 'Jan_Fev_Mar_Avr_Mai_Gn_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
	        weekdays : 'Sladi_Lnei_Maitzi_Mrcuri_Xhadi_Vineri_Sturi'.split('_'),
	        weekdaysShort : 'Sl_Ln_Mai_Mr_Xh_Vi_St'.split('_'),
	        weekdaysMin : 'S_L_Ma_M_Xh_Vi_S'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM [dallas] YYYY',
	            LLL : 'D. MMMM [dallas] YYYY HH.mm',
	            LLLL : 'dddd, [li] D. MMMM [dallas] YYYY HH.mm'
	        },
	        meridiemParse: /d\'o|d\'a/i,
	        isPM : function (input) {
	            return 'd\'o' === input.toLowerCase();
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours > 11) {
	                return isLower ? 'd\'o' : 'D\'O';
	            } else {
	                return isLower ? 'd\'a' : 'D\'A';
	            }
	        },
	        calendar : {
	            sameDay : '[oxhi ] LT',
	            nextDay : '[dem ] LT',
	            nextWeek : 'dddd [] LT',
	            lastDay : '[ieiri ] LT',
	            lastWeek : '[sr el] dddd [lasteu ] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'osprei %s',
	            past : 'ja%s',
	            s : processRelativeTime,
	            m : processRelativeTime,
	            mm : processRelativeTime,
	            h : processRelativeTime,
	            hh : processRelativeTime,
	            d : processRelativeTime,
	            dd : processRelativeTime,
	            M : processRelativeTime,
	            MM : processRelativeTime,
	            y : processRelativeTime,
	            yy : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            's': ['viensas secunds', '\'iensas secunds'],
	            'm': ['\'n mut', '\'iens mut'],
	            'mm': [number + ' muts', '' + number + ' muts'],
	            'h': ['\'n ora', '\'iensa ora'],
	            'hh': [number + ' oras', '' + number + ' oras'],
	            'd': ['\'n ziua', '\'iensa ziua'],
	            'dd': [number + ' ziuas', '' + number + ' ziuas'],
	            'M': ['\'n mes', '\'iens mes'],
	            'MM': [number + ' mesen', '' + number + ' mesen'],
	            'y': ['\'n ar', '\'iens ar'],
	            'yy': [number + ' ars', '' + number + ' ars']
	        };
	        return isFuture ? format[key][0] : (withoutSuffix ? format[key][0] : format[key][1]);
	    }

	    return tzl;

	}));

/***/ },
/* 306 */
/*!********************************!*\
  !*** ./~/moment/locale/tzm.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Central Atlas Tamazight [tzm]
	//! author : Abdel Said : https://github.com/abdelsaid

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var tzm = moment.defineLocale('tzm', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[ ] LT',
	            nextDay: '[ ] LT',
	            nextWeek: 'dddd [] LT',
	            lastDay: '[ ] LT',
	            lastWeek: 'dddd [] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : '   %s',
	            past : ' %s',
	            s : '',
	            m : '',
	            mm : '%d ',
	            h : '',
	            hh : '%d ',
	            d : '',
	            dd : '%d o',
	            M : 'o',
	            MM : '%d ',
	            y : '',
	            yy : '%d '
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return tzm;

	}));

/***/ },
/* 307 */
/*!*************************************!*\
  !*** ./~/moment/locale/tzm-latn.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Central Atlas Tamazight Latin [tzm-latn]
	//! author : Abdel Said : https://github.com/abdelsaid

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var tzm_latn = moment.defineLocale('tzm-latn', {
	        months : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
	        monthsShort : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
	        weekdays : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
	        weekdaysShort : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
	        weekdaysMin : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[asdkh g] LT',
	            nextDay: '[aska g] LT',
	            nextWeek: 'dddd [g] LT',
	            lastDay: '[assant g] LT',
	            lastWeek: 'dddd [g] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'dadkh s yan %s',
	            past : 'yan %s',
	            s : 'imik',
	            m : 'minu',
	            mm : '%d minu',
	            h : 'saa',
	            hh : '%d tassain',
	            d : 'ass',
	            dd : '%d ossan',
	            M : 'ayowr',
	            MM : '%d iyyirn',
	            y : 'asgas',
	            yy : '%d isgasn'
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return tzm_latn;

	}));

/***/ },
/* 308 */
/*!*******************************!*\
  !*** ./~/moment/locale/uk.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Ukrainian [uk]
	//! author : zemlanin : https://github.com/zemlanin
	//! Author : Menelion Elensle : https://github.com/Oire

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    function plural(word, num) {
	        var forms = word.split('_');
	        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	    }
	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        var format = {
	            'mm': withoutSuffix ? '__' : '__',
	            'hh': withoutSuffix ? '__' : '__',
	            'dd': '__',
	            'MM': '__',
	            'yy': '__'
	        };
	        if (key === 'm') {
	            return withoutSuffix ? '' : '';
	        }
	        else if (key === 'h') {
	            return withoutSuffix ? '' : '';
	        }
	        else {
	            return number + ' ' + plural(format[key], +number);
	        }
	    }
	    function weekdaysCaseReplace(m, format) {
	        var weekdays = {
	            'nominative': '______'.split('_'),
	            'accusative': '______'.split('_'),
	            'genitive': '______'.split('_')
	        },
	        nounCase = (/(\[[]\]) ?dddd/).test(format) ?
	            'accusative' :
	            ((/\[?(?:|)? ?\] ?dddd/).test(format) ?
	                'genitive' :
	                'nominative');
	        return weekdays[nounCase][m.day()];
	    }
	    function processHoursFunction(str) {
	        return function () {
	            return str + '' + (this.hours() === 11 ? '' : '') + '] LT';
	        };
	    }

	    var uk = moment.defineLocale('uk', {
	        months : {
	            'format': '___________'.split('_'),
	            'standalone': '___________'.split('_')
	        },
	        monthsShort : '___________'.split('_'),
	        weekdays : weekdaysCaseReplace,
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY .',
	            LLL : 'D MMMM YYYY ., HH:mm',
	            LLLL : 'dddd, D MMMM YYYY ., HH:mm'
	        },
	        calendar : {
	            sameDay: processHoursFunction('[ '),
	            nextDay: processHoursFunction('[ '),
	            lastDay: processHoursFunction('[ '),
	            nextWeek: processHoursFunction('[] dddd ['),
	            lastWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                    case 3:
	                    case 5:
	                    case 6:
	                        return processHoursFunction('[] dddd [').call(this);
	                    case 1:
	                    case 2:
	                    case 4:
	                        return processHoursFunction('[] dddd [').call(this);
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : ' %s',
	            past : '%s ',
	            s : ' ',
	            m : relativeTimeWithPlural,
	            mm : relativeTimeWithPlural,
	            h : '',
	            hh : relativeTimeWithPlural,
	            d : '',
	            dd : relativeTimeWithPlural,
	            M : '',
	            MM : relativeTimeWithPlural,
	            y : '',
	            yy : relativeTimeWithPlural
	        },
	        // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
	        meridiemParse: /|||/,
	        isPM: function (input) {
	            return /^(|)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return '';
	            } else if (hour < 12) {
	                return '';
	            } else if (hour < 17) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        ordinalParse: /\d{1,2}-(|)/,
	        ordinal: function (number, period) {
	            switch (period) {
	                case 'M':
	                case 'd':
	                case 'DDD':
	                case 'w':
	                case 'W':
	                    return number + '-';
	                case 'D':
	                    return number + '-';
	                default:
	                    return number;
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });

	    return uk;

	}));

/***/ },
/* 309 */
/*!*******************************!*\
  !*** ./~/moment/locale/uz.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Uzbek [uz]
	//! author : Sardor Muminov : https://github.com/muminoff

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var uz = moment.defineLocale('uz', {
	        months : '___________'.split('_'),
	        monthsShort : '___________'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'D MMMM YYYY, dddd HH:mm'
	        },
	        calendar : {
	            sameDay : '[ ] LT []',
	            nextDay : '[] LT []',
	            nextWeek : 'dddd [ ] LT []',
	            lastDay : '[ ] LT []',
	            lastWeek : '[] dddd [ ] LT []',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : ' %s ',
	            past : '  %s ',
	            s : '',
	            m : ' ',
	            mm : '%d ',
	            h : ' ',
	            hh : '%d ',
	            d : ' ',
	            dd : '%d ',
	            M : ' ',
	            MM : '%d ',
	            y : ' ',
	            yy : '%d '
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return uz;

	}));

/***/ },
/* 310 */
/*!*******************************!*\
  !*** ./~/moment/locale/vi.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Vietnamese [vi]
	//! author : Bang Nguyen : https://github.com/bangnk

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var vi = moment.defineLocale('vi', {
	        months : 'thng 1_thng 2_thng 3_thng 4_thng 5_thng 6_thng 7_thng 8_thng 9_thng 10_thng 11_thng 12'.split('_'),
	        monthsShort : 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'ch nht_th hai_th ba_th t_th nm_th su_th by'.split('_'),
	        weekdaysShort : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
	        weekdaysMin : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
	        weekdaysParseExact : true,
	        meridiemParse: /sa|ch/i,
	        isPM : function (input) {
	            return /^ch$/i.test(input);
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 12) {
	                return isLower ? 'sa' : 'SA';
	            } else {
	                return isLower ? 'ch' : 'CH';
	            }
	        },
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM [nm] YYYY',
	            LLL : 'D MMMM [nm] YYYY HH:mm',
	            LLLL : 'dddd, D MMMM [nm] YYYY HH:mm',
	            l : 'DD/M/YYYY',
	            ll : 'D MMM YYYY',
	            lll : 'D MMM YYYY HH:mm',
	            llll : 'ddd, D MMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay: '[Hm nay lc] LT',
	            nextDay: '[Ngy mai lc] LT',
	            nextWeek: 'dddd [tun ti lc] LT',
	            lastDay: '[Hm qua lc] LT',
	            lastWeek: 'dddd [tun ri lc] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : '%s ti',
	            past : '%s trc',
	            s : 'vi giy',
	            m : 'mt pht',
	            mm : '%d pht',
	            h : 'mt gi',
	            hh : '%d gi',
	            d : 'mt ngy',
	            dd : '%d ngy',
	            M : 'mt thng',
	            MM : '%d thng',
	            y : 'mt nm',
	            yy : '%d nm'
	        },
	        ordinalParse: /\d{1,2}/,
	        ordinal : function (number) {
	            return number;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return vi;

	}));

/***/ },
/* 311 */
/*!*************************************!*\
  !*** ./~/moment/locale/x-pseudo.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Pseudo [x-pseudo]
	//! author : Andrew Hood : https://github.com/andrewhood125

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var x_pseudo = moment.defineLocale('x-pseudo', {
	        months : 'J~~r_F~br~r_~Mrc~h_p~rl_~M_~J~_Jl~_~gst~_Sp~tmb~r_~ctb~r_~vm~br_~Dc~mbr'.split('_'),
	        monthsShort : 'J~_~Fb_~Mr_~pr_~M_~J_~Jl_~g_~Sp_~ct_~v_~Dc'.split('_'),
	        monthsParseExact : true,
	        weekdays : 'S~d~_M~d~_T~sd~_Wd~sd~_T~hrs~d_~Frd~_S~tr~d'.split('_'),
	        weekdaysShort : 'S~_~M_~T_~Wd_~Th_~Fr_~St'.split('_'),
	        weekdaysMin : 'S~_M~_T_~W_T~h_Fr~_S'.split('_'),
	        weekdaysParseExact : true,
	        longDateFormat : {
	            LT : 'HH:mm',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY HH:mm',
	            LLLL : 'dddd, D MMMM YYYY HH:mm'
	        },
	        calendar : {
	            sameDay : '[T~d~ t] LT',
	            nextDay : '[T~m~rr~w t] LT',
	            nextWeek : 'dddd [t] LT',
	            lastDay : '[~st~rd~ t] LT',
	            lastWeek : '[L~st] dddd [t] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '~ %s',
	            past : '%s ~g',
	            s : ' ~fw ~sc~ds',
	            m : ' ~m~t',
	            mm : '%d m~~ts',
	            h : '~ h~r',
	            hh : '%d h~rs',
	            d : ' ~d',
	            dd : '%d d~s',
	            M : ' ~m~th',
	            MM : '%d m~t~hs',
	            y : ' ~r',
	            yy : '%d ~rs'
	        },
	        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return x_pseudo;

	}));

/***/ },
/* 312 */
/*!**********************************!*\
  !*** ./~/moment/locale/zh-cn.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Chinese (China) [zh-cn]
	//! author : suupic : https://github.com/suupic
	//! author : Zeno Zeng : https://github.com/zenozeng

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var zh_cn = moment.defineLocale('zh-cn', {
	        months : '___________'.split('_'),
	        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'Ahmm',
	            LTS : 'Ahms',
	            L : 'YYYY-MM-DD',
	            LL : 'YYYYMMMD',
	            LLL : 'YYYYMMMDAhmm',
	            LLLL : 'YYYYMMMDddddAhmm',
	            l : 'YYYY-MM-DD',
	            ll : 'YYYYMMMD',
	            lll : 'YYYYMMMDAhmm',
	            llll : 'YYYYMMMDddddAhmm'
	        },
	        meridiemParse: /|||||/,
	        meridiemHour: function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === '' || meridiem === '' ||
	                    meridiem === '') {
	                return hour;
	            } else if (meridiem === '' || meridiem === '') {
	                return hour + 12;
	            } else {
	                // ''
	                return hour >= 11 ? hour : hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            var hm = hour * 100 + minute;
	            if (hm < 600) {
	                return '';
	            } else if (hm < 900) {
	                return '';
	            } else if (hm < 1130) {
	                return '';
	            } else if (hm < 1230) {
	                return '';
	            } else if (hm < 1800) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        calendar : {
	            sameDay : function () {
	                return this.minutes() === 0 ? '[]Ah[]' : '[]LT';
	            },
	            nextDay : function () {
	                return this.minutes() === 0 ? '[]Ah[]' : '[]LT';
	            },
	            lastDay : function () {
	                return this.minutes() === 0 ? '[]Ah[]' : '[]LT';
	            },
	            nextWeek : function () {
	                var startOfWeek, prefix;
	                startOfWeek = moment().startOf('week');
	                prefix = this.diff(startOfWeek, 'days') >= 7 ? '[]' : '[]';
	                return this.minutes() === 0 ? prefix + 'dddAh' : prefix + 'dddAhmm';
	            },
	            lastWeek : function () {
	                var startOfWeek, prefix;
	                startOfWeek = moment().startOf('week');
	                prefix = this.unix() < startOfWeek.unix()  ? '[]' : '[]';
	                return this.minutes() === 0 ? prefix + 'dddAh' : prefix + 'dddAhmm';
	            },
	            sameElse : 'LL'
	        },
	        ordinalParse: /\d{1,2}(||)/,
	        ordinal : function (number, period) {
	            switch (period) {
	                case 'd':
	                case 'D':
	                case 'DDD':
	                    return number + '';
	                case 'M':
	                    return number + '';
	                case 'w':
	                case 'W':
	                    return number + '';
	                default:
	                    return number;
	            }
	        },
	        relativeTime : {
	            future : '%s',
	            past : '%s',
	            s : '',
	            m : '1 ',
	            mm : '%d ',
	            h : '1 ',
	            hh : '%d ',
	            d : '1 ',
	            dd : '%d ',
	            M : '1 ',
	            MM : '%d ',
	            y : '1 ',
	            yy : '%d '
	        },
	        week : {
	            // GB/T 7408-1994ISO 8601:1988
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });

	    return zh_cn;

	}));

/***/ },
/* 313 */
/*!**********************************!*\
  !*** ./~/moment/locale/zh-hk.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Chinese (Hong Kong) [zh-hk]
	//! author : Ben : https://github.com/ben-lin
	//! author : Chris Lam : https://github.com/hehachris
	//! author : Konstantin : https://github.com/skfd

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var zh_hk = moment.defineLocale('zh-hk', {
	        months : '___________'.split('_'),
	        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'Ahmm',
	            LTS : 'Ahms',
	            L : 'YYYYMMMD',
	            LL : 'YYYYMMMD',
	            LLL : 'YYYYMMMDAhmm',
	            LLLL : 'YYYYMMMDddddAhmm',
	            l : 'YYYYMMMD',
	            ll : 'YYYYMMMD',
	            lll : 'YYYYMMMDAhmm',
	            llll : 'YYYYMMMDddddAhmm'
	        },
	        meridiemParse: /|||||/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === '' || meridiem === '' || meridiem === '') {
	                return hour;
	            } else if (meridiem === '') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === '' || meridiem === '') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            var hm = hour * 100 + minute;
	            if (hm < 600) {
	                return '';
	            } else if (hm < 900) {
	                return '';
	            } else if (hm < 1130) {
	                return '';
	            } else if (hm < 1230) {
	                return '';
	            } else if (hm < 1800) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        calendar : {
	            sameDay : '[]LT',
	            nextDay : '[]LT',
	            nextWeek : '[]ddddLT',
	            lastDay : '[]LT',
	            lastWeek : '[]ddddLT',
	            sameElse : 'L'
	        },
	        ordinalParse: /\d{1,2}(||)/,
	        ordinal : function (number, period) {
	            switch (period) {
	                case 'd' :
	                case 'D' :
	                case 'DDD' :
	                    return number + '';
	                case 'M' :
	                    return number + '';
	                case 'w' :
	                case 'W' :
	                    return number + '';
	                default :
	                    return number;
	            }
	        },
	        relativeTime : {
	            future : '%s',
	            past : '%s',
	            s : '',
	            m : '1 ',
	            mm : '%d ',
	            h : '1 ',
	            hh : '%d ',
	            d : '1 ',
	            dd : '%d ',
	            M : '1 ',
	            MM : '%d ',
	            y : '1 ',
	            yy : '%d '
	        }
	    });

	    return zh_hk;

	}));

/***/ },
/* 314 */
/*!**********************************!*\
  !*** ./~/moment/locale/zh-tw.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Chinese (Taiwan) [zh-tw]
	//! author : Ben : https://github.com/ben-lin
	//! author : Chris Lam : https://github.com/hehachris

	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 209)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, function (moment) { 'use strict';


	    var zh_tw = moment.defineLocale('zh-tw', {
	        months : '___________'.split('_'),
	        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	        weekdays : '______'.split('_'),
	        weekdaysShort : '______'.split('_'),
	        weekdaysMin : '______'.split('_'),
	        longDateFormat : {
	            LT : 'Ahmm',
	            LTS : 'Ahms',
	            L : 'YYYYMMMD',
	            LL : 'YYYYMMMD',
	            LLL : 'YYYYMMMDAhmm',
	            LLLL : 'YYYYMMMDddddAhmm',
	            l : 'YYYYMMMD',
	            ll : 'YYYYMMMD',
	            lll : 'YYYYMMMDAhmm',
	            llll : 'YYYYMMMDddddAhmm'
	        },
	        meridiemParse: /|||||/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === '' || meridiem === '' || meridiem === '') {
	                return hour;
	            } else if (meridiem === '') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === '' || meridiem === '') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            var hm = hour * 100 + minute;
	            if (hm < 600) {
	                return '';
	            } else if (hm < 900) {
	                return '';
	            } else if (hm < 1130) {
	                return '';
	            } else if (hm < 1230) {
	                return '';
	            } else if (hm < 1800) {
	                return '';
	            } else {
	                return '';
	            }
	        },
	        calendar : {
	            sameDay : '[]LT',
	            nextDay : '[]LT',
	            nextWeek : '[]ddddLT',
	            lastDay : '[]LT',
	            lastWeek : '[]ddddLT',
	            sameElse : 'L'
	        },
	        ordinalParse: /\d{1,2}(||)/,
	        ordinal : function (number, period) {
	            switch (period) {
	                case 'd' :
	                case 'D' :
	                case 'DDD' :
	                    return number + '';
	                case 'M' :
	                    return number + '';
	                case 'w' :
	                case 'W' :
	                    return number + '';
	                default :
	                    return number;
	            }
	        },
	        relativeTime : {
	            future : '%s',
	            past : '%s',
	            s : '',
	            m : '1 ',
	            mm : '%d ',
	            h : '1 ',
	            hh : '%d ',
	            d : '1 ',
	            dd : '%d ',
	            M : '1 ',
	            MM : '%d ',
	            y : '1 ',
	            yy : '%d '
	        }
	    });

	    return zh_tw;

	}));

/***/ },
/* 315 */
/*!*****************************************!*\
  !*** ./~/node-helpers/gsap-defaults.js ***!
  \*****************************************/
/***/ function(module, exports) {

	'use strict';

	module.exports = function gsapd(global) {
	    if (!global.Power3) {
	        throw new Error("The Power3 gsap easing object doesn't exist in the current scope.  Are you certain TweenLite or TweenMax has been loaded properly?");
	    }
	    return {
	        DURATION: 0.4
	        , SHORT_DURATION: 0.25
	        , LONG_DURATION: 0.7
	        , EASE: global.Power3.easeOut
	    };
	}


/***/ },
/* 316 */
/*!**********************************!*\
  !*** ./~/node-helpers/config.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var path = __webpack_require__(/*! path */ 11)
	    , Lazy = __webpack_require__(/*! ./lazy-extensions */ 173)
	    , bFs = __webpack_require__(/*! fs-bluebird */ 317);

	Config._DEFAULT_CONFIG_LOCATION = '../config.json';

	function Config(argsObj) {
	    argsObj = argsObj || {};

	    this.envPrefix = argsObj.envPrefix || "";
	    this.packageJsonDir = argsObj.packageJsonDir || process.cwd();
	    this.packageJsonRootProperty = argsObj.packageJsonRootProperty || "";

	    // this property is meant for testing purposes only
	    this._defaultConfig = argsObj._defaultConfig || Config._DEFAULT_CONFIG_LOCATION;

	    this.Locations = [
	        new Location(Config.PACKAGE.key, Config.PACKAGE.name, 10, getFromPackageJson, {
	            dir: this.packageJsonDir
	            , rootProp: this.packageJsonRootProperty
	        })
	        , new Location(Config.ENV.key, Config.ENV.name, 20, getFromEnv, {
	            envPrefix: this.envPrefix
	        })
	        , new Location(Config.DEFAULT.key, Config.DEFAULT.name, 30, getFromDefault, {
	            defaultConfig: this._defaultConfig
	        })
	    ];
	}

	Config.PACKAGE = {
	    key: 'PACKAGE'
	    , name: 'package.json'
	};
	Config.ENV = {
	    key: 'ENV'
	    , name: 'Environment variable'
	};
	Config.DEFAULT = {
	    key: 'DEFAULT'
	    , name: 'Default configuration'
	};

	Config.prototype.get = function get(propName, argsObj) {
	    argsObj = argsObj || {};
	    var newArgsObj = {
	        defaultIfNone: argsObj.defaultIfNone
	        , shouldThrow: argsObj.shouldThrow
	    };
	    return this._getValAndLocation(propName, argsObj).val;
	};

	Config.prototype.getValAndLocation = function getValAndLocation(propName, argsObj) {
	    argsObj = argsObj || {};
	    var newArgsObj = {
	        defaultIfNone: argsObj.defaultIfNone
	        , shouldThrow: argsObj.shouldThrow
	    };
	    return this._getValAndLocation(propName, newArgsObj);
	};

	Config.prototype.getFromLocation = function getFromLocation(propName, location, argsObj) {
	    argsObj = argsObj || {};
	    var newArgsObj = {
	        defaultIfNone: argsObj.defaultIfNone
	        , shouldThrow: argsObj.shouldThrow
	        , location: location
	    };
	    return this._getValAndLocation(propName, newArgsObj).val;
	};

	Config.prototype._getValAndLocation = function _getValAndLocation(propName, argsObj) {
	    var res;
	    argsObj = argsObj || {};
	    var defaultIfNone = argsObj.defaultIfNone;
	    var location = argsObj.location;
	    var shouldThrow = argsObj.shouldThrow;
	    var curLocation;

	    if (defaultIfNone && shouldThrow) {
	        throw new Error("Invalid Argument: defaultIfNone and shouldThrow cannot both be truthy");
	    }

	    if (typeof location === 'undefined') {
	        curLocation = Lazy(this.Locations)
	            .sort(function(left, right) {
	                return left.priority - right.priority;
	            })
	            .find(function(l) {
	                return l.getProp(propName);
	            });

	        if (typeof curLocation === 'undefined' && shouldThrow) {
	            throw new Error("Invalid Argument: Configuration property '" + propName + "' not found in any locations");
	        }
	    } else { // location is defined
	        curLocation = Lazy(this.Locations)
	            .find(function(l) {
	                return l.key.toLowerCase() === location.toLowerCase();
	            });
	        if (typeof curLocation === 'undefined') {
	            throw new Error("Invalid Argument: Location '" + location + "' doesn't exist");
	        }
	    }

	    res = curLocation && curLocation.getProp(propName);

	    if (typeof res === 'undefined' && typeof defaultIfNone !== 'undefined') {
	        res = defaultIfNone;
	        curLocation = {
	            name: Config.DEFAULT.name
	        };
	    } else if (typeof res === 'undefined' && shouldThrow) {
	        throw new Error("Invalid Argument: Property '" + propName + "' hasn't been set");
	    }

	    return {
	        location: curLocation.name
	        , val: res
	    };
	};

	Config.prototype.setDefault = function setDefault(propName, val) {
	    var tmpConfigFile = path.join(__dirname, this._defaultConfig);
	    var resJson;
	    if (bFs.existsSync(tmpConfigFile)) {
	        resJson = __webpack_require__(/*! . */ 318)(tmpConfigFile);
	    } else {
	        resJson = {};
	    }

	    if (typeof val === 'undefined') {
	        delete resJson[propName];
	    } else {
	        resJson[propName] = val;
	    }

	    bFs.writeFileSync(tmpConfigFile, JSON.stringify(resJson, null, 4));
	};

	Config.prototype.getDefault = function getDefault(propName, argsObj) {
	    return this.getFromLocation(propName, 'default', argsObj);
	};

	Config.prototype.removeDefault = function removeDefault(propName) {
	    this.setDefault(propName, undefined);
	};


	//---------------------------//
	// Set up built-in locations //
	//---------------------------//

	function Location(key_, name_, priority_, getter_, getterArgsObj_) {
	    this.key = key_;
	    this.name = name_;
	    this.priority = priority_;
	    this.getter = getter_;
	    this.getArgsObj = getterArgsObj_;
	}
	Location.prototype.getProp = function getProp(propName, shouldThrow) {
	    return this.getter.call(this, propName, shouldThrow, this.getArgsObj);
	};

	function getFromEnv(propName, shouldThrow, argsObj) {
	    argsObj = argsObj || {};

	    var res;
	    if (typeof argsObj.envPrefix === 'string') {
	        res = process.env[argsObj.envPrefix + propName];
	    }

	    if (shouldThrow && typeof res === 'undefined') {
	        throw new Error("Invalid Argument: environment variable '" + propName + "' doesn't exist");
	    }

	    return res;
	}

	function getFromPackageJson(propName, shouldThrow, argsObj) {
	    argsObj = argsObj || {};

	    var pjson
	        , pjsonPath
	        , res;
	    if (argsObj.dir.length > 0 && argsObj.dir.slice(0, 1) !== '/') {
	        pjsonPath = './' + path.join(argsObj.dir, 'package.json');
	    } else {
	        pjsonPath = path.join(argsObj.dir, 'package.json');
	    }
	    if (bFs.existsSync(pjsonPath)) {
	        pjson = __webpack_require__(/*! . */ 318)(pjsonPath);
	        res = (pjson[argsObj.rootProp] && pjson[argsObj.rootProp][propName])
	            ? pjson[argsObj.rootProp][propName]
	            : undefined;
	    } else {
	        res = undefined;
	    }

	    if (shouldThrow && typeof res === 'undefined') {
	        throw new Error("Invalid Argument: package.json setting '" + argsObj.rootProp + "." + propName + "' doesn't exist");
	    }

	    return res;
	}

	function getFromDefault(propName, shouldThrow, argsObj) {
	    argsObj = argsObj || {};
	    var configJson = {};

	    var configPath = path.join(__dirname, argsObj.defaultConfig);
	    if (bFs.existsSync(configPath)) {
	        configJson = __webpack_require__(/*! . */ 318)(configPath);
	    } else { // config.json doesn't exist, so let's create it
	        bFs.writeFileSync(configPath, JSON.stringify({}));
	    }

	    var res = configJson[propName];
	    if (shouldThrow && typeof res === 'undefined') {
	        throw new Error("Invalid Argument: config property '" + propName + "' doesn't exist");
	    }

	    return res;
	}

	//-----------------------//
	// End of location logic //
	//-----------------------//

	module.exports = Config;


/***/ },
/* 317 */
/*!********************************!*\
  !*** ./~/fs-bluebird/index.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var bPromise = __webpack_require__(/*! bluebird */ 93)
	    , fs = __webpack_require__(/*! fs */ 19)
	    , bFs = bPromise.promisifyAll(fs);

	bFs.existsAsync = function(path) {
	    return new bPromise(function(resolve, reject) {
	        fs.exists(path, resolve);
	    })
	}

	// internal bluebird property to tell whether a method is the promisified version.  Setting this will prevent errors
	//   arrising from the fs library being promisified more than once.
	bFs.existsAsync.__isPromisified__ = true;

	module.exports = bFs;


/***/ },
/* 318 */
/*!*********************************!*\
  !*** ./~/node-helpers ^\.\/.*$ ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./BRequest": 319,
		"./BRequest.js": 319,
		"./bunyan-streams": 178,
		"./bunyan-streams.js": 178,
		"./common-pgconfs": 91,
		"./common-pgconfs.js": 91,
		"./config": 316,
		"./config-tests": 324,
		"./config-tests.js": 324,
		"./config.js": 316,
		"./config.json": 357,
		"./environment": 177,
		"./environment.js": 177,
		"./gsap-defaults": 315,
		"./gsap-defaults.js": 315,
		"./index": 90,
		"./index.browser": 358,
		"./index.browser.js": 358,
		"./index.js": 90,
		"./lazy-extensions": 173,
		"./lazy-extensions-tests": 360,
		"./lazy-extensions-tests.js": 360,
		"./lazy-extensions.js": 173,
		"./log-provider": 359,
		"./log-provider.js": 359,
		"./package": 361,
		"./package.json": 361,
		"./psql-wrapper": 92,
		"./psql-wrapper-tests": 363,
		"./psql-wrapper-tests.js": 363,
		"./psql-wrapper.js": 92,
		"./utils": 131,
		"./utils-tests": 364,
		"./utils-tests.js": 364,
		"./utils.js": 131
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 318;


/***/ },
/* 319 */
/*!************************************!*\
  !*** ./~/node-helpers/BRequest.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	//---------//
	// Imports //
	//---------//

	var bPromise = __webpack_require__(/*! bluebird */ 93)
	    , S = __webpack_require__(/*! string */ 320)
	    , utils = __webpack_require__(/*! ./utils */ 131);


	//-------//
	// Model //
	//-------//

	function BRequest() {
	    var self = this;

	    var my = {
	        BaseUrl: null
	        , IsJSONRequest: null
	    };

	    self.BaseUrl = function BaseUrl(baseurl_) {
	        var res = my.BaseUrl;
	        if (arguments.length > 0) {
	            if (baseurl_ !== null) {
	                BRequest.ValidateBaseUrl(baseurl_, true);
	            }
	            my.BaseUrl = baseurl_;
	            res = self;
	        }
	        return res;
	    };

	    self.IsJSON = function IsJSON(isjson_) {
	        var res = my.IsJSON;
	        if (arguments.length > 0) {
	            if (isjson_ !== null) {
	                BRequest.ValidateIsJSON(isjson_, true);
	            }
	            my.IsJSON = isjson_;
	            res = self;
	        }
	        return res;
	    };
	}


	//------------//
	// Validation //
	//------------//

	BRequest.ValidateBaseUrl = function ValidateBaseUrl(input, throwErr) {
	    var msg = '';
	    if (typeof input !== 'string') {
	        msg = 'Invalid Argument: <BRequest>.ValidateBaseUrl requires a typeof string argument';
	    }

	    if (throwErr && msg) {
	        throw new Error(msg);
	    }

	    return msg;
	};

	BRequest.ValidateIsJSON = function ValidateIsJSON(input, throwErr) {
	    var msg = '';
	    var errMsg = 'Invalid Argument: <BRequest>.ValidateIsJSON requires a typeof boolean argument or string equal to "true" or "false"';

	    if (typeof input === 'string') {
	        input = input.toLowerCase();
	        if (input !== 'true' && input !== 'false') {
	            msg = errMsg;
	        } else {
	            input = (input === 'true');
	        }
	    }
	    if (typeof input !== 'boolean') {
	        msg = errMsg;
	    }

	    if (throwErr && msg) {
	        throw new Error(msg);
	    }

	    return msg;
	};


	//-----------------------//
	// Prototyped Extensions //
	//-----------------------//

	BRequest.prototype.get = function get(url) {
	    if (!url || (typeof url !== 'string')) {
	        throw new Error("Invalid Argument: <BRequest>.get requires a string url");
	    }

	    return this._transmit({
	        method: 'GET', url: this._getUrl(url)
	    });
	};


	//-------------------------------//
	// Private Prototyped Extensions //
	//-------------------------------//

	BRequest.prototype._transmit = function _transmit(opts) {
	    var self = this;

	    var xhr = new XMLHttpRequest();
	    var method = opts.method;
	    var url = opts.url;
	    var data = opts.data || null;

	    var res = new bPromise(function(resolve, reject) {
	        xhr.addEventListener("error", reject);
	        xhr.addEventListener("load", resolve);

	        xhr.open(method, url);

	        if (self.IsJSON()) {
	            if (typeof data === 'object') {
	                data = JSON.stringify(data);
	            } else if ((typeof data === 'string' && !isJson(data)) || typeof data !== 'string') {
	                throw new Error("Invalid Argument: <BRequest>.send requires data to be valid JSON when the IsJSON property is true");
	            }

	            xhr.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
	        }

	        xhr.send(data);
	    });

	    if (self.IsJSON()) {
	        res = res.then(function() {
	            return JSON.parse(xhr.response);
	        });
	    }

	    return res;
	};

	BRequest.prototype._getUrl = function _getUrl(url) {
	    var res;
	    if (this.BaseUrl() === null) {
	        res = url;
	    } else {
	        var burl = S(this.BaseUrl()).ensureRight('/');
	        url = S(url).chompLeft('/');
	        res = burl.s + url.s;
	    }
	    return res;
	};


	//---------//
	// Helpers //
	//---------//

	function isJson(str) {
	    try {
	        JSON.parse(str);
	    } catch (e) {
	        return false;
	    }
	    return true;
	}


	//---------//
	// Exports //
	//---------//

	module.exports = BRequest;


/***/ },
/* 320 */
/*!********************************!*\
  !*** ./~/string/lib/string.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	string.js - Copyright (C) 2012-2014, JP Richardson <jprichardson@gmail.com>
	*/

	!(function() {
	  "use strict";

	  var VERSION = '3.3.3';

	  var ENTITIES = {};

	  // from http://semplicewebsites.com/removing-accents-javascript
	  var latin_map={"":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"AA","":"AE","":"AE","":"AE","":"AO","":"AU","":"AV","":"AV","":"AY","":"B","":"B","":"B","":"B","":"B","":"B","":"C","":"C","":"C","":"C","":"C","":"C","":"C","":"C","":"D","":"D","":"D","":"D","":"D","":"D","":"D","":"D","":"D","":"D","":"D","":"DZ","":"DZ","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"ET","":"F","":"F","":"G","":"G","":"G","":"G","":"G","":"G","":"G","":"G","":"G","":"H","":"H","":"H","":"H","":"H","":"H","":"H","":"H","":"H","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"D","":"F","":"G","":"R","":"S","":"T","":"IS","":"J","":"J","":"K","":"K","":"K","":"K","":"K","":"K","":"K","":"K","":"K","":"K","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"LJ","":"M","":"M","":"M","":"M","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"NJ","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"OI","":"OO","":"E","":"O","":"OU","":"P","":"P","":"P","":"P","":"P","":"P","":"P","":"Q","":"Q","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"C","":"E","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"SS","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"A","":"L","":"M","":"V","":"TZ","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"V","":"V","":"V","":"V","":"VY","":"W","":"W","":"W","":"W","":"W","":"W","":"W","":"X","":"X","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Z","":"Z","":"Z","":"Z","":"Z","":"Z","":"Z","":"Z","":"Z","":"IJ","":"OE","":"A","":"AE","":"B","":"B","":"C","":"D","":"E","":"F","":"G","":"G","":"H","":"I","":"R","":"J","":"K","":"L","":"L","":"M","":"N","":"O","":"OE","":"O","":"OU","":"P","":"R","":"N","":"R","":"S","":"T","":"E","":"R","":"U","":"V","":"W","":"Y","":"Z","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"aa","":"ae","":"ae","":"ae","":"ao","":"au","":"av","":"av","":"ay","":"b","":"b","":"b","":"b","":"b","":"b","":"b","":"b","":"o","":"c","":"c","":"c","":"c","":"c","":"c","":"c","":"c","":"c","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"i","":"j","":"j","":"j","":"dz","":"dz","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"et","":"f","":"f","":"f","":"f","":"g","":"g","":"g","":"g","":"g","":"g","":"g","":"g","":"g","":"g","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"hv","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"d","":"f","":"g","":"r","":"s","":"t","":"is","":"j","":"j","":"j","":"j","":"k","":"k","":"k","":"k","":"k","":"k","":"k","":"k","":"k","":"k","":"k","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"lj","":"s","":"s","":"s","":"s","":"m","":"m","":"m","":"m","":"m","":"m","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"nj","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"oi","":"oo","":"e","":"e","":"o","":"o","":"ou","":"p","":"p","":"p","":"p","":"p","":"p","":"p","":"p","":"p","":"q","":"q","":"q","":"q","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"c","":"c","":"e","":"r","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"g","":"ss","":"o","":"o","":"u","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"th","":"a","":"ae","":"e","":"g","":"h","":"h","":"h","":"i","":"k","":"l","":"m","":"m","":"oe","":"r","":"r","":"r","":"r","":"t","":"v","":"w","":"y","":"tz","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"ue","":"um","":"v","":"v","":"v","":"v","":"v","":"v","":"v","":"vy","":"w","":"w","":"w","":"w","":"w","":"w","":"w","":"w","":"x","":"x","":"x","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"ff","":"ffi","":"ffl","":"fi","":"fl","":"ij","":"oe","":"st","":"a","":"e","":"i","":"j","":"o","":"r","":"u","":"v","":"x"};

	//******************************************************************************
	// Added an initialize function which is essentially the code from the S
	// constructor.  Now, the S constructor calls this and a new method named
	// setValue calls it as well.  The setValue function allows constructors for
	// modules that extend string.js to set the initial value of an object without
	// knowing the internal workings of string.js.
	//
	// Also, all methods which return a new S object now call:
	//
	//      return new this.constructor(s);
	//
	// instead of:
	//
	//      return new S(s);
	//
	// This allows extended objects to keep their proper instanceOf and constructor.
	//******************************************************************************

	  function initialize (object, s) {
	    if (s !== null && s !== undefined) {
	      if (typeof s === 'string')
	        object.s = s;
	      else
	        object.s = s.toString();
	    } else {
	      object.s = s; //null or undefined
	    }

	    object.orig = s; //original object, currently only used by toCSV() and toBoolean()

	    if (s !== null && s !== undefined) {
	      if (object.__defineGetter__) {
	        object.__defineGetter__('length', function() {
	          return object.s.length;
	        })
	      } else {
	        object.length = s.length;
	      }
	    } else {
	      object.length = -1;
	    }
	  }

	  function S(s) {
	  	initialize(this, s);
	  }

	  var __nsp = String.prototype;
	  var __sp = S.prototype = {

	    between: function(left, right) {
	      var s = this.s;
	      var startPos = s.indexOf(left);
	      var endPos = s.indexOf(right, startPos + left.length);
	      if (endPos == -1 && right != null)
	        return new this.constructor('')
	      else if (endPos == -1 && right == null)
	        return new this.constructor(s.substring(startPos + left.length))
	      else
	        return new this.constructor(s.slice(startPos + left.length, endPos));
	    },

	    //# modified slightly from https://github.com/epeli/underscore.string
	    camelize: function() {
	      var s = this.trim().s.replace(/(\-|_|\s)+(.)?/g, function(mathc, sep, c) {
	        return (c ? c.toUpperCase() : '');
	      });
	      return new this.constructor(s);
	    },

	    capitalize: function() {
	      return new this.constructor(this.s.substr(0, 1).toUpperCase() + this.s.substring(1).toLowerCase());
	    },

	    charAt: function(index) {
	      return this.s.charAt(index);
	    },

	    chompLeft: function(prefix) {
	      var s = this.s;
	      if (s.indexOf(prefix) === 0) {
	         s = s.slice(prefix.length);
	         return new this.constructor(s);
	      } else {
	        return this;
	      }
	    },

	    chompRight: function(suffix) {
	      if (this.endsWith(suffix)) {
	        var s = this.s;
	        s = s.slice(0, s.length - suffix.length);
	        return new this.constructor(s);
	      } else {
	        return this;
	      }
	    },

	    //#thanks Google
	    collapseWhitespace: function() {
	      var s = this.s.replace(/[\s\xa0]+/g, ' ').replace(/^\s+|\s+$/g, '');
	      return new this.constructor(s);
	    },

	    contains: function(ss) {
	      return this.s.indexOf(ss) >= 0;
	    },

	    count: function(ss) {
	      return __webpack_require__(/*! ./_count */ 321)(this.s, ss)
	    },

	    //#modified from https://github.com/epeli/underscore.string
	    dasherize: function() {
	      var s = this.trim().s.replace(/[_\s]+/g, '-').replace(/([A-Z])/g, '-$1').replace(/-+/g, '-').toLowerCase();
	      return new this.constructor(s);
	    },
	    
	    equalsIgnoreCase: function(prefix) {
	      var s = this.s;
	      return s.toLowerCase() == prefix.toLowerCase()
	    },

	    latinise: function() {
	      var s = this.replace(/[^A-Za-z0-9\[\] ]/g, function(x) { return latin_map[x] || x; });
	      return new this.constructor(s);
	    },

	    decodeHtmlEntities: function() { //https://github.com/substack/node-ent/blob/master/index.js
	      var s = this.s;
	      s = s.replace(/&#(\d+);?/g, function (_, code) {
	        return String.fromCharCode(code);
	      })
	      .replace(/&#[xX]([A-Fa-f0-9]+);?/g, function (_, hex) {
	        return String.fromCharCode(parseInt(hex, 16));
	      })
	      .replace(/&([^;\W]+;?)/g, function (m, e) {
	        var ee = e.replace(/;$/, '');
	        var target = ENTITIES[e] || (e.match(/;$/) && ENTITIES[ee]);

	        if (typeof target === 'number') {
	          return String.fromCharCode(target);
	        }
	        else if (typeof target === 'string') {
	          return target;
	        }
	        else {
	          return m;
	        }
	      })

	      return new this.constructor(s);
	    },

	    endsWith: function() {
	      var suffixes = Array.prototype.slice.call(arguments, 0);
	      for (var i = 0; i < suffixes.length; ++i) {
	        var l  = this.s.length - suffixes[i].length;
	        if (l >= 0 && this.s.indexOf(suffixes[i], l) === l) return true;
	      }
	      return false;
	    },

	    escapeHTML: function() { //from underscore.string
	      return new this.constructor(this.s.replace(/[&<>"']/g, function(m){ return '&' + reversedEscapeChars[m] + ';'; }));
	    },

	    ensureLeft: function(prefix) {
	      var s = this.s;
	      if (s.indexOf(prefix) === 0) {
	        return this;
	      } else {
	        return new this.constructor(prefix + s);
	      }
	    },

	    ensureRight: function(suffix) {
	      var s = this.s;
	      if (this.endsWith(suffix))  {
	        return this;
	      } else {
	        return new this.constructor(s + suffix);
	      }
	    },

	    humanize: function() { //modified from underscore.string
	      if (this.s === null || this.s === undefined)
	        return new this.constructor('')
	      var s = this.underscore().replace(/_id$/,'').replace(/_/g, ' ').trim().capitalize()
	      return new this.constructor(s)
	    },

	    isAlpha: function() {
	      return !/[^a-z\xDF-\xFF]|^$/.test(this.s.toLowerCase());
	    },

	    isAlphaNumeric: function() {
	      return !/[^0-9a-z\xDF-\xFF]/.test(this.s.toLowerCase());
	    },

	    isEmpty: function() {
	      return this.s === null || this.s === undefined ? true : /^[\s\xa0]*$/.test(this.s);
	    },

	    isLower: function() {
	      return this.isAlpha() && this.s.toLowerCase() === this.s;
	    },

	    isNumeric: function() {
	      return !/[^0-9]/.test(this.s);
	    },

	    isUpper: function() {
	      return this.isAlpha() && this.s.toUpperCase() === this.s;
	    },

	    left: function(N) {
	      if (N >= 0) {
	        var s = this.s.substr(0, N);
	        return new this.constructor(s);
	      } else {
	        return this.right(-N);
	      }
	    },

	    lines: function() { //convert windows newlines to unix newlines then convert to an Array of lines
	      return this.replaceAll('\r\n', '\n').s.split('\n');
	    },

	    pad: function(len, ch) { //https://github.com/component/pad
	      if (ch == null) ch = ' ';
	      if (this.s.length >= len) return new this.constructor(this.s);
	      len = len - this.s.length;
	      var left = Array(Math.ceil(len / 2) + 1).join(ch);
	      var right = Array(Math.floor(len / 2) + 1).join(ch);
	      return new this.constructor(left + this.s + right);
	    },

	    padLeft: function(len, ch) { //https://github.com/component/pad
	      if (ch == null) ch = ' ';
	      if (this.s.length >= len) return new this.constructor(this.s);
	      return new this.constructor(Array(len - this.s.length + 1).join(ch) + this.s);
	    },

	    padRight: function(len, ch) { //https://github.com/component/pad
	      if (ch == null) ch = ' ';
	      if (this.s.length >= len) return new this.constructor(this.s);
	      return new this.constructor(this.s + Array(len - this.s.length + 1).join(ch));
	    },

	    parseCSV: function(delimiter, qualifier, escape, lineDelimiter) { //try to parse no matter what
	      delimiter = delimiter || ',';
	      escape = escape || '\\'
	      if (typeof qualifier == 'undefined')
	        qualifier = '"';

	      var i = 0, fieldBuffer = [], fields = [], len = this.s.length, inField = false, inUnqualifiedString = false, self = this;
	      var ca = function(i){return self.s.charAt(i)};
	      if (typeof lineDelimiter !== 'undefined') var rows = [];

	      if (!qualifier)
	        inField = true;

	      while (i < len) {
	        var current = ca(i);
	        switch (current) {
	          case escape:
	            //fix for issues #32 and #35
	            if (inField && ((escape !== qualifier) || ca(i+1) === qualifier)) {
	              i += 1;
	              fieldBuffer.push(ca(i));
	              break;
	            }
	            if (escape !== qualifier) break;
	          case qualifier:
	            inField = !inField;
	            break;
	          case delimiter:
	            if(inUnqualifiedString) {
	              inField=false;
	              inUnqualifiedString=false;
	            }
	            if (inField && qualifier)
	              fieldBuffer.push(current);
	            else {
	              fields.push(fieldBuffer.join(''))
	              fieldBuffer.length = 0;
	            }
	            break;
	          case lineDelimiter:
	            if(inUnqualifiedString) {
	              inField=false;
	              inUnqualifiedString=false;
	              fields.push(fieldBuffer.join(''))
	              rows.push(fields);
	              fields = [];
	              fieldBuffer.length = 0;
	            }
	            else if (inField) {
	              fieldBuffer.push(current);
	            } else {
	              if (rows) {
	                fields.push(fieldBuffer.join(''))
	                rows.push(fields);
	                fields = [];
	                fieldBuffer.length = 0;
	              }
	            }
	            break;
	          case ' ':
	            if (inField)
	              fieldBuffer.push(current);
	            break;
	          default:
	            if (inField)
	              fieldBuffer.push(current);
	            else if(current!==qualifier) {
	              fieldBuffer.push(current);
	              inField=true;
	              inUnqualifiedString=true;
	            }
	            break;
	        }
	        i += 1;
	      }

	      fields.push(fieldBuffer.join(''));
	      if (rows) {
	        rows.push(fields);
	        return rows;
	      }
	      return fields;
	    },

	    replaceAll: function(ss, r) {
	      //var s = this.s.replace(new RegExp(ss, 'g'), r);
	      var s = this.s.split(ss).join(r)
	      return new this.constructor(s);
	    },

	    splitLeft: function(sep, maxSplit, limit) {
	      return __webpack_require__(/*! ./_splitLeft */ 322)(this.s, sep, maxSplit, limit)
	    },

	    splitRight: function(sep, maxSplit, limit) {
	      return __webpack_require__(/*! ./_splitRight */ 323)(this.s, sep, maxSplit, limit)
	    },

	    strip: function() {
	      var ss = this.s;
	      for(var i= 0, n=arguments.length; i<n; i++) {
	        ss = ss.split(arguments[i]).join('');
	      }
	      return new this.constructor(ss);
	    },

	    stripLeft: function (chars) {
	      var regex;
	      var pattern;
	      var ss = ensureString(this.s);

	      if (chars === undefined) {
	        pattern = /^\s+/g;
	      }
	      else {
	        regex = escapeRegExp(chars);
	        pattern = new RegExp("^[" + regex + "]+", "g");
	      }

	      return new this.constructor(ss.replace(pattern, ""));
	    },

	    stripRight: function (chars) {
	      var regex;
	      var pattern;
	      var ss = ensureString(this.s);

	      if (chars === undefined) {
	        pattern = /\s+$/g;
	      }
	      else {
	        regex = escapeRegExp(chars);
	        pattern = new RegExp("[" + regex + "]+$", "g");
	      }

	      return new this.constructor(ss.replace(pattern, ""));
	    },

	    right: function(N) {
	      if (N >= 0) {
	        var s = this.s.substr(this.s.length - N, N);
	        return new this.constructor(s);
	      } else {
	        return this.left(-N);
	      }
	    },

	    setValue: function (s) {
		  initialize(this, s);
		  return this;
	    },

	    slugify: function() {
	      var sl = (new S(new S(this.s).latinise().s.replace(/[^\w\s-]/g, '').toLowerCase())).dasherize().s;
	      if (sl.charAt(0) === '-')
	        sl = sl.substr(1);
	      return new this.constructor(sl);
	    },

	    startsWith: function() {
	      var prefixes = Array.prototype.slice.call(arguments, 0);
	      for (var i = 0; i < prefixes.length; ++i) {
	        if (this.s.lastIndexOf(prefixes[i], 0) === 0) return true;
	      }
	      return false;
	    },

	    stripPunctuation: function() {
	      //return new this.constructor(this.s.replace(/[\.,-\/#!$%\^&\*;:{}=\-_`~()]/g,""));
	      return new this.constructor(this.s.replace(/[^\w\s]|_/g, "").replace(/\s+/g, " "));
	    },

	    stripTags: function() { //from sugar.js
	      var s = this.s, args = arguments.length > 0 ? arguments : [''];
	      multiArgs(args, function(tag) {
	        s = s.replace(RegExp('<\/?' + tag + '[^<>]*>', 'gi'), '');
	      });
	      return new this.constructor(s);
	    },

	    template: function(values, opening, closing) {
	      var s = this.s
	      var opening = opening || Export.TMPL_OPEN
	      var closing = closing || Export.TMPL_CLOSE

	      var open = opening.replace(/[-[\]()*\s]/g, "\\$&").replace(/\$/g, '\\$')
	      var close = closing.replace(/[-[\]()*\s]/g, "\\$&").replace(/\$/g, '\\$')
	      var r = new RegExp(open + '(.+?)' + close, 'g')
	        //, r = /\{\{(.+?)\}\}/g
	      var matches = s.match(r) || [];

	      matches.forEach(function(match) {
	        var key = match.substring(opening.length, match.length - closing.length).trim();//chop {{ and }}
	        var value = typeof values[key] == 'undefined' ? '' : values[key];
	        s = s.replace(match, value);
	      });
	      return new this.constructor(s);
	    },

	    times: function(n) {
	      return new this.constructor(new Array(n + 1).join(this.s));
	    },

	    titleCase: function() {
	      var s = this.s;
	      if (s) {
	        s = s.replace(/(^[a-z]| [a-z]|-[a-z]|_[a-z])/g,
	          function($1){
	            return $1.toUpperCase();
	          }
	        );
	      }
	      return new this.constructor(s);
	    },

	    toBoolean: function() {
	      if (typeof this.orig === 'string') {
	        var s = this.s.toLowerCase();
	        return s === 'true' || s === 'yes' || s === 'on' || s === '1';
	      } else
	        return this.orig === true || this.orig === 1;
	    },

	    toFloat: function(precision) {
	      var num = parseFloat(this.s)
	      if (precision)
	        return parseFloat(num.toFixed(precision))
	      else
	        return num
	    },

	    toInt: function() { //thanks Google
	      // If the string starts with '0x' or '-0x', parse as hex.
	      return /^\s*-?0x/i.test(this.s) ? parseInt(this.s, 16) : parseInt(this.s, 10)
	    },

	    trim: function() {
	      var s;
	      if (typeof __nsp.trim === 'undefined')
	        s = this.s.replace(/(^\s*|\s*$)/g, '')
	      else
	        s = this.s.trim()
	      return new this.constructor(s);
	    },

	    trimLeft: function() {
	      var s;
	      if (__nsp.trimLeft)
	        s = this.s.trimLeft();
	      else
	        s = this.s.replace(/(^\s*)/g, '');
	      return new this.constructor(s);
	    },

	    trimRight: function() {
	      var s;
	      if (__nsp.trimRight)
	        s = this.s.trimRight();
	      else
	        s = this.s.replace(/\s+$/, '');
	      return new this.constructor(s);
	    },

	    truncate: function(length, pruneStr) { //from underscore.string, author: github.com/rwz
	      var str = this.s;

	      length = ~~length;
	      pruneStr = pruneStr || '...';

	      if (str.length <= length) return new this.constructor(str);

	      var tmpl = function(c){ return c.toUpperCase() !== c.toLowerCase() ? 'A' : ' '; },
	        template = str.slice(0, length+1).replace(/.(?=\W*\w*$)/g, tmpl); // 'Hello, world' -> 'HellAA AAAAA'

	      if (template.slice(template.length-2).match(/\w\w/))
	        template = template.replace(/\s*\S+$/, '');
	      else
	        template = new S(template.slice(0, template.length-1)).trimRight().s;

	      return (template+pruneStr).length > str.length ? new S(str) : new S(str.slice(0, template.length)+pruneStr);
	    },

	    toCSV: function() {
	      var delim = ',', qualifier = '"', escape = '\\', encloseNumbers = true, keys = false;
	      var dataArray = [];

	      function hasVal(it) {
	        return it !== null && it !== '';
	      }

	      if (typeof arguments[0] === 'object') {
	        delim = arguments[0].delimiter || delim;
	        delim = arguments[0].separator || delim;
	        qualifier = arguments[0].qualifier || qualifier;
	        encloseNumbers = !!arguments[0].encloseNumbers;
	        escape = arguments[0].escape || escape;
	        keys = !!arguments[0].keys;
	      } else if (typeof arguments[0] === 'string') {
	        delim = arguments[0];
	      }

	      if (typeof arguments[1] === 'string')
	        qualifier = arguments[1];

	      if (arguments[1] === null)
	        qualifier = null;

	       if (this.orig instanceof Array)
	        dataArray  = this.orig;
	      else { //object
	        for (var key in this.orig)
	          if (this.orig.hasOwnProperty(key))
	            if (keys)
	              dataArray.push(key);
	            else
	              dataArray.push(this.orig[key]);
	      }

	      var rep = escape + qualifier;
	      var buildString = [];
	      for (var i = 0; i < dataArray.length; ++i) {
	        var shouldQualify = hasVal(qualifier)
	        if (typeof dataArray[i] == 'number')
	          shouldQualify &= encloseNumbers;

	        if (shouldQualify)
	          buildString.push(qualifier);

	        if (dataArray[i] !== null && dataArray[i] !== undefined) {
	          var d = new S(dataArray[i]).replaceAll(qualifier, rep).s;
	          buildString.push(d);
	        } else
	          buildString.push('')

	        if (shouldQualify)
	          buildString.push(qualifier);

	        if (delim)
	          buildString.push(delim);
	      }

	      //chop last delim
	      //console.log(buildString.length)
	      buildString.length = buildString.length - 1;
	      return new this.constructor(buildString.join(''));
	    },

	    toString: function() {
	      return this.s;
	    },

	    //#modified from https://github.com/epeli/underscore.string
	    underscore: function() {
	      var s = this.trim().s.replace(/([a-z\d])([A-Z]+)/g, '$1_$2').replace(/([A-Z\d]+)([A-Z][a-z])/g,'$1_$2').replace(/[-\s]+/g, '_').toLowerCase();
	      return new this.constructor(s);
	    },

	    unescapeHTML: function() { //from underscore.string
	      return new this.constructor(this.s.replace(/\&([^;]+);/g, function(entity, entityCode){
	        var match;

	        if (entityCode in escapeChars) {
	          return escapeChars[entityCode];
	        } else if (match = entityCode.match(/^#x([\da-fA-F]+)$/)) {
	          return String.fromCharCode(parseInt(match[1], 16));
	        } else if (match = entityCode.match(/^#(\d+)$/)) {
	          return String.fromCharCode(~~match[1]);
	        } else {
	          return entity;
	        }
	      }));
	    },

	    valueOf: function() {
	      return this.s.valueOf();
	    },

	    //#Added a New Function called wrapHTML.
	    wrapHTML: function (tagName, tagAttrs) {
	      var s = this.s, el = (tagName == null) ? 'span' : tagName, elAttr = '', wrapped = '';
	      if(typeof tagAttrs == 'object') for(var prop in tagAttrs) elAttr += ' ' + prop + '="' +(new this.constructor(tagAttrs[prop])).escapeHTML() + '"';
	      s = wrapped.concat('<', el, elAttr, '>', this, '</', el, '>');
	      return new this.constructor(s);
	    }
	  }

	  var methodsAdded = [];
	  function extendPrototype() {
	    for (var name in __sp) {
	      (function(name){
	        var func = __sp[name];
	        if (!__nsp.hasOwnProperty(name)) {
	          methodsAdded.push(name);
	          __nsp[name] = function() {
	            String.prototype.s = this;
	            return func.apply(this, arguments);
	          }
	        }
	      })(name);
	    }
	  }

	  function restorePrototype() {
	    for (var i = 0; i < methodsAdded.length; ++i)
	      delete String.prototype[methodsAdded[i]];
	    methodsAdded.length = 0;
	  }


	/*************************************
	/* Attach Native JavaScript String Properties
	/*************************************/

	  var nativeProperties = getNativeStringProperties();
	  for (var name in nativeProperties) {
	    (function(name) {
	      var stringProp = __nsp[name];
	      if (typeof stringProp == 'function') {
	        //console.log(stringProp)
	        if (!__sp[name]) {
	          if (nativeProperties[name] === 'string') {
	            __sp[name] = function() {
	              //console.log(name)
	              return new this.constructor(stringProp.apply(this, arguments));
	            }
	          } else {
	            __sp[name] = stringProp;
	          }
	        }
	      }
	    })(name);
	  }


	/*************************************
	/* Function Aliases
	/*************************************/

	  __sp.repeat = __sp.times;
	  __sp.include = __sp.contains;
	  __sp.toInteger = __sp.toInt;
	  __sp.toBool = __sp.toBoolean;
	  __sp.decodeHTMLEntities = __sp.decodeHtmlEntities //ensure consistent casing scheme of 'HTML'


	//******************************************************************************
	// Set the constructor.  Without this, string.js objects are instances of
	// Object instead of S.
	//******************************************************************************

	  __sp.constructor = S;


	/*************************************
	/* Private Functions
	/*************************************/

	  function getNativeStringProperties() {
	    var names = getNativeStringPropertyNames();
	    var retObj = {};

	    for (var i = 0; i < names.length; ++i) {
	      var name = names[i];
	      if (name === 'to' || name === 'toEnd') continue;       // get rid of the shelljs prototype messup
	      var func = __nsp[name];
	      try {
	        var type = typeof func.apply('teststring');
	        retObj[name] = type;
	      } catch (e) {}
	    }
	    return retObj;
	  }

	  function getNativeStringPropertyNames() {
	    var results = [];
	    if (Object.getOwnPropertyNames) {
	      results = Object.getOwnPropertyNames(__nsp);
	      results.splice(results.indexOf('valueOf'), 1);
	      results.splice(results.indexOf('toString'), 1);
	      return results;
	    } else { //meant for legacy cruft, this could probably be made more efficient
	      var stringNames = {};
	      var objectNames = [];
	      for (var name in String.prototype)
	        stringNames[name] = name;

	      for (var name in Object.prototype)
	        delete stringNames[name];

	      //stringNames['toString'] = 'toString'; //this was deleted with the rest of the object names
	      for (var name in stringNames) {
	        results.push(name);
	      }
	      return results;
	    }
	  }

	  function Export(str) {
	    return new S(str);
	  };

	  //attach exports to StringJSWrapper
	  Export.extendPrototype = extendPrototype;
	  Export.restorePrototype = restorePrototype;
	  Export.VERSION = VERSION;
	  Export.TMPL_OPEN = '{{';
	  Export.TMPL_CLOSE = '}}';
	  Export.ENTITIES = ENTITIES;



	/*************************************
	/* Exports
	/*************************************/

	  if (typeof module !== 'undefined'  && typeof module.exports !== 'undefined') {
	    module.exports = Export;

	  } else {

	    if(true) {
	      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	        return Export;
	      }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else {
	      window.S = Export;
	    }
	  }


	/*************************************
	/* 3rd Party Private Functions
	/*************************************/

	  //from sugar.js
	  function multiArgs(args, fn) {
	    var result = [], i;
	    for(i = 0; i < args.length; i++) {
	      result.push(args[i]);
	      if(fn) fn.call(args, args[i], i);
	    }
	    return result;
	  }

	  //from underscore.string
	  var escapeChars = {
	    lt: '<',
	    gt: '>',
	    quot: '"',
	    apos: "'",
	    amp: '&'
	  };

	  function escapeRegExp (s) {
	    // most part from https://github.com/skulpt/skulpt/blob/ecaf75e69c2e539eff124b2ab45df0b01eaf2295/src/str.js#L242
	    var c;
	    var i;
	    var ret = [];
	    var re = /^[A-Za-z0-9]+$/;
	    s = ensureString(s);
	    for (i = 0; i < s.length; ++i) {
	      c = s.charAt(i);

	      if (re.test(c)) {
	        ret.push(c);
	      }
	      else {
	        if (c === "\\000") {
	          ret.push("\\000");
	        }
	        else {
	          ret.push("\\" + c);
	        }
	      }
	    }
	    return ret.join("");
	  }

	  function ensureString(string) {
	    return string == null ? '' : '' + string;
	  }

	  //from underscore.string
	  var reversedEscapeChars = {};
	  for(var key in escapeChars){ reversedEscapeChars[escapeChars[key]] = key; }

	  ENTITIES = {
	    "amp" : "&",
	    "gt" : ">",
	    "lt" : "<",
	    "quot" : "\"",
	    "apos" : "'",
	    "AElig" : 198,
	    "Aacute" : 193,
	    "Acirc" : 194,
	    "Agrave" : 192,
	    "Aring" : 197,
	    "Atilde" : 195,
	    "Auml" : 196,
	    "Ccedil" : 199,
	    "ETH" : 208,
	    "Eacute" : 201,
	    "Ecirc" : 202,
	    "Egrave" : 200,
	    "Euml" : 203,
	    "Iacute" : 205,
	    "Icirc" : 206,
	    "Igrave" : 204,
	    "Iuml" : 207,
	    "Ntilde" : 209,
	    "Oacute" : 211,
	    "Ocirc" : 212,
	    "Ograve" : 210,
	    "Oslash" : 216,
	    "Otilde" : 213,
	    "Ouml" : 214,
	    "THORN" : 222,
	    "Uacute" : 218,
	    "Ucirc" : 219,
	    "Ugrave" : 217,
	    "Uuml" : 220,
	    "Yacute" : 221,
	    "aacute" : 225,
	    "acirc" : 226,
	    "aelig" : 230,
	    "agrave" : 224,
	    "aring" : 229,
	    "atilde" : 227,
	    "auml" : 228,
	    "ccedil" : 231,
	    "eacute" : 233,
	    "ecirc" : 234,
	    "egrave" : 232,
	    "eth" : 240,
	    "euml" : 235,
	    "iacute" : 237,
	    "icirc" : 238,
	    "igrave" : 236,
	    "iuml" : 239,
	    "ntilde" : 241,
	    "oacute" : 243,
	    "ocirc" : 244,
	    "ograve" : 242,
	    "oslash" : 248,
	    "otilde" : 245,
	    "ouml" : 246,
	    "szlig" : 223,
	    "thorn" : 254,
	    "uacute" : 250,
	    "ucirc" : 251,
	    "ugrave" : 249,
	    "uuml" : 252,
	    "yacute" : 253,
	    "yuml" : 255,
	    "copy" : 169,
	    "reg" : 174,
	    "nbsp" : 160,
	    "iexcl" : 161,
	    "cent" : 162,
	    "pound" : 163,
	    "curren" : 164,
	    "yen" : 165,
	    "brvbar" : 166,
	    "sect" : 167,
	    "uml" : 168,
	    "ordf" : 170,
	    "laquo" : 171,
	    "not" : 172,
	    "shy" : 173,
	    "macr" : 175,
	    "deg" : 176,
	    "plusmn" : 177,
	    "sup1" : 185,
	    "sup2" : 178,
	    "sup3" : 179,
	    "acute" : 180,
	    "micro" : 181,
	    "para" : 182,
	    "middot" : 183,
	    "cedil" : 184,
	    "ordm" : 186,
	    "raquo" : 187,
	    "frac14" : 188,
	    "frac12" : 189,
	    "frac34" : 190,
	    "iquest" : 191,
	    "times" : 215,
	    "divide" : 247,
	    "OElig;" : 338,
	    "oelig;" : 339,
	    "Scaron;" : 352,
	    "scaron;" : 353,
	    "Yuml;" : 376,
	    "fnof;" : 402,
	    "circ;" : 710,
	    "tilde;" : 732,
	    "Alpha;" : 913,
	    "Beta;" : 914,
	    "Gamma;" : 915,
	    "Delta;" : 916,
	    "Epsilon;" : 917,
	    "Zeta;" : 918,
	    "Eta;" : 919,
	    "Theta;" : 920,
	    "Iota;" : 921,
	    "Kappa;" : 922,
	    "Lambda;" : 923,
	    "Mu;" : 924,
	    "Nu;" : 925,
	    "Xi;" : 926,
	    "Omicron;" : 927,
	    "Pi;" : 928,
	    "Rho;" : 929,
	    "Sigma;" : 931,
	    "Tau;" : 932,
	    "Upsilon;" : 933,
	    "Phi;" : 934,
	    "Chi;" : 935,
	    "Psi;" : 936,
	    "Omega;" : 937,
	    "alpha;" : 945,
	    "beta;" : 946,
	    "gamma;" : 947,
	    "delta;" : 948,
	    "epsilon;" : 949,
	    "zeta;" : 950,
	    "eta;" : 951,
	    "theta;" : 952,
	    "iota;" : 953,
	    "kappa;" : 954,
	    "lambda;" : 955,
	    "mu;" : 956,
	    "nu;" : 957,
	    "xi;" : 958,
	    "omicron;" : 959,
	    "pi;" : 960,
	    "rho;" : 961,
	    "sigmaf;" : 962,
	    "sigma;" : 963,
	    "tau;" : 964,
	    "upsilon;" : 965,
	    "phi;" : 966,
	    "chi;" : 967,
	    "psi;" : 968,
	    "omega;" : 969,
	    "thetasym;" : 977,
	    "upsih;" : 978,
	    "piv;" : 982,
	    "ensp;" : 8194,
	    "emsp;" : 8195,
	    "thinsp;" : 8201,
	    "zwnj;" : 8204,
	    "zwj;" : 8205,
	    "lrm;" : 8206,
	    "rlm;" : 8207,
	    "ndash;" : 8211,
	    "mdash;" : 8212,
	    "lsquo;" : 8216,
	    "rsquo;" : 8217,
	    "sbquo;" : 8218,
	    "ldquo;" : 8220,
	    "rdquo;" : 8221,
	    "bdquo;" : 8222,
	    "dagger;" : 8224,
	    "Dagger;" : 8225,
	    "bull;" : 8226,
	    "hellip;" : 8230,
	    "permil;" : 8240,
	    "prime;" : 8242,
	    "Prime;" : 8243,
	    "lsaquo;" : 8249,
	    "rsaquo;" : 8250,
	    "oline;" : 8254,
	    "frasl;" : 8260,
	    "euro;" : 8364,
	    "image;" : 8465,
	    "weierp;" : 8472,
	    "real;" : 8476,
	    "trade;" : 8482,
	    "alefsym;" : 8501,
	    "larr;" : 8592,
	    "uarr;" : 8593,
	    "rarr;" : 8594,
	    "darr;" : 8595,
	    "harr;" : 8596,
	    "crarr;" : 8629,
	    "lArr;" : 8656,
	    "uArr;" : 8657,
	    "rArr;" : 8658,
	    "dArr;" : 8659,
	    "hArr;" : 8660,
	    "forall;" : 8704,
	    "part;" : 8706,
	    "exist;" : 8707,
	    "empty;" : 8709,
	    "nabla;" : 8711,
	    "isin;" : 8712,
	    "notin;" : 8713,
	    "ni;" : 8715,
	    "prod;" : 8719,
	    "sum;" : 8721,
	    "minus;" : 8722,
	    "lowast;" : 8727,
	    "radic;" : 8730,
	    "prop;" : 8733,
	    "infin;" : 8734,
	    "ang;" : 8736,
	    "and;" : 8743,
	    "or;" : 8744,
	    "cap;" : 8745,
	    "cup;" : 8746,
	    "int;" : 8747,
	    "there4;" : 8756,
	    "sim;" : 8764,
	    "cong;" : 8773,
	    "asymp;" : 8776,
	    "ne;" : 8800,
	    "equiv;" : 8801,
	    "le;" : 8804,
	    "ge;" : 8805,
	    "sub;" : 8834,
	    "sup;" : 8835,
	    "nsub;" : 8836,
	    "sube;" : 8838,
	    "supe;" : 8839,
	    "oplus;" : 8853,
	    "otimes;" : 8855,
	    "perp;" : 8869,
	    "sdot;" : 8901,
	    "lceil;" : 8968,
	    "rceil;" : 8969,
	    "lfloor;" : 8970,
	    "rfloor;" : 8971,
	    "lang;" : 9001,
	    "rang;" : 9002,
	    "loz;" : 9674,
	    "spades;" : 9824,
	    "clubs;" : 9827,
	    "hearts;" : 9829,
	    "diams;" : 9830
	  }


	}).call(this);


/***/ },
/* 321 */
/*!********************************!*\
  !*** ./~/string/lib/_count.js ***!
  \********************************/
/***/ function(module, exports) {

	function count(self, substr) {
	  var count = 0
	  var pos = self.indexOf(substr)

	  while (pos >= 0) {
	    count += 1
	    pos = self.indexOf(substr, pos + 1)
	  }

	  return count
	}

	module.exports = count

/***/ },
/* 322 */
/*!************************************!*\
  !*** ./~/string/lib/_splitLeft.js ***!
  \************************************/
/***/ function(module, exports) {

	function splitLeft(self, sep, maxSplit, limit) {

	  if (typeof maxSplit === 'undefined') {
	    var maxSplit = -1;
	  }

	  var splitResult = self.split(sep);
	  var splitPart1 = splitResult.slice(0, maxSplit);
	  var splitPart2 = splitResult.slice(maxSplit);

	  if (splitPart2.length === 0) {
	    splitResult = splitPart1;
	  } else {
	    splitResult = splitPart1.concat(splitPart2.join(sep));
	  }

	  if (typeof limit === 'undefined') {
	    return splitResult;
	  } else if (limit < 0) {
	    return splitResult.slice(limit);
	  } else {
	    return splitResult.slice(0, limit);
	  }

	}

	module.exports = splitLeft;


/***/ },
/* 323 */
/*!*************************************!*\
  !*** ./~/string/lib/_splitRight.js ***!
  \*************************************/
/***/ function(module, exports) {

	function splitRight(self, sep, maxSplit, limit) {

	  if (typeof maxSplit === 'undefined') {
	    var maxSplit = -1;
	  }
	  if (typeof limit === 'undefined') {
	    var limit = 0;
	  }

	  var splitResult = [self];

	  for (var i = self.length-1; i >= 0; i--) {

	    if (
	      splitResult[0].slice(i).indexOf(sep) === 0 &&
	      (splitResult.length <= maxSplit || maxSplit === -1)
	    ) {
	      splitResult.splice(1, 0, splitResult[0].slice(i+sep.length)); // insert
	      splitResult[0] = splitResult[0].slice(0, i)
	    }
	  }

	  if (limit >= 0) {
	    return splitResult.slice(-limit);
	  } else {
	    return splitResult.slice(0, -limit);
	  }

	}

	module.exports = splitRight;


/***/ },
/* 324 */
/*!****************************************!*\
  !*** ./~/node-helpers/config-tests.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/* --execute=mocha-- */

	var Config = __webpack_require__(/*! ./config */ 316)
	    , chai = __webpack_require__(/*! chai */ 325);

	var assert = chai.assert;
	chai.config.includeStack = true;

	suite("config.js", function() {
	    var testConf;
	    setup(function() {
	        testConf = new Config({
	            envPrefix: 'testConfig_'
	            , packageJsonDir: __dirname
	            , packageJsonRootProperty: 'testConfig'
	            , _defaultConfig: './config.json'
	        });
	        process.env.testConfig_testPropName = 'testPropVal';
	    });

	    suite("getFromLocation - test all built in locations", function getFromLocation() {
	        test("get package", function get_package() {
	            assert.strictEqual(testConf.getFromLocation('testPropName', 'package'), 'testPropVal');
	        });
	        test("get env", function get_env() {
	            assert.strictEqual(testConf.getFromLocation('testPropName', 'env'), 'testPropVal');
	        });
	        test("get default", function get_defeault() {
	            assert.strictEqual(testConf.getFromLocation('testPropName', 'default'), 'testPropVal');
	            assert.strictEqual(testConf.getDefault('testPropName'), 'testPropVal');
	        });
	        test("throws error", function throws_error() {
	            assert.throw(function() {
	                testConf.getFromLocation('testDefaultPriority', 'env', {
	                    shouldThrow: true
	                });
	            });
	        });
	    });

	    test("get - various priority assertions", function get() {
	        process.env.testConfig_testPackageJsonPriority = 'envVal';
	        process.env.testConfig_testEnvPriority = 'envVal';

	        assert.strictEqual(testConf.get('testPackageJsonPriority'), 'packageJsonVal');
	        assert.strictEqual(testConf.get('testEnvPriority'), 'envVal');
	        assert.strictEqual(testConf.get('testDefaultPriority'), 'defaultVal');
	    });

	    test("getValAndLocation", function getValAndLocation() {
	        process.env.testConfig_testPackageJsonPriority = 'envVal';
	        process.env.testConfig_testEnvPriority = 'envVal';

	        assert.deepEqual(testConf.getValAndLocation('testPackageJsonPriority'), {
	            val: 'packageJsonVal'
	            , location: 'package.json'
	        });
	        assert.deepEqual(testConf.getValAndLocation('testEnvPriority'), {
	            val: 'envVal'
	            , location: 'Environment variable'
	        });
	        assert.deepEqual(testConf.getValAndLocation('testDefaultPriority'), {
	            val: 'defaultVal'
	            , location: 'Default configuration'
	        });
	    });

	    test("set and delete default", function set_and_delete_default() {
	        var whataday = 'whataday';
	        var yesitwas = 'yesitwas';
	        assert.throw(function() {
	            testConf.getFromLocation(whataday, 'default', {
	                shouldThrow: true
	            });
	        });

	        testConf.setDefault(whataday, yesitwas);
	        assert.strictEqual(testConf.getFromLocation(whataday, 'default'), yesitwas);
	        testConf.removeDefault(whataday);

	        assert.throw(function() {
	            testConf.getFromLocation(whataday, 'default', {
	                shouldThrow: true
	            });
	        });

	        testConf.setDefault(whataday, yesitwas);
	        assert.strictEqual(testConf.getFromLocation(whataday, 'default'), yesitwas);
	        // making sure setDefault without a second parameter is the same thing as removeDefault
	        testConf.setDefault(whataday);

	        assert.throw(function() {
	            testConf.getFromLocation(whataday, 'default', {
	                shouldThrow: true
	            });
	        });
	    });
	});


/***/ },
/* 325 */
/*!****************************************!*\
  !*** ./~/node-helpers/~/chai/index.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(/*! ./lib/chai */ 326);


/***/ },
/* 326 */
/*!*******************************************!*\
  !*** ./~/node-helpers/~/chai/lib/chai.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * chai
	 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	var used = []
	  , exports = module.exports = {};

	/*!
	 * Chai version
	 */

	exports.version = '1.10.0';

	/*!
	 * Assertion Error
	 */

	exports.AssertionError = __webpack_require__(/*! assertion-error */ 327);

	/*!
	 * Utils for plugins (not exported)
	 */

	var util = __webpack_require__(/*! ./chai/utils */ 328);

	/**
	 * # .use(function)
	 *
	 * Provides a way to extend the internals of Chai
	 *
	 * @param {Function}
	 * @returns {this} for chaining
	 * @api public
	 */

	exports.use = function (fn) {
	  if (!~used.indexOf(fn)) {
	    fn(this, util);
	    used.push(fn);
	  }

	  return this;
	};

	/*!
	 * Configuration
	 */

	var config = __webpack_require__(/*! ./chai/config */ 339);
	exports.config = config;

	/*!
	 * Primary `Assertion` prototype
	 */

	var assertion = __webpack_require__(/*! ./chai/assertion */ 352);
	exports.use(assertion);

	/*!
	 * Core Assertions
	 */

	var core = __webpack_require__(/*! ./chai/core/assertions */ 353);
	exports.use(core);

	/*!
	 * Expect interface
	 */

	var expect = __webpack_require__(/*! ./chai/interface/expect */ 354);
	exports.use(expect);

	/*!
	 * Should interface
	 */

	var should = __webpack_require__(/*! ./chai/interface/should */ 355);
	exports.use(should);

	/*!
	 * Assert interface
	 */

	var assert = __webpack_require__(/*! ./chai/interface/assert */ 356);
	exports.use(assert);


/***/ },
/* 327 */
/*!************************************!*\
  !*** ./~/assertion-error/index.js ***!
  \************************************/
/***/ function(module, exports) {

	/*!
	 * assertion-error
	 * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
	 * MIT Licensed
	 */

	/*!
	 * Return a function that will copy properties from
	 * one object to another excluding any originally
	 * listed. Returned function will create a new `{}`.
	 *
	 * @param {String} excluded properties ...
	 * @return {Function}
	 */

	function exclude () {
	  var excludes = [].slice.call(arguments);

	  function excludeProps (res, obj) {
	    Object.keys(obj).forEach(function (key) {
	      if (!~excludes.indexOf(key)) res[key] = obj[key];
	    });
	  }

	  return function extendExclude () {
	    var args = [].slice.call(arguments)
	      , i = 0
	      , res = {};

	    for (; i < args.length; i++) {
	      excludeProps(res, args[i]);
	    }

	    return res;
	  };
	};

	/*!
	 * Primary Exports
	 */

	module.exports = AssertionError;

	/**
	 * ### AssertionError
	 *
	 * An extension of the JavaScript `Error` constructor for
	 * assertion and validation scenarios.
	 *
	 * @param {String} message
	 * @param {Object} properties to include (optional)
	 * @param {callee} start stack function (optional)
	 */

	function AssertionError (message, _props, ssf) {
	  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON')
	    , props = extend(_props || {});

	  // default values
	  this.message = message || 'Unspecified AssertionError';
	  this.showDiff = false;

	  // copy from properties
	  for (var key in props) {
	    this[key] = props[key];
	  }

	  // capture stack trace
	  ssf = ssf || arguments.callee;
	  if (ssf && Error.captureStackTrace) {
	    Error.captureStackTrace(this, ssf);
	  }
	}

	/*!
	 * Inherit from Error.prototype
	 */

	AssertionError.prototype = Object.create(Error.prototype);

	/*!
	 * Statically set name
	 */

	AssertionError.prototype.name = 'AssertionError';

	/*!
	 * Ensure correct constructor
	 */

	AssertionError.prototype.constructor = AssertionError;

	/**
	 * Allow errors to be converted to JSON for static transfer.
	 *
	 * @param {Boolean} include stack (default: `true`)
	 * @return {Object} object that can be `JSON.stringify`
	 */

	AssertionError.prototype.toJSON = function (stack) {
	  var extend = exclude('constructor', 'toJSON', 'stack')
	    , props = extend({ name: this.name }, this);

	  // include stack if exists and not turned off
	  if (false !== stack && this.stack) {
	    props.stack = this.stack;
	  }

	  return props;
	};


/***/ },
/* 328 */
/*!*******************************************************!*\
  !*** ./~/node-helpers/~/chai/lib/chai/utils/index.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * chai
	 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/*!
	 * Main exports
	 */

	var exports = module.exports = {};

	/*!
	 * test utility
	 */

	exports.test = __webpack_require__(/*! ./test */ 329);

	/*!
	 * type utility
	 */

	exports.type = __webpack_require__(/*! ./type */ 331);

	/*!
	 * message utility
	 */

	exports.getMessage = __webpack_require__(/*! ./getMessage */ 332);

	/*!
	 * actual utility
	 */

	exports.getActual = __webpack_require__(/*! ./getActual */ 333);

	/*!
	 * Inspect util
	 */

	exports.inspect = __webpack_require__(/*! ./inspect */ 334);

	/*!
	 * Object Display util
	 */

	exports.objDisplay = __webpack_require__(/*! ./objDisplay */ 338);

	/*!
	 * Flag utility
	 */

	exports.flag = __webpack_require__(/*! ./flag */ 330);

	/*!
	 * Flag transferring utility
	 */

	exports.transferFlags = __webpack_require__(/*! ./transferFlags */ 340);

	/*!
	 * Deep equal utility
	 */

	exports.eql = __webpack_require__(/*! deep-eql */ 341);

	/*!
	 * Deep path value
	 */

	exports.getPathValue = __webpack_require__(/*! ./getPathValue */ 345);

	/*!
	 * Function name
	 */

	exports.getName = __webpack_require__(/*! ./getName */ 335);

	/*!
	 * add Property
	 */

	exports.addProperty = __webpack_require__(/*! ./addProperty */ 346);

	/*!
	 * add Method
	 */

	exports.addMethod = __webpack_require__(/*! ./addMethod */ 347);

	/*!
	 * overwrite Property
	 */

	exports.overwriteProperty = __webpack_require__(/*! ./overwriteProperty */ 348);

	/*!
	 * overwrite Method
	 */

	exports.overwriteMethod = __webpack_require__(/*! ./overwriteMethod */ 349);

	/*!
	 * Add a chainable method
	 */

	exports.addChainableMethod = __webpack_require__(/*! ./addChainableMethod */ 350);

	/*!
	 * Overwrite chainable method
	 */

	exports.overwriteChainableMethod = __webpack_require__(/*! ./overwriteChainableMethod */ 351);



/***/ },
/* 329 */
/*!******************************************************!*\
  !*** ./~/node-helpers/~/chai/lib/chai/utils/test.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Chai - test utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/*!
	 * Module dependancies
	 */

	var flag = __webpack_require__(/*! ./flag */ 330);

	/**
	 * # test(object, expression)
	 *
	 * Test and object for expression.
	 *
	 * @param {Object} object (constructed Assertion)
	 * @param {Arguments} chai.Assertion.prototype.assert arguments
	 */

	module.exports = function (obj, args) {
	  var negate = flag(obj, 'negate')
	    , expr = args[0];
	  return negate ? !expr : expr;
	};


/***/ },
/* 330 */
/*!******************************************************!*\
  !*** ./~/node-helpers/~/chai/lib/chai/utils/flag.js ***!
  \******************************************************/
/***/ function(module, exports) {

	/*!
	 * Chai - flag utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/**
	 * ### flag(object ,key, [value])
	 *
	 * Get or set a flag value on an object. If a
	 * value is provided it will be set, else it will
	 * return the currently set value or `undefined` if
	 * the value is not set.
	 *
	 *     utils.flag(this, 'foo', 'bar'); // setter
	 *     utils.flag(this, 'foo'); // getter, returns `bar`
	 *
	 * @param {Object} object (constructed Assertion
	 * @param {String} key
	 * @param {Mixed} value (optional)
	 * @name flag
	 * @api private
	 */

	module.exports = function (obj, key, value) {
	  var flags = obj.__flags || (obj.__flags = Object.create(null));
	  if (arguments.length === 3) {
	    flags[key] = value;
	  } else {
	    return flags[key];
	  }
	};


/***/ },
/* 331 */
/*!******************************************************!*\
  !*** ./~/node-helpers/~/chai/lib/chai/utils/type.js ***!
  \******************************************************/
/***/ function(module, exports) {

	/*!
	 * Chai - type utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/*!
	 * Detectable javascript natives
	 */

	var natives = {
	    '[object Arguments]': 'arguments'
	  , '[object Array]': 'array'
	  , '[object Date]': 'date'
	  , '[object Function]': 'function'
	  , '[object Number]': 'number'
	  , '[object RegExp]': 'regexp'
	  , '[object String]': 'string'
	};

	/**
	 * ### type(object)
	 *
	 * Better implementation of `typeof` detection that can
	 * be used cross-browser. Handles the inconsistencies of
	 * Array, `null`, and `undefined` detection.
	 *
	 *     utils.type({}) // 'object'
	 *     utils.type(null) // `null'
	 *     utils.type(undefined) // `undefined`
	 *     utils.type([]) // `array`
	 *
	 * @param {Mixed} object to detect type of
	 * @name type
	 * @api private
	 */

	module.exports = function (obj) {
	  var str = Object.prototype.toString.call(obj);
	  if (natives[str]) return natives[str];
	  if (obj === null) return 'null';
	  if (obj === undefined) return 'undefined';
	  if (obj === Object(obj)) return 'object';
	  return typeof obj;
	};


/***/ },
/* 332 */
/*!************************************************************!*\
  !*** ./~/node-helpers/~/chai/lib/chai/utils/getMessage.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Chai - message composition utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/*!
	 * Module dependancies
	 */

	var flag = __webpack_require__(/*! ./flag */ 330)
	  , getActual = __webpack_require__(/*! ./getActual */ 333)
	  , inspect = __webpack_require__(/*! ./inspect */ 334)
	  , objDisplay = __webpack_require__(/*! ./objDisplay */ 338);

	/**
	 * ### .getMessage(object, message, negateMessage)
	 *
	 * Construct the error message based on flags
	 * and template tags. Template tags will return
	 * a stringified inspection of the object referenced.
	 *
	 * Message template tags:
	 * - `#{this}` current asserted object
	 * - `#{act}` actual value
	 * - `#{exp}` expected value
	 *
	 * @param {Object} object (constructed Assertion)
	 * @param {Arguments} chai.Assertion.prototype.assert arguments
	 * @name getMessage
	 * @api public
	 */

	module.exports = function (obj, args) {
	  var negate = flag(obj, 'negate')
	    , val = flag(obj, 'object')
	    , expected = args[3]
	    , actual = getActual(obj, args)
	    , msg = negate ? args[2] : args[1]
	    , flagMsg = flag(obj, 'message');

	  if(typeof msg === "function") msg = msg();
	  msg = msg || '';
	  msg = msg
	    .replace(/#{this}/g, objDisplay(val))
	    .replace(/#{act}/g, objDisplay(actual))
	    .replace(/#{exp}/g, objDisplay(expected));

	  return flagMsg ? flagMsg + ': ' + msg : msg;
	};


/***/ },
/* 333 */
/*!***********************************************************!*\
  !*** ./~/node-helpers/~/chai/lib/chai/utils/getActual.js ***!
  \***********************************************************/
/***/ function(module, exports) {

	/*!
	 * Chai - getActual utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/**
	 * # getActual(object, [actual])
	 *
	 * Returns the `actual` value for an Assertion
	 *
	 * @param {Object} object (constructed Assertion)
	 * @param {Arguments} chai.Assertion.prototype.assert arguments
	 */

	module.exports = function (obj, args) {
	  return args.length > 4 ? args[4] : obj._obj;
	};


/***/ },
/* 334 */
/*!*********************************************************!*\
  !*** ./~/node-helpers/~/chai/lib/chai/utils/inspect.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// This is (almost) directly from Node.js utils
	// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js

	var getName = __webpack_require__(/*! ./getName */ 335);
	var getProperties = __webpack_require__(/*! ./getProperties */ 336);
	var getEnumerableProperties = __webpack_require__(/*! ./getEnumerableProperties */ 337);

	module.exports = inspect;

	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
	 *    properties of objects.
	 * @param {Number} depth Depth in which to descend in object. Default is 2.
	 * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
	 *    output. Default is false (no coloring).
	 */
	function inspect(obj, showHidden, depth, colors) {
	  var ctx = {
	    showHidden: showHidden,
	    seen: [],
	    stylize: function (str) { return str; }
	  };
	  return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));
	}

	// Returns true if object is a DOM element.
	var isDOMElement = function (object) {
	  if (typeof HTMLElement === 'object') {
	    return object instanceof HTMLElement;
	  } else {
	    return object &&
	      typeof object === 'object' &&
	      object.nodeType === 1 &&
	      typeof object.nodeName === 'string';
	  }
	};

	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (value && typeof value.inspect === 'function' &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes);
	    if (typeof ret !== 'string') {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // If this is a DOM element, try to get the outer HTML.
	  if (isDOMElement(value)) {
	    if ('outerHTML' in value) {
	      return value.outerHTML;
	      // This value does not have an outerHTML attribute,
	      //   it could still be an XML element
	    } else {
	      // Attempt to serialize it
	      try {
	        if (document.xmlVersion) {
	          var xmlSerializer = new XMLSerializer();
	          return xmlSerializer.serializeToString(value);
	        } else {
	          // Firefox 11- do not support outerHTML
	          //   It does, however, support innerHTML
	          //   Use the following to render the element
	          var ns = "http://www.w3.org/1999/xhtml";
	          var container = document.createElementNS(ns, '_');

	          container.appendChild(value.cloneNode(false));
	          html = container.innerHTML
	            .replace('><', '>' + value.innerHTML + '<');
	          container.innerHTML = '';
	          return html;
	        }
	      } catch (err) {
	        // This could be a non-native DOM implementation,
	        //   continue with the normal flow:
	        //   printing the element as if it is an object.
	      }
	    }
	  }

	  // Look up the keys of the object.
	  var visibleKeys = getEnumerableProperties(value);
	  var keys = ctx.showHidden ? getProperties(value) : visibleKeys;

	  // Some type of object without properties can be shortcutted.
	  // In IE, errors have a single `stack` property, or if they are vanilla `Error`,
	  // a `stack` plus `description` property; ignore those for consistency.
	  if (keys.length === 0 || (isError(value) && (
	      (keys.length === 1 && keys[0] === 'stack') ||
	      (keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')
	     ))) {
	    if (typeof value === 'function') {
	      var name = getName(value);
	      var nameSuffix = name ? ': ' + name : '';
	      return ctx.stylize('[Function' + nameSuffix + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }

	  var base = '', array = false, braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (typeof value === 'function') {
	    var name = getName(value);
	    var nameSuffix = name ? ': ' + name : '';
	    base = ' [Function' + nameSuffix + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    return formatError(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}


	function formatPrimitive(ctx, value) {
	  switch (typeof value) {
	    case 'undefined':
	      return ctx.stylize('undefined', 'undefined');

	    case 'string':
	      var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                               .replace(/'/g, "\\'")
	                                               .replace(/\\"/g, '"') + '\'';
	      return ctx.stylize(simple, 'string');

	    case 'number':
	      if (value === 0 && (1/value) === -Infinity) {
	        return ctx.stylize('-0', 'number');
	      }
	      return ctx.stylize('' + value, 'number');

	    case 'boolean':
	      return ctx.stylize('' + value, 'boolean');
	  }
	  // For some reason typeof null is "object", so special case here.
	  if (value === null) {
	    return ctx.stylize('null', 'null');
	  }
	}


	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}


	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (Object.prototype.hasOwnProperty.call(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}


	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str;
	  if (value.__lookupGetter__) {
	    if (value.__lookupGetter__(key)) {
	      if (value.__lookupSetter__(key)) {
	        str = ctx.stylize('[Getter/Setter]', 'special');
	      } else {
	        str = ctx.stylize('[Getter]', 'special');
	      }
	    } else {
	      if (value.__lookupSetter__(key)) {
	        str = ctx.stylize('[Setter]', 'special');
	      }
	    }
	  }
	  if (visibleKeys.indexOf(key) < 0) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(value[key]) < 0) {
	      if (recurseTimes === null) {
	        str = formatValue(ctx, value[key], null);
	      } else {
	        str = formatValue(ctx, value[key], recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (typeof name === 'undefined') {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}


	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}

	function isArray(ar) {
	  return Array.isArray(ar) ||
	         (typeof ar === 'object' && objectToString(ar) === '[object Array]');
	}

	function isRegExp(re) {
	  return typeof re === 'object' && objectToString(re) === '[object RegExp]';
	}

	function isDate(d) {
	  return typeof d === 'object' && objectToString(d) === '[object Date]';
	}

	function isError(e) {
	  return typeof e === 'object' && objectToString(e) === '[object Error]';
	}

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}


/***/ },
/* 335 */
/*!*********************************************************!*\
  !*** ./~/node-helpers/~/chai/lib/chai/utils/getName.js ***!
  \*********************************************************/
/***/ function(module, exports) {

	/*!
	 * Chai - getName utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/**
	 * # getName(func)
	 *
	 * Gets the name of a function, in a cross-browser way.
	 *
	 * @param {Function} a function (usually a constructor)
	 */

	module.exports = function (func) {
	  if (func.name) return func.name;

	  var match = /^\s?function ([^(]*)\(/.exec(func);
	  return match && match[1] ? match[1] : "";
	};


/***/ },
/* 336 */
/*!***************************************************************!*\
  !*** ./~/node-helpers/~/chai/lib/chai/utils/getProperties.js ***!
  \***************************************************************/
/***/ function(module, exports) {

	/*!
	 * Chai - getProperties utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/**
	 * ### .getProperties(object)
	 *
	 * This allows the retrieval of property names of an object, enumerable or not,
	 * inherited or not.
	 *
	 * @param {Object} object
	 * @returns {Array}
	 * @name getProperties
	 * @api public
	 */

	module.exports = function getProperties(object) {
	  var result = Object.getOwnPropertyNames(subject);

	  function addProperty(property) {
	    if (result.indexOf(property) === -1) {
	      result.push(property);
	    }
	  }

	  var proto = Object.getPrototypeOf(subject);
	  while (proto !== null) {
	    Object.getOwnPropertyNames(proto).forEach(addProperty);
	    proto = Object.getPrototypeOf(proto);
	  }

	  return result;
	};


/***/ },
/* 337 */
/*!*************************************************************************!*\
  !*** ./~/node-helpers/~/chai/lib/chai/utils/getEnumerableProperties.js ***!
  \*************************************************************************/
/***/ function(module, exports) {

	/*!
	 * Chai - getEnumerableProperties utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/**
	 * ### .getEnumerableProperties(object)
	 *
	 * This allows the retrieval of enumerable property names of an object,
	 * inherited or not.
	 *
	 * @param {Object} object
	 * @returns {Array}
	 * @name getEnumerableProperties
	 * @api public
	 */

	module.exports = function getEnumerableProperties(object) {
	  var result = [];
	  for (var name in object) {
	    result.push(name);
	  }
	  return result;
	};


/***/ },
/* 338 */
/*!************************************************************!*\
  !*** ./~/node-helpers/~/chai/lib/chai/utils/objDisplay.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Chai - flag utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/*!
	 * Module dependancies
	 */

	var inspect = __webpack_require__(/*! ./inspect */ 334);
	var config = __webpack_require__(/*! ../config */ 339);

	/**
	 * ### .objDisplay (object)
	 *
	 * Determines if an object or an array matches
	 * criteria to be inspected in-line for error
	 * messages or should be truncated.
	 *
	 * @param {Mixed} javascript object to inspect
	 * @name objDisplay
	 * @api public
	 */

	module.exports = function (obj) {
	  var str = inspect(obj)
	    , type = Object.prototype.toString.call(obj);

	  if (config.truncateThreshold && str.length >= config.truncateThreshold) {
	    if (type === '[object Function]') {
	      return !obj.name || obj.name === ''
	        ? '[Function]'
	        : '[Function: ' + obj.name + ']';
	    } else if (type === '[object Array]') {
	      return '[ Array(' + obj.length + ') ]';
	    } else if (type === '[object Object]') {
	      var keys = Object.keys(obj)
	        , kstr = keys.length > 2
	          ? keys.splice(0, 2).join(', ') + ', ...'
	          : keys.join(', ');
	      return '{ Object (' + kstr + ') }';
	    } else {
	      return str;
	    }
	  } else {
	    return str;
	  }
	};


/***/ },
/* 339 */
/*!**************************************************!*\
  !*** ./~/node-helpers/~/chai/lib/chai/config.js ***!
  \**************************************************/
/***/ function(module, exports) {

	module.exports = {

	  /**
	   * ### config.includeStack
	   *
	   * User configurable property, influences whether stack trace
	   * is included in Assertion error message. Default of false
	   * suppresses stack trace in the error message.
	   *
	   *     chai.config.includeStack = true;  // enable stack on error
	   *
	   * @param {Boolean}
	   * @api public
	   */

	   includeStack: false,

	  /**
	   * ### config.showDiff
	   *
	   * User configurable property, influences whether or not
	   * the `showDiff` flag should be included in the thrown
	   * AssertionErrors. `false` will always be `false`; `true`
	   * will be true when the assertion has requested a diff
	   * be shown.
	   *
	   * @param {Boolean}
	   * @api public
	   */

	  showDiff: true,

	  /**
	   * ### config.truncateThreshold
	   *
	   * User configurable property, sets length threshold for actual and
	   * expected values in assertion errors. If this threshold is exceeded,
	   * the value is truncated.
	   *
	   * Set it to zero if you want to disable truncating altogether.
	   *
	   *     chai.config.truncateThreshold = 0;  // disable truncating
	   *
	   * @param {Number}
	   * @api public
	   */

	  truncateThreshold: 40

	};


/***/ },
/* 340 */
/*!***************************************************************!*\
  !*** ./~/node-helpers/~/chai/lib/chai/utils/transferFlags.js ***!
  \***************************************************************/
/***/ function(module, exports) {

	/*!
	 * Chai - transferFlags utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/**
	 * ### transferFlags(assertion, object, includeAll = true)
	 *
	 * Transfer all the flags for `assertion` to `object`. If
	 * `includeAll` is set to `false`, then the base Chai
	 * assertion flags (namely `object`, `ssfi`, and `message`)
	 * will not be transferred.
	 *
	 *
	 *     var newAssertion = new Assertion();
	 *     utils.transferFlags(assertion, newAssertion);
	 *
	 *     var anotherAsseriton = new Assertion(myObj);
	 *     utils.transferFlags(assertion, anotherAssertion, false);
	 *
	 * @param {Assertion} assertion the assertion to transfer the flags from
	 * @param {Object} object the object to transfer the flags too; usually a new assertion
	 * @param {Boolean} includeAll
	 * @name getAllFlags
	 * @api private
	 */

	module.exports = function (assertion, object, includeAll) {
	  var flags = assertion.__flags || (assertion.__flags = Object.create(null));

	  if (!object.__flags) {
	    object.__flags = Object.create(null);
	  }

	  includeAll = arguments.length === 3 ? includeAll : true;

	  for (var flag in flags) {
	    if (includeAll ||
	        (flag !== 'object' && flag !== 'ssfi' && flag != 'message')) {
	      object.__flags[flag] = flags[flag];
	    }
	  }
	};


/***/ },
/* 341 */
/*!*****************************!*\
  !*** ./~/deep-eql/index.js ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(/*! ./lib/eql */ 342);


/***/ },
/* 342 */
/*!*******************************!*\
  !*** ./~/deep-eql/lib/eql.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * deep-eql
	 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/*!
	 * Module dependencies
	 */

	var type = __webpack_require__(/*! type-detect */ 343);

	/*!
	 * Buffer.isBuffer browser shim
	 */

	var Buffer;
	try { Buffer = __webpack_require__(/*! buffer */ 46).Buffer; }
	catch(ex) {
	  Buffer = {};
	  Buffer.isBuffer = function() { return false; }
	}

	/*!
	 * Primary Export
	 */

	module.exports = deepEqual;

	/**
	 * Assert super-strict (egal) equality between
	 * two objects of any type.
	 *
	 * @param {Mixed} a
	 * @param {Mixed} b
	 * @param {Array} memoised (optional)
	 * @return {Boolean} equal match
	 */

	function deepEqual(a, b, m) {
	  if (sameValue(a, b)) {
	    return true;
	  } else if ('date' === type(a)) {
	    return dateEqual(a, b);
	  } else if ('regexp' === type(a)) {
	    return regexpEqual(a, b);
	  } else if (Buffer.isBuffer(a)) {
	    return bufferEqual(a, b);
	  } else if ('arguments' === type(a)) {
	    return argumentsEqual(a, b, m);
	  } else if (!typeEqual(a, b)) {
	    return false;
	  } else if (('object' !== type(a) && 'object' !== type(b))
	  && ('array' !== type(a) && 'array' !== type(b))) {
	    return sameValue(a, b);
	  } else {
	    return objectEqual(a, b, m);
	  }
	}

	/*!
	 * Strict (egal) equality test. Ensures that NaN always
	 * equals NaN and `-0` does not equal `+0`.
	 *
	 * @param {Mixed} a
	 * @param {Mixed} b
	 * @return {Boolean} equal match
	 */

	function sameValue(a, b) {
	  if (a === b) return a !== 0 || 1 / a === 1 / b;
	  return a !== a && b !== b;
	}

	/*!
	 * Compare the types of two given objects and
	 * return if they are equal. Note that an Array
	 * has a type of `array` (not `object`) and arguments
	 * have a type of `arguments` (not `array`/`object`).
	 *
	 * @param {Mixed} a
	 * @param {Mixed} b
	 * @return {Boolean} result
	 */

	function typeEqual(a, b) {
	  return type(a) === type(b);
	}

	/*!
	 * Compare two Date objects by asserting that
	 * the time values are equal using `saveValue`.
	 *
	 * @param {Date} a
	 * @param {Date} b
	 * @return {Boolean} result
	 */

	function dateEqual(a, b) {
	  if ('date' !== type(b)) return false;
	  return sameValue(a.getTime(), b.getTime());
	}

	/*!
	 * Compare two regular expressions by converting them
	 * to string and checking for `sameValue`.
	 *
	 * @param {RegExp} a
	 * @param {RegExp} b
	 * @return {Boolean} result
	 */

	function regexpEqual(a, b) {
	  if ('regexp' !== type(b)) return false;
	  return sameValue(a.toString(), b.toString());
	}

	/*!
	 * Assert deep equality of two `arguments` objects.
	 * Unfortunately, these must be sliced to arrays
	 * prior to test to ensure no bad behavior.
	 *
	 * @param {Arguments} a
	 * @param {Arguments} b
	 * @param {Array} memoize (optional)
	 * @return {Boolean} result
	 */

	function argumentsEqual(a, b, m) {
	  if ('arguments' !== type(b)) return false;
	  a = [].slice.call(a);
	  b = [].slice.call(b);
	  return deepEqual(a, b, m);
	}

	/*!
	 * Get enumerable properties of a given object.
	 *
	 * @param {Object} a
	 * @return {Array} property names
	 */

	function enumerable(a) {
	  var res = [];
	  for (var key in a) res.push(key);
	  return res;
	}

	/*!
	 * Simple equality for flat iterable objects
	 * such as Arrays or Node.js buffers.
	 *
	 * @param {Iterable} a
	 * @param {Iterable} b
	 * @return {Boolean} result
	 */

	function iterableEqual(a, b) {
	  if (a.length !==  b.length) return false;

	  var i = 0;
	  var match = true;

	  for (; i < a.length; i++) {
	    if (a[i] !== b[i]) {
	      match = false;
	      break;
	    }
	  }

	  return match;
	}

	/*!
	 * Extension to `iterableEqual` specifically
	 * for Node.js Buffers.
	 *
	 * @param {Buffer} a
	 * @param {Mixed} b
	 * @return {Boolean} result
	 */

	function bufferEqual(a, b) {
	  if (!Buffer.isBuffer(b)) return false;
	  return iterableEqual(a, b);
	}

	/*!
	 * Block for `objectEqual` ensuring non-existing
	 * values don't get in.
	 *
	 * @param {Mixed} object
	 * @return {Boolean} result
	 */

	function isValue(a) {
	  return a !== null && a !== undefined;
	}

	/*!
	 * Recursively check the equality of two objects.
	 * Once basic sameness has been established it will
	 * defer to `deepEqual` for each enumerable key
	 * in the object.
	 *
	 * @param {Mixed} a
	 * @param {Mixed} b
	 * @return {Boolean} result
	 */

	function objectEqual(a, b, m) {
	  if (!isValue(a) || !isValue(b)) {
	    return false;
	  }

	  if (a.prototype !== b.prototype) {
	    return false;
	  }

	  var i;
	  if (m) {
	    for (i = 0; i < m.length; i++) {
	      if ((m[i][0] === a && m[i][1] === b)
	      ||  (m[i][0] === b && m[i][1] === a)) {
	        return true;
	      }
	    }
	  } else {
	    m = [];
	  }

	  try {
	    var ka = enumerable(a);
	    var kb = enumerable(b);
	  } catch (ex) {
	    return false;
	  }

	  ka.sort();
	  kb.sort();

	  if (!iterableEqual(ka, kb)) {
	    return false;
	  }

	  m.push([ a, b ]);

	  var key;
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!deepEqual(a[key], b[key], m)) {
	      return false;
	    }
	  }

	  return true;
	}


/***/ },
/* 343 */
/*!********************************!*\
  !*** ./~/type-detect/index.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(/*! ./lib/type */ 344);


/***/ },
/* 344 */
/*!***********************************!*\
  !*** ./~/type-detect/lib/type.js ***!
  \***********************************/
/***/ function(module, exports) {

	/*!
	 * type-detect
	 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/*!
	 * Primary Exports
	 */

	var exports = module.exports = getType;

	/*!
	 * Detectable javascript natives
	 */

	var natives = {
	    '[object Array]': 'array'
	  , '[object RegExp]': 'regexp'
	  , '[object Function]': 'function'
	  , '[object Arguments]': 'arguments'
	  , '[object Date]': 'date'
	};

	/**
	 * ### typeOf (obj)
	 *
	 * Use several different techniques to determine
	 * the type of object being tested.
	 *
	 *
	 * @param {Mixed} object
	 * @return {String} object type
	 * @api public
	 */

	function getType (obj) {
	  var str = Object.prototype.toString.call(obj);
	  if (natives[str]) return natives[str];
	  if (obj === null) return 'null';
	  if (obj === undefined) return 'undefined';
	  if (obj === Object(obj)) return 'object';
	  return typeof obj;
	}

	exports.Library = Library;

	/**
	 * ### Library
	 *
	 * Create a repository for custom type detection.
	 *
	 * ```js
	 * var lib = new type.Library;
	 * ```
	 *
	 */

	function Library () {
	  this.tests = {};
	}

	/**
	 * #### .of (obj)
	 *
	 * Expose replacement `typeof` detection to the library.
	 *
	 * ```js
	 * if ('string' === lib.of('hello world')) {
	 *   // ...
	 * }
	 * ```
	 *
	 * @param {Mixed} object to test
	 * @return {String} type
	 */

	Library.prototype.of = getType;

	/**
	 * #### .define (type, test)
	 *
	 * Add a test to for the `.test()` assertion.
	 *
	 * Can be defined as a regular expression:
	 *
	 * ```js
	 * lib.define('int', /^[0-9]+$/);
	 * ```
	 *
	 * ... or as a function:
	 *
	 * ```js
	 * lib.define('bln', function (obj) {
	 *   if ('boolean' === lib.of(obj)) return true;
	 *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];
	 *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();
	 *   return !! ~blns.indexOf(obj);
	 * });
	 * ```
	 *
	 * @param {String} type
	 * @param {RegExp|Function} test
	 * @api public
	 */

	Library.prototype.define = function (type, test) {
	  if (arguments.length === 1) return this.tests[type];
	  this.tests[type] = test;
	  return this;
	};

	/**
	 * #### .test (obj, test)
	 *
	 * Assert that an object is of type. Will first
	 * check natives, and if that does not pass it will
	 * use the user defined custom tests.
	 *
	 * ```js
	 * assert(lib.test('1', 'int'));
	 * assert(lib.test('yes', 'bln'));
	 * ```
	 *
	 * @param {Mixed} object
	 * @param {String} type
	 * @return {Boolean} result
	 * @api public
	 */

	Library.prototype.test = function (obj, type) {
	  if (type === getType(obj)) return true;
	  var test = this.tests[type];

	  if (test && 'regexp' === getType(test)) {
	    return test.test(obj);
	  } else if (test && 'function' === getType(test)) {
	    return test(obj);
	  } else {
	    throw new ReferenceError('Type test "' + type + '" not defined or invalid.');
	  }
	};


/***/ },
/* 345 */
/*!**************************************************************!*\
  !*** ./~/node-helpers/~/chai/lib/chai/utils/getPathValue.js ***!
  \**************************************************************/
/***/ function(module, exports) {

	/*!
	 * Chai - getPathValue utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * @see https://github.com/logicalparadox/filtr
	 * MIT Licensed
	 */

	/**
	 * ### .getPathValue(path, object)
	 *
	 * This allows the retrieval of values in an
	 * object given a string path.
	 *
	 *     var obj = {
	 *         prop1: {
	 *             arr: ['a', 'b', 'c']
	 *           , str: 'Hello'
	 *         }
	 *       , prop2: {
	 *             arr: [ { nested: 'Universe' } ]
	 *           , str: 'Hello again!'
	 *         }
	 *     }
	 *
	 * The following would be the results.
	 *
	 *     getPathValue('prop1.str', obj); // Hello
	 *     getPathValue('prop1.att[2]', obj); // b
	 *     getPathValue('prop2.arr[0].nested', obj); // Universe
	 *
	 * @param {String} path
	 * @param {Object} object
	 * @returns {Object} value or `undefined`
	 * @name getPathValue
	 * @api public
	 */

	var getPathValue = module.exports = function (path, obj) {
	  var parsed = parsePath(path);
	  return _getPathValue(parsed, obj);
	};

	/*!
	 * ## parsePath(path)
	 *
	 * Helper function used to parse string object
	 * paths. Use in conjunction with `_getPathValue`.
	 *
	 *      var parsed = parsePath('myobject.property.subprop');
	 *
	 * ### Paths:
	 *
	 * * Can be as near infinitely deep and nested
	 * * Arrays are also valid using the formal `myobject.document[3].property`.
	 *
	 * @param {String} path
	 * @returns {Object} parsed
	 * @api private
	 */

	function parsePath (path) {
	  var str = path.replace(/\[/g, '.[')
	    , parts = str.match(/(\\\.|[^.]+?)+/g);
	  return parts.map(function (value) {
	    var re = /\[(\d+)\]$/
	      , mArr = re.exec(value)
	    if (mArr) return { i: parseFloat(mArr[1]) };
	    else return { p: value };
	  });
	};

	/*!
	 * ## _getPathValue(parsed, obj)
	 *
	 * Helper companion function for `.parsePath` that returns
	 * the value located at the parsed address.
	 *
	 *      var value = getPathValue(parsed, obj);
	 *
	 * @param {Object} parsed definition from `parsePath`.
	 * @param {Object} object to search against
	 * @returns {Object|Undefined} value
	 * @api private
	 */

	function _getPathValue (parsed, obj) {
	  var tmp = obj
	    , res;
	  for (var i = 0, l = parsed.length; i < l; i++) {
	    var part = parsed[i];
	    if (tmp) {
	      if ('undefined' !== typeof part.p)
	        tmp = tmp[part.p];
	      else if ('undefined' !== typeof part.i)
	        tmp = tmp[part.i];
	      if (i == (l - 1)) res = tmp;
	    } else {
	      res = undefined;
	    }
	  }
	  return res;
	};


/***/ },
/* 346 */
/*!*************************************************************!*\
  !*** ./~/node-helpers/~/chai/lib/chai/utils/addProperty.js ***!
  \*************************************************************/
/***/ function(module, exports) {

	/*!
	 * Chai - addProperty utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/**
	 * ### addProperty (ctx, name, getter)
	 *
	 * Adds a property to the prototype of an object.
	 *
	 *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {
	 *       var obj = utils.flag(this, 'object');
	 *       new chai.Assertion(obj).to.be.instanceof(Foo);
	 *     });
	 *
	 * Can also be accessed directly from `chai.Assertion`.
	 *
	 *     chai.Assertion.addProperty('foo', fn);
	 *
	 * Then can be used as any other assertion.
	 *
	 *     expect(myFoo).to.be.foo;
	 *
	 * @param {Object} ctx object to which the property is added
	 * @param {String} name of property to add
	 * @param {Function} getter function to be used for name
	 * @name addProperty
	 * @api public
	 */

	module.exports = function (ctx, name, getter) {
	  Object.defineProperty(ctx, name,
	    { get: function () {
	        var result = getter.call(this);
	        return result === undefined ? this : result;
	      }
	    , configurable: true
	  });
	};


/***/ },
/* 347 */
/*!***********************************************************!*\
  !*** ./~/node-helpers/~/chai/lib/chai/utils/addMethod.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Chai - addMethod utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	var config = __webpack_require__(/*! ../config */ 339);

	/**
	 * ### .addMethod (ctx, name, method)
	 *
	 * Adds a method to the prototype of an object.
	 *
	 *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {
	 *       var obj = utils.flag(this, 'object');
	 *       new chai.Assertion(obj).to.be.equal(str);
	 *     });
	 *
	 * Can also be accessed directly from `chai.Assertion`.
	 *
	 *     chai.Assertion.addMethod('foo', fn);
	 *
	 * Then can be used as any other assertion.
	 *
	 *     expect(fooStr).to.be.foo('bar');
	 *
	 * @param {Object} ctx object to which the method is added
	 * @param {String} name of method to add
	 * @param {Function} method function to be used for name
	 * @name addMethod
	 * @api public
	 */
	var flag = __webpack_require__(/*! ./flag */ 330);

	module.exports = function (ctx, name, method) {
	  ctx[name] = function () {
	    var old_ssfi = flag(this, 'ssfi');
	    if (old_ssfi && config.includeStack === false)
	      flag(this, 'ssfi', ctx[name]);
	    var result = method.apply(this, arguments);
	    return result === undefined ? this : result;
	  };
	};


/***/ },
/* 348 */
/*!*******************************************************************!*\
  !*** ./~/node-helpers/~/chai/lib/chai/utils/overwriteProperty.js ***!
  \*******************************************************************/
/***/ function(module, exports) {

	/*!
	 * Chai - overwriteProperty utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/**
	 * ### overwriteProperty (ctx, name, fn)
	 *
	 * Overwites an already existing property getter and provides
	 * access to previous value. Must return function to use as getter.
	 *
	 *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {
	 *       return function () {
	 *         var obj = utils.flag(this, 'object');
	 *         if (obj instanceof Foo) {
	 *           new chai.Assertion(obj.name).to.equal('bar');
	 *         } else {
	 *           _super.call(this);
	 *         }
	 *       }
	 *     });
	 *
	 *
	 * Can also be accessed directly from `chai.Assertion`.
	 *
	 *     chai.Assertion.overwriteProperty('foo', fn);
	 *
	 * Then can be used as any other assertion.
	 *
	 *     expect(myFoo).to.be.ok;
	 *
	 * @param {Object} ctx object whose property is to be overwritten
	 * @param {String} name of property to overwrite
	 * @param {Function} getter function that returns a getter function to be used for name
	 * @name overwriteProperty
	 * @api public
	 */

	module.exports = function (ctx, name, getter) {
	  var _get = Object.getOwnPropertyDescriptor(ctx, name)
	    , _super = function () {};

	  if (_get && 'function' === typeof _get.get)
	    _super = _get.get

	  Object.defineProperty(ctx, name,
	    { get: function () {
	        var result = getter(_super).call(this);
	        return result === undefined ? this : result;
	      }
	    , configurable: true
	  });
	};


/***/ },
/* 349 */
/*!*****************************************************************!*\
  !*** ./~/node-helpers/~/chai/lib/chai/utils/overwriteMethod.js ***!
  \*****************************************************************/
/***/ function(module, exports) {

	/*!
	 * Chai - overwriteMethod utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/**
	 * ### overwriteMethod (ctx, name, fn)
	 *
	 * Overwites an already existing method and provides
	 * access to previous function. Must return function
	 * to be used for name.
	 *
	 *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {
	 *       return function (str) {
	 *         var obj = utils.flag(this, 'object');
	 *         if (obj instanceof Foo) {
	 *           new chai.Assertion(obj.value).to.equal(str);
	 *         } else {
	 *           _super.apply(this, arguments);
	 *         }
	 *       }
	 *     });
	 *
	 * Can also be accessed directly from `chai.Assertion`.
	 *
	 *     chai.Assertion.overwriteMethod('foo', fn);
	 *
	 * Then can be used as any other assertion.
	 *
	 *     expect(myFoo).to.equal('bar');
	 *
	 * @param {Object} ctx object whose method is to be overwritten
	 * @param {String} name of method to overwrite
	 * @param {Function} method function that returns a function to be used for name
	 * @name overwriteMethod
	 * @api public
	 */

	module.exports = function (ctx, name, method) {
	  var _method = ctx[name]
	    , _super = function () { return this; };

	  if (_method && 'function' === typeof _method)
	    _super = _method;

	  ctx[name] = function () {
	    var result = method(_super).apply(this, arguments);
	    return result === undefined ? this : result;
	  }
	};


/***/ },
/* 350 */
/*!********************************************************************!*\
  !*** ./~/node-helpers/~/chai/lib/chai/utils/addChainableMethod.js ***!
  \********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Chai - addChainingMethod utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/*!
	 * Module dependencies
	 */

	var transferFlags = __webpack_require__(/*! ./transferFlags */ 340);
	var flag = __webpack_require__(/*! ./flag */ 330);
	var config = __webpack_require__(/*! ../config */ 339);

	/*!
	 * Module variables
	 */

	// Check whether `__proto__` is supported
	var hasProtoSupport = '__proto__' in Object;

	// Without `__proto__` support, this module will need to add properties to a function.
	// However, some Function.prototype methods cannot be overwritten,
	// and there seems no easy cross-platform way to detect them (@see chaijs/chai/issues/69).
	var excludeNames = /^(?:length|name|arguments|caller)$/;

	// Cache `Function` properties
	var call  = Function.prototype.call,
	    apply = Function.prototype.apply;

	/**
	 * ### addChainableMethod (ctx, name, method, chainingBehavior)
	 *
	 * Adds a method to an object, such that the method can also be chained.
	 *
	 *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {
	 *       var obj = utils.flag(this, 'object');
	 *       new chai.Assertion(obj).to.be.equal(str);
	 *     });
	 *
	 * Can also be accessed directly from `chai.Assertion`.
	 *
	 *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);
	 *
	 * The result can then be used as both a method assertion, executing both `method` and
	 * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.
	 *
	 *     expect(fooStr).to.be.foo('bar');
	 *     expect(fooStr).to.be.foo.equal('foo');
	 *
	 * @param {Object} ctx object to which the method is added
	 * @param {String} name of method to add
	 * @param {Function} method function to be used for `name`, when called
	 * @param {Function} chainingBehavior function to be called every time the property is accessed
	 * @name addChainableMethod
	 * @api public
	 */

	module.exports = function (ctx, name, method, chainingBehavior) {
	  if (typeof chainingBehavior !== 'function') {
	    chainingBehavior = function () { };
	  }

	  var chainableBehavior = {
	      method: method
	    , chainingBehavior: chainingBehavior
	  };

	  // save the methods so we can overwrite them later, if we need to.
	  if (!ctx.__methods) {
	    ctx.__methods = {};
	  }
	  ctx.__methods[name] = chainableBehavior;

	  Object.defineProperty(ctx, name,
	    { get: function () {
	        chainableBehavior.chainingBehavior.call(this);

	        var assert = function assert() {
	          var old_ssfi = flag(this, 'ssfi');
	          if (old_ssfi && config.includeStack === false)
	            flag(this, 'ssfi', assert);
	          var result = chainableBehavior.method.apply(this, arguments);
	          return result === undefined ? this : result;
	        };

	        // Use `__proto__` if available
	        if (hasProtoSupport) {
	          // Inherit all properties from the object by replacing the `Function` prototype
	          var prototype = assert.__proto__ = Object.create(this);
	          // Restore the `call` and `apply` methods from `Function`
	          prototype.call = call;
	          prototype.apply = apply;
	        }
	        // Otherwise, redefine all properties (slow!)
	        else {
	          var asserterNames = Object.getOwnPropertyNames(ctx);
	          asserterNames.forEach(function (asserterName) {
	            if (!excludeNames.test(asserterName)) {
	              var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
	              Object.defineProperty(assert, asserterName, pd);
	            }
	          });
	        }

	        transferFlags(this, assert);
	        return assert;
	      }
	    , configurable: true
	  });
	};


/***/ },
/* 351 */
/*!**************************************************************************!*\
  !*** ./~/node-helpers/~/chai/lib/chai/utils/overwriteChainableMethod.js ***!
  \**************************************************************************/
/***/ function(module, exports) {

	/*!
	 * Chai - overwriteChainableMethod utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	/**
	 * ### overwriteChainableMethod (ctx, name, fn)
	 *
	 * Overwites an already existing chainable method
	 * and provides access to the previous function or
	 * property.  Must return functions to be used for
	 * name.
	 *
	 *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'length',
	 *       function (_super) {
	 *       }
	 *     , function (_super) {
	 *       }
	 *     );
	 *
	 * Can also be accessed directly from `chai.Assertion`.
	 *
	 *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);
	 *
	 * Then can be used as any other assertion.
	 *
	 *     expect(myFoo).to.have.length(3);
	 *     expect(myFoo).to.have.length.above(3);
	 *
	 * @param {Object} ctx object whose method / property is to be overwritten
	 * @param {String} name of method / property to overwrite
	 * @param {Function} method function that returns a function to be used for name
	 * @param {Function} chainingBehavior function that returns a function to be used for property
	 * @name overwriteChainableMethod
	 * @api public
	 */

	module.exports = function (ctx, name, method, chainingBehavior) {
	  var chainableBehavior = ctx.__methods[name];

	  var _chainingBehavior = chainableBehavior.chainingBehavior;
	  chainableBehavior.chainingBehavior = function () {
	    var result = chainingBehavior(_chainingBehavior).call(this);
	    return result === undefined ? this : result;
	  };

	  var _method = chainableBehavior.method;
	  chainableBehavior.method = function () {
	    var result = method(_method).apply(this, arguments);
	    return result === undefined ? this : result;
	  };
	};


/***/ },
/* 352 */
/*!*****************************************************!*\
  !*** ./~/node-helpers/~/chai/lib/chai/assertion.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * chai
	 * http://chaijs.com
	 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	var config = __webpack_require__(/*! ./config */ 339);
	var NOOP = function() { };

	module.exports = function (_chai, util) {
	  /*!
	   * Module dependencies.
	   */

	  var AssertionError = _chai.AssertionError
	    , flag = util.flag;

	  /*!
	   * Module export.
	   */

	  _chai.Assertion = Assertion;

	  /*!
	   * Assertion Constructor
	   *
	   * Creates object for chaining.
	   *
	   * @api private
	   */

	  function Assertion (obj, msg, stack) {
	    flag(this, 'ssfi', stack || arguments.callee);
	    flag(this, 'object', obj);
	    flag(this, 'message', msg);
	  }

	  Object.defineProperty(Assertion, 'includeStack', {
	    get: function() {
	      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
	      return config.includeStack;
	    },
	    set: function(value) {
	      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
	      config.includeStack = value;
	    }
	  });

	  Object.defineProperty(Assertion, 'showDiff', {
	    get: function() {
	      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
	      return config.showDiff;
	    },
	    set: function(value) {
	      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
	      config.showDiff = value;
	    }
	  });

	  Assertion.addProperty = function (name, fn) {
	    util.addProperty(this.prototype, name, fn);
	  };

	  Assertion.addMethod = function (name, fn) {
	    util.addMethod(this.prototype, name, fn);
	  };

	  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {
	    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);
	  };

	  Assertion.addChainableNoop = function(name, fn) {
	    util.addChainableMethod(this.prototype, name, NOOP, fn);
	  };

	  Assertion.overwriteProperty = function (name, fn) {
	    util.overwriteProperty(this.prototype, name, fn);
	  };

	  Assertion.overwriteMethod = function (name, fn) {
	    util.overwriteMethod(this.prototype, name, fn);
	  };

	  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {
	    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
	  };

	  /*!
	   * ### .assert(expression, message, negateMessage, expected, actual)
	   *
	   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
	   *
	   * @name assert
	   * @param {Philosophical} expression to be tested
	   * @param {String or Function} message or function that returns message to display if fails
	   * @param {String or Function} negatedMessage or function that returns negatedMessage to display if negated expression fails
	   * @param {Mixed} expected value (remember to check for negation)
	   * @param {Mixed} actual (optional) will default to `this.obj`
	   * @api private
	   */

	  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {
	    var ok = util.test(this, arguments);
	    if (true !== showDiff) showDiff = false;
	    if (true !== config.showDiff) showDiff = false;

	    if (!ok) {
	      var msg = util.getMessage(this, arguments)
	        , actual = util.getActual(this, arguments);
	      throw new AssertionError(msg, {
	          actual: actual
	        , expected: expected
	        , showDiff: showDiff
	      }, (config.includeStack) ? this.assert : flag(this, 'ssfi'));
	    }
	  };

	  /*!
	   * ### ._obj
	   *
	   * Quick reference to stored `actual` value for plugin developers.
	   *
	   * @api private
	   */

	  Object.defineProperty(Assertion.prototype, '_obj',
	    { get: function () {
	        return flag(this, 'object');
	      }
	    , set: function (val) {
	        flag(this, 'object', val);
	      }
	  });
	};


/***/ },
/* 353 */
/*!***********************************************************!*\
  !*** ./~/node-helpers/~/chai/lib/chai/core/assertions.js ***!
  \***********************************************************/
/***/ function(module, exports) {

	/*!
	 * chai
	 * http://chaijs.com
	 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	module.exports = function (chai, _) {
	  var Assertion = chai.Assertion
	    , toString = Object.prototype.toString
	    , flag = _.flag;

	  /**
	   * ### Language Chains
	   *
	   * The following are provided as chainable getters to
	   * improve the readability of your assertions. They
	   * do not provide testing capabilities unless they
	   * have been overwritten by a plugin.
	   *
	   * **Chains**
	   *
	   * - to
	   * - be
	   * - been
	   * - is
	   * - that
	   * - and
	   * - has
	   * - have
	   * - with
	   * - at
	   * - of
	   * - same
	   *
	   * @name language chains
	   * @api public
	   */

	  [ 'to', 'be', 'been'
	  , 'is', 'and', 'has', 'have'
	  , 'with', 'that', 'at'
	  , 'of', 'same' ].forEach(function (chain) {
	    Assertion.addProperty(chain, function () {
	      return this;
	    });
	  });

	  /**
	   * ### .not
	   *
	   * Negates any of assertions following in the chain.
	   *
	   *     expect(foo).to.not.equal('bar');
	   *     expect(goodFn).to.not.throw(Error);
	   *     expect({ foo: 'baz' }).to.have.property('foo')
	   *       .and.not.equal('bar');
	   *
	   * @name not
	   * @api public
	   */

	  Assertion.addProperty('not', function () {
	    flag(this, 'negate', true);
	  });

	  /**
	   * ### .deep
	   *
	   * Sets the `deep` flag, later used by the `equal` and
	   * `property` assertions.
	   *
	   *     expect(foo).to.deep.equal({ bar: 'baz' });
	   *     expect({ foo: { bar: { baz: 'quux' } } })
	   *       .to.have.deep.property('foo.bar.baz', 'quux');
	   *
	   * @name deep
	   * @api public
	   */

	  Assertion.addProperty('deep', function () {
	    flag(this, 'deep', true);
	  });

	  /**
	   * ### .a(type)
	   *
	   * The `a` and `an` assertions are aliases that can be
	   * used either as language chains or to assert a value's
	   * type.
	   *
	   *     // typeof
	   *     expect('test').to.be.a('string');
	   *     expect({ foo: 'bar' }).to.be.an('object');
	   *     expect(null).to.be.a('null');
	   *     expect(undefined).to.be.an('undefined');
	   *
	   *     // language chain
	   *     expect(foo).to.be.an.instanceof(Foo);
	   *
	   * @name a
	   * @alias an
	   * @param {String} type
	   * @param {String} message _optional_
	   * @api public
	   */

	  function an (type, msg) {
	    if (msg) flag(this, 'message', msg);
	    type = type.toLowerCase();
	    var obj = flag(this, 'object')
	      , article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';

	    this.assert(
	        type === _.type(obj)
	      , 'expected #{this} to be ' + article + type
	      , 'expected #{this} not to be ' + article + type
	    );
	  }

	  Assertion.addChainableMethod('an', an);
	  Assertion.addChainableMethod('a', an);

	  /**
	   * ### .include(value)
	   *
	   * The `include` and `contain` assertions can be used as either property
	   * based language chains or as methods to assert the inclusion of an object
	   * in an array or a substring in a string. When used as language chains,
	   * they toggle the `contain` flag for the `keys` assertion.
	   *
	   *     expect([1,2,3]).to.include(2);
	   *     expect('foobar').to.contain('foo');
	   *     expect({ foo: 'bar', hello: 'universe' }).to.include.keys('foo');
	   *
	   * @name include
	   * @alias contain
	   * @param {Object|String|Number} obj
	   * @param {String} message _optional_
	   * @api public
	   */

	  function includeChainingBehavior () {
	    flag(this, 'contains', true);
	  }

	  function include (val, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    var expected = false;
	    if (_.type(obj) === 'array' && _.type(val) === 'object') {
	      for (var i in obj) {
	        if (_.eql(obj[i], val)) {
	          expected = true;
	          break;
	        }
	      }
	    } else if (_.type(val) === 'object') {
	      if (!flag(this, 'negate')) {
	        for (var k in val) new Assertion(obj).property(k, val[k]);
	        return;
	      }
	      var subset = {}
	      for (var k in val) subset[k] = obj[k]
	      expected = _.eql(subset, val);
	    } else {
	      expected = obj && ~obj.indexOf(val)
	    }
	    this.assert(
	        expected
	      , 'expected #{this} to include ' + _.inspect(val)
	      , 'expected #{this} to not include ' + _.inspect(val));
	  }

	  Assertion.addChainableMethod('include', include, includeChainingBehavior);
	  Assertion.addChainableMethod('contain', include, includeChainingBehavior);

	  /**
	   * ### .ok
	   *
	   * Asserts that the target is truthy.
	   *
	   *     expect('everthing').to.be.ok;
	   *     expect(1).to.be.ok;
	   *     expect(false).to.not.be.ok;
	   *     expect(undefined).to.not.be.ok;
	   *     expect(null).to.not.be.ok;
	   *
	   * Can also be used as a function, which prevents some linter errors.
	   *
	   *     expect('everthing').to.be.ok();
	   *     
	   * @name ok
	   * @api public
	   */

	  Assertion.addChainableNoop('ok', function () {
	    this.assert(
	        flag(this, 'object')
	      , 'expected #{this} to be truthy'
	      , 'expected #{this} to be falsy');
	  });

	  /**
	   * ### .true
	   *
	   * Asserts that the target is `true`.
	   *
	   *     expect(true).to.be.true;
	   *     expect(1).to.not.be.true;
	   *
	   * Can also be used as a function, which prevents some linter errors.
	   *
	   *     expect(true).to.be.true();
	   *
	   * @name true
	   * @api public
	   */

	  Assertion.addChainableNoop('true', function () {
	    this.assert(
	        true === flag(this, 'object')
	      , 'expected #{this} to be true'
	      , 'expected #{this} to be false'
	      , this.negate ? false : true
	    );
	  });

	  /**
	   * ### .false
	   *
	   * Asserts that the target is `false`.
	   *
	   *     expect(false).to.be.false;
	   *     expect(0).to.not.be.false;
	   *
	   * Can also be used as a function, which prevents some linter errors.
	   *
	   *     expect(false).to.be.false();
	   *
	   * @name false
	   * @api public
	   */

	  Assertion.addChainableNoop('false', function () {
	    this.assert(
	        false === flag(this, 'object')
	      , 'expected #{this} to be false'
	      , 'expected #{this} to be true'
	      , this.negate ? true : false
	    );
	  });

	  /**
	   * ### .null
	   *
	   * Asserts that the target is `null`.
	   *
	   *     expect(null).to.be.null;
	   *     expect(undefined).not.to.be.null;
	   *
	   * Can also be used as a function, which prevents some linter errors.
	   *
	   *     expect(null).to.be.null();
	   *
	   * @name null
	   * @api public
	   */

	  Assertion.addChainableNoop('null', function () {
	    this.assert(
	        null === flag(this, 'object')
	      , 'expected #{this} to be null'
	      , 'expected #{this} not to be null'
	    );
	  });

	  /**
	   * ### .undefined
	   *
	   * Asserts that the target is `undefined`.
	   *
	   *     expect(undefined).to.be.undefined;
	   *     expect(null).to.not.be.undefined;
	   *
	   * Can also be used as a function, which prevents some linter errors.
	   *
	   *     expect(undefined).to.be.undefined();
	   *
	   * @name undefined
	   * @api public
	   */

	  Assertion.addChainableNoop('undefined', function () {
	    this.assert(
	        undefined === flag(this, 'object')
	      , 'expected #{this} to be undefined'
	      , 'expected #{this} not to be undefined'
	    );
	  });

	  /**
	   * ### .exist
	   *
	   * Asserts that the target is neither `null` nor `undefined`.
	   *
	   *     var foo = 'hi'
	   *       , bar = null
	   *       , baz;
	   *
	   *     expect(foo).to.exist;
	   *     expect(bar).to.not.exist;
	   *     expect(baz).to.not.exist;
	   *
	   * Can also be used as a function, which prevents some linter errors.
	   *
	   *     expect(foo).to.exist();
	   *
	   * @name exist
	   * @api public
	   */

	  Assertion.addChainableNoop('exist', function () {
	    this.assert(
	        null != flag(this, 'object')
	      , 'expected #{this} to exist'
	      , 'expected #{this} to not exist'
	    );
	  });


	  /**
	   * ### .empty
	   *
	   * Asserts that the target's length is `0`. For arrays, it checks
	   * the `length` property. For objects, it gets the count of
	   * enumerable keys.
	   *
	   *     expect([]).to.be.empty;
	   *     expect('').to.be.empty;
	   *     expect({}).to.be.empty;
	   *
	   * Can also be used as a function, which prevents some linter errors.
	   *
	   *     expect([]).to.be.empty();
	   *
	   * @name empty
	   * @api public
	   */

	  Assertion.addChainableNoop('empty', function () {
	    var obj = flag(this, 'object')
	      , expected = obj;

	    if (Array.isArray(obj) || 'string' === typeof object) {
	      expected = obj.length;
	    } else if (typeof obj === 'object') {
	      expected = Object.keys(obj).length;
	    }

	    this.assert(
	        !expected
	      , 'expected #{this} to be empty'
	      , 'expected #{this} not to be empty'
	    );
	  });

	  /**
	   * ### .arguments
	   *
	   * Asserts that the target is an arguments object.
	   *
	   *     function test () {
	   *       expect(arguments).to.be.arguments;
	   *     }
	   *
	   * Can also be used as a function, which prevents some linter errors.
	   *
	   *     function test () {
	   *       expect(arguments).to.be.arguments();
	   *     }
	   *
	   * @name arguments
	   * @alias Arguments
	   * @api public
	   */

	  function checkArguments () {
	    var obj = flag(this, 'object')
	      , type = Object.prototype.toString.call(obj);
	    this.assert(
	        '[object Arguments]' === type
	      , 'expected #{this} to be arguments but got ' + type
	      , 'expected #{this} to not be arguments'
	    );
	  }

	  Assertion.addChainableNoop('arguments', checkArguments);
	  Assertion.addChainableNoop('Arguments', checkArguments);

	  /**
	   * ### .equal(value)
	   *
	   * Asserts that the target is strictly equal (`===`) to `value`.
	   * Alternately, if the `deep` flag is set, asserts that
	   * the target is deeply equal to `value`.
	   *
	   *     expect('hello').to.equal('hello');
	   *     expect(42).to.equal(42);
	   *     expect(1).to.not.equal(true);
	   *     expect({ foo: 'bar' }).to.not.equal({ foo: 'bar' });
	   *     expect({ foo: 'bar' }).to.deep.equal({ foo: 'bar' });
	   *
	   * @name equal
	   * @alias equals
	   * @alias eq
	   * @alias deep.equal
	   * @param {Mixed} value
	   * @param {String} message _optional_
	   * @api public
	   */

	  function assertEqual (val, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    if (flag(this, 'deep')) {
	      return this.eql(val);
	    } else {
	      this.assert(
	          val === obj
	        , 'expected #{this} to equal #{exp}'
	        , 'expected #{this} to not equal #{exp}'
	        , val
	        , this._obj
	        , true
	      );
	    }
	  }

	  Assertion.addMethod('equal', assertEqual);
	  Assertion.addMethod('equals', assertEqual);
	  Assertion.addMethod('eq', assertEqual);

	  /**
	   * ### .eql(value)
	   *
	   * Asserts that the target is deeply equal to `value`.
	   *
	   *     expect({ foo: 'bar' }).to.eql({ foo: 'bar' });
	   *     expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);
	   *
	   * @name eql
	   * @alias eqls
	   * @param {Mixed} value
	   * @param {String} message _optional_
	   * @api public
	   */

	  function assertEql(obj, msg) {
	    if (msg) flag(this, 'message', msg);
	    this.assert(
	        _.eql(obj, flag(this, 'object'))
	      , 'expected #{this} to deeply equal #{exp}'
	      , 'expected #{this} to not deeply equal #{exp}'
	      , obj
	      , this._obj
	      , true
	    );
	  }

	  Assertion.addMethod('eql', assertEql);
	  Assertion.addMethod('eqls', assertEql);

	  /**
	   * ### .above(value)
	   *
	   * Asserts that the target is greater than `value`.
	   *
	   *     expect(10).to.be.above(5);
	   *
	   * Can also be used in conjunction with `length` to
	   * assert a minimum length. The benefit being a
	   * more informative error message than if the length
	   * was supplied directly.
	   *
	   *     expect('foo').to.have.length.above(2);
	   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
	   *
	   * @name above
	   * @alias gt
	   * @alias greaterThan
	   * @param {Number} value
	   * @param {String} message _optional_
	   * @api public
	   */

	  function assertAbove (n, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    if (flag(this, 'doLength')) {
	      new Assertion(obj, msg).to.have.property('length');
	      var len = obj.length;
	      this.assert(
	          len > n
	        , 'expected #{this} to have a length above #{exp} but got #{act}'
	        , 'expected #{this} to not have a length above #{exp}'
	        , n
	        , len
	      );
	    } else {
	      this.assert(
	          obj > n
	        , 'expected #{this} to be above ' + n
	        , 'expected #{this} to be at most ' + n
	      );
	    }
	  }

	  Assertion.addMethod('above', assertAbove);
	  Assertion.addMethod('gt', assertAbove);
	  Assertion.addMethod('greaterThan', assertAbove);

	  /**
	   * ### .least(value)
	   *
	   * Asserts that the target is greater than or equal to `value`.
	   *
	   *     expect(10).to.be.at.least(10);
	   *
	   * Can also be used in conjunction with `length` to
	   * assert a minimum length. The benefit being a
	   * more informative error message than if the length
	   * was supplied directly.
	   *
	   *     expect('foo').to.have.length.of.at.least(2);
	   *     expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);
	   *
	   * @name least
	   * @alias gte
	   * @param {Number} value
	   * @param {String} message _optional_
	   * @api public
	   */

	  function assertLeast (n, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    if (flag(this, 'doLength')) {
	      new Assertion(obj, msg).to.have.property('length');
	      var len = obj.length;
	      this.assert(
	          len >= n
	        , 'expected #{this} to have a length at least #{exp} but got #{act}'
	        , 'expected #{this} to have a length below #{exp}'
	        , n
	        , len
	      );
	    } else {
	      this.assert(
	          obj >= n
	        , 'expected #{this} to be at least ' + n
	        , 'expected #{this} to be below ' + n
	      );
	    }
	  }

	  Assertion.addMethod('least', assertLeast);
	  Assertion.addMethod('gte', assertLeast);

	  /**
	   * ### .below(value)
	   *
	   * Asserts that the target is less than `value`.
	   *
	   *     expect(5).to.be.below(10);
	   *
	   * Can also be used in conjunction with `length` to
	   * assert a maximum length. The benefit being a
	   * more informative error message than if the length
	   * was supplied directly.
	   *
	   *     expect('foo').to.have.length.below(4);
	   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
	   *
	   * @name below
	   * @alias lt
	   * @alias lessThan
	   * @param {Number} value
	   * @param {String} message _optional_
	   * @api public
	   */

	  function assertBelow (n, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    if (flag(this, 'doLength')) {
	      new Assertion(obj, msg).to.have.property('length');
	      var len = obj.length;
	      this.assert(
	          len < n
	        , 'expected #{this} to have a length below #{exp} but got #{act}'
	        , 'expected #{this} to not have a length below #{exp}'
	        , n
	        , len
	      );
	    } else {
	      this.assert(
	          obj < n
	        , 'expected #{this} to be below ' + n
	        , 'expected #{this} to be at least ' + n
	      );
	    }
	  }

	  Assertion.addMethod('below', assertBelow);
	  Assertion.addMethod('lt', assertBelow);
	  Assertion.addMethod('lessThan', assertBelow);

	  /**
	   * ### .most(value)
	   *
	   * Asserts that the target is less than or equal to `value`.
	   *
	   *     expect(5).to.be.at.most(5);
	   *
	   * Can also be used in conjunction with `length` to
	   * assert a maximum length. The benefit being a
	   * more informative error message than if the length
	   * was supplied directly.
	   *
	   *     expect('foo').to.have.length.of.at.most(4);
	   *     expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);
	   *
	   * @name most
	   * @alias lte
	   * @param {Number} value
	   * @param {String} message _optional_
	   * @api public
	   */

	  function assertMost (n, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    if (flag(this, 'doLength')) {
	      new Assertion(obj, msg).to.have.property('length');
	      var len = obj.length;
	      this.assert(
	          len <= n
	        , 'expected #{this} to have a length at most #{exp} but got #{act}'
	        , 'expected #{this} to have a length above #{exp}'
	        , n
	        , len
	      );
	    } else {
	      this.assert(
	          obj <= n
	        , 'expected #{this} to be at most ' + n
	        , 'expected #{this} to be above ' + n
	      );
	    }
	  }

	  Assertion.addMethod('most', assertMost);
	  Assertion.addMethod('lte', assertMost);

	  /**
	   * ### .within(start, finish)
	   *
	   * Asserts that the target is within a range.
	   *
	   *     expect(7).to.be.within(5,10);
	   *
	   * Can also be used in conjunction with `length` to
	   * assert a length range. The benefit being a
	   * more informative error message than if the length
	   * was supplied directly.
	   *
	   *     expect('foo').to.have.length.within(2,4);
	   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
	   *
	   * @name within
	   * @param {Number} start lowerbound inclusive
	   * @param {Number} finish upperbound inclusive
	   * @param {String} message _optional_
	   * @api public
	   */

	  Assertion.addMethod('within', function (start, finish, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object')
	      , range = start + '..' + finish;
	    if (flag(this, 'doLength')) {
	      new Assertion(obj, msg).to.have.property('length');
	      var len = obj.length;
	      this.assert(
	          len >= start && len <= finish
	        , 'expected #{this} to have a length within ' + range
	        , 'expected #{this} to not have a length within ' + range
	      );
	    } else {
	      this.assert(
	          obj >= start && obj <= finish
	        , 'expected #{this} to be within ' + range
	        , 'expected #{this} to not be within ' + range
	      );
	    }
	  });

	  /**
	   * ### .instanceof(constructor)
	   *
	   * Asserts that the target is an instance of `constructor`.
	   *
	   *     var Tea = function (name) { this.name = name; }
	   *       , Chai = new Tea('chai');
	   *
	   *     expect(Chai).to.be.an.instanceof(Tea);
	   *     expect([ 1, 2, 3 ]).to.be.instanceof(Array);
	   *
	   * @name instanceof
	   * @param {Constructor} constructor
	   * @param {String} message _optional_
	   * @alias instanceOf
	   * @api public
	   */

	  function assertInstanceOf (constructor, msg) {
	    if (msg) flag(this, 'message', msg);
	    var name = _.getName(constructor);
	    this.assert(
	        flag(this, 'object') instanceof constructor
	      , 'expected #{this} to be an instance of ' + name
	      , 'expected #{this} to not be an instance of ' + name
	    );
	  };

	  Assertion.addMethod('instanceof', assertInstanceOf);
	  Assertion.addMethod('instanceOf', assertInstanceOf);

	  /**
	   * ### .property(name, [value])
	   *
	   * Asserts that the target has a property `name`, optionally asserting that
	   * the value of that property is strictly equal to  `value`.
	   * If the `deep` flag is set, you can use dot- and bracket-notation for deep
	   * references into objects and arrays.
	   *
	   *     // simple referencing
	   *     var obj = { foo: 'bar' };
	   *     expect(obj).to.have.property('foo');
	   *     expect(obj).to.have.property('foo', 'bar');
	   *
	   *     // deep referencing
	   *     var deepObj = {
	   *         green: { tea: 'matcha' }
	   *       , teas: [ 'chai', 'matcha', { tea: 'konacha' } ]
	   *     };

	   *     expect(deepObj).to.have.deep.property('green.tea', 'matcha');
	   *     expect(deepObj).to.have.deep.property('teas[1]', 'matcha');
	   *     expect(deepObj).to.have.deep.property('teas[2].tea', 'konacha');
	   *
	   * You can also use an array as the starting point of a `deep.property`
	   * assertion, or traverse nested arrays.
	   *
	   *     var arr = [
	   *         [ 'chai', 'matcha', 'konacha' ]
	   *       , [ { tea: 'chai' }
	   *         , { tea: 'matcha' }
	   *         , { tea: 'konacha' } ]
	   *     ];
	   *
	   *     expect(arr).to.have.deep.property('[0][1]', 'matcha');
	   *     expect(arr).to.have.deep.property('[1][2].tea', 'konacha');
	   *
	   * Furthermore, `property` changes the subject of the assertion
	   * to be the value of that property from the original object. This
	   * permits for further chainable assertions on that property.
	   *
	   *     expect(obj).to.have.property('foo')
	   *       .that.is.a('string');
	   *     expect(deepObj).to.have.property('green')
	   *       .that.is.an('object')
	   *       .that.deep.equals({ tea: 'matcha' });
	   *     expect(deepObj).to.have.property('teas')
	   *       .that.is.an('array')
	   *       .with.deep.property('[2]')
	   *         .that.deep.equals({ tea: 'konacha' });
	   *
	   * @name property
	   * @alias deep.property
	   * @param {String} name
	   * @param {Mixed} value (optional)
	   * @param {String} message _optional_
	   * @returns value of property for chaining
	   * @api public
	   */

	  Assertion.addMethod('property', function (name, val, msg) {
	    if (msg) flag(this, 'message', msg);

	    var descriptor = flag(this, 'deep') ? 'deep property ' : 'property '
	      , negate = flag(this, 'negate')
	      , obj = flag(this, 'object')
	      , value = flag(this, 'deep')
	        ? _.getPathValue(name, obj)
	        : obj[name];

	    if (negate && undefined !== val) {
	      if (undefined === value) {
	        msg = (msg != null) ? msg + ': ' : '';
	        throw new Error(msg + _.inspect(obj) + ' has no ' + descriptor + _.inspect(name));
	      }
	    } else {
	      this.assert(
	          undefined !== value
	        , 'expected #{this} to have a ' + descriptor + _.inspect(name)
	        , 'expected #{this} to not have ' + descriptor + _.inspect(name));
	    }

	    if (undefined !== val) {
	      this.assert(
	          val === value
	        , 'expected #{this} to have a ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}'
	        , 'expected #{this} to not have a ' + descriptor + _.inspect(name) + ' of #{act}'
	        , val
	        , value
	      );
	    }

	    flag(this, 'object', value);
	  });


	  /**
	   * ### .ownProperty(name)
	   *
	   * Asserts that the target has an own property `name`.
	   *
	   *     expect('test').to.have.ownProperty('length');
	   *
	   * @name ownProperty
	   * @alias haveOwnProperty
	   * @param {String} name
	   * @param {String} message _optional_
	   * @api public
	   */

	  function assertOwnProperty (name, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    this.assert(
	        obj.hasOwnProperty(name)
	      , 'expected #{this} to have own property ' + _.inspect(name)
	      , 'expected #{this} to not have own property ' + _.inspect(name)
	    );
	  }

	  Assertion.addMethod('ownProperty', assertOwnProperty);
	  Assertion.addMethod('haveOwnProperty', assertOwnProperty);

	  /**
	   * ### .length(value)
	   *
	   * Asserts that the target's `length` property has
	   * the expected value.
	   *
	   *     expect([ 1, 2, 3]).to.have.length(3);
	   *     expect('foobar').to.have.length(6);
	   *
	   * Can also be used as a chain precursor to a value
	   * comparison for the length property.
	   *
	   *     expect('foo').to.have.length.above(2);
	   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
	   *     expect('foo').to.have.length.below(4);
	   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
	   *     expect('foo').to.have.length.within(2,4);
	   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
	   *
	   * @name length
	   * @alias lengthOf
	   * @param {Number} length
	   * @param {String} message _optional_
	   * @api public
	   */

	  function assertLengthChain () {
	    flag(this, 'doLength', true);
	  }

	  function assertLength (n, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    new Assertion(obj, msg).to.have.property('length');
	    var len = obj.length;

	    this.assert(
	        len == n
	      , 'expected #{this} to have a length of #{exp} but got #{act}'
	      , 'expected #{this} to not have a length of #{act}'
	      , n
	      , len
	    );
	  }

	  Assertion.addChainableMethod('length', assertLength, assertLengthChain);
	  Assertion.addMethod('lengthOf', assertLength);

	  /**
	   * ### .match(regexp)
	   *
	   * Asserts that the target matches a regular expression.
	   *
	   *     expect('foobar').to.match(/^foo/);
	   *
	   * @name match
	   * @param {RegExp} RegularExpression
	   * @param {String} message _optional_
	   * @api public
	   */

	  Assertion.addMethod('match', function (re, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    this.assert(
	        re.exec(obj)
	      , 'expected #{this} to match ' + re
	      , 'expected #{this} not to match ' + re
	    );
	  });

	  /**
	   * ### .string(string)
	   *
	   * Asserts that the string target contains another string.
	   *
	   *     expect('foobar').to.have.string('bar');
	   *
	   * @name string
	   * @param {String} string
	   * @param {String} message _optional_
	   * @api public
	   */

	  Assertion.addMethod('string', function (str, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    new Assertion(obj, msg).is.a('string');

	    this.assert(
	        ~obj.indexOf(str)
	      , 'expected #{this} to contain ' + _.inspect(str)
	      , 'expected #{this} to not contain ' + _.inspect(str)
	    );
	  });


	  /**
	   * ### .keys(key1, [key2], [...])
	   *
	   * Asserts that the target has exactly the given keys, or
	   * asserts the inclusion of some keys when using the
	   * `include` or `contain` modifiers.
	   *
	   *     expect({ foo: 1, bar: 2 }).to.have.keys(['foo', 'bar']);
	   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.keys('foo', 'bar');
	   *
	   * @name keys
	   * @alias key
	   * @param {String...|Array} keys
	   * @api public
	   */

	  function assertKeys (keys) {
	    var obj = flag(this, 'object')
	      , str
	      , ok = true;

	    keys = keys instanceof Array
	      ? keys
	      : Array.prototype.slice.call(arguments);

	    if (!keys.length) throw new Error('keys required');

	    var actual = Object.keys(obj)
	      , expected = keys
	      , len = keys.length;

	    // Inclusion
	    ok = keys.every(function(key){
	      return ~actual.indexOf(key);
	    });

	    // Strict
	    if (!flag(this, 'negate') && !flag(this, 'contains')) {
	      ok = ok && keys.length == actual.length;
	    }

	    // Key string
	    if (len > 1) {
	      keys = keys.map(function(key){
	        return _.inspect(key);
	      });
	      var last = keys.pop();
	      str = keys.join(', ') + ', and ' + last;
	    } else {
	      str = _.inspect(keys[0]);
	    }

	    // Form
	    str = (len > 1 ? 'keys ' : 'key ') + str;

	    // Have / include
	    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;

	    // Assertion
	    this.assert(
	        ok
	      , 'expected #{this} to ' + str
	      , 'expected #{this} to not ' + str
	      , expected.sort()
	      , actual.sort()
	      , true
	    );
	  }

	  Assertion.addMethod('keys', assertKeys);
	  Assertion.addMethod('key', assertKeys);

	  /**
	   * ### .throw(constructor)
	   *
	   * Asserts that the function target will throw a specific error, or specific type of error
	   * (as determined using `instanceof`), optionally with a RegExp or string inclusion test
	   * for the error's message.
	   *
	   *     var err = new ReferenceError('This is a bad function.');
	   *     var fn = function () { throw err; }
	   *     expect(fn).to.throw(ReferenceError);
	   *     expect(fn).to.throw(Error);
	   *     expect(fn).to.throw(/bad function/);
	   *     expect(fn).to.not.throw('good function');
	   *     expect(fn).to.throw(ReferenceError, /bad function/);
	   *     expect(fn).to.throw(err);
	   *     expect(fn).to.not.throw(new RangeError('Out of range.'));
	   *
	   * Please note that when a throw expectation is negated, it will check each
	   * parameter independently, starting with error constructor type. The appropriate way
	   * to check for the existence of a type of error but for a message that does not match
	   * is to use `and`.
	   *
	   *     expect(fn).to.throw(ReferenceError)
	   *        .and.not.throw(/good function/);
	   *
	   * @name throw
	   * @alias throws
	   * @alias Throw
	   * @param {ErrorConstructor} constructor
	   * @param {String|RegExp} expected error message
	   * @param {String} message _optional_
	   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
	   * @returns error for chaining (null if no error)
	   * @api public
	   */

	  function assertThrows (constructor, errMsg, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    new Assertion(obj, msg).is.a('function');

	    var thrown = false
	      , desiredError = null
	      , name = null
	      , thrownError = null;

	    if (arguments.length === 0) {
	      errMsg = null;
	      constructor = null;
	    } else if (constructor && (constructor instanceof RegExp || 'string' === typeof constructor)) {
	      errMsg = constructor;
	      constructor = null;
	    } else if (constructor && constructor instanceof Error) {
	      desiredError = constructor;
	      constructor = null;
	      errMsg = null;
	    } else if (typeof constructor === 'function') {
	      name = constructor.prototype.name || constructor.name;
	      if (name === 'Error' && constructor !== Error) {
	        name = (new constructor()).name;
	      }
	    } else {
	      constructor = null;
	    }

	    try {
	      obj();
	    } catch (err) {
	      // first, check desired error
	      if (desiredError) {
	        this.assert(
	            err === desiredError
	          , 'expected #{this} to throw #{exp} but #{act} was thrown'
	          , 'expected #{this} to not throw #{exp}'
	          , (desiredError instanceof Error ? desiredError.toString() : desiredError)
	          , (err instanceof Error ? err.toString() : err)
	        );

	        flag(this, 'object', err);
	        return this;
	      }

	      // next, check constructor
	      if (constructor) {
	        this.assert(
	            err instanceof constructor
	          , 'expected #{this} to throw #{exp} but #{act} was thrown'
	          , 'expected #{this} to not throw #{exp} but #{act} was thrown'
	          , name
	          , (err instanceof Error ? err.toString() : err)
	        );

	        if (!errMsg) {
	          flag(this, 'object', err);
	          return this;
	        }
	      }

	      // next, check message
	      var message = 'object' === _.type(err) && "message" in err
	        ? err.message
	        : '' + err;

	      if ((message != null) && errMsg && errMsg instanceof RegExp) {
	        this.assert(
	            errMsg.exec(message)
	          , 'expected #{this} to throw error matching #{exp} but got #{act}'
	          , 'expected #{this} to throw error not matching #{exp}'
	          , errMsg
	          , message
	        );

	        flag(this, 'object', err);
	        return this;
	      } else if ((message != null) && errMsg && 'string' === typeof errMsg) {
	        this.assert(
	            ~message.indexOf(errMsg)
	          , 'expected #{this} to throw error including #{exp} but got #{act}'
	          , 'expected #{this} to throw error not including #{act}'
	          , errMsg
	          , message
	        );

	        flag(this, 'object', err);
	        return this;
	      } else {
	        thrown = true;
	        thrownError = err;
	      }
	    }

	    var actuallyGot = ''
	      , expectedThrown = name !== null
	        ? name
	        : desiredError
	          ? '#{exp}' //_.inspect(desiredError)
	          : 'an error';

	    if (thrown) {
	      actuallyGot = ' but #{act} was thrown'
	    }

	    this.assert(
	        thrown === true
	      , 'expected #{this} to throw ' + expectedThrown + actuallyGot
	      , 'expected #{this} to not throw ' + expectedThrown + actuallyGot
	      , (desiredError instanceof Error ? desiredError.toString() : desiredError)
	      , (thrownError instanceof Error ? thrownError.toString() : thrownError)
	    );

	    flag(this, 'object', thrownError);
	  };

	  Assertion.addMethod('throw', assertThrows);
	  Assertion.addMethod('throws', assertThrows);
	  Assertion.addMethod('Throw', assertThrows);

	  /**
	   * ### .respondTo(method)
	   *
	   * Asserts that the object or class target will respond to a method.
	   *
	   *     Klass.prototype.bar = function(){};
	   *     expect(Klass).to.respondTo('bar');
	   *     expect(obj).to.respondTo('bar');
	   *
	   * To check if a constructor will respond to a static function,
	   * set the `itself` flag.
	   *
	   *     Klass.baz = function(){};
	   *     expect(Klass).itself.to.respondTo('baz');
	   *
	   * @name respondTo
	   * @param {String} method
	   * @param {String} message _optional_
	   * @api public
	   */

	  Assertion.addMethod('respondTo', function (method, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object')
	      , itself = flag(this, 'itself')
	      , context = ('function' === _.type(obj) && !itself)
	        ? obj.prototype[method]
	        : obj[method];

	    this.assert(
	        'function' === typeof context
	      , 'expected #{this} to respond to ' + _.inspect(method)
	      , 'expected #{this} to not respond to ' + _.inspect(method)
	    );
	  });

	  /**
	   * ### .itself
	   *
	   * Sets the `itself` flag, later used by the `respondTo` assertion.
	   *
	   *     function Foo() {}
	   *     Foo.bar = function() {}
	   *     Foo.prototype.baz = function() {}
	   *
	   *     expect(Foo).itself.to.respondTo('bar');
	   *     expect(Foo).itself.not.to.respondTo('baz');
	   *
	   * @name itself
	   * @api public
	   */

	  Assertion.addProperty('itself', function () {
	    flag(this, 'itself', true);
	  });

	  /**
	   * ### .satisfy(method)
	   *
	   * Asserts that the target passes a given truth test.
	   *
	   *     expect(1).to.satisfy(function(num) { return num > 0; });
	   *
	   * @name satisfy
	   * @param {Function} matcher
	   * @param {String} message _optional_
	   * @api public
	   */

	  Assertion.addMethod('satisfy', function (matcher, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    var result = matcher(obj);
	    this.assert(
	        result
	      , 'expected #{this} to satisfy ' + _.objDisplay(matcher)
	      , 'expected #{this} to not satisfy' + _.objDisplay(matcher)
	      , this.negate ? false : true
	      , result
	    );
	  });

	  /**
	   * ### .closeTo(expected, delta)
	   *
	   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
	   *
	   *     expect(1.5).to.be.closeTo(1, 0.5);
	   *
	   * @name closeTo
	   * @param {Number} expected
	   * @param {Number} delta
	   * @param {String} message _optional_
	   * @api public
	   */

	  Assertion.addMethod('closeTo', function (expected, delta, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');

	    new Assertion(obj, msg).is.a('number');
	    if (_.type(expected) !== 'number' || _.type(delta) !== 'number') {
	      throw new Error('the arguments to closeTo must be numbers');
	    }

	    this.assert(
	        Math.abs(obj - expected) <= delta
	      , 'expected #{this} to be close to ' + expected + ' +/- ' + delta
	      , 'expected #{this} not to be close to ' + expected + ' +/- ' + delta
	    );
	  });

	  function isSubsetOf(subset, superset, cmp) {
	    return subset.every(function(elem) {
	      if (!cmp) return superset.indexOf(elem) !== -1;

	      return superset.some(function(elem2) {
	        return cmp(elem, elem2);
	      });
	    })
	  }

	  /**
	   * ### .members(set)
	   *
	   * Asserts that the target is a superset of `set`,
	   * or that the target and `set` have the same strictly-equal (===) members.
	   * Alternately, if the `deep` flag is set, set members are compared for deep
	   * equality.
	   *
	   *     expect([1, 2, 3]).to.include.members([3, 2]);
	   *     expect([1, 2, 3]).to.not.include.members([3, 2, 8]);
	   *
	   *     expect([4, 2]).to.have.members([2, 4]);
	   *     expect([5, 2]).to.not.have.members([5, 2, 1]);
	   *
	   *     expect([{ id: 1 }]).to.deep.include.members([{ id: 1 }]);
	   *
	   * @name members
	   * @param {Array} set
	   * @param {String} message _optional_
	   * @api public
	   */

	  Assertion.addMethod('members', function (subset, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');

	    new Assertion(obj).to.be.an('array');
	    new Assertion(subset).to.be.an('array');

	    var cmp = flag(this, 'deep') ? _.eql : undefined;

	    if (flag(this, 'contains')) {
	      return this.assert(
	          isSubsetOf(subset, obj, cmp)
	        , 'expected #{this} to be a superset of #{act}'
	        , 'expected #{this} to not be a superset of #{act}'
	        , obj
	        , subset
	      );
	    }

	    this.assert(
	        isSubsetOf(obj, subset, cmp) && isSubsetOf(subset, obj, cmp)
	        , 'expected #{this} to have the same members as #{act}'
	        , 'expected #{this} to not have the same members as #{act}'
	        , obj
	        , subset
	    );
	  });
	};


/***/ },
/* 354 */
/*!************************************************************!*\
  !*** ./~/node-helpers/~/chai/lib/chai/interface/expect.js ***!
  \************************************************************/
/***/ function(module, exports) {

	/*!
	 * chai
	 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	module.exports = function (chai, util) {
	  chai.expect = function (val, message) {
	    return new chai.Assertion(val, message);
	  };
	};



/***/ },
/* 355 */
/*!************************************************************!*\
  !*** ./~/node-helpers/~/chai/lib/chai/interface/should.js ***!
  \************************************************************/
/***/ function(module, exports) {

	/*!
	 * chai
	 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */

	module.exports = function (chai, util) {
	  var Assertion = chai.Assertion;

	  function loadShould () {
	    // explicitly define this method as function as to have it's name to include as `ssfi`
	    function shouldGetter() {
	      if (this instanceof String || this instanceof Number) {
	        return new Assertion(this.constructor(this), null, shouldGetter);
	      } else if (this instanceof Boolean) {
	        return new Assertion(this == true, null, shouldGetter);
	      }
	      return new Assertion(this, null, shouldGetter);
	    }
	    function shouldSetter(value) {
	      // See https://github.com/chaijs/chai/issues/86: this makes
	      // `whatever.should = someValue` actually set `someValue`, which is
	      // especially useful for `global.should = require('chai').should()`.
	      //
	      // Note that we have to use [[DefineProperty]] instead of [[Put]]
	      // since otherwise we would trigger this very setter!
	      Object.defineProperty(this, 'should', {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    }
	    // modify Object.prototype to have `should`
	    Object.defineProperty(Object.prototype, 'should', {
	      set: shouldSetter
	      , get: shouldGetter
	      , configurable: true
	    });

	    var should = {};

	    should.equal = function (val1, val2, msg) {
	      new Assertion(val1, msg).to.equal(val2);
	    };

	    should.Throw = function (fn, errt, errs, msg) {
	      new Assertion(fn, msg).to.Throw(errt, errs);
	    };

	    should.exist = function (val, msg) {
	      new Assertion(val, msg).to.exist;
	    }

	    // negation
	    should.not = {}

	    should.not.equal = function (val1, val2, msg) {
	      new Assertion(val1, msg).to.not.equal(val2);
	    };

	    should.not.Throw = function (fn, errt, errs, msg) {
	      new Assertion(fn, msg).to.not.Throw(errt, errs);
	    };

	    should.not.exist = function (val, msg) {
	      new Assertion(val, msg).to.not.exist;
	    }

	    should['throw'] = should['Throw'];
	    should.not['throw'] = should.not['Throw'];

	    return should;
	  };

	  chai.should = loadShould;
	  chai.Should = loadShould;
	};


/***/ },
/* 356 */
/*!************************************************************!*\
  !*** ./~/node-helpers/~/chai/lib/chai/interface/assert.js ***!
  \************************************************************/
/***/ function(module, exports) {

	/*!
	 * chai
	 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */


	module.exports = function (chai, util) {

	  /*!
	   * Chai dependencies.
	   */

	  var Assertion = chai.Assertion
	    , flag = util.flag;

	  /*!
	   * Module export.
	   */

	  /**
	   * ### assert(expression, message)
	   *
	   * Write your own test expressions.
	   *
	   *     assert('foo' !== 'bar', 'foo is not bar');
	   *     assert(Array.isArray([]), 'empty arrays are arrays');
	   *
	   * @param {Mixed} expression to test for truthiness
	   * @param {String} message to display on error
	   * @name assert
	   * @api public
	   */

	  var assert = chai.assert = function (express, errmsg) {
	    var test = new Assertion(null, null, chai.assert);
	    test.assert(
	        express
	      , errmsg
	      , '[ negation message unavailable ]'
	    );
	  };

	  /**
	   * ### .fail(actual, expected, [message], [operator])
	   *
	   * Throw a failure. Node.js `assert` module-compatible.
	   *
	   * @name fail
	   * @param {Mixed} actual
	   * @param {Mixed} expected
	   * @param {String} message
	   * @param {String} operator
	   * @api public
	   */

	  assert.fail = function (actual, expected, message, operator) {
	    message = message || 'assert.fail()';
	    throw new chai.AssertionError(message, {
	        actual: actual
	      , expected: expected
	      , operator: operator
	    }, assert.fail);
	  };

	  /**
	   * ### .ok(object, [message])
	   *
	   * Asserts that `object` is truthy.
	   *
	   *     assert.ok('everything', 'everything is ok');
	   *     assert.ok(false, 'this will fail');
	   *
	   * @name ok
	   * @param {Mixed} object to test
	   * @param {String} message
	   * @api public
	   */

	  assert.ok = function (val, msg) {
	    new Assertion(val, msg).is.ok;
	  };

	  /**
	   * ### .notOk(object, [message])
	   *
	   * Asserts that `object` is falsy.
	   *
	   *     assert.notOk('everything', 'this will fail');
	   *     assert.notOk(false, 'this will pass');
	   *
	   * @name notOk
	   * @param {Mixed} object to test
	   * @param {String} message
	   * @api public
	   */

	  assert.notOk = function (val, msg) {
	    new Assertion(val, msg).is.not.ok;
	  };

	  /**
	   * ### .equal(actual, expected, [message])
	   *
	   * Asserts non-strict equality (`==`) of `actual` and `expected`.
	   *
	   *     assert.equal(3, '3', '== coerces values to strings');
	   *
	   * @name equal
	   * @param {Mixed} actual
	   * @param {Mixed} expected
	   * @param {String} message
	   * @api public
	   */

	  assert.equal = function (act, exp, msg) {
	    var test = new Assertion(act, msg, assert.equal);

	    test.assert(
	        exp == flag(test, 'object')
	      , 'expected #{this} to equal #{exp}'
	      , 'expected #{this} to not equal #{act}'
	      , exp
	      , act
	    );
	  };

	  /**
	   * ### .notEqual(actual, expected, [message])
	   *
	   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
	   *
	   *     assert.notEqual(3, 4, 'these numbers are not equal');
	   *
	   * @name notEqual
	   * @param {Mixed} actual
	   * @param {Mixed} expected
	   * @param {String} message
	   * @api public
	   */

	  assert.notEqual = function (act, exp, msg) {
	    var test = new Assertion(act, msg, assert.notEqual);

	    test.assert(
	        exp != flag(test, 'object')
	      , 'expected #{this} to not equal #{exp}'
	      , 'expected #{this} to equal #{act}'
	      , exp
	      , act
	    );
	  };

	  /**
	   * ### .strictEqual(actual, expected, [message])
	   *
	   * Asserts strict equality (`===`) of `actual` and `expected`.
	   *
	   *     assert.strictEqual(true, true, 'these booleans are strictly equal');
	   *
	   * @name strictEqual
	   * @param {Mixed} actual
	   * @param {Mixed} expected
	   * @param {String} message
	   * @api public
	   */

	  assert.strictEqual = function (act, exp, msg) {
	    new Assertion(act, msg).to.equal(exp);
	  };

	  /**
	   * ### .notStrictEqual(actual, expected, [message])
	   *
	   * Asserts strict inequality (`!==`) of `actual` and `expected`.
	   *
	   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');
	   *
	   * @name notStrictEqual
	   * @param {Mixed} actual
	   * @param {Mixed} expected
	   * @param {String} message
	   * @api public
	   */

	  assert.notStrictEqual = function (act, exp, msg) {
	    new Assertion(act, msg).to.not.equal(exp);
	  };

	  /**
	   * ### .deepEqual(actual, expected, [message])
	   *
	   * Asserts that `actual` is deeply equal to `expected`.
	   *
	   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });
	   *
	   * @name deepEqual
	   * @param {Mixed} actual
	   * @param {Mixed} expected
	   * @param {String} message
	   * @api public
	   */

	  assert.deepEqual = function (act, exp, msg) {
	    new Assertion(act, msg).to.eql(exp);
	  };

	  /**
	   * ### .notDeepEqual(actual, expected, [message])
	   *
	   * Assert that `actual` is not deeply equal to `expected`.
	   *
	   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });
	   *
	   * @name notDeepEqual
	   * @param {Mixed} actual
	   * @param {Mixed} expected
	   * @param {String} message
	   * @api public
	   */

	  assert.notDeepEqual = function (act, exp, msg) {
	    new Assertion(act, msg).to.not.eql(exp);
	  };

	  /**
	   * ### .isTrue(value, [message])
	   *
	   * Asserts that `value` is true.
	   *
	   *     var teaServed = true;
	   *     assert.isTrue(teaServed, 'the tea has been served');
	   *
	   * @name isTrue
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isTrue = function (val, msg) {
	    new Assertion(val, msg).is['true'];
	  };

	  /**
	   * ### .isFalse(value, [message])
	   *
	   * Asserts that `value` is false.
	   *
	   *     var teaServed = false;
	   *     assert.isFalse(teaServed, 'no tea yet? hmm...');
	   *
	   * @name isFalse
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isFalse = function (val, msg) {
	    new Assertion(val, msg).is['false'];
	  };

	  /**
	   * ### .isNull(value, [message])
	   *
	   * Asserts that `value` is null.
	   *
	   *     assert.isNull(err, 'there was no error');
	   *
	   * @name isNull
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isNull = function (val, msg) {
	    new Assertion(val, msg).to.equal(null);
	  };

	  /**
	   * ### .isNotNull(value, [message])
	   *
	   * Asserts that `value` is not null.
	   *
	   *     var tea = 'tasty chai';
	   *     assert.isNotNull(tea, 'great, time for tea!');
	   *
	   * @name isNotNull
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isNotNull = function (val, msg) {
	    new Assertion(val, msg).to.not.equal(null);
	  };

	  /**
	   * ### .isUndefined(value, [message])
	   *
	   * Asserts that `value` is `undefined`.
	   *
	   *     var tea;
	   *     assert.isUndefined(tea, 'no tea defined');
	   *
	   * @name isUndefined
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isUndefined = function (val, msg) {
	    new Assertion(val, msg).to.equal(undefined);
	  };

	  /**
	   * ### .isDefined(value, [message])
	   *
	   * Asserts that `value` is not `undefined`.
	   *
	   *     var tea = 'cup of chai';
	   *     assert.isDefined(tea, 'tea has been defined');
	   *
	   * @name isDefined
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isDefined = function (val, msg) {
	    new Assertion(val, msg).to.not.equal(undefined);
	  };

	  /**
	   * ### .isFunction(value, [message])
	   *
	   * Asserts that `value` is a function.
	   *
	   *     function serveTea() { return 'cup of tea'; };
	   *     assert.isFunction(serveTea, 'great, we can have tea now');
	   *
	   * @name isFunction
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isFunction = function (val, msg) {
	    new Assertion(val, msg).to.be.a('function');
	  };

	  /**
	   * ### .isNotFunction(value, [message])
	   *
	   * Asserts that `value` is _not_ a function.
	   *
	   *     var serveTea = [ 'heat', 'pour', 'sip' ];
	   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');
	   *
	   * @name isNotFunction
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isNotFunction = function (val, msg) {
	    new Assertion(val, msg).to.not.be.a('function');
	  };

	  /**
	   * ### .isObject(value, [message])
	   *
	   * Asserts that `value` is an object (as revealed by
	   * `Object.prototype.toString`).
	   *
	   *     var selection = { name: 'Chai', serve: 'with spices' };
	   *     assert.isObject(selection, 'tea selection is an object');
	   *
	   * @name isObject
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isObject = function (val, msg) {
	    new Assertion(val, msg).to.be.a('object');
	  };

	  /**
	   * ### .isNotObject(value, [message])
	   *
	   * Asserts that `value` is _not_ an object.
	   *
	   *     var selection = 'chai'
	   *     assert.isNotObject(selection, 'tea selection is not an object');
	   *     assert.isNotObject(null, 'null is not an object');
	   *
	   * @name isNotObject
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isNotObject = function (val, msg) {
	    new Assertion(val, msg).to.not.be.a('object');
	  };

	  /**
	   * ### .isArray(value, [message])
	   *
	   * Asserts that `value` is an array.
	   *
	   *     var menu = [ 'green', 'chai', 'oolong' ];
	   *     assert.isArray(menu, 'what kind of tea do we want?');
	   *
	   * @name isArray
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isArray = function (val, msg) {
	    new Assertion(val, msg).to.be.an('array');
	  };

	  /**
	   * ### .isNotArray(value, [message])
	   *
	   * Asserts that `value` is _not_ an array.
	   *
	   *     var menu = 'green|chai|oolong';
	   *     assert.isNotArray(menu, 'what kind of tea do we want?');
	   *
	   * @name isNotArray
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isNotArray = function (val, msg) {
	    new Assertion(val, msg).to.not.be.an('array');
	  };

	  /**
	   * ### .isString(value, [message])
	   *
	   * Asserts that `value` is a string.
	   *
	   *     var teaOrder = 'chai';
	   *     assert.isString(teaOrder, 'order placed');
	   *
	   * @name isString
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isString = function (val, msg) {
	    new Assertion(val, msg).to.be.a('string');
	  };

	  /**
	   * ### .isNotString(value, [message])
	   *
	   * Asserts that `value` is _not_ a string.
	   *
	   *     var teaOrder = 4;
	   *     assert.isNotString(teaOrder, 'order placed');
	   *
	   * @name isNotString
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isNotString = function (val, msg) {
	    new Assertion(val, msg).to.not.be.a('string');
	  };

	  /**
	   * ### .isNumber(value, [message])
	   *
	   * Asserts that `value` is a number.
	   *
	   *     var cups = 2;
	   *     assert.isNumber(cups, 'how many cups');
	   *
	   * @name isNumber
	   * @param {Number} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isNumber = function (val, msg) {
	    new Assertion(val, msg).to.be.a('number');
	  };

	  /**
	   * ### .isNotNumber(value, [message])
	   *
	   * Asserts that `value` is _not_ a number.
	   *
	   *     var cups = '2 cups please';
	   *     assert.isNotNumber(cups, 'how many cups');
	   *
	   * @name isNotNumber
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isNotNumber = function (val, msg) {
	    new Assertion(val, msg).to.not.be.a('number');
	  };

	  /**
	   * ### .isBoolean(value, [message])
	   *
	   * Asserts that `value` is a boolean.
	   *
	   *     var teaReady = true
	   *       , teaServed = false;
	   *
	   *     assert.isBoolean(teaReady, 'is the tea ready');
	   *     assert.isBoolean(teaServed, 'has tea been served');
	   *
	   * @name isBoolean
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isBoolean = function (val, msg) {
	    new Assertion(val, msg).to.be.a('boolean');
	  };

	  /**
	   * ### .isNotBoolean(value, [message])
	   *
	   * Asserts that `value` is _not_ a boolean.
	   *
	   *     var teaReady = 'yep'
	   *       , teaServed = 'nope';
	   *
	   *     assert.isNotBoolean(teaReady, 'is the tea ready');
	   *     assert.isNotBoolean(teaServed, 'has tea been served');
	   *
	   * @name isNotBoolean
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.isNotBoolean = function (val, msg) {
	    new Assertion(val, msg).to.not.be.a('boolean');
	  };

	  /**
	   * ### .typeOf(value, name, [message])
	   *
	   * Asserts that `value`'s type is `name`, as determined by
	   * `Object.prototype.toString`.
	   *
	   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');
	   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');
	   *     assert.typeOf('tea', 'string', 'we have a string');
	   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');
	   *     assert.typeOf(null, 'null', 'we have a null');
	   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');
	   *
	   * @name typeOf
	   * @param {Mixed} value
	   * @param {String} name
	   * @param {String} message
	   * @api public
	   */

	  assert.typeOf = function (val, type, msg) {
	    new Assertion(val, msg).to.be.a(type);
	  };

	  /**
	   * ### .notTypeOf(value, name, [message])
	   *
	   * Asserts that `value`'s type is _not_ `name`, as determined by
	   * `Object.prototype.toString`.
	   *
	   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');
	   *
	   * @name notTypeOf
	   * @param {Mixed} value
	   * @param {String} typeof name
	   * @param {String} message
	   * @api public
	   */

	  assert.notTypeOf = function (val, type, msg) {
	    new Assertion(val, msg).to.not.be.a(type);
	  };

	  /**
	   * ### .instanceOf(object, constructor, [message])
	   *
	   * Asserts that `value` is an instance of `constructor`.
	   *
	   *     var Tea = function (name) { this.name = name; }
	   *       , chai = new Tea('chai');
	   *
	   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');
	   *
	   * @name instanceOf
	   * @param {Object} object
	   * @param {Constructor} constructor
	   * @param {String} message
	   * @api public
	   */

	  assert.instanceOf = function (val, type, msg) {
	    new Assertion(val, msg).to.be.instanceOf(type);
	  };

	  /**
	   * ### .notInstanceOf(object, constructor, [message])
	   *
	   * Asserts `value` is not an instance of `constructor`.
	   *
	   *     var Tea = function (name) { this.name = name; }
	   *       , chai = new String('chai');
	   *
	   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');
	   *
	   * @name notInstanceOf
	   * @param {Object} object
	   * @param {Constructor} constructor
	   * @param {String} message
	   * @api public
	   */

	  assert.notInstanceOf = function (val, type, msg) {
	    new Assertion(val, msg).to.not.be.instanceOf(type);
	  };

	  /**
	   * ### .include(haystack, needle, [message])
	   *
	   * Asserts that `haystack` includes `needle`. Works
	   * for strings and arrays.
	   *
	   *     assert.include('foobar', 'bar', 'foobar contains string "bar"');
	   *     assert.include([ 1, 2, 3 ], 3, 'array contains value');
	   *
	   * @name include
	   * @param {Array|String} haystack
	   * @param {Mixed} needle
	   * @param {String} message
	   * @api public
	   */

	  assert.include = function (exp, inc, msg) {
	    new Assertion(exp, msg, assert.include).include(inc);
	  };

	  /**
	   * ### .notInclude(haystack, needle, [message])
	   *
	   * Asserts that `haystack` does not include `needle`. Works
	   * for strings and arrays.
	   *i
	   *     assert.notInclude('foobar', 'baz', 'string not include substring');
	   *     assert.notInclude([ 1, 2, 3 ], 4, 'array not include contain value');
	   *
	   * @name notInclude
	   * @param {Array|String} haystack
	   * @param {Mixed} needle
	   * @param {String} message
	   * @api public
	   */

	  assert.notInclude = function (exp, inc, msg) {
	    new Assertion(exp, msg, assert.notInclude).not.include(inc);
	  };

	  /**
	   * ### .match(value, regexp, [message])
	   *
	   * Asserts that `value` matches the regular expression `regexp`.
	   *
	   *     assert.match('foobar', /^foo/, 'regexp matches');
	   *
	   * @name match
	   * @param {Mixed} value
	   * @param {RegExp} regexp
	   * @param {String} message
	   * @api public
	   */

	  assert.match = function (exp, re, msg) {
	    new Assertion(exp, msg).to.match(re);
	  };

	  /**
	   * ### .notMatch(value, regexp, [message])
	   *
	   * Asserts that `value` does not match the regular expression `regexp`.
	   *
	   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');
	   *
	   * @name notMatch
	   * @param {Mixed} value
	   * @param {RegExp} regexp
	   * @param {String} message
	   * @api public
	   */

	  assert.notMatch = function (exp, re, msg) {
	    new Assertion(exp, msg).to.not.match(re);
	  };

	  /**
	   * ### .property(object, property, [message])
	   *
	   * Asserts that `object` has a property named by `property`.
	   *
	   *     assert.property({ tea: { green: 'matcha' }}, 'tea');
	   *
	   * @name property
	   * @param {Object} object
	   * @param {String} property
	   * @param {String} message
	   * @api public
	   */

	  assert.property = function (obj, prop, msg) {
	    new Assertion(obj, msg).to.have.property(prop);
	  };

	  /**
	   * ### .notProperty(object, property, [message])
	   *
	   * Asserts that `object` does _not_ have a property named by `property`.
	   *
	   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');
	   *
	   * @name notProperty
	   * @param {Object} object
	   * @param {String} property
	   * @param {String} message
	   * @api public
	   */

	  assert.notProperty = function (obj, prop, msg) {
	    new Assertion(obj, msg).to.not.have.property(prop);
	  };

	  /**
	   * ### .deepProperty(object, property, [message])
	   *
	   * Asserts that `object` has a property named by `property`, which can be a
	   * string using dot- and bracket-notation for deep reference.
	   *
	   *     assert.deepProperty({ tea: { green: 'matcha' }}, 'tea.green');
	   *
	   * @name deepProperty
	   * @param {Object} object
	   * @param {String} property
	   * @param {String} message
	   * @api public
	   */

	  assert.deepProperty = function (obj, prop, msg) {
	    new Assertion(obj, msg).to.have.deep.property(prop);
	  };

	  /**
	   * ### .notDeepProperty(object, property, [message])
	   *
	   * Asserts that `object` does _not_ have a property named by `property`, which
	   * can be a string using dot- and bracket-notation for deep reference.
	   *
	   *     assert.notDeepProperty({ tea: { green: 'matcha' }}, 'tea.oolong');
	   *
	   * @name notDeepProperty
	   * @param {Object} object
	   * @param {String} property
	   * @param {String} message
	   * @api public
	   */

	  assert.notDeepProperty = function (obj, prop, msg) {
	    new Assertion(obj, msg).to.not.have.deep.property(prop);
	  };

	  /**
	   * ### .propertyVal(object, property, value, [message])
	   *
	   * Asserts that `object` has a property named by `property` with value given
	   * by `value`.
	   *
	   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');
	   *
	   * @name propertyVal
	   * @param {Object} object
	   * @param {String} property
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.propertyVal = function (obj, prop, val, msg) {
	    new Assertion(obj, msg).to.have.property(prop, val);
	  };

	  /**
	   * ### .propertyNotVal(object, property, value, [message])
	   *
	   * Asserts that `object` has a property named by `property`, but with a value
	   * different from that given by `value`.
	   *
	   *     assert.propertyNotVal({ tea: 'is good' }, 'tea', 'is bad');
	   *
	   * @name propertyNotVal
	   * @param {Object} object
	   * @param {String} property
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.propertyNotVal = function (obj, prop, val, msg) {
	    new Assertion(obj, msg).to.not.have.property(prop, val);
	  };

	  /**
	   * ### .deepPropertyVal(object, property, value, [message])
	   *
	   * Asserts that `object` has a property named by `property` with value given
	   * by `value`. `property` can use dot- and bracket-notation for deep
	   * reference.
	   *
	   *     assert.deepPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');
	   *
	   * @name deepPropertyVal
	   * @param {Object} object
	   * @param {String} property
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.deepPropertyVal = function (obj, prop, val, msg) {
	    new Assertion(obj, msg).to.have.deep.property(prop, val);
	  };

	  /**
	   * ### .deepPropertyNotVal(object, property, value, [message])
	   *
	   * Asserts that `object` has a property named by `property`, but with a value
	   * different from that given by `value`. `property` can use dot- and
	   * bracket-notation for deep reference.
	   *
	   *     assert.deepPropertyNotVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');
	   *
	   * @name deepPropertyNotVal
	   * @param {Object} object
	   * @param {String} property
	   * @param {Mixed} value
	   * @param {String} message
	   * @api public
	   */

	  assert.deepPropertyNotVal = function (obj, prop, val, msg) {
	    new Assertion(obj, msg).to.not.have.deep.property(prop, val);
	  };

	  /**
	   * ### .lengthOf(object, length, [message])
	   *
	   * Asserts that `object` has a `length` property with the expected value.
	   *
	   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');
	   *     assert.lengthOf('foobar', 5, 'string has length of 6');
	   *
	   * @name lengthOf
	   * @param {Mixed} object
	   * @param {Number} length
	   * @param {String} message
	   * @api public
	   */

	  assert.lengthOf = function (exp, len, msg) {
	    new Assertion(exp, msg).to.have.length(len);
	  };

	  /**
	   * ### .throws(function, [constructor/string/regexp], [string/regexp], [message])
	   *
	   * Asserts that `function` will throw an error that is an instance of
	   * `constructor`, or alternately that it will throw an error with message
	   * matching `regexp`.
	   *
	   *     assert.throw(fn, 'function throws a reference error');
	   *     assert.throw(fn, /function throws a reference error/);
	   *     assert.throw(fn, ReferenceError);
	   *     assert.throw(fn, ReferenceError, 'function throws a reference error');
	   *     assert.throw(fn, ReferenceError, /function throws a reference error/);
	   *
	   * @name throws
	   * @alias throw
	   * @alias Throw
	   * @param {Function} function
	   * @param {ErrorConstructor} constructor
	   * @param {RegExp} regexp
	   * @param {String} message
	   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
	   * @api public
	   */

	  assert.Throw = function (fn, errt, errs, msg) {
	    if ('string' === typeof errt || errt instanceof RegExp) {
	      errs = errt;
	      errt = null;
	    }

	    var assertErr = new Assertion(fn, msg).to.Throw(errt, errs);
	    return flag(assertErr, 'object');
	  };

	  /**
	   * ### .doesNotThrow(function, [constructor/regexp], [message])
	   *
	   * Asserts that `function` will _not_ throw an error that is an instance of
	   * `constructor`, or alternately that it will not throw an error with message
	   * matching `regexp`.
	   *
	   *     assert.doesNotThrow(fn, Error, 'function does not throw');
	   *
	   * @name doesNotThrow
	   * @param {Function} function
	   * @param {ErrorConstructor} constructor
	   * @param {RegExp} regexp
	   * @param {String} message
	   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
	   * @api public
	   */

	  assert.doesNotThrow = function (fn, type, msg) {
	    if ('string' === typeof type) {
	      msg = type;
	      type = null;
	    }

	    new Assertion(fn, msg).to.not.Throw(type);
	  };

	  /**
	   * ### .operator(val1, operator, val2, [message])
	   *
	   * Compares two values using `operator`.
	   *
	   *     assert.operator(1, '<', 2, 'everything is ok');
	   *     assert.operator(1, '>', 2, 'this will fail');
	   *
	   * @name operator
	   * @param {Mixed} val1
	   * @param {String} operator
	   * @param {Mixed} val2
	   * @param {String} message
	   * @api public
	   */

	  assert.operator = function (val, operator, val2, msg) {
	    if (!~['==', '===', '>', '>=', '<', '<=', '!=', '!=='].indexOf(operator)) {
	      throw new Error('Invalid operator "' + operator + '"');
	    }
	    var test = new Assertion(eval(val + operator + val2), msg);
	    test.assert(
	        true === flag(test, 'object')
	      , 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2)
	      , 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2) );
	  };

	  /**
	   * ### .closeTo(actual, expected, delta, [message])
	   *
	   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
	   *
	   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');
	   *
	   * @name closeTo
	   * @param {Number} actual
	   * @param {Number} expected
	   * @param {Number} delta
	   * @param {String} message
	   * @api public
	   */

	  assert.closeTo = function (act, exp, delta, msg) {
	    new Assertion(act, msg).to.be.closeTo(exp, delta);
	  };

	  /**
	   * ### .sameMembers(set1, set2, [message])
	   *
	   * Asserts that `set1` and `set2` have the same members.
	   * Order is not taken into account.
	   *
	   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');
	   *
	   * @name sameMembers
	   * @param {Array} set1
	   * @param {Array} set2
	   * @param {String} message
	   * @api public
	   */

	  assert.sameMembers = function (set1, set2, msg) {
	    new Assertion(set1, msg).to.have.same.members(set2);
	  }

	  /**
	   * ### .includeMembers(superset, subset, [message])
	   *
	   * Asserts that `subset` is included in `superset`.
	   * Order is not taken into account.
	   *
	   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1 ], 'include members');
	   *
	   * @name includeMembers
	   * @param {Array} superset
	   * @param {Array} subset
	   * @param {String} message
	   * @api public
	   */

	  assert.includeMembers = function (superset, subset, msg) {
	    new Assertion(superset, msg).to.include.members(subset);
	  }

	  /*!
	   * Undocumented / untested
	   */

	  assert.ifError = function (val, msg) {
	    new Assertion(val, msg).to.not.be.ok;
	  };

	  /*!
	   * Aliases.
	   */

	  (function alias(name, as){
	    assert[as] = assert[name];
	    return alias;
	  })
	  ('Throw', 'throw')
	  ('Throw', 'throws');
	};


/***/ },
/* 357 */
/*!************************************!*\
  !*** ./~/node-helpers/config.json ***!
  \************************************/
/***/ function(module, exports) {

	module.exports = {
		"testPropName": "testPropVal",
		"testEnvPriority": "defaultVal",
		"testDefaultPriority": "defaultVal",
		"testPackageJsonPriority": "defaultVal"
	};

/***/ },
/* 358 */
/*!*****************************************!*\
  !*** ./~/node-helpers/index.browser.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports.lazyExtensions = __webpack_require__(/*! ./lazy-extensions */ 173);
	module.exports.utils = __webpack_require__(/*! ./utils */ 131);
	module.exports.Environment = __webpack_require__(/*! ./environment */ 177);
	module.exports.bunyanStreams = __webpack_require__(/*! ./bunyan-streams */ 178);
	module.exports.gsapDefaults = __webpack_require__(/*! ./gsap-defaults */ 315);
	module.exports.BRequest = __webpack_require__(/*! ./BRequest */ 319);
	module.exports.LogProvider = __webpack_require__(/*! ./log-provider */ 359);


/***/ },
/* 359 */
/*!****************************************!*\
  !*** ./~/node-helpers/log-provider.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';


	//---------//
	// Imports //
	//---------//

	var bunyan = __webpack_require__(/*! bunyan */ 179)
	  , bunyanStreams = __webpack_require__(/*! ./bunyan-streams */ 178)
	  , Environment = __webpack_require__(/*! ./environment */ 177)
	  , Utils = __webpack_require__(/*! ./utils */ 131)
	  ;


	//------//
	// Main //
	//------//

	function LogProvider() {
	  var self = this;

	  var my = {
	    EnvInst: null
	    , AppName: null
	    , AllowDefaultEnvInst: true
	    , AllowDefaultAppName: true
	    , DefaultEnvInst: new Environment()
	    , DefaultAppName: 'weather-accuracy'
	  };

	  self.EnvInst = function(envinst_) {
	    var res = my.EnvInst;
	    if (arguments.length > 0) {
	      if (envinst_ !== null) {
	        LogProvider.ValidateEnvInst(envinst_, true);
	      }
	      my.EnvInst = envinst_;
	      res = self;
	    } else if (self.AllowDefaultEnvInst()) {
	      res = res || my.DefaultEnvInst;
	    }
	    return res;
	  };

	  self.AppName = function(appname_) {
	    var res = my.AppName;
	    if (arguments.length > 0) {
	      if (appname_ !== null) {
	        LogProvider.ValidateAppName(appname_, true);
	      }
	      my.AppName = appname_;
	      res = self;
	    } else if (self.AllowDefaultEnvInst()) {
	      res = res || my.DefaultAppName;
	    }
	    return res;
	  };

	  self.AllowDefaultEnvInst = function(allowdefaultenvinst_) {
	    var res = my.AllowDefaultEnvInst;
	    if (arguments.length > 0) {
	      if (allowdefaultenvinst_ !== null) {
	        LogProvider.ValidateAllowDefaultEnvInst(allowdefaultenvinst_, true);
	      }
	      my.AllowDefaultEnvInst = allowdefaultenvinst_;
	      res = self;
	    }
	    return res;
	  };

	  self.AllowDefaultAppName = function(allowdefaultappname_) {
	    var res = my.AllowDefaultAppName;
	    if (arguments.length > 0) {
	      if (allowdefaultappname_ !== null) {
	        LogProvider.ValidateAllowDefaultAppName(allowdefaultappname_, true);
	      }
	      my.AllowDefaultAppName = allowdefaultappname_;
	      res = self;
	    }
	    return res;
	  };
	}


	//------------//
	// Validation //
	//------------//

	LogProvider.ValidateEnvInst = function ValidateEnvInst(input, throwErr) {
	  var msg = '';
	  if (!Utils.instance_of(input, Environment)) {
	    msg = 'Invalid Argument: <LogProvider>.ValidateEnvInst requires an instance_of Environment argument';
	  }

	  if (throwErr && msg) {
	    throw new Error(msg);
	  }

	  return msg;
	};

	LogProvider.ValidateAppName = function ValidateAppName(input, throwErr) {
	  var msg = '';
	  if (typeof input !== 'string') {
	    msg = 'Invalid Argument: <LogProvider>.ValidateAppName requires a typeof string argument';
	  }

	  if (throwErr && msg) {
	    throw new Error(msg);
	  }

	  return msg;
	};

	LogProvider.ValidateAllowDefaultEnvInst = function ValidateAllowDefaultEnvInst(input, throwErr) {
	  var msg = '';
	  if (typeof input !== 'boolean') {
	    msg = 'Invalid Argument: <LogProvider>.ValidateDefaultEnvInst requires a typeof boolean argument';
	  }

	  if (throwErr && msg) {
	    throw new Error(msg);
	  }

	  return msg;
	};

	LogProvider.ValidateAllowDefaultAppName = function ValidateAllowDefaultAppName(input, throwErr) {
	  var msg = '';
	  if (typeof input !== 'boolean') {
	    msg = 'Invalid Argument: <LogProvider>.ValidateDefaultAppName requires a typeof boolean argument';
	  }

	  if (throwErr && msg) {
	    throw new Error(msg);
	  }

	  return msg;
	};


	//-----------------------//
	// Prototyped Extensions //
	//-----------------------//

	LogProvider.prototype.getLogger = function getLogger() {
	  if (this.EnvInst() === null || this.AppName() === null) {
	    throw new Error("Invalid State: <LogProvider>.getLogger requires both EnvInst and AppName to either be set or allowed to use their defaults");
	  }

	  var bstream = bunyanStreams(this.AppName(), this.EnvInst().curEnv());
	  return bunyan.createLogger({
	    name: this.AppName()
	    , src: bstream.source
	    , streams: [{
	      level: bstream.level
	      , stream: bstream.stream
	      , type: bstream.type
	    }]
	  });
	};


	//---------//
	// Exports //
	//---------//

	module.exports = LogProvider;


/***/ },
/* 360 */
/*!*************************************************!*\
  !*** ./~/node-helpers/lazy-extensions-tests.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/* --execute=mocha-- */

	var Lazy = __webpack_require__(/*! ./lazy-extensions */ 173)
	    , chai = __webpack_require__(/*! chai */ 325);

	var assert = chai.assert;
	chai.config.includeStack = true;

	suite("lazy-extensions.js", function() {
	    var vals
	        , valsConst
	        , objs
	        , objsConst
	        , objLit
	        , objLitConst;

	    function TestObj(name, val) {
	        this.name = name;
	        this.val = val;
	    }
	    TestObj.prototype.equals = function equals(other) {
	        return this.name === other.name
	            && this.val === other.val;
	    };
	    TestObj.equals = function equals(left, right) {
	        return left.equals(right);
	    };

	    function getNewObjs() {
	        return [new TestObj('name1', 'val1')
	            , new TestObj('name2', 'val2')
	            , new TestObj('name3', 'val3')
	            , new TestObj('name4', 'val4')
	            , new TestObj('name5', 'val5')
	        ];
	    }

	    function getNewVals() {
	        return [1, 2, 3, 4, 5];
	    }

	    function getNewObjLit() {
	        return {
	            'akey': 'aval'
	            , 'bkey': 'bval'
	            , 'ckey': 'cval'
	        };
	    }

	    setup(function() {
	        vals = Lazy(getNewVals());
	        valsConst = Lazy(getNewVals());

	        objs = Lazy(getNewObjs());
	        objsConst = Lazy(getNewObjs());

	        objLit = Lazy(getNewObjLit());
	        objLitConst = Lazy(getNewObjLit());
	    });
	    test("Sequence.indexOf", function Sequence_indexOf() {
	        assert.strictEqual(vals.indexOf(1), 0);
	        assert.strictEqual(vals.indexOf(3), 2);

	        assert.strictEqual(objs.indexOf(objsConst.get(0), TestObj.equals), 0);
	        assert.strictEqual(objs.indexOf(objsConst.get(0), 'equals'), 0);
	        assert.strictEqual(objs.indexOf(objsConst.get(3), TestObj.equals), 3);
	        assert.strictEqual(objs.indexOf(objsConst.get(3), 'equals'), 3);
	    });

	    test("Sequence.rotate", function Sequence_rotate() {
	        vals = vals.rotate(1);
	        assert.strictEqual(vals.first(), valsConst.last());

	        // reset vals
	        vals = Lazy(getNewVals());
	        vals = vals.rotate(2);
	        assert.strictEqual(vals.first(), valsConst.get(3));

	        vals = Lazy(getNewVals());
	        vals = vals.rotate(-2);
	        assert.strictEqual(vals.first(), valsConst.get(2));

	        // now test for objects
	    });

	    test("Sequence.rotateTo", function Sequence_roateTo() {
	        vals = vals.rotateTo(3);
	        assert.strictEqual(vals.first(), valsConst.get(2));

	        vals = Lazy(getNewVals());
	        vals = vals.rotateTo(4);
	        assert.strictEqual(vals.first(), valsConst.get(3));

	        objs = objs.rotateTo(new TestObj('name4', 'val4'), TestObj.equals);
	        assert.isTrue(objs.first().equals(objsConst.get(3)));
	        objs = Lazy(getNewObjs()).rotateTo(new TestObj('name4', 'val4'), 'equals');
	        assert.isTrue(objs.first().equals(objsConst.get(3)));
	    });

	    test("Sequence.allTypeOf", function Sequence_allTypeOf() {
	        assert.isTrue(vals.allTypeOf('number'));
	        assert.isTrue(objs.allTypeOf('object'));
	        vals = vals.concat(['a']);
	        objs = objs.concat([1]);
	        assert.isFalse(vals.allTypeOf('number'));
	        assert.isFalse(objs.allTypeOf('object'));
	    });

	    test("Sequence.allInstanceOf", function Sequence_allInstanceOf() {
	        assert.isTrue(objs.allInstanceOf(TestObj));
	        objs = objs.concat([1]);
	        assert.isFalse(objs.allInstanceOf(TestObj));
	    });

	    test("Sequence.equals", function Sequence_equals() {
	        assert.isTrue(vals.equals(valsConst));
	        var vals2 = Lazy(getNewVals()).concat([6]);
	        assert.isFalse(vals.equals(vals2));
	        assert.isFalse(objs.equals(objsConst));
	        assert.isTrue(objs.equals(objsConst, 'equals'));
	        assert.isTrue(objs.equals(objsConst, TestObj.equals));
	    });

	    test("Sequence.mustFind", function Sequence_mustFind() {
	        assert.strictEqual(vals.mustFind(function(aVal) {
	            return aVal === 1;
	        }), valsConst.toArray()[0]);

	        assert.throws(function() {
	            vals.mustFind(function(aVal) {
	                return aVal === 10;
	            })
	        });
	    });

	    test("ObjectLikeSequence.keys", function ObjectLikeSequence_keys() {
	        assert.isTrue(objLit.keys().equals(objLitConst.keys()));
	        objLit = objLit.assign({
	            'dkey': 'dval'
	        });
	        assert.isFalse(objLit.keys().equals(objLitConst.keys()));
	    });

	    test("ObjectLikeSequence.values", function ObjectLikeSequence_keys() {
	        assert.isTrue(objLit.values().equals(objLitConst.values()));
	        objLit = objLit.assign({
	            'dkey': 'dval'
	        });
	        assert.isFalse(objLit.values().equals(objLitConst.values()));
	    });

	    test("KeySequence.toArray", function KeySequence_toArray() {
	        var keyArray = objLitConst.keys().toArray();
	        var expectedKeyArray = Object.keys(getNewObjLit());

	        assert.strictEqual(keyArray[0], expectedKeyArray[0]);
	        assert.strictEqual(keyArray[2], expectedKeyArray[2]);
	    });

	    test("KeySequence.each", function KeySequence_each() {
	        var keyArray = objLitConst.keys().toArray();
	        var i = 0;
	        objLit.keys().each(function(k) {
	            assert.strictEqual(k, keyArray[i]);
	            i += 1;
	        });
	    });

	    test("KeyIterator.current && moveNext", function KeyIterator_current_moveNext() {
	        var keyArray = objLitConst.keys().toArray();
	        var kit = objLit.keys().getIterator();
	        var i = 0;
	        while (kit.moveNext()) {
	            assert.strictEqual(kit.current(), keyArray[i]);
	            i += 1;
	        }
	    });

	    test("ValueSequence.toArray", function ValueSequence_toArray() {
	        var valArray = objLitConst.values().toArray();
	        var tmpObj = getNewObjLit();
	        var expectedValArray = Object.keys(tmpObj).reduce(function(aggr, k) {
	            aggr.push(tmpObj[k])
	            return aggr;
	        }, []);

	        assert.strictEqual(valArray[0], expectedValArray[0]);
	        assert.strictEqual(valArray[2], expectedValArray[2]);
	    });

	    test("ValueSequence.each", function KeySequence_each() {
	        var valArray = objLitConst.values().toArray();
	        var i = 0;
	        objLit.values().each(function(v) {
	            assert.strictEqual(v, valArray[i]);
	            i += 1;
	        });
	    });

	    test("ValueIterator.current && moveNext", function KeyIterator_current_moveNext() {
	        var valArray = objLitConst.values().toArray();
	        var vit = objLit.values().getIterator();
	        var i = 0;
	        while (vit.moveNext()) {
	            assert.strictEqual(vit.current(), valArray[i]);
	            i += 1;
	        }
	    });
	});


/***/ },
/* 361 */
/*!*************************************!*\
  !*** ./~/node-helpers/package.json ***!
  \*************************************/
/***/ function(module, exports) {

	module.exports = {
		"_args": [
			[
				{
					"raw": "node-helpers@github:olsonpm/node-helpers#weather_accuracy",
					"scope": null,
					"escapedName": "node-helpers",
					"name": "node-helpers",
					"rawSpec": "github:olsonpm/node-helpers#weather_accuracy",
					"spec": "github:olsonpm/node-helpers#weather_accuracy",
					"type": "hosted",
					"hosted": {
						"type": "github",
						"ssh": "git@github.com:olsonpm/node-helpers.git#weather_accuracy",
						"sshUrl": "git+ssh://git@github.com/olsonpm/node-helpers.git#weather_accuracy",
						"httpsUrl": "git+https://github.com/olsonpm/node-helpers.git#weather_accuracy",
						"gitUrl": "git://github.com/olsonpm/node-helpers.git#weather_accuracy",
						"shortcut": "github:olsonpm/node-helpers#weather_accuracy",
						"directUrl": "https://raw.githubusercontent.com/olsonpm/node-helpers/weather_accuracy/package.json"
					}
				},
				"/home/phil/git-repos/personal/weather-accuracy"
			]
		],
		"_from": "olsonpm/node-helpers#weather_accuracy",
		"_id": "node-helpers@1.0.0",
		"_inCache": true,
		"_location": "/node-helpers",
		"_phantomChildren": {
			"assertion-error": "1.0.0",
			"deep-eql": "0.1.3"
		},
		"_requested": {
			"raw": "node-helpers@github:olsonpm/node-helpers#weather_accuracy",
			"scope": null,
			"escapedName": "node-helpers",
			"name": "node-helpers",
			"rawSpec": "github:olsonpm/node-helpers#weather_accuracy",
			"spec": "github:olsonpm/node-helpers#weather_accuracy",
			"type": "hosted",
			"hosted": {
				"type": "github",
				"ssh": "git@github.com:olsonpm/node-helpers.git#weather_accuracy",
				"sshUrl": "git+ssh://git@github.com/olsonpm/node-helpers.git#weather_accuracy",
				"httpsUrl": "git+https://github.com/olsonpm/node-helpers.git#weather_accuracy",
				"gitUrl": "git://github.com/olsonpm/node-helpers.git#weather_accuracy",
				"shortcut": "github:olsonpm/node-helpers#weather_accuracy",
				"directUrl": "https://raw.githubusercontent.com/olsonpm/node-helpers/weather_accuracy/package.json"
			}
		},
		"_requiredBy": [
			"/"
		],
		"_resolved": "git://github.com/olsonpm/node-helpers.git#60d8271056c40ac6e9fa6e3dd7d7883e7cb95d2e",
		"_shasum": "6085f7691c0b11b6003fc41f02f69c6676e94e50",
		"_shrinkwrap": null,
		"_spec": "node-helpers@github:olsonpm/node-helpers#weather_accuracy",
		"_where": "/home/phil/git-repos/personal/weather-accuracy",
		"author": {
			"name": "Phil Olson",
			"email": "philip.olson@protonmail.ch",
			"url": "https://github.com/olsonpm"
		},
		"browser": "index.browser.js",
		"dependencies": {
			"bluebird": "^2.9.3",
			"bunyan": "^1.3.3",
			"chai": "^1.10.0",
			"component-xor": "0.0.3",
			"fs-bluebird": "^0.1.2",
			"lazy.js": "^0.4.0",
			"mocha": "^2.1.0",
			"moment": "^2.9.0",
			"pg": "^6",
			"string": "^3.1.1"
		},
		"devDependencies": {},
		"gitHead": "60d8271056c40ac6e9fa6e3dd7d7883e7cb95d2e",
		"license": "ISC",
		"main": "index.js",
		"name": "node-helpers",
		"optionalDependencies": {},
		"readme": "ERROR: No README data found!",
		"scripts": {
			"test": "echo \"Error: no test specified\" && exit 1"
		},
		"testConfig": {
			"testPropName": "testPropVal",
			"testPackageJsonPriority": "packageJsonVal"
		},
		"version": "1.0.0"
	};

/***/ },
/* 362 */,
/* 363 */
/*!**********************************************!*\
  !*** ./~/node-helpers/psql-wrapper-tests.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	/* --execute=mocha-- */

	var PGWrapper = __webpack_require__(/*! ./psql-wrapper */ 92).PGWrapper
	    , commonPgConfs = __webpack_require__(/*! ./common-pgconfs */ 91)
	    , assert = __webpack_require__(/*! chai */ 325).assert;

	suite("psql-wrapper.js", function() {
	    var constUser1
	        , constUserAddress1;

	    var pg = new PGWrapper(commonPgConfs.test);

	    function Test_user(id_, name_, what_) {
	        this.id = Number(id_);
	        this.name = name_;
	        this.what = what_;
	    }
	    Test_user.prototype.equals = function(other_) {
	        return this.id === other_.id
	            && this.name === other_.name
	            && this.what === other_.what;
	    };
	    Test_user.UserFromRow = function UserFromRow(pgRow_) {
	        return new Test_user(
	            pgRow_.test_user_id
	            , pgRow_.test_user_name
	            , pgRow_.what
	        );
	    };

	    function Test_user_address(id_, info_, uid_, what_) {
	        this.id = Number(id_);
	        this.info = info_;
	        this.uid = Number(uid_);
	        this.what = what_;
	    }
	    Test_user_address.prototype.equals = function(other_) {
	        return this.id === other_.id
	            && this.info === other_.info
	            && this.uid === other_.uid
	            && this.what === other_.what;
	    };
	    Test_user_address.UserAddressFromRow = function UserAddressFromRow(pgRow_) {
	        return new Test_user_address(
	            pgRow_.test_user_address_id
	            , pgRow_.address_info
	            , pgRow_.test_user_id
	            , pgRow_.address_what
	        );
	    };

	    setup(function() {
	        constUser1 = new Test_user(1, 'my user1', 'ok');
	        constUserAddress1 = new Test_user_address(1, 'my address', 1, 'address ok');
	    });
	    test("run_parameterized_query", function run_parameterized_query() {
	        var queryText = "\
					select * \
					from test_user \
				";
	        var p1 = pg.RunParameterizedQuery(queryText)
	            .then(function(result) {
	                var userOut = Test_user.UserFromRow(result.rows[0]);
	                assert.isTrue(userOut.equals(constUser1));
	            });

	        queryText = "\
	                select * \
	                from test_user tu \
						join test_user_address tua \
							on tu.test_user_id = tua.test_user_id \
	                where tu.test_user_id = 1 \
	                ";

	        var p2 = pg.RunParameterizedQuery(queryText)
	            .then(function(result) {
	                var userOut = Test_user.UserFromRow(result.rows[0]);
	                var userAddressOut = Test_user_address.UserAddressFromRow(result.rows[0]);
	                assert.isTrue(userOut.equals(constUser1));
	                assert.isTrue(userAddressOut.equals(constUserAddress1));
	            });

	        return p1 && p2;
	    });
	});


/***/ },
/* 364 */
/*!***************************************!*\
  !*** ./~/node-helpers/utils-tests.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/* --execute=mocha-- */

	var Utils = __webpack_require__(/*! ./utils */ 131)
	    , chai = __webpack_require__(/*! chai */ 325);

	var assert = chai.assert;
	chai.config.includeStack = true;

	suite("utils.js", function() {
	    test("instance_of", function instance_of() {
	        var aGrandparent
	            , aParent
	            , aChild;
	        var wParent
	            , wChild;

	        function Grandparent() {}

	        function Parent() {}

	        function Child() {}

	        function WildParent() {}

	        function WildChild() {}

	        Parent.prototype = new Grandparent();
	        Parent.prototype.constructor = Parent;
	        WildParent.prototype = new Grandparent();
	        WildParent.prototype.constructor = WildParent;

	        Child.prototype = new Parent();
	        Child.prototype.constructor = Child;
	        WildChild.prototype = new WildParent();
	        WildChild.prototype.constructor = WildChild;

	        aGrandparent = new Grandparent();
	        aParent = new Parent();
	        wParent = new WildParent();
	        aChild = new Child();
	        wChild = new WildChild();

	        assert.isTrue(Utils.instance_of(aGrandparent, Grandparent));
	        assert.isFalse(Utils.instance_of(aGrandparent, Parent));

	        assert.isTrue(Utils.instance_of(aParent, Grandparent));
	        assert.isTrue(Utils.instance_of(aParent, Parent));
	        assert.isFalse(Utils.instance_of(aParent, Child));
	        assert.isFalse(Utils.instance_of(aParent, WildParent));

	        assert.isTrue(Utils.instance_of(aChild, Grandparent));
	        assert.isTrue(Utils.instance_of(aChild, Parent));
	        assert.isTrue(Utils.instance_of(aChild, Child));
	        assert.isFalse(Utils.instance_of(aChild, WildParent));

	        assert.isTrue(Utils.instance_of(wChild, Grandparent));
	        assert.isTrue(Utils.instance_of(wChild, WildParent));
	        assert.isTrue(Utils.instance_of(wChild, WildChild));
	        assert.isFalse(Utils.instance_of(wChild, Parent));
	    });

	    test("is_numeric", function is_numeric() {
	        assert.isTrue(Utils.isNumeric(1));
	        assert.isTrue(Utils.isNumeric("1"));
	        assert.isFalse(Utils.isNumeric(Infinity));
	    });

	    test("repeat_string", function repeat_string() {
	        assert.strictEqual(Utils.repeatString("a", 0), "");
	        assert.strictEqual(Utils.repeatString("a", 1), "a");
	        assert.strictEqual(Utils.repeatString("a", 5), "aaaaa");
	        assert.throws(function() {
	            Utils.repeatString(1, "ok");
	        })
	    });

	    test("every_combination_of", function every_combination_of() {
	        var a = [1, 2, 3]
	            , b = ['a', 'b', 'c']
	            , c = ['x', 'y', 'z'];

	        var expected = [
	            [1, 'a', 'x'],
	            [1, 'a', 'y'],
	            [1, 'a', 'z'],
	            [1, 'b', 'x'],
	            [1, 'b', 'y'],
	            [1, 'b', 'z'],
	            [1, 'c', 'x'],
	            [1, 'c', 'y'],
	            [1, 'c', 'z'],
	            [2, 'a', 'x'],
	            [2, 'a', 'y'],
	            [2, 'a', 'z'],
	            [2, 'b', 'x'],
	            [2, 'b', 'y'],
	            [2, 'b', 'z'],
	            [2, 'c', 'x'],
	            [2, 'c', 'y'],
	            [2, 'c', 'z'],
	            [3, 'a', 'x'],
	            [3, 'a', 'y'],
	            [3, 'a', 'z'],
	            [3, 'b', 'x'],
	            [3, 'b', 'y'],
	            [3, 'b', 'z'],
	            [3, 'c', 'x'],
	            [3, 'c', 'y'],
	            [3, 'c', 'z'],
	        ];

	        var actual = Utils.everyCombinationOf(a, b, c);
	        assert.strictEqual(actual.length, expected.length);
	        console.log(actual);
	        expected.forEach(function(aVal, i) {
	            switch (i % 3) {
	                case 0:
	                    assert.strictEqual(aVal[2], 'x');
	                    break;
	                case 1:
	                    assert.strictEqual(aVal[2], 'y');
	                    break;
	                case 2:
	                    assert.strictEqual(aVal[2], 'z');
	                    break;
	            }
	            switch (Math.floor(i / 3) % 3) {
	                case 0:
	                    assert.strictEqual(aVal[1], 'a');
	                    break;
	                case 1:
	                    assert.strictEqual(aVal[1], 'b');
	                    break;
	                case 2:
	                    assert.strictEqual(aVal[1], 'c');
	                    break;
	            }
	            switch (Math.floor(i / 9)) {
	                case 0:
	                    assert.strictEqual(aVal[0], 1);
	                    break;
	                case 1:
	                    assert.strictEqual(aVal[0], 2);
	                    break;
	                case 2:
	                    assert.strictEqual(aVal[0], 3);
	                    break;
	            }
	        });
	    });
	});


/***/ },
/* 365 */
/*!*************************************!*\
  !*** ./db/models/dal/data-point.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	//---------//
	// Imports //
	//---------//

	var DataPoint = __webpack_require__(/*! ../extensions/data-point */ 366)
	    , YMD = __webpack_require__(/*! ../extensions/ymd */ 378)
	    , DALData = __webpack_require__(/*! ./data */ 382)
	    , DALMeasurementName = __webpack_require__(/*! ./measurement-name */ 387)
	    , bPromise = __webpack_require__(/*! bluebird */ 93)
	    , moment = __webpack_require__(/*! moment */ 209)
	    , nh = __webpack_require__(/*! node-helpers */ 90);


	//------//
	// Init //
	//------//

	var PGWrapper = nh.psqlWrapper.PGWrapper
	    , Utils = nh.utils
	    , lazy = nh.lazyExtensions;


	//-------//
	// Main	 //
	//-------//

	function DALDataPoint(aPGWrapper) {
	    if (!Utils.instance_of(aPGWrapper, PGWrapper)) {
	        throw new Error("Invalid Argument: DALDataPoint constructor expects an instance_of PGWrapper");
	    }
	    this.pgWrapperInstance = aPGWrapper;
	    this.dalDataInstance = new DALData(aPGWrapper);
	    this.dalMeasurementNameInstance = new DALMeasurementName(aPGWrapper);
	}


	//-------------------//
	// Static Extensions //
	//-------------------//

	DALDataPoint.getDataPointFromRow = function getDataPointFromRow(row) {
	    return new DataPoint()
	        .DataPointID(row.weather_data_point_id)
	        .Data(DALData.getDataFromRow(row))
	        .Value(row.weather_data_point_value)
	        .MeasurementName(DALMeasurementName.getMeasurementNameFromRow(row));
	};


	//-----------------------//
	// Prototyped Extensions //
	//-----------------------//

	DALDataPoint.prototype.getDataPointFromID = function getDataPointFromID(aDataPointID) {
	    if (typeof aDataPointID !== 'string') {
	        throw new Error("Invalid Argument: <DALDataPoint>.getDataPointFromID requires a typeof string argument");
	    }

	    var queryText = "\
			select * \
			from weather_data_point wdp \
				join weather_data wd \
					on wdp.weather_data_point_data_id = wd.weather_data_id \
				join weather_data_point_name wdn \
					on wdp.weather_data_point_name_id = wdn.weather_data_point_name_id \
				\
				/* the following joins are weather_data dependencies */ \
				join weather_data_type wdt \
					on wd.weather_data_type_id = wdt.weather_data_type_id \
				join weather_source ws \
					on wd.weather_data_source_id = ws.weather_source_id \
				join weather_date wda \
					on wd.weather_data_date_id = wda.weather_date_id \
				join weather_location wl \
					on wd.weather_data_location_id = wl.weather_location_id \
				\
				/* the following joins are weather_data_point_name dependencies */ \
				join weather_data_point_unit wdu \
					on wdn.weather_data_point_name_unit_id = wdu.weather_data_point_unit_id \
				\
			where wdp.weather_data_point_id = $1 \
		";

	    var queryValues = [
	        aDataPointID
	    ];

	    return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	        .then(function(res) {
	            return DALDataPoint.getDataPointFromRow(res.rows[0]);
	        });
	};

	DALDataPoint.prototype.getDataPointsBetweenDates = function getDataPointsBetweenDates(date1, date2) {
	    if (Utils.instance_of(date1, Date)) {
	        date1 = moment(date1).format('YYYYMMDD');
	    }
	    if (Utils.instance_of(date2, Date)) {
	        date2 = moment(date2).format('YYYYMMDD');
	    }

	    if (YMD.ValidateValue(date1) || YMD.ValidateValue(date2)) {
	        throw new Error("Invalid Argument: <DALDataPoint>.getDataPointsBetweenDates requires two arguments that are either typeof string in the format (YYYYMMDD) or instance_of date");
	    }

	    var queryText = "\
			select * \
			from weather_data_point wdp \
				join weather_data wd \
					on wdp.weather_data_point_data_id = wd.weather_data_id \
				join weather_data_point_name wdn \
					on wdp.weather_data_point_name_id = wdn.weather_data_point_name_id \
				\
				/* the following joins are weather_data dependencies */ \
				join weather_data_type wdt \
					on wd.weather_data_type_id = wdt.weather_data_type_id \
				join weather_source ws \
					on wd.weather_data_source_id = ws.weather_source_id \
				join weather_date wda \
					on wd.weather_data_date_id = wda.weather_date_id \
				join weather_location wl \
					on wd.weather_data_location_id = wl.weather_location_id \
				\
				/* the following joins are weather_data_point_name dependencies */ \
				join weather_data_point_unit wdu \
					on wdn.weather_data_point_name_unit_id = wdu.weather_data_point_unit_id \
				\
			where wda.weather_date_value between $1 and $2 \
		";

	    var queryValues = [
	        date1
	        , date2
	    ];

	    return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	        .then(function(res) {
	            return lazy(res.rows)
	                .map(function(row) {
	                    return DALDataPoint.getDataPointFromRow(row);
	                });
	        });
	};

	DALDataPoint.prototype.insert = function insert(aDataPoint) {
	    var self = this;

	    if (!Utils.instance_of(aDataPoint, DataPoint)) {
	        throw new Error("Invalid Argument: <DALDataPoint>.insert requires instance_of DataPoint");
	    }

	    var bInsertedData
	        , bInsertedMeasurementName;

	    bInsertedData = (aDataPoint.Data().DataID() === null)
	        ? self.dalDataInstance.insert(aDataPoint.Data())
	        : bPromise.resolve(aDataPoint.Data());

	    bInsertedMeasurementName = (aDataPoint.MeasurementName().MeasurementNameID() === null)
	        ? self.dalMeasurementNameInstance.insert(aDataPoint.MeasurementName())
	        : bPromise.resolve(aDataPoint.MeasurementName());

	    return bPromise.resolve([
	            bInsertedData
	            , bInsertedMeasurementName
	            , aDataPoint
	        ])
	        .spread(function(resData, resMeasurementName, resDataPoint) {
	            resDataPoint.Data(resData)
	                .MeasurementName(resMeasurementName);

	            var queryText = "\
					insert into weather_data_point (weather_data_point_data_id, weather_data_point_value, weather_data_point_name_id) \
					values ($1, $2, $3) \
					returning weather_data_point_id \
				";

	            var queryValues = [
	                resData.DataID()
	                , resDataPoint.Value()
	                , resMeasurementName.MeasurementNameID()
	            ];

	            return [
	                self.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	                , resDataPoint
	            ];
	        })
	        .spread(function(resInsert, resDataPoint) {
	            return resDataPoint.DataPointID(resInsert.rows[0].weather_data_point_id);
	        });
	};

	DALDataPoint.prototype.deleteByID = function deleteByID(aDataPointID) {
	    if (typeof aDataPointID !== 'string') {
	        throw new Error("Invalid Argument: <DALDataPoint>.deleteByID requires a typeof string argument");
	    }

	    var queryText = "\
			delete from weather_data_point \
			where weather_data_point_id = $1 \
		";

	    var queryValues = [
	        aDataPointID
	    ];

	    return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	        .then(function(res) {
	            if (res.rowCount !== 1) {
	                throw new Error("Invalid Argument: <DALDataPoint>.deleteByID expected to delete a single record.  Instead '" + res.rowCount + "' were deleted");
	            }
	        });
	};


	//---------//
	// Exports //
	//---------//

	module.exports = DALDataPoint;


/***/ },
/* 366 */
/*!********************************************!*\
  !*** ./db/models/extensions/data-point.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';


	//---------//
	// Imports //
	//---------//

	var nh = __webpack_require__(/*! node-helpers */ 90)
	    , DataPoint = __webpack_require__(/*! ../data-point */ 367)
	    , Data = __webpack_require__(/*! ./data */ 375)
	    , MeasurementName = __webpack_require__(/*! ./measurement-name */ 380);


	//------//
	// Init //
	//------//

	var Utils = nh.utils
	    , lazy = nh.lazyExtensions;


	//-------------------//
	// Static Extensions //
	//-------------------//

	DataPoint.ValidateConvertedValue = function ValidateConvertedValue(input, throwErr) {
	    var msg = '';
	    if (typeof input !== 'string') {
	        msg = 'Invalid Argument: <DataPoint>.ValidateConvertedValue requires a typeof string argument';
	    }

	    if (throwErr && msg) {
	        throw new Error(msg);
	    }

	    return msg;
	};

	DataPoint.ValidateConvertedUnit = function ValidateConvertedUnit(input, throwErr) {
	    var msg = '';
	    if (typeof input !== 'string') {
	        msg = 'Invalid Argument: <DataPoint>.ValidateConvertedUnit requires a typeof string argument';
	    }

	    if (throwErr && msg) {
	        throw new Error(msg);
	    }

	    return msg;
	};

	DataPoint.deserialize = function deserialize(jsonData, my) {
	    var self = this;

	    if (!Utils.instance_of(jsonData, Object)) {
	        throw new Error("Invalid Argument: the DataPoint constructor requires jsonData to be an instance_of Object");
	    }

	    var allKeysMatch = lazy(Object.keys(jsonData))
	        .every(function(aKey) {
	            return Utils.in_array(aKey, Object.keys(my));
	        });

	    if (!allKeysMatch) {
	        throw new Error("Invalid Argument: the DataPoint constructor requires jsonData to either be undefined, or a json object whose enumerable keys match Data's members");
	    }

	    // jsonData is valid - build from it
	    Object.keys(jsonData).forEach(function(aKey) {
	        switch (aKey) {
	            case 'Data':
	                self.Data(new Data(jsonData[aKey]));
	                break;
	            case 'MeasurementName':
	                self.MeasurementName(new MeasurementName(jsonData[aKey]));
	                break;
	            default:
	                self[aKey](jsonData[aKey]);
	                break;
	        }
	    });
	};


	//-----------------------//
	// Prototyped Extensions //
	//-----------------------//

	DataPoint.prototype.ConvertedValue = function ConvertedValue(convertedvalue_) {
	    var my = this._my;

	    var res = (typeof my.ConvertedValue === 'undefined')
	        ? null
	        : my.ConvertedValue;

	    if (typeof convertedvalue_ !== 'undefined') {
	        if (convertedvalue_ !== null) {
	            DataPoint.ValidateConvertedValue(convertedvalue_, true);
	        }
	        my.ConvertedValue = convertedvalue_;
	        res = this;
	    }
	    return res;
	};

	DataPoint.prototype.ConvertedUnit = function ConvertedUnit(convertedunit_) {
	    var my = this._my;

	    var res = (typeof my.ConvertedUnit === 'undefined')
	        ? null
	        : my.ConvertedUnit;

	    if (typeof convertedunit_ !== 'undefined') {
	        if (convertedunit_ !== null) {
	            DataPoint.ValidateConvertedUnit(convertedunit_, true);
	        }
	        my.ConvertedUnit = convertedunit_;
	        res = this;
	    }
	    return res;
	};

	DataPoint.prototype.CurrentValue = function CurrentValue() {
	    if (arguments.length > 0) {
	        throw new Error('Invalid Call: <DataPoint>.Data is read-only');
	    }
	    return this.ConvertedValue() || this.Value();
	};

	DataPoint.prototype.CurrentUnit = function CurrentUnit() {
	    if (arguments.length > 0) {
	        throw new Error('Invalid Call: <DataPoint>.Unit is read-only');
	    }
	    return this.ConvertedUnit() || this.MeasurementName().Unit().Name();
	};


	//-------------------------------//
	// Private Prototyped Extensions //
	//-------------------------------//

	DataPoint.prototype._deserialize = function _deserialize(jsonData, my) {
	    var self = this;

	    if (!Utils.instance_of(jsonData, Object)) {
	        throw new Error("Invalid Argument: <DataPoint>._deserialize requires jsonData to be an instance_of Object");
	    }

	    var allKeysMatch = lazy(Object.keys(jsonData))
	        .every(function(aKey) {
	            return Utils.in_array(aKey, Object.keys(my));
	        });

	    if (!allKeysMatch) {
	        throw new Error("Invalid Argument: <DataPoint>._deserialize requires jsonData to be an object whose enumerable keys match DataPoint's members");
	    }

	    // jsonData is valid - build from it
	    Object.keys(jsonData).forEach(function(aKey) {
	        switch (aKey) {
	            case 'Data':
	                self.Data(new Data(jsonData[aKey]));
	                break;
	            case 'MeasurementName':
	                self.MeasurementName(new MeasurementName(jsonData[aKey]));
	                break;
	            default:
	                self[aKey](jsonData[aKey]);
	                break;
	        }
	    });
	};


	//------//
	// Mock //
	//------//

	function createMockDataPoint(aData, aMeasurementName) {
	    return new DataPoint()
	        .DataPointID('1')
	        .Value('10')
	        .Data(aData)
	        .MeasurementName(aMeasurementName);
	}


	//---------//
	// Exports //
	//---------//

	module.exports = DataPoint;
	module.exports.createMockDataPoint = createMockDataPoint;


/***/ },
/* 367 */
/*!*********************************!*\
  !*** ./db/models/data-point.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';


	//---------//
	// Imports //
	//---------//

	var nh = __webpack_require__(/*! node-helpers */ 90)
	    , Data = __webpack_require__(/*! ./data */ 368)
	    , MeasurementName = __webpack_require__(/*! ./measurement-name */ 373);


	//------//
	// Init //
	//------//

	var Utils = nh.utils;


	//---------------------------------------------------------------------------------//
	// MODEL
	//---------------------------------------------------------------------------------//
	//
	// Front-end accessible
	//   - Data
	//   - Value
	//   - MeasurementName
	//
	//---------------------------------------------------------------------------------//

	function DataPoint(jsonData) {
	    var self = this;

	    this._my = {};
	    var my = {
	        DataPointID: null
	        , Data: null
	        , Value: null
	        , MeasurementName: null
	    };

	    self.DataPointID = function(datapointid_) {
	        var res = my.DataPointID;
	        if (arguments.length > 0) {
	            if (datapointid_ !== null) {
	                DataPoint.ValidateDataPointID(datapointid_, true);
	            }
	            my.DataPointID = datapointid_;
	            res = self;
	        }
	        return res;
	    };

	    self.Data = function(data_) {
	        var res = my.Data;
	        if (arguments.length > 0) {
	            if (data_ !== null) {
	                DataPoint.ValidateData(data_, true);
	            }
	            my.Data = data_;
	            res = self;
	        }
	        return res;
	    };

	    self.Value = function(value_) {
	        var res = my.Value;
	        if (arguments.length > 0) {
	            if (value_ !== null) {
	                DataPoint.ValidateValue(value_, true);
	            }
	            my.Value = value_;
	            res = self;
	        }
	        return res;
	    };

	    self.MeasurementName = function(measurementname_) {
	        var res = my.MeasurementName;
	        if (arguments.length > 0) {
	            if (measurementname_ !== null) {
	                DataPoint.ValidateMeasurementName(measurementname_, true);
	            }
	            my.MeasurementName = measurementname_;
	            res = self;
	        }
	        return res;
	    };

	    if (typeof jsonData !== 'undefined') {
	        if (typeof this._deserialize === 'undefined') {
	            throw new Error("Invalid State: this._deserialize doesn't exist.  Make sure you are loading this model via its extension");
	        }

	        this._deserialize(jsonData, my);
	    }
	}


	//------------//
	// Validation //
	//------------//

	DataPoint.ValidateDataPointID = function ValidateDataPointID(input_, throwErr_) {
	    var msg = '';
	    if (typeof input_ !== 'string') {
	        msg = 'Invalid Argument: <DataPoint>.ValidateDataPointID requires a typeof string argument';
	    }

	    if (throwErr_ && msg) {
	        throw new Error(msg);
	    }

	    return msg;
	};

	DataPoint.ValidateData = function ValidateData(input_, throwErr_) {
	    var msg = '';
	    if (!Utils.instance_of(input_, Data)) {
	        msg = 'Invalid Argument: <DataPoint>.ValidateData requires an instance_of Data';
	    }

	    if (throwErr_ && msg) {
	        throw new Error(msg);
	    }

	    return msg;
	};

	DataPoint.ValidateValue = function ValidateValue(input_, throwErr_) {
	    if (Utils.isNumeric(input_)) {
	        input_ = '' + input_;
	    }

	    var msg = '';
	    if (typeof input_ !== 'string') {
	        msg = 'Invalid Argument: <DataPoint>.ValidateValue requires a typeof string or isNumeric argument';
	    }

	    if (throwErr_ && msg) {
	        throw new Error(msg);
	    }

	    return msg;
	};

	DataPoint.ValidateMeasurementName = function ValidateMeasurementName(input_, throwErr_) {
	    var msg = '';
	    if (!Utils.instance_of(input_, MeasurementName)) {
	        msg = 'Invalid Argument: <DataPoint>.ValidateMeasurementName requires an instance_of MeasurementName';
	    }

	    if (throwErr_ && msg) {
	        throw new Error(msg);
	    }

	    return msg;
	};


	//--------//
	// Unique //
	//--------//

	DataPoint.prototype.Key = function Key() {
	    return ''
	        + this.Data().Key()
	        + this.MeasurementName().Key();
	};


	//--------//
	// Equals //
	//--------//

	DataPoint.equals = function static_equals(left, right) {
	    if (!(Utils.instance_of(left, DataPoint) && Utils.instance_of(right, DataPoint))) {
	        throw new Error("Source.equals requires both arguments to be instance_of DataPoint");
	    }

	    return left.DataPointID() === right.DataPointID()
	        && Utils.bothNullOrEquals(left.Data(), right.Data(), Data.equals)
	        && left.Value() === right.Value()
	        && Utils.bothNullOrEquals(left.MeasurementName(), right.MeasurementName(), MeasurementName.equals);
	};

	DataPoint.prototype.equals = function equals(other) {
	    return DataPoint.equals(this, other);
	};


	//-----------//
	// Serialize //
	//-----------//

	DataPoint.prototype.serialize = function serialize() {
	    return {
	        DataPointID: this.DataPointID()
	        , Value: this.Value()
	        , Data: this.Data().serialize()
	        , MeasurementName: this.MeasurementName().serialize()
	    };
	};


	//----------//
	// toString //
	//----------//

	DataPoint.prototype.toString = function toString(indentLevel) {
	    indentLevel = indentLevel || 0;
	    var header = (indentLevel === 0)
	        ? "DataPoint \n"
	        : "\n";
	    var indent = Utils.repeatString("  ", indentLevel++);

	    return header
	        + indent + "  DataPointID: " + this.DataPointID() + "\n"
	        + indent + "  Value: " + this.Value() + "\n"
	        + indent + "  Data: " + this.Data().toString(indentLevel)
	        + indent + "  MeasurementName: " + this.MeasurementName().toString(indentLevel);
	};


	//---------//
	// Exports //
	//---------//

	module.exports = DataPoint;


/***/ },
/* 368 */
/*!***************************!*\
  !*** ./db/models/data.js ***!
  \***************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	//---------//
	// Imports //
	//---------//

	var nh = __webpack_require__(/*! node-helpers */ 90)
	    , Type = __webpack_require__(/*! ./type */ 369)
	    , Source = __webpack_require__(/*! ./source */ 370)
	    , YMD = __webpack_require__(/*! ./ymd */ 371)
	    , Location = __webpack_require__(/*! ./location */ 372);


	//------//
	// Init //
	//------//

	var Utils = nh.utils;


	//---------------------------------------------------------------------------------//
	// MODEL
	//---------------------------------------------------------------------------------//
	//
	// Front-end accessible
	//   - Type
	//   - Source
	//   - YMD
	//   - Location
	//
	//---------------------------------------------------------------------------------//

	function Data(jsonData) {
	    var self = this;

	    this._my = {};
	    var my = {
	        DataID: null
	        , Type: null
	        , Source: null
	        , YMD: null
	        , Location: null
	    };

	    self.DataID = function(dataid_) {
	        var res = my.DataID;
	        if (arguments.length > 0) {
	            if (dataid_ !== null) {
	                Data.ValidateDataID(dataid_, true);
	            }
	            my.DataID = dataid_;
	            res = self;
	        }
	        return res;
	    };

	    self.Type = function(type_) {
	        var res = my.Type;
	        if (arguments.length > 0) {
	            if (type_ !== null) {
	                Data.ValidateType(type_, true);
	            }
	            my.Type = type_;
	            res = self;
	        }
	        return res;
	    };

	    self.Source = function(source_) {
	        var res = my.Source;
	        if (arguments.length > 0) {
	            if (source_ !== null) {
	                Data.ValidateSource(source_, true);
	            }
	            my.Source = source_;
	            res = self;
	        }
	        return res;
	    };

	    self.YMD = function(ymd_) {
	        var res = my.YMD;
	        if (arguments.length > 0) {
	            if (ymd_ !== null) {
	                Data.ValidateYMD(ymd_, true);
	            }
	            my.YMD = ymd_;
	            res = self;
	        }
	        return res;
	    };

	    self.Location = function(location_) {
	        var res = my.Location;
	        if (arguments.length > 0) {
	            if (location_ !== null) {
	                Data.ValidateLocation(location_, true);
	            }
	            my.Location = location_;
	            res = self;
	        }
	        return res;
	    };

	    if (typeof jsonData !== 'undefined') {
	        if (typeof this._deserialize === 'undefined') {
	            throw new Error("Invalid State: this._deserialize doesn't exist.  Make sure you are loading this model via its extension");
	        }

	        this._deserialize(jsonData, my);
	    }
	}


	//------------//
	// Validation //
	//------------//

	Data.ValidateDataID = function ValidateDataID(input_, throwErr_) {
	    var msg = '';
	    if (typeof input_ !== 'string') {
	        msg = 'Invalid Argument: <Data>.ValidateDataID requires a typeof string argument';
	    }

	    if (throwErr_ && msg) {
	        throw new Error(msg);
	    }

	    return msg;
	};

	Data.ValidateType = function ValidateType(input_, throwErr_) {
	    var msg = '';
	    if (!Utils.instance_of(input_, Type)) {
	        msg = 'Invalid Argument: <Data>.ValidateType requires an instance_of Type';
	    }

	    if (throwErr_ && msg) {
	        throw new Error(msg);
	    }

	    return msg;
	};

	Data.ValidateSource = function ValidateSource(input_, throwErr_) {
	    var msg = '';
	    if (!Utils.instance_of(input_, Source)) {
	        msg = 'Invalid Argument: <Data>.ValidateSource requires an instance_of Source';
	    }

	    if (throwErr_ && msg) {
	        throw new Error(msg);
	    }

	    return msg;
	};

	Data.ValidateYMD = function ValidateYMD(input_, throwErr_) {
	    var msg = '';
	    if (!Utils.instance_of(input_, YMD)) {
	        msg = 'Invalid Argument: <Data>.ValidateYMD requires an instance_of YMD';
	    }

	    if (throwErr_ && msg) {
	        throw new Error(msg);
	    }

	    return msg;
	};

	Data.ValidateLocation = function ValidateLocation(input_, throwErr_) {
	    var msg = '';
	    if (!Utils.instance_of(input_, Location)) {
	        msg = 'Invalid Argument: <Data>.ValidateLocation requires an instance_of Location';
	    }

	    if (throwErr_ && msg) {
	        throw new Error(msg);
	    }

	    return msg;
	};


	//--------//
	// Unique //
	//--------//

	Data.prototype.Key = function Key() {
	    return ''
	        + this.Type().Key()
	        + this.Source().Key()
	        + this.YMD().Key()
	        + this.Location().Key();
	};


	//--------//
	// Equals //
	//--------//

	Data.equals = function static_equals(left, right) {
	    if (!(Utils.instance_of(left, Data) && Utils.instance_of(right, Data))) {
	        throw new Error("Data.equals requires both arguments to be instance_of Data");
	    }

	    return left.DataID() === right.DataID()
	        && Utils.bothNullOrEquals(left.Type(), right.Type(), Type.equals)
	        && Utils.bothNullOrEquals(left.Source(), right.Source(), Source.equals)
	        && Utils.bothNullOrEquals(left.YMD(), right.YMD(), YMD.equals)
	        && Utils.bothNullOrEquals(left.Location(), right.Location(), Location.equals);
	};

	Data.prototype.equals = function equals(other) {
	    return Data.equals(this, other);
	};


	//-----------//
	// Serialize //
	//-----------//

	Data.prototype.serialize = function serialize() {
	    return {
	        DataID: this.DataID()
	        , Type: this.Type().serialize()
	        , Source: this.Source().serialize()
	        , YMD: this.YMD().serialize()
	        , Location: this.Location().serialize()
	    };
	};


	//----------//
	// toString //
	//----------//

	Data.prototype.toString = function toString(indentLevel) {
	    indentLevel = indentLevel || 0;
	    var header = (indentLevel === 0)
	        ? "Data \n"
	        : "\n";
	    var indent = Utils.repeatString("  ", indentLevel++);

	    return header
	        + indent + "  DataID: " + this.DataID().toString(indentLevel) + "\n"
	        + indent + "  Type: " + this.Type().toString(indentLevel)
	        + indent + "  Source: " + this.Source().toString(indentLevel)
	        + indent + "  YMD: " + this.YMD().toString(indentLevel)
	        + indent + "  Location: " + this.Location().toString(indentLevel);
	};


	//---------//
	// Exports //
	//---------//

	module.exports = Data;


/***/ },
/* 369 */
/*!***************************!*\
  !*** ./db/models/type.js ***!
  \***************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';


	//---------//
	// Imports //
	//---------//

	var nh = __webpack_require__(/*! node-helpers */ 90);


	//------//
	// Init //
	//------//

	var Utils = nh.utils
	    , lazy = nh.lazyExtensions;


	//---------------------------------------------------------------------------------//
	// MODEL
	//---------------------------------------------------------------------------------//
	//
	// Front-end accessible
	//   - Name
	//
	//---------------------------------------------------------------------------------//

	function Type(jsonData) {
	    var self = this;

	    this._my = {};
	    var my = {
	        TypeID: null
	        , Name: null
	    };

	    self.TypeID = function(typeid_) {
	        var res = my.TypeID;
	        if (arguments.length > 0) {
	            if (typeid_ !== null) {
	                Type.ValidateTypeID(typeid_, true);
	            }
	            my.TypeID = typeid_;
	            res = self;
	        }
	        return res;
	    };

	    self.Name = function(name_) {
	        var res = my.Name;
	        if (arguments.length > 0) {
	            if (name_ !== null) {
	                Type.ValidateName(name_, true);
	            }
	            my.Name = name_;
	            res = self;
	        }
	        return res;
	    };

	    if (typeof jsonData !== 'undefined') {
	        if (typeof this._deserialize === 'undefined') {
	            throw new Error("Invalid State: this._deserialize doesn't exist.  Make sure you are loading this model via its extension");
	        }

	        this._deserialize(jsonData, my);
	    }
	}


	//------------//
	// Validation //
	//------------//

	Type.ValidateTypeID = function ValidateTypeID(input_, throwErr_) {
	    var msg = '';
	    if (typeof input_ !== 'string') {
	        msg = 'Invalid Argument: <Type>.ValidateTypeID requires a typeof string argument';
	    }

	    if (throwErr_ && msg) {
	        throw new Error(msg);
	    }

	    return msg;
	};

	Type.ValidateName = function ValidateName(input_, throwErr_) {
	    var msg = '';
	    if (typeof input_ !== 'string') {
	        msg = 'Invalid Argument: <Type>.ValidateName requires a typeof string argument';
	    }

	    if (throwErr_ && msg) {
	        throw new Error(msg);
	    }

	    return msg;
	};


	//-----//
	// Key //
	//-----//

	Type.prototype.Key = function Key() {
	    return ''
	        + this.Name();
	};


	//--------//
	// Equals //
	//--------//

	Type.equals = function static_equals(left, right) {
	    if (!(Utils.instance_of(left, Type) && Utils.instance_of(right, Type))) {
	        throw new Error("Source.equals requires both arguments to be instance_of Type");
	    }

	    return left.TypeID() === right.TypeID()
	        && left.Name() === right.Name();
	};

	Type.prototype.equals = function equals(other) {
	    return Type.equals(this, other);
	};


	//-----------//
	// Serialize //
	//-----------//

	Type.prototype.serialize = function serialize() {
	    return {
	        TypeID: this.TypeID()
	        , Name: this.Name()
	    };
	};


	//----------//
	// toString //
	//----------//

	Type.prototype.toString = function toString(indentLevel) {
	    indentLevel = indentLevel || 0;
	    var header = (indentLevel === 0)
	        ? "Type \n"
	        : "\n";
	    var indent = Utils.repeatString("  ", indentLevel++);

	    return header
	        + indent + "  TypeID: " + this.TypeID() + "\n"
	        + indent + "  Name: " + this.Name() + "\n";
	};


	//---------//
	// Exports //
	//---------//

	module.exports = Type;


/***/ },
/* 370 */
/*!*****************************!*\
  !*** ./db/models/source.js ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';


	//---------//
	// Imports //
	//---------//

	var nh = __webpack_require__(/*! node-helpers */ 90);


	//------//
	// Init //
	//------//

	var Utils = nh.utils
	    , lazy = nh.lazyExtensions;


	//---------------------------------------------------------------------------------//
	// MODEL
	//---------------------------------------------------------------------------------//
	//
	// Front-end accessible
	//   - Name
	//
	//---------------------------------------------------------------------------------//

	function Source(jsonData) {
	    var self = this;

	    this._my = {};
	    var my = {
	        SourceID: null
	        , Name: null
	    };

	    self.SourceID = function(sourceid_) {
	        var res = my.SourceID;
	        if (arguments.length > 0) {
	            if (sourceid_ !== null) {
	                Source.ValidateSourceID(sourceid_, true);
	            }
	            my.SourceID = sourceid_;
	            res = self;
	        }
	        return res;
	    };

	    self.Name = function(name_) {
	        var res = my.Name;
	        if (arguments.length > 0) {
	            if (name_ !== null) {
	                Source.ValidateName(name_, true);
	            }
	            my.Name = name_;
	            res = self;
	        }
	        return res;
	    };

	    if (typeof jsonData !== 'undefined') {
	        if (typeof this._deserialize === 'undefined') {
	            throw new Error("Invalid State: this._deserialize doesn't exist.  Make sure you are loading this model via its extension");
	        }

	        this._deserialize(jsonData, my);
	    }
	}


	//------------//
	// Validation //
	//------------//

	Source.ValidateSourceID = function ValidateSourceID(input_, throwErr_) {
	    var msg = '';
	    if (typeof input_ !== 'string') {
	        msg = 'Invalid Argument: <Source>.ValidateSourceID requires a typeof string argument';
	    }

	    if (throwErr_ && msg) {
	        throw new Error(msg);
	    }

	    return msg;
	};

	Source.ValidateName = function ValidateName(input_, throwErr_) {
	    var msg = '';
	    if (typeof input_ !== 'string') {
	        msg = 'Invalid Argument: <Source>.ValidateName requires a typeof string argument';
	    }

	    if (throwErr_ && msg) {
	        throw new Error(msg);
	    }

	    return msg;
	};


	//-----//
	// Key //
	//-----//

	Source.prototype.Key = function Key() {
	    return ''
	        + this.Name();
	};


	//--------//
	// Equals //
	//--------//

	Source.equals = function static_equals(left, right) {
	    if (!(Utils.instance_of(left, Source) && Utils.instance_of(right, Source))) {
	        throw new Error("Source.equals requires both arguments to be instance_of Source");
	    }

	    return left.SourceID() === right.SourceID()
	        && left.Name() === right.Name();
	};

	Source.prototype.equals = function equals(other) {
	    return Source.equals(this, other);
	};


	//-----------//
	// Serialize //
	//-----------//

	Source.prototype.serialize = function serialize() {
	    return {
	        SourceID: this.SourceID()
	        , Name: this.Name()
	    };
	};


	//----------//
	// toString //
	//----------//

	Source.prototype.toString = function toString(indentLevel) {
	    indentLevel = indentLevel || 0;
	    var header = (indentLevel === 0)
	        ? "Source \n"
	        : "\n";
	    var indent = Utils.repeatString("  ", indentLevel++);

	    return header
	        + indent + "  SourceID: " + this.SourceID() + "\n"
	        + indent + "  Name: " + this.Name() + "\n";
	};


	//---------//
	// Exports //
	//---------//

	module.exports = Source;


/***/ },
/* 371 */
/*!**************************!*\
  !*** ./db/models/ymd.js ***!
  \**************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';


	//---------//
	// Imports //
	//---------//

	var nh = __webpack_require__(/*! node-helpers */ 90)
	    , moment = __webpack_require__(/*! moment */ 209);


	//------//
	// Init //
	//------//

	var Utils = nh.utils
	    , lazy = nh.lazyExtensions;


	//---------------------------------------------------------------------------------//
	// MODEL
	//---------------------------------------------------------------------------------//
	//
	// Front-end accessible
	//   - Value
	//
	//---------------------------------------------------------------------------------//

	function YMD(jsonData) {
	    var self = this;

	    this._my = {};
	    var my = {
	        YMDid: null
	        , Value: null
	    };

	    self.YMDid = function(ymdid_) {
	        var res = my.YMDid;
	        if (arguments.length > 0) {
	            if (ymdid_ !== null) {
	                YMD.ValidateYMDid(ymdid_, true);
	            }
	            my.YMDid = ymdid_;
	            res = self;
	        }
	        return res;
	    };

	    self.Value = function(value_) {
	        var res = my.Value;
	        if (arguments.length > 0) {
	            if (Utils.instance_of(value_, Date)) {
	                value_ = moment(value_).format('YYYYMMDD');
	            }

	            if (value_ !== null) {
	                YMD.ValidateValue(value_, true);
	            }

	            my.Value = value_;
	            res = self;
	        }
	        return res;
	    };

	    if (typeof jsonData !== 'undefined') {
	        if (typeof this._deserialize === 'undefined') {
	            throw new Error("Invalid State: this._deserialize doesn't exist.  Make sure you are loading this model via its extension");
	        }

	        this._deserialize(jsonData, my);
	    }
	}


	//------------//
	// Validation //
	//------------//

	YMD.ValidateYMDid = function ValidateYMDid(input_, throwErr_) {
	    var msg = '';

	    if (typeof input_ !== 'string') {
	        msg = 'Invalid Argument: <YMD>.ValidateYMDid requires a typeof string argument';
	    }

	    if (throwErr_ && msg) {
	        throw new Error(msg);
	    }

	    return msg;
	};

	YMD.ValidateValue = function ValidateValue(input, throwErr) {
	    var msg = '';

	    if (!(typeof input === 'string' && input.match(/^\d{8}$/) && moment(input, 'YYYYMMDD').isValid())) {
	        msg = "Invalid Argument: <YMD>.ValidateValue requires a valid date in the format 'YYYYMMDD'";
	    }

	    if (throwErr && msg) {
	        throw new Error(msg);
	    }

	    return msg;
	};


	//-----//
	// Key //
	//-----//

	YMD.prototype.Key = function Key() {
	    return ''
	        + this.Value();
	};


	//--------//
	// Equals //
	//--------//

	YMD.equals = function static_equals(left, right) {
	    if (!(Utils.instance_of(left, YMD) && Utils.instance_of(right, YMD))) {
	        throw new Error("Source.equals requires both arguments to be instance_of YMD");
	    }

	    return left.YMDid() === right.YMDid()
	        && left.Value() === right.Value();
	};

	YMD.prototype.equals = function equals(other) {
	    return YMD.equals(this, other);
	};


	//-----------//
	// Serialize //
	//-----------//

	YMD.prototype.serialize = function serialize() {
	    return {
	        YMDid: this.YMDid()
	        , Value: this.Value()
	    };
	};


	//----------//
	// toString //
	//----------//

	YMD.prototype.toString = function toString(indentLevel) {
	    indentLevel = indentLevel || 0;
	    var header = (indentLevel === 0)
	        ? "YMD \n"
	        : "\n";
	    var indent = Utils.repeatString("  ", indentLevel++);

	    return header
	        + indent + "  YMDid: " + this.YMDid() + "\n"
	        + indent + "  Value: " + this.Value() + "\n";
	};


	//---------//
	// Exports //
	//---------//

	module.exports = YMD;


/***/ },
/* 372 */
/*!*******************************!*\
  !*** ./db/models/location.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';


	//---------//
	// Imports //
	//---------//

	var nh = __webpack_require__(/*! node-helpers */ 90);


	//------//
	// Init //
	//------//

	var Utils = nh.utils
	    , lazy = nh.lazyExtensions;


	//---------------------------------------------------------------------------------//
	// MODEL
	//---------------------------------------------------------------------------------//
	//
	// Front-end accessible
	//   - Latitude
	//   - Longitude
	//   - Name
	//
	//---------------------------------------------------------------------------------//

	function Location(jsonData) {
	    var self = this;

	    this._my = {};
	    var my = {
	        LocationID: null
	        , Latitude: null
	        , Longitude: null
	        , Name: null
	        , TZ: null
	    };

	    self.LocationID = function(locationid_) {
	        var res = my.LocationID;
	        if (arguments.length > 0) {
	            if (locationid_ !== null) {
	                Location.ValidateLocationID(locationid_, true);
	            }
	            my.LocationID = locationid_;
	            res = self;
	        }
	        return res;
	    };

	    self.Latitude = function(latitude_) {
	        var res = my.Latitude;
	        if (arguments.length > 0) {
	            if (latitude_ !== null) {
	                Location.ValidateLatitude(latitude_, true);
	            }
	            my.Latitude = latitude_;
	            res = self;
	        }
	        return res;
	    };

	    self.Longitude = function(longitude_) {
	        var res = my.Longitude;
	        if (arguments.length > 0) {
	            if (longitude_ !== null) {
	                Location.ValidateLongitude(longitude_, true);
	            }
	            my.Longitude = longitude_;
	            res = self;
	        }
	        return res;
	    };

	    self.Name = function(name_) {
	        var res = my.Name;
	        if (arguments.length > 0) {
	            if (name_ !== null) {
	                Location.ValidateName(name_, true);
	            }
	            my.Name = name_;
	            res = self;
	        }
	        return res;
	    };

	    self.TZ = function(tz_) {
	        var res = my.TZ;
	        if (arguments.length > 0) {
	            if (tz_ !== null) {
	                Location.ValidateTZ(tz_, true);
	            }
	            my.TZ = tz_;
	            res = self;
	        }
	        return res;
	    };

	    if (typeof jsonData !== 'undefined') {
	        if (typeof this._deserialize === 'undefined') {
	            throw new Error("Invalid State: this._deserialize doesn't exist.  Make sure you are loading this model via its extension");
	        }

	        this._deserialize(jsonData, my);
	    }
	}


	//------------//
	// Validation //
	//------------//

	Location.ValidateLocationID = function ValidateLocationID(input_, throwErr_) {
	    var msg = '';
	    if (typeof input_ !== 'string') {
	        msg = 'Invalid Argument: <Location>.LocationID requires a typeof string argument';
	    }

	    if (throwErr_ && msg) {
	        throw new Error(msg);
	    }

	    return msg;
	};

	Location.ValidateLatitude = function ValidateLatitude(input_, throwErr_) {
	    var msg = '';
	    if (typeof input_ !== 'string') {
	        msg = 'Invalid Argument: <Location>.Latitude requires a typeof string argument';
	    }

	    if (throwErr_ && msg) {
	        throw new Error(msg);
	    }

	    return msg;
	};

	Location.ValidateLongitude = function ValidateLongitude(input_, throwErr_) {
	    var msg = '';
	    if (typeof input_ !== 'string') {
	        msg = 'Invalid Argument: <Location>.Longitude requires a typeof string argument';
	    }

	    if (throwErr_ && msg) {
	        throw new Error(msg);
	    }

	    return msg;
	};

	Location.ValidateName = function ValidateName(input_, throwErr_) {
	    var msg = '';
	    if (typeof input_ !== 'string') {
	        msg = 'Invalid Argument: <Location>.Name requires a typeof string argument';
	    }

	    if (throwErr_ && msg) {
	        throw new Error(msg);
	    }

	    return msg;
	};

	Location.ValidateTZ = function ValidateTZ(input_, throwErr_) {
	    var msg = '';
	    if (typeof input_ !== 'string') {
	        msg = 'Invalid Argument: <Location>.TZ requires a typeof string argument';
	    }

	    if (throwErr_ && msg) {
	        throw new Error(msg);
	    }

	    return msg;
	};


	//--------//
	// Unique //
	//--------//

	Location.prototype.Key = function Key() {
	    return ''
	        + this.Latitude()
	        + this.Longitude();
	};


	//--------//
	// Equals //
	//--------//

	Location.equals = function static_equals(left, right) {
	    if (!(Utils.instance_of(left, Location) && Utils.instance_of(right, Location))) {
	        throw new Error("Source.equals requires both arguments to be instance_of Location");
	    }

	    return left.LocationID() === right.LocationID()
	        && left.Latitude() === right.Latitude()
	        && left.Longitude() === right.Longitude()
	        && left.Name() === right.Name();
	};

	Location.prototype.equals = function equals(other) {
	    return Location.equals(this, other);
	};


	//-----------//
	// Serialize //
	//-----------//

	Location.prototype.serialize = function serialize() {
	    return {
	        LocationID: this.LocationID()
	        , Latitude: this.Latitude()
	        , Longitude: this.Longitude()
	        , Name: this.Name()
	        , TZ: this.TZ()
	    };
	};


	//----------//
	// toString //
	//----------//

	Location.prototype.toString = function toString(indentLevel) {
	    indentLevel = indentLevel || 0;
	    var header = (indentLevel === 0)
	        ? "Location \n"
	        : "\n";
	    var indent = Utils.repeatString("  ", indentLevel++);

	    return header
	        + indent + "  LocationID: " + this.LocationID() + "\n"
	        + indent + "  Name: " + this.Name() + "\n";
	};


	//---------//
	// Exports //
	//---------//

	module.exports = Location;


/***/ },
/* 373 */
/*!***************************************!*\
  !*** ./db/models/measurement-name.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	//---------//
	// Import //
	//---------//

	var nh = __webpack_require__(/*! node-helpers */ 90)
	    , Unit = __webpack_require__(/*! ./unit */ 374);


	//------//
	// Init //
	//------//

	var Utils = nh.utils
	    , lazy = nh.lazyExtensions;


	//---------------------------------------------------------------------------------//
	// MODEL
	//---------------------------------------------------------------------------------//
	//
	// Front-end accessible
	//   - Unit
	//   - Value
	//
	//---------------------------------------------------------------------------------//

	function MeasurementName(jsonData) {
	    var self = this;

	    this._my = {};
	    var my = {
	        MeasurementNameID: null
	        , Unit: null
	        , Value: null
	    };

	    self.MeasurementNameID = function(measurementnameid_) {
	        var res = my.MeasurementNameID;
	        if (arguments.length > 0) {
	            if (measurementnameid_ !== null) {
	                MeasurementName.ValidateMeasurementNameID(measurementnameid_, true);
	            }
	            my.MeasurementNameID = measurementnameid_;
	            res = self;
	        }
	        return res;
	    };

	    self.Unit = function(unit_) {
	        var res = my.Unit;
	        if (arguments.length > 0) {
	            if (unit_ !== null) {
	                MeasurementName.ValidateUnit(unit_, true);
	            }
	            my.Unit = unit_;
	            res = self;
	        }
	        return res;
	    };

	    self.Value = function(value_) {
	        var res = my.Value;
	        if (arguments.length > 0) {
	            if (value_ !== null) {
	                MeasurementName.ValidateValue(value_, true);
	            }
	            my.Value = value_;
	            res = self;
	        }
	        return res;
	    };

	    if (typeof jsonData !== 'undefined') {
	        if (typeof this._deserialize === 'undefined') {
	            throw new Error("Invalid State: this._deserialize doesn't exist.  Make sure you are loading this model via its extension");
	        }

	        this._deserialize(jsonData, my);
	    }
	}


	//------------//
	// Validation //
	//------------//

	MeasurementName.ValidateMeasurementNameID = function ValidateMeasurementNameID(input_, throwErr_) {
	    var msg = '';
	    if (typeof input_ !== 'string') {
	        msg = 'Invalid Argument: <MeasurementName>.ValidateMeasurementNameID requires a typeof string argument';
	    }

	    if (throwErr_ && msg) {
	        throw new Error(msg);
	    }

	    return msg;
	};

	MeasurementName.ValidateUnit = function ValidateUnit(input_, throwErr_) {
	    var msg = '';
	    if (!Utils.instance_of(input_, Unit)) {
	        msg = 'Invalid Argument: <MeasurementName>.ValidateUnit requires an instance_of Unit';
	    }

	    if (throwErr_ && msg) {
	        throw new Error(msg);
	    }

	    return msg;
	};

	MeasurementName.ValidateValue = function ValidateValue(input_, throwErr_) {
	    var msg = '';
	    if (typeof input_ !== 'string') {
	        msg = 'Invalid Argument: <MeasurementName>.Value requires a typeof string argument';
	    }

	    if (throwErr_ && msg) {
	        throw new Error(msg);
	    }

	    return msg;
	};


	//-----//
	// Key //
	//-----//

	MeasurementName.prototype.Key = function Key() {
	    return ''
	        + this.ValidateValue();
	};


	//--------//
	// Equals //
	//--------//

	MeasurementName.equals = function static_equals(left, right) {
	    if (!(Utils.instance_of(left, MeasurementName) && Utils.instance_of(right, MeasurementName))) {
	        throw new Error("MeasurementName.equals requires both arguments to be instance_of MeasurementName");
	    }

	    return left.MeasurementNameID() === right.MeasurementNameID()
	        && left.Value() === right.Value()
	        && Utils.bothNullOrEquals(left.Unit(), right.Unit(), Unit.equals);
	};

	MeasurementName.prototype.equals = function equals(other) {
	    return MeasurementName.equals(this, other);
	};


	//----------//
	// toString //
	//----------//

	MeasurementName.prototype.toString = function toString(indentLevel) {
	    indentLevel = indentLevel || 0;
	    var header = (indentLevel === 0)
	        ? "MeasurementName \n"
	        : "\n";
	    var indent = Utils.repeatString("  ", indentLevel++);

	    return header
	        + indent + "  MeasurementNameID: " + this.MeasurementNameID() + "\n"
	        + indent + "  Value: " + this.Value() + "\n"
	        + indent + "  Unit: " + this.Unit().toString(indentLevel);
	};


	//-----------//
	// Serialize //
	//-----------//

	MeasurementName.prototype.serialize = function serialize() {
	    return {
	        MeasurementNameID: this.MeasurementNameID()
	        , Value: this.Value()
	        , Unit: this.Unit().serialize()
	    };
	};


	//----------//
	// toString //
	//----------//

	MeasurementName.prototype.toString = function toString(indentLevel) {
	    indentLevel = indentLevel || 0;
	    var header = (indentLevel === 0)
	        ? "MeasurementName \n"
	        : "\n";
	    var indent = Utils.repeatString("  ", indentLevel++);

	    return header
	        + indent + "  MeasurementNameID: " + this.MeasurementNameID() + "\n"
	        + indent + "  Value: " + this.Value() + "\n"
	        + indent + "  Unit: " + this.Unit().toString(indentLevel);
	};


	//---------//
	// Exports //
	//---------//

	module.exports = MeasurementName;


/***/ },
/* 374 */
/*!***************************!*\
  !*** ./db/models/unit.js ***!
  \***************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';


	//---------//
	// Imports //
	//---------//

	var nh = __webpack_require__(/*! node-helpers */ 90);


	//------//
	// Init //
	//------//

	var Utils = nh.utils
	    , lazy = nh.lazyExtensions;


	//---------------------------------------------------------------------------------//
	// MODEL
	//---------------------------------------------------------------------------------//
	//
	// Front-end accessible
	//   - Name
	//
	//---------------------------------------------------------------------------------//

	function Unit(jsonData) {
	    var self = this;

	    this._my = {};
	    var my = {
	        UnitID: null
	        , Name: null
	    };

	    self.UnitID = function(unitid_) {
	        var res = my.UnitID;
	        if (arguments.length > 0) {
	            if (unitid_ !== null) {
	                Unit.ValidateUnitID(unitid_, true);
	            }
	            my.UnitID = unitid_;
	            res = self;
	        }
	        return res;
	    };

	    self.Name = function(name_) {
	        var res = my.Name;
	        if (arguments.length > 0) {
	            if (name_ !== null) {
	                Unit.ValidateName(name_, true);
	            }
	            my.Name = name_;
	            res = self;
	        }
	        return res;
	    };

	    if (typeof jsonData !== 'undefined') {
	        if (typeof this._deserialize === 'undefined') {
	            throw new Error("Invalid State: this._deserialize doesn't exist.  Make sure you are loading this model via its extension");
	        }

	        this._deserialize(jsonData, my);
	    }
	}


	//------------//
	// Validation //
	//------------//

	Unit.ValidateUnitID = function ValidateUnitID(input_, throwErr_) {
	    var msg = '';
	    if (typeof input_ !== 'string') {
	        msg = 'Invalid Argument: <Unit>.ValidateUnitID requires a typeof string argument';
	    }

	    if (throwErr_ && msg) {
	        throw new Error(msg);
	    }

	    return msg;
	};

	Unit.ValidateName = function ValidateName(input_, throwErr_) {
	    var msg = '';
	    if (typeof input_ !== 'string') {
	        msg = 'Invalid Argument: <Unit>.ValidateName requires a typeof string argument';
	    }

	    if (throwErr_ && msg) {
	        throw new Error(msg);
	    }

	    return msg;
	};


	//-----//
	// Key //
	//-----//

	Unit.prototype.Key = function Key() {
	    return ''
	        + this.Name();
	};


	//--------//
	// Equals //
	//--------//

	Unit.equals = function static_equals(left, right) {
	    if (!(Utils.instance_of(left, Unit) && Utils.instance_of(right, Unit))) {
	        throw new Error("Source.equals requires both arguments to be instance_of Unit");
	    }

	    return left.UnitID() === right.UnitID()
	        && left.Name() === right.Name();
	};

	Unit.prototype.equals = function equals(other) {
	    return Unit.equals(this, other);
	};


	//-----------//
	// Serialize //
	//-----------//

	Unit.prototype.serialize = function serialize() {
	    return {
	        UnitID: this.UnitID()
	        , Name: this.Name()
	    };
	};


	//----------//
	// toString //
	//----------//

	Unit.prototype.toString = function toString(indentLevel) {
	    indentLevel = indentLevel || 0;
	    var header = (indentLevel === 0)
	        ? "Unit \n"
	        : "\n";
	    var indent = Utils.repeatString("  ", indentLevel++);

	    return header
	        + indent + "  UnitID: " + this.UnitID() + "\n"
	        + indent + "  Name: " + this.Name() + "\n";
	};


	//---------//
	// Exports //
	//---------//

	module.exports = Unit;


/***/ },
/* 375 */
/*!**************************************!*\
  !*** ./db/models/extensions/data.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';


	//--------//
	// Import //
	//--------//

	var nh = __webpack_require__(/*! node-helpers */ 90)
	    , Data = __webpack_require__(/*! ../data */ 368)
	    , Type = __webpack_require__(/*! ./type */ 376)
	    , Source = __webpack_require__(/*! ./source */ 377)
	    , YMD = __webpack_require__(/*! ./ymd */ 378)
	    , Location = __webpack_require__(/*! ./location */ 379);


	//------//
	// Init //
	//------//

	var Utils = nh.utils
	    , lazy = nh.lazyExtensions;


	//-------------------------------//
	// Private Prototyped Extensions //
	//-------------------------------//

	Data.prototype._deserialize = function _deserialize(jsonData, my) {
	    var self = this;

	    if (!Utils.instance_of(jsonData, Object)) {
	        throw new Error("Invalid Argument: <Data>._deserialize requires jsonData to be an instance_of Object");
	    }

	    var allKeysMatch = lazy(Object.keys(jsonData))
	        .every(function(aKey) {
	            return Utils.in_array(aKey, Object.keys(my));
	        });

	    if (!allKeysMatch) {
	        throw new Error("Invalid Argument: <Data>._deserialize requires jsonData to be an object whose enumerable keys match Data's members");
	    }

	    // jsonData is valid - build from it
	    Object.keys(jsonData).forEach(function(aKey) {
	        switch (aKey) {
	            case 'Type':
	                self.Type(new Type(jsonData[aKey]));
	                break;
	            case 'Source':
	                self.Source(new Source(jsonData[aKey]));
	                break;
	            case 'YMD':
	                self.YMD(new YMD(jsonData[aKey]));
	                break;
	            case 'Location':
	                self.Location(new Location(jsonData[aKey]));
	                break;
	            default:
	                self[aKey](jsonData[aKey]);
	                break;
	        }
	    });
	};


	//------//
	// Mock //
	//------//

	function createMockData(aType, aSource, aYmd, aLocation) {
	    return new Data()
	        .DataID('1')
	        .Type(aType)
	        .Source(aSource)
	        .YMD(aYmd)
	        .Location(aLocation);
	}


	//---------//
	// Exports //
	//---------//

	module.exports = Data;
	module.exports.createMockData = createMockData;


/***/ },
/* 376 */
/*!**************************************!*\
  !*** ./db/models/extensions/type.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';


	//--------//
	// Import //
	//--------//

	var nh = __webpack_require__(/*! node-helpers */ 90)
	    , Type = __webpack_require__(/*! ../type */ 369);


	//------//
	// Init //
	//------//

	var Utils = nh.utils
	    , lazy = nh.lazyExtensions;


	//-------------------//
	// Static Extensions //
	//-------------------//

	Type.NAMES = {
	    ACTUAL: 'actual'
	    , FORECAST_DAY_1: 'forecast_1_day_out'
	    , FORECAST_DAY_2: 'forecast_2_days_out'
	    , FORECAST_DAY_3: 'forecast_3_days_out'
	    , FORECAST_DAY_4: 'forecast_4_days_out'
	    , FORECAST_DAY_5: 'forecast_5_days_out'
	};


	//-------------------------------//
	// Private Prototyped Extensions //
	//-------------------------------//

	Type.prototype._deserialize = function _deserialize(jsonData, my) {
	    var self = this;

	    if (!Utils.instance_of(jsonData, Object)) {
	        throw new Error("Invalid Argument: <Type>._deserialize requires jsonData to be an instance_of Object");
	    }

	    var allKeysMatch = lazy(Object.keys(jsonData))
	        .every(function(aKey) {
	            return Utils.in_array(aKey, Object.keys(my));
	        });

	    if (!allKeysMatch) {
	        throw new Error("Invalid Argument: <Type>._deserialize requires jsonData to be an object whose enumerable keys match Type's members");
	    }

	    // jsonData is valid - build from it
	    Object.keys(jsonData).forEach(function(aKey) {
	        self[aKey](jsonData[aKey]);
	    });
	};


	//------//
	// Mock //
	//------//

	function createMockType() {
	    return new Type()
	        .TypeID('1')
	        .Name(Type.NAMES.ACTUAL);
	}


	//---------//
	// Exports //
	//---------//

	module.exports = Type;
	module.exports.createMockType = createMockType;


/***/ },
/* 377 */
/*!****************************************!*\
  !*** ./db/models/extensions/source.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';


	//--------//
	// Import //
	//--------//

	var nh = __webpack_require__(/*! node-helpers */ 90)
	    , Source = __webpack_require__(/*! ../source */ 370);


	//------//
	// Init //
	//------//

	var Utils = nh.utils
	    , lazy = nh.lazyExtensions;


	//-------------------//
	// Static Extensions //
	//-------------------//

	// ideally these would be dynamically created via the database.  That is more work than it's worth for now though.
	Source.NAMES = {
	    WUNDERGROUND: 'weather_underground'
	    , HAM: 'ham_weather'
	    , FIO: 'forecast_io'
	};

	// also ideally the following would be database fields.  That would require a little more refactoring than it's worth
	//   considering I don't have future plans for this project
	Source.NICE = {};
	Source.NICE[Source.NAMES.WUNDERGROUND] = 'Weather Underground';
	Source.NICE[Source.NAMES.HAM] = 'Ham Weather';
	Source.NICE[Source.NAMES.FIO] = 'Forecast IO';

	Source.SHORT = {};
	Source.SHORT[Source.NAMES.WUNDERGROUND] = 'WU';
	Source.SHORT[Source.NAMES.HAM] = 'HW';
	Source.SHORT[Source.NAMES.FIO] = 'FIO';


	//-----------------------//
	// Prototyped Extensions //
	//-----------------------//

	Source.prototype.NiceName = function NiceName() {
	    return Source.NICE[this.Name()];
	};
	Source.prototype.ShortName = function ShortName() {
	    return Source.SHORT[this.Name()];
	};


	//-------------------------------//
	// Private Prototyped Extensions //
	//-------------------------------//

	Source.prototype._deserialize = function _deserialize(jsonData, my) {
	    var self = this;

	    if (!Utils.instance_of(jsonData, Object)) {
	        throw new Error("Invalid Argument: <Source>._deserialize requires jsonData to be an instance_of Object");
	    }

	    var allKeysMatch = lazy(Object.keys(jsonData))
	        .every(function(aKey) {
	            return Utils.in_array(aKey, Object.keys(my));
	        });

	    if (!allKeysMatch) {
	        throw new Error("Invalid Argument: <Source>._deserialize requires jsonData to be an object whose enumerable keys match Source's members");
	    }

	    // jsonData is valid - build from it
	    Object.keys(jsonData).forEach(function(aKey) {
	        self[aKey](jsonData[aKey]);
	    });
	};


	//------//
	// Mock //
	//------//

	function createMockSource() {
	    return new Source()
	        .SourceID('1')
	        .Name(Source.NAMES.WUNDERGROUND);
	}


	//---------//
	// Exports //
	//---------//

	module.exports = Source;
	module.exports.createMockSource = createMockSource;


/***/ },
/* 378 */
/*!*************************************!*\
  !*** ./db/models/extensions/ymd.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';


	//--------//
	// Import //
	//--------//

	var nh = __webpack_require__(/*! node-helpers */ 90)
	    , YMD = __webpack_require__(/*! ../ymd */ 371)
	    , moment = __webpack_require__(/*! moment */ 209);


	//------//
	// Init //
	//------//

	var Utils = nh.utils
	    , lazy = nh.lazyExtensions;


	//-------------------//
	// Static Extensions //
	//-------------------//

	YMD.getMoment = function static_getMoment(aYmd) {
	    YMD.ValidateValue(aYmd, true);

	    return moment(aYmd, 'YYYYMMDD');
	};


	//-----------------------//
	// Prototyped Extensions //
	//-----------------------//

	YMD.prototype.getMoment = function getMoment() {
	    if (!this._moment) {
	        this._moment = moment(this.Value(), 'YYYYMMDD');
	    }

	    return this._moment;
	};


	//-------------------------------//
	// Private Prototyped Extensions //
	//-------------------------------//

	YMD.prototype._deserialize = function _deserialize(jsonData, my) {
	    var self = this;

	    if (!Utils.instance_of(jsonData, Object)) {
	        throw new Error("Invalid Argument: <YMD>._deserialize requires jsonData to be an instance_of Object");
	    }

	    var allKeysMatch = lazy(Object.keys(jsonData))
	        .every(function(aKey) {
	            return Utils.in_array(aKey, Object.keys(my));
	        });

	    if (!allKeysMatch) {
	        throw new Error("Invalid Argument: <YMD>._deserialize requires jsonData to be an object whose enumerable keys match YMD's members");
	    }

	    // jsonData is valid - build from it
	    Object.keys(jsonData).forEach(function(aKey) {
	        self[aKey](jsonData[aKey]);
	    });
	};


	//------//
	// Mock //
	//------//

	function createMockYmd() {
	    return new YMD()
	        .YMDid('1')
	        .Value('20150101');
	}

	//---------//
	// Exports //
	//---------//

	module.exports = YMD;
	module.exports.createMockYmd = createMockYmd;


/***/ },
/* 379 */
/*!******************************************!*\
  !*** ./db/models/extensions/location.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';


	//--------//
	// Import //
	//--------//

	var nh = __webpack_require__(/*! node-helpers */ 90)
	    , Location = __webpack_require__(/*! ../location */ 372);


	//------//
	// Init //
	//------//

	var Utils = nh.utils
	    , lazy = nh.lazyExtensions;


	//-------------------//
	// Static Extensions //
	//-------------------//

	Location.NAMES = {
	    RICHMOND: "Richmond, CA"
	    , CHICAGO: "Chicago, IL"
	    , NEW_YORK: "New York, NY"
	};

	Location.TZ = {
	    LOS_ANGELES: "America/Los_Angeles"
	    , CHICAGO: "America/Chicago"
	    , NEW_YORK: "America/New_York"
	};


	//-------------------------------//
	// Private Prototyped Extensions //
	//-------------------------------//

	Location.prototype._deserialize = function _deserialize(jsonData, my) {
	    var self = this;

	    if (!Utils.instance_of(jsonData, Object)) {
	        throw new Error("Invalid Argument: <Location>._deserialize requires jsonData to be an instance_of Object");
	    }

	    var allKeysMatch = lazy(Object.keys(jsonData))
	        .every(function(aKey) {
	            return Utils.in_array(aKey, Object.keys(my));
	        });

	    if (!allKeysMatch) {
	        throw new Error("Invalid Argument: <Location>._deserialize requires jsonData to be an object whose enumerable keys match Location's members");
	    }

	    // jsonData is valid - build from it
	    Object.keys(jsonData).forEach(function(aKey) {
	        self[aKey](jsonData[aKey]);
	    });
	};


	//------//
	// Mock //
	//------//

	function createMockLocation() {
	    return new Location()
	        .LocationID('1')
	        .Name(Location.NAMES.RICHMOND)
	        .Latitude('37.935758')
	        .Longitude('-122.347749')
	        .TZ(Location.TZ.LOS_ANGELES);
	}


	//---------//
	// Exports //
	//---------//

	module.exports = Location;
	module.exports.createMockLocation = createMockLocation;


/***/ },
/* 380 */
/*!**************************************************!*\
  !*** ./db/models/extensions/measurement-name.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';


	//--------//
	// Import //
	//--------//

	var nh = __webpack_require__(/*! node-helpers */ 90)
	    , MeasurementName = __webpack_require__(/*! ../measurement-name */ 373)
	    , Unit = __webpack_require__(/*! ./unit */ 381);


	//------//
	// Init //
	//------//

	var Utils = nh.utils
	    , lazy = nh.lazyExtensions;


	//-------------------//
	// Static Extensions //
	//-------------------//

	MeasurementName.VALUES = {
	    HIGH_TEMP: 'high_temperature'
	    , LOW_TEMP: 'low_temperature'
	    , MEAN_WIND_SPEED: 'mean_wind_speed'
	};

	MeasurementName.SYMBOLS = {
	    METRIC_TEMP: 'C'
	    , METRIC_WIND_SPEED: 'km/h'
	};

	MeasurementName.NICE = {};
	MeasurementName.NICE[MeasurementName.VALUES.HIGH_TEMP] = 'high temperature';
	MeasurementName.NICE[MeasurementName.VALUES.LOW_TEMP] = 'low temperature';
	MeasurementName.NICE[MeasurementName.VALUES.MEAN_WIND_SPEED] = 'mean wind speed';

	MeasurementName.SYMBOLS_PER_VALUE = {};
	MeasurementName.SYMBOLS_PER_VALUE[MeasurementName.VALUES.HIGH_TEMP] = MeasurementName.SYMBOLS.METRIC_TEMP;
	MeasurementName.SYMBOLS_PER_VALUE[MeasurementName.VALUES.LOW_TEMP] = MeasurementName.SYMBOLS.METRIC_TEMP;
	MeasurementName.SYMBOLS_PER_VALUE[MeasurementName.VALUES.MEAN_WIND_SPEED] = MeasurementName.SYMBOLS.METRIC_WIND_SPEED;

	//-----------------------//
	// Prototyped Extensions //
	//-----------------------//

	MeasurementName.prototype.NiceValue = function NiceValue() {
	    return MeasurementName.NICE[this.Value()];
	};

	MeasurementName.prototype.Symbol = function Symbol() {
	    return MeasurementName.SYMBOLS_PER_VALUE[this.Value()];
	};


	//-------------------------------//
	// Private Prototyped Extensions //
	//-------------------------------//

	MeasurementName.prototype._deserialize = function _deserialize(jsonData, my) {
	    var self = this;

	    if (!Utils.instance_of(jsonData, Object)) {
	        throw new Error("Invalid Argument: <MeasurementName>._deserialize requires jsonData to be an instance_of Object");
	    }

	    var allKeysMatch = lazy(Object.keys(jsonData))
	        .every(function(aKey) {
	            return Utils.in_array(aKey, Object.keys(my));
	        });

	    if (!allKeysMatch) {
	        throw new Error("Invalid Argument: <MeasurementName>._deserialize requires jsonData to be an object whose enumerable keys match MeasurementName's members");
	    }

	    // jsonData is valid - build from it
	    Object.keys(jsonData).forEach(function(aKey) {
	        switch (aKey) {
	            case 'Unit':
	                self.Unit(new Unit(jsonData[aKey]));
	                break;
	            default:
	                self[aKey](jsonData[aKey]);
	                break;
	        }
	    });
	};

	//------//
	// Mock //
	//------//

	function createMockMeasurementName(aUnit) {
	    return new MeasurementName()
	        .MeasurementNameID('1')
	        .Value(MeasurementName.VALUES.HIGH_TEMP)
	        .Unit(aUnit);
	}


	//---------//
	// Exports //
	//---------//

	module.exports = MeasurementName;
	module.exports.createMockMeasurementName = createMockMeasurementName;


/***/ },
/* 381 */
/*!**************************************!*\
  !*** ./db/models/extensions/unit.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';


	//--------//
	// Import //
	//--------//

	var nh = __webpack_require__(/*! node-helpers */ 90)
	    , Unit = __webpack_require__(/*! ../unit */ 374);


	//------//
	// Init //
	//------//

	var Utils = nh.utils
	    , lazy = nh.lazyExtensions;


	//-------------------//
	// Static Extensions //
	//-------------------//

	Unit.NAMES = {
	    CELSIUS: 'celsius'
	    , KPH: 'kilometers_per_hour'
	};


	//-------------------------------//
	// Private Prototyped Extensions //
	//-------------------------------//

	Unit.prototype._deserialize = function _deserialize(jsonData, my) {
	    var self = this;

	    if (!Utils.instance_of(jsonData, Object)) {
	        throw new Error("Invalid Argument: <Unit>._deserialize requires jsonData to be an instance_of Object");
	    }

	    var allKeysMatch = lazy(Object.keys(jsonData))
	        .every(function(aKey) {
	            return Utils.in_array(aKey, Object.keys(my));
	        });

	    if (!allKeysMatch) {
	        throw new Error("Invalid Argument: <Unit>._deserialize requires jsonData to be an object whose enumerable keys match Unit's members");
	    }

	    // jsonData is valid - build from it
	    Object.keys(jsonData).forEach(function(aKey) {
	        self[aKey](jsonData[aKey]);
	    });
	};


	//------//
	// Mock //
	//------//

	function createMockUnit() {
	    return new Unit()
	        .UnitID('1')
	        .Name(Unit.NAMES.CELSIUS);
	}


	//---------//
	// Exports //
	//---------//

	module.exports = Unit;
	module.exports.createMockUnit = createMockUnit;


/***/ },
/* 382 */
/*!*******************************!*\
  !*** ./db/models/dal/data.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';


	//---------//
	// Imports //
	//---------//

	var YMD = __webpack_require__(/*! ../extensions/ymd */ 378)
	    , Source = __webpack_require__(/*! ../extensions/source */ 377)
	    , nh = __webpack_require__(/*! node-helpers */ 90)
	    , moment = __webpack_require__(/*! moment */ 209)
	    , bPromise = __webpack_require__(/*! bluebird */ 93);


	//------//
	// Init //
	//------//

	var PGWrapper = nh.psqlWrapper.PGWrapper
	    , Utils = nh.utils
	    , lazy = nh.lazyExtensions
	    , Data = __webpack_require__(/*! ../extensions/data */ 375)
	    , DALType = __webpack_require__(/*! ./type */ 383)
	    , DALSource = __webpack_require__(/*! ./source */ 384)
	    , DALymd = __webpack_require__(/*! ./ymd */ 385)
	    , DALLocation = __webpack_require__(/*! ./location */ 386);


	//-------//
	// Main	 //
	//-------//

	function DALData(aPGWrapper) {
	    if (!Utils.instance_of(aPGWrapper, PGWrapper)) {
	        throw new Error("Invalid Argument: DALDataPoint constructor expects an instance_of PGWrapper");
	    }
	    this.pgWrapperInstance = aPGWrapper;

	    this.dalTypeInstance = new DALType(aPGWrapper);
	    this.dalSourceInstance = new DALSource(aPGWrapper);
	    this.dalYMDInstance = new DALymd(aPGWrapper);
	    this.dalLocationInstance = new DALLocation(aPGWrapper);
	}


	//-------------------//
	// Static Extensions //
	//-------------------//

	DALData.getDataFromRow = function getDataFromRow(row) {
	    return new Data()
	        .DataID(row.weather_data_id)
	        .Type(DALType.getTypeFromRow(row))
	        .Source(DALSource.getSourceFromRow(row))
	        .YMD(DALymd.getYmdFromRow(row))
	        .Location(DALLocation.getLocationFromRow(row));
	};


	//-----------------------//
	// Prototyped Extensions //
	//-----------------------//

	DALData.prototype.getDataFromID = function getDataFromID(aDataID) {
	    if (typeof aDataID !== 'string') {
	        throw new Error("Invalid Argument: <DALData>.getDataFromID requires a typeof string argument");
	    }

	    var queryText = "\
			select * \
			from weather_data wd \
				join weather_data_type wdt \
					on wd.weather_data_type_id = wdt.weather_data_type_id \
				join weather_source wds \
					on wd.weather_data_source_id = wds.weather_source_id \
				join weather_date wda \
					on wd.weather_data_date_id = wda.weather_date_id \
				join weather_location wl \
					on wd.weather_data_location_id = wl.weather_location_id \
			where wd.weather_data_id = $1 \
		";

	    var queryValues = [
	        aDataID
	    ];

	    return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	        .then(function(res) {
	            return DALData.getDataFromRow(res.rows[0]);
	        });
	};

	DALData.prototype.getDataBetweenDates = function getDataBetweenDates(date1, date2) {
	    if (Utils.instance_of(date1, Date)) {
	        date1 = moment(date1).format('YYYYMMDD');
	    }
	    if (Utils.instance_of(date2, Date)) {
	        date2 = moment(date2).format('YYYYMMDD');
	    }

	    if (YMD.ValidateValue(date1) || YMD.ValidateValue(date2)) {
	        throw new Error("Invalid Argument: <DALData>.getDataBetweenDates requires two arguments that are either typeof string in the format (YYYYMMDD) or an instance_of date");
	    }

	    var queryText = "\
			select * \
			from weather_data wd \
				join weather_data_type wdt \
					on wd.weather_data_type_id = wdt.weather_data_type_id \
				join weather_source wds \
					on wd.weather_data_source_id = wds.weather_source_id \
				join weather_date wda \
					on wd.weather_data_date_id = wda.weather_date_id \
				join weather_location wl \
					on wd.weather_data_location_id = wl.weather_location_id \
			where wda.weather_date_value between $1 and $2 \
		";

	    var queryValues = [
	        date1
	        , date2
	    ];

	    return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	        .then(function(res) {
	            return lazy(res.rows)
	                .map(function(row) {
	                    return DALData.getDataFromRow(row);
	                });
	        });
	};

	DALData.prototype.getDataBetweenDatesFromSource = function getDataBetweenDatesFromSource(date1, date2, aSource) {
	    if (Utils.instance_of(date1, Date)) {
	        date1 = moment(date1).format('YYYYMMDD');
	    }
	    if (Utils.instance_of(date2, Date)) {
	        date2 = moment(date2).format('YYYYMMDD');
	    }

	    if (YMD.ValidateValue(date1) || YMD.ValidateValue(date2)) {
	        throw new Error("Invalid Argument: <DALData>.getDataBetweenDatesFromSource requires the first two arguments be either typeof string in the format (YYYYMMDD) or an instance_of date");
	    }

	    if (Utils.instance_of(aSource, Source)) {
	        aSource = aSource.SourceID();
	    }
	    if (typeof aSource !== 'string') {
	        throw new Error("Invalid Argument: <DALData>.getDataBetweenDatesFromSource requires the third argument be either typeof string or an instance_of Source");
	    }

	    var queryText = "\
			select * \
			from weather_data wd \
				join weather_data_type wdt \
					on wd.weather_data_type_id = wdt.weather_data_type_id \
				join weather_source wds \
					on wd.weather_data_source_id = wds.weather_source_id \
				join weather_date wda \
					on wd.weather_data_date_id = wda.weather_date_id \
				join weather_location wl \
					on wd.weather_data_location_id = wl.weather_location_id \
			where wda.weather_date_value between $1 and $2 \
				and wd.weather_data_source_id = $3 \
		";

	    var queryValues = [
	        date1
	        , date2
	        , aSource
	    ];

	    return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	        .then(function(res) {
	            return lazy(res.rows)
	                .map(function(row) {
	                    return DALData.getDataFromRow(row);
	                });
	        });
	};

	DALData.prototype.insert = function insert(aData) {
	    var self = this;

	    if (!Utils.instance_of(aData, Data)) {
	        throw new Error("Invalid Argument: <DALData>.insert requires instance_of Data");
	    }

	    var bInsertedType
	        , bInsertedSource
	        , bInsertedYMD
	        , bInsertedLocation;

	    bInsertedType = (aData.Type().TypeID() === null)
	        ? self.dalTypeInstance.insert(aData.Type())
	        : bPromise.resolve(aData.Type());

	    bInsertedSource = (aData.Source().SourceID() === null)
	        ? self.dalSourceInstance.insert(aData.Source())
	        : bPromise.resolve(aData.Source());

	    bInsertedYMD = (aData.YMD().YMDid() === null)
	        ? self.dalYMDInstance.insert(aData.YMD())
	        : bPromise.resolve(aData.YMD());

	    bInsertedLocation = (aData.Location().LocationID() === null)
	        ? self.dalLocationInstance.insert(aData.Location())
	        : bPromise.resolve(aData.Location());

	    return bPromise.resolve([
	            bInsertedType
	            , bInsertedSource
	            , bInsertedYMD
	            , bInsertedLocation
	            , aData
	        ])
	        .spread(function(resType, resSource, resYMD, resLocation, resData) {
	            resData.Type(resType)
	                .Source(resSource)
	                .YMD(resYMD)
	                .Location(resLocation);

	            var queryText = "\
					insert into weather_data (weather_data_type_id, weather_data_source_id, weather_data_date_id, weather_data_location_id) \
					values ($1, $2, $3, $4) \
					returning weather_data_id \
				";

	            var queryValues = [
	                resType.TypeID()
	                , resSource.SourceID()
	                , resYMD.YMDid()
	                , resLocation.LocationID()
	            ];

	            return [
	                self.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	                , resData
	            ];
	        })
	        .spread(function(resInsert, resData) {
	            return resData.DataID(resInsert.rows[0].weather_data_id);
	        });
	};

	DALData.prototype.deleteByID = function deleteByID(aDataID, shouldDeleteSingle) {
	    if (typeof aDataID !== 'string') {
	        throw new Error("Invalid Argument: <DALData>.deleteByID requires a typeof string argument");
	    }

	    var queryText = "\
			delete from weather_data \
			where weather_data_id = $1 \
		";

	    var queryValues = [
	        aDataID
	    ];

	    return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	        .then(function(res) {
	            if (shouldDeleteSingle && res.rowCount !== 1) {
	                throw new Error("Invalid Argument: <DALData>.deleteByID expected to delete a single record.  Instead '" + res.rowCount + "' were deleted");
	            }
	        });
	};


	//---------//
	// Exports //
	//---------//

	module.exports = DALData;


/***/ },
/* 383 */
/*!*******************************!*\
  !*** ./db/models/dal/type.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	//---------//
	// Imports //
	//---------//

	var Type = __webpack_require__(/*! ../type */ 369)
	    , nh = __webpack_require__(/*! node-helpers */ 90);


	//------//
	// Init //
	//------//

	var PGWrapper = nh.psqlWrapper.PGWrapper
	    , Utils = nh.utils
	    , lazy = nh.lazyExtensions;


	//-------------//
	// Constructor //
	//-------------//

	function DALType(aPGWrapper) {
	    if (!Utils.instance_of(aPGWrapper, PGWrapper)) {
	        throw new Error("Invalid Argument: DALType constructor expects an instance_of PGWrapper");
	    }
	    this.pgWrapperInstance = aPGWrapper;
	}


	//-------------------//
	// Static Extensions //
	//-------------------//

	DALType.getTypeFromRow = function getTypeFromRow(row) {
	    return new Type()
	        .TypeID(row.weather_data_type_id)
	        .Name(row.weather_data_type_name);
	};


	//-----------------------//
	// Prototyped Extensions //
	//-----------------------//

	DALType.prototype.getTypeFromID = function getTypeFromID(aTypeID) {
	    if (typeof aTypeID !== 'string') {
	        throw new Error("Invalid Argument: <DALType>.getTypeFromID requires a typeof string argument");
	    }

	    var queryText = "\
			select * \
			from weather_data_type wdt \
			where wdt.weather_data_type_id = $1 \
		";

	    var queryValues = [
	        aTypeID
	    ];

	    return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	        .then(function(res) {
	            return DALType.getTypeFromRow(res.rows[0]);
	        });
	};

	DALType.prototype.getTypeFromName = function getTypeFromName(aTypeName) {
	    if (typeof aTypeName !== 'string') {
	        throw new Error("Invalid Argument: <DALType>.getTypeFromName requires a typeof string argument");
	    }

	    var queryText = "\
			select * \
			from weather_data_type wdt \
			where wdt.weather_data_type_name = $1 \
		";

	    var queryValues = [
	        aTypeName
	    ];

	    return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	        .then(function(res) {
	            return DALType.getTypeFromRow(res.rows[0]);
	        });
	};

	DALType.prototype.getAllTypes = function getAllTypes() {
	    var queryText = "select * from weather_data_type";

	    return this.pgWrapperInstance.RunQuery(queryText)
	        .then(function(res) {
	            return lazy(res.rows)
	                .map(function(row) {
	                    return DALType.getTypeFromRow(row);
	                });
	        });
	};

	DALType.prototype.getClientOptionTypes = function getAllTypes() {
	    var queryText = "\
			select * \
			from weather_data_type \
			where weather_data_type_name <> 'actual' \
		";

	    return this.pgWrapperInstance.RunQuery(queryText)
	        .then(function(res) {
	            return lazy(res.rows)
	                .map(function(row) {
	                    return DALType.getTypeFromRow(row);
	                });
	        });
	};

	DALType.prototype.insert = function insert(aType) {
	    if (!Utils.instance_of(aType, Type)) {
	        throw new Error("Invalid Argument: <DALType>.insert requires instance_of Type");
	    }

	    var queryText = "\
			insert into weather_data_type (weather_data_type_name) \
			values ($1) \
			returning weather_data_type_id \
		";

	    var queryValues = [
	        aType.Name()
	    ];

	    return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	        .then(function(res) {
	            return aType.TypeID(res.rows[0].weather_data_type_id);
	        });
	};

	DALType.prototype.deleteByID = function deleteByID(aTypeID, shouldDeleteSingle) {
	    if (typeof aTypeID !== 'string') {
	        throw new Error("Invalid Argument: <DALType>.deleteByID requires a typeof string argument");
	    }

	    var queryText = "\
			delete from weather_data_type \
			where weather_data_type_id = $1 \
		";

	    var queryValues = [
	        aTypeID
	    ];

	    return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	        .then(function(res) {
	            if (shouldDeleteSingle && res.rowCount !== 1) {
	                throw new Error("Invalid Argument: <DALType>.deleteByID expected to delete a single record.  Instead '" + res.rowCount + "' were deleted");
	            }
	        });
	};

	DALType.prototype.deleteByName = function deleteByName(aTypeName, shouldDeleteSingle) {
	    if (typeof aTypeName !== 'string') {
	        throw new Error("Invalid Argument: <DALType>.deleteByName requires a typeof string argument");
	    }

	    var queryText = "\
			delete from weather_data_type \
			where weather_data_type_name = $1 \
		";

	    var queryValues = [
	        aTypeName
	    ];

	    return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	        .then(function(res) {
	            if (shouldDeleteSingle && res.rowCount !== 1) {
	                throw new Error("Invalid Argument: <DALType>.deleteByName expected to delete a single record.  Instead '" + res.rowCount + "' were deleted");
	            }
	        });
	};


	//---------//
	// Exports //
	//---------//

	module.exports = DALType;


/***/ },
/* 384 */
/*!*********************************!*\
  !*** ./db/models/dal/source.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	//---------//
	// Imports //
	//---------//

	var Source = __webpack_require__(/*! ../source */ 370)
	    , nh = __webpack_require__(/*! node-helpers */ 90);


	//------//
	// Init //
	//------//

	var PGWrapper = nh.psqlWrapper.PGWrapper
	    , Utils = nh.utils
	    , lazy = nh.lazyExtensions;


	//-------------//
	// Constructor //
	//-------------//

	function DALSource(aPGWrapper) {
	    if (!Utils.instance_of(aPGWrapper, PGWrapper)) {
	        throw new Error("Invalid Argument: DALSource constructor expects an instance_of PGWrapper");
	    }
	    this.pgWrapperInstance = aPGWrapper;
	}


	//-------------------//
	// Static Extensions //
	//-------------------//

	DALSource.getSourceFromRow = function getSourceFromRow(row) {
	    return new Source()
	        .SourceID(row.weather_source_id)
	        .Name(row.weather_source_name);
	};


	//-----------------------//
	// Prototyped Extensions //
	//-----------------------//

	DALSource.prototype.getSourceFromID = function getSourceFromID(aSourceID) {
	    if (typeof aSourceID !== 'string') {
	        throw new Error("Invalid Argument: <DALSource>.getSourceFromID requires a typeof string argument");
	    }

	    var queryText = "\
			select * \
			from weather_source ws \
			where ws.weather_source_id = $1 \
		";

	    var queryValues = [
	        aSourceID
	    ];

	    return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	        .then(function(res) {
	            return DALSource.getSourceFromRow(res.rows[0]);
	        });
	};

	DALSource.prototype.getSourceFromName = function getSourceFromName(aSourceName) {
	    if (typeof aSourceName !== 'string') {
	        throw new Error("Invalid Argument: <DALSource>.getSourceFromName requires a typeof string argument");
	    }

	    var queryText = "\
			select * \
			from weather_source ws \
			where ws.weather_source_name = $1 \
		";

	    var queryValues = [
	        aSourceName
	    ];

	    return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	        .then(function(res) {
	            return DALSource.getSourceFromRow(res.rows[0]);
	        });
	};

	DALSource.prototype.getAllSources = function getAllSources() {
	    var queryText = "select * from weather_source";

	    return this.pgWrapperInstance.RunQuery(queryText)
	        .then(function(res) {
	            return lazy(res.rows)
	                .map(function(row) {
	                    return DALSource.getSourceFromRow(row);
	                });
	        });
	};

	DALSource.prototype.insert = function insert(aSource) {
	    if (!Utils.instance_of(aSource, Source)) {
	        throw new Error("Invalid Argument: <DALSource>.insert requires instance_of Source");
	    }

	    var queryText = "\
			insert into weather_source (weather_source_name) \
			values ($1) \
			returning weather_source_id \
		";

	    var queryValues = [
	        aSource.Name()
	    ];

	    return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	        .then(function(res) {
	            return aSource.SourceID(res.rows[0].weather_source_id);
	        });
	};

	DALSource.prototype.deleteByID = function deleteByID(aSourceID, shouldDeleteSingle) {
	    if (typeof aSourceID !== 'string') {
	        throw new Error("Invalid Argument: <DALSource>.deleteByID requires a typeof string argument");
	    }

	    var queryText = "\
			delete from weather_source \
			where weather_source_id = $1 \
		";

	    var queryValues = [
	        aSourceID
	    ];

	    return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	        .then(function(res) {
	            if (shouldDeleteSingle && res.rowCount !== 1) {
	                throw new Error("Invalid Argument: <DALSource>.deleteByID expected to delete a single record.  Instead '" + res.rowCount + "' were deleted");
	            }
	        });
	};

	DALSource.prototype.deleteByName = function deleteByName(aSourceName, shouldDeleteSingle) {
	    if (typeof aSourceName !== 'string') {
	        throw new Error("Invalid Argument: <DALSource>.deleteByName requires a typeof string argument");
	    }

	    var queryText = "\
			delete from weather_source \
			where weather_source_name = $1 \
		";

	    var queryValues = [
	        aSourceName
	    ];

	    return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	        .then(function(res) {
	            if (shouldDeleteSingle && res.rowCount !== 1) {
	                throw new Error("Invalid Argument: <DALSource>.deleteByName expected to delete a single record.  Instead '" + res.rowCount + "' were deleted");
	            }
	        });
	};


	//---------//
	// Exports //
	//---------//

	module.exports = DALSource;


/***/ },
/* 385 */
/*!******************************!*\
  !*** ./db/models/dal/ymd.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';


	//---------//
	// Imports //
	//---------//

	var YMD = __webpack_require__(/*! ../extensions/ymd */ 378)
	  , nh = __webpack_require__(/*! node-helpers */ 90)
	  , moment = __webpack_require__(/*! moment */ 209);


	//------//
	// Init //
	//------//

	var PGWrapper = nh.psqlWrapper.PGWrapper
	  , Utils = nh.utils
	  , lazy = nh.lazyExtensions;


	//-------------//
	// Constructor //
	//-------------//

	function DALymd(aPGWrapper) {
	  if (!Utils.instance_of(aPGWrapper, PGWrapper)) {
	    throw new Error("Invalid Argument: DALymd constructor expects an instance_of PGWrapper");
	  }
	  this.pgWrapperInstance = aPGWrapper;
	}


	//-------------------//
	// Static Extensions //
	//-------------------//

	DALymd.getYmdFromRow = function getYmdFromRow(row) {
	  return new YMD()
	    .YMDid(row.weather_date_id)
	    .Value(row.weather_date_value);
	};


	//-----------------------//
	// Prototyped Extensions //
	//-----------------------//

	DALymd.prototype.getAllYMDs = function getAllYMDs() {
	  var queryText = "select * from weather_date";

	  return this.pgWrapperInstance.RunQuery(queryText)
	    .then(function(res) {
	      return lazy(res.rows)
	        .map(function(row) {
	          return DALymd.getYmdFromRow(row);
	        });
	    });
	};

	DALymd.prototype.getYmdsFromDate = function getYmdsFromDate(aDate) {
	  if (Utils.instance_of(aDate, Date)) {
	    aDate = moment(aDate).format('YYYYMMDD');
	  }

	  if (YMD.ValidateValue(aDate)) {
	    throw new Error("Invalid Argument: <DALymd>.getYmdsFromDate requires either a typeof string in the format (YYYYMMDD) or an instance_of Date");
	  }

	  var queryText = `
			select *
			from weather_date wd
			where wd.weather_date_value >= $1
		`;

	  var queryValues = [
	    aDate
	  ];

	  return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	    .then(function(res) {
	      return lazy(res.rows)
	        .map(function(row) {
	          return DALymd.getYmdFromRow(row);
	        });
	    });
	};

	DALymd.prototype.getYmdFromID = function getYmdFromID(aYmdID) {
	  if (typeof aYmdID !== 'string') {
	    throw new Error("Invalid Argument: <DALymd>.getYmdFromID requires a typeof string argument");
	  }

	  var queryText = `
			select *
			from weather_date wd
			where wd.weather_date_id = $1
		`;

	  var queryValues = [
	    aYmdID
	  ];

	  return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	    .then(function(res) {
	      return DALymd.getYmdFromRow(res.rows[0]);
	    });
	};

	DALymd.prototype.getYmdFromValue = function getYmdFromValue(aYmdValue) {
	  if (typeof aYmdValue !== 'string') {
	    throw new Error("Invalid Argument: <DALymd>.getYmdFromValue requires a typeof string argument");
	  }

	  var queryText = `
			select *
			from weather_date wd
			where wd.weather_date_value = $1
		`;

	  var queryValues = [
	    aYmdValue
	  ];

	  return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	    .then(function(res) {
	      return DALymd.getYmdFromRow(res.rows[0]);
	    });
	};

	DALymd.prototype.getYmdRangeWithFullData = function getYmdRangeWithFullData() {
	  var queryText = `
			select min(wda.weather_date_value) as min
				, max(wda.weather_date_value) as max
			from weather_date wda
			where (
					select count(*)
					from weather_data_type
				) * (
					select count(*)
					from weather_source
				) * (
					select count(*)
					from weather_location
				) = (
					select count(*)
					from weather_data wd
					where wd.weather_data_date_id = wda.weather_date_id
				)
		`;

	  return this.pgWrapperInstance.RunQuery(queryText)
	    .then(function(res) {
	      var min = new YMD().Value(res.rows[0].min);
	      var max = new YMD().Value(res.rows[0].max);
	      return {
	        min: min
	        , max: max
	      };
	    });
	};

	DALymd.prototype.insert = function insert(aYMD) {
	  if (!Utils.instance_of(aYMD, YMD)) {
	    throw new Error("Invalid Argument: <DALymd>.insert requires instance_of YMD");
	  }

	  var queryText = `
			insert into weather_date (weather_date_value)
			values ($1)
			returning weather_date_id
		`;

	  var queryValues = [
	    aYMD.Value()
	  ];

	  return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	    .then(function(res) {
	      return aYMD.YMDid(res.rows[0].weather_date_id);
	    });
	};

	DALymd.prototype.deleteByID = function deleteByID(aYmdID, shouldDeleteSingle) {
	  if (typeof aYmdID !== 'string') {
	    throw new Error("Invalid Argument: <DALymd>.deleteByID requires a typeof string argument");
	  }

	  var queryText = `
			delete from weather_date
			where weather_date_id = $1
		`;

	  var queryValues = [ aYmdID ];

	  return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	    .then(function(res) {
	      if (shouldDeleteSingle && res.rowCount !== 1) {
	        throw new Error("Invalid Argument: <DALymd>.deleteByID expected to delete a single record.  Instead '" + res.rowCount + "' were deleted");
	      }
	    });
	};

	DALymd.prototype.deleteByValue = function deleteByValue(aYmdValue, shouldDeleteSingle) {
	  if (typeof aYmdValue !== 'string') {
	    throw new Error("Invalid Argument: <DALymd>.deleteByValue requires a typeof string argument");
	  }

	  var queryText = `
			delete from weather_date
			where weather_date_value = $1
		`;

	  var queryValues = [
	    aYmdValue
	  ];

	  return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	    .then(function(res) {
	      if (shouldDeleteSingle && res.rowCount !== 1) {
	        throw new Error("Invalid Argument: <DALymd>.deleteByValue expected to delete a single record.  Instead '" + res.rowCount + "' were deleted");
	      }
	    });
	};


	//---------//
	// Exports //
	//---------//

	module.exports = DALymd;


/***/ },
/* 386 */
/*!***********************************!*\
  !*** ./db/models/dal/location.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	//---------//
	// Imports //
	//---------//

	var Location = __webpack_require__(/*! ../location */ 372)
	    , nh = __webpack_require__(/*! node-helpers */ 90)
	    , bPromise = __webpack_require__(/*! bluebird */ 93);


	//------//
	// Init //
	//------//

	var PGWrapper = nh.psqlWrapper.PGWrapper
	    , Utils = nh.utils
	    , lazy = nh.lazyExtensions;


	//-------------//
	// Constructor //
	//-------------//

	function DALLocation(aPGWrapper) {
	    if (!Utils.instance_of(aPGWrapper, PGWrapper)) {
	        throw new Error("Invalid Argument: DALLocation constructor expects an instance_of PGWrapper");
	    }
	    this.pgWrapperInstance = aPGWrapper;
	}


	//-------------------//
	// Static Extensions //
	//-------------------//

	DALLocation.getLocationFromRow = function getLocationFromRow(row) {
	    return new Location()
	        .LocationID(row.weather_location_id)
	        .Latitude(row.weather_location_latitude)
	        .Longitude(row.weather_location_longitude)
	        .Name(row.weather_location_name)
	        .TZ(row.weather_location_tz);
	};


	//-----------------------//
	// Prototyped Extensions //
	//-----------------------//

	DALLocation.prototype.getLocationFromID = function getLocationFromID(aLocationID) {
	    if (typeof aLocationID !== 'string') {
	        throw new Error("Invalid Argument: <DALLocation>.getLocationFromID requires a typeof string argument");
	    }

	    var queryText = "\
			select * \
			from weather_location wl \
			where wl.weather_location_id = $1 \
		";

	    var queryValues = [
	        aLocationID
	    ];

	    return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	        .then(function(res) {
	            return DALLocation.getLocationFromRow(res.rows[0]);
	        });
	};

	DALLocation.prototype.getLocationFromLatLong = function getLocationFromLatLong(aLatitude, aLongitude) {
	    var lat, long;

	    // if more than one argument, then both lat and long were passed
	    if (arguments.length > 1) {
	        if (typeof aLatitude !== 'string' || typeof aLongitude !== 'string') {
	            throw new Error("Invalid Argument(s): <DALLocation>.getLocationFromLatLong requires two typeof string arguments or an instance_of Location");
	        }
	        lat = aLatitude;
	        long = aLongitude;
	    } else { // otherwise a Location object should have been passed in
	        if (!Utils.instance_of(aLatitude, Location)) {
	            throw new Error("Invalid Argument(s): <DALLocation>.getLocationFromLatLong requires two typeof string arguments or an instance_of Location");
	        }
	        lat = aLatitude.Latitude();
	        long = aLatitude.Longitude();
	    }

	    var queryText = "\
			select * \
			from weather_location wl \
			where wl.weather_location_latitude = $1 \
				and wl.weather_location_longitude = $2 \
		";

	    var queryValues = [
	        lat
	        , long
	    ];

	    return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	        .then(function(res) {
	            return DALLocation.getLocationFromRow(res.rows[0]);
	        });
	};

	DALLocation.prototype.getAllLocations = function getAllLocations() {
	    var queryText = "select * from weather_location";

	    return this.pgWrapperInstance.RunQuery(queryText)
	        .then(function(res) {
	            return lazy(res.rows)
	                .map(function(row) {
	                    return DALLocation.getLocationFromRow(row);
	                });
	        });
	};

	DALLocation.prototype.insert = function insert(aLocation) {
	    if (!Utils.instance_of(aLocation, Location)) {
	        throw new Error("Invalid Argument: <DALLocation>.insert requires instance_of Location");
	    }

	    var queryText = "\
			insert into weather_location (weather_location_latitude, weather_location_longitude, weather_location_name, weather_location_tz) \
			values ($1, $2, $3, $4) \
			returning weather_location_id \
		";

	    var queryValues = [
	        aLocation.Latitude()
	        , aLocation.Longitude()
	        , aLocation.Name()
	        , aLocation.TZ()
	    ];

	    return bPromise.resolve([
	            this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	            , aLocation
	        ])
	        .spread(function(resInsert, resLocation) {
	            return resLocation.LocationID(resInsert.rows[0].weather_location_id);
	        });
	};

	DALLocation.prototype.deleteByID = function deleteByID(aLocationID, shouldDeleteSingle) {
	    if (typeof aLocationID !== 'string') {
	        throw new Error("Invalid Argument: <DALLocation>.deleteByID requires a typeof string argument");
	    }

	    var queryText = "\
			delete from weather_location \
			where weather_location_id = $1 \
		";

	    var queryValues = [
	        aLocationID
	    ];

	    return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	        .then(function(res) {
	            if (shouldDeleteSingle && res.rowCount !== 1) {
	                throw new Error("Invalid Argument: <DALLocation>.deleteByID expected to delete a single record.  Instead '" + res.rowCount + "' were deleted");
	            }
	        });
	};

	DALLocation.prototype.deleteByLatLong = function deleteByLatLong(aLatitude, aLongitude, shouldDeleteSingle) {
	    var lat, long;

	    // if more than one argument, then both lat and long were passed
	    if (typeof aLatitude === 'string' && typeof aLongitude === 'string') {
	        if (typeof aLatitude !== 'string' || typeof aLongitude !== 'string') {
	            throw new Error("Invalid Argument(s): <DALLocation>.deleteByLatLong requires two typeof string arguments or an instance_of Location");
	        }
	        lat = aLatitude;
	        long = aLongitude;
	    } else { // otherwise a Location object should have been passed in
	        if (!Utils.instance_of(aLatitude, Location)) {
	            throw new Error("Invalid Argument(s): <DALLocation>.deleteByLatLong requires two typeof string arguments or an instance_of Location");
	        }
	        lat = aLatitude.Latitude();
	        long = aLatitude.Longitude();
	    }

	    var queryText = "\
			delete from weather_location \
			where weather_location_latitude = $1 \
				and weather_location_longitude = $2 \
		";

	    var queryValues = [
	        lat
	        , long
	    ];

	    return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	        .then(function(res) {
	            if (shouldDeleteSingle && res.rowCount !== 1) {
	                throw new Error("Invalid Argument: <DALLocation>.deleteByLatLong expected to delete a single record.  Instead '" + res.rowCount + "' were deleted");
	            }
	        });
	};


	//---------//
	// Exports //
	//---------//

	module.exports = DALLocation;


/***/ },
/* 387 */
/*!*******************************************!*\
  !*** ./db/models/dal/measurement-name.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	//---------//
	// Imports //
	//---------//

	var MeasurementName = __webpack_require__(/*! ../measurement-name */ 373)
	    , DALUnit = __webpack_require__(/*! ./unit */ 388)
	    , nh = __webpack_require__(/*! node-helpers */ 90)
	    , bPromise = __webpack_require__(/*! bluebird */ 93);


	//------//
	// Init //
	//------//

	var PGWrapper = nh.psqlWrapper.PGWrapper
	    , Utils = nh.utils
	    , lazy = nh.lazyExtensions;


	//-------------//
	// Constructor //
	//-------------//

	function DALMeasurementName(aPGWrapper) {
	    if (!Utils.instance_of(aPGWrapper, PGWrapper)) {
	        throw new Error("Invalid Argument: DALMeasurementName constructor requires an instance_of PGWrapper");
	    }
	    this.dalUnitInstance = new DALUnit(aPGWrapper);
	    this.pgWrapperInstance = aPGWrapper;
	}


	//-------------------//
	// Static Extensions //
	//-------------------//

	DALMeasurementName.getMeasurementNameFromRow = function getMeasurementNameFromRow(row) {
	    return new MeasurementName()
	        .MeasurementNameID(row.weather_data_point_name_id)
	        .Unit(DALUnit.getUnitFromRow(row))
	        .Value(row.weather_data_point_name_value);
	};


	//-----------------------//
	// Prototyped Extensions //
	//-----------------------//

	DALMeasurementName.prototype.getMeasurementNameFromID = function getMeasurementNameFromID(aMeasurementNameID) {
	    if (typeof aMeasurementNameID !== 'string') {
	        throw new Error("Invalid Argument: <DALMeasurementName>.getMeasurementNameFromID requires a typeof string argument");
	    }

	    var queryText = "\
			select * \
			from weather_data_point_name wdn \
				join weather_data_point_unit wdu \
					on wdn.weather_data_point_name_unit_id = wdu.weather_data_point_unit_id \
			where wdn.weather_data_point_name_id = $1 \
		";

	    var queryValues = [
	        aMeasurementNameID
	    ];

	    return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	        .then(function(res) {
	            return DALMeasurementName.getMeasurementNameFromRow(res.rows[0]);
	        });
	};

	DALMeasurementName.prototype.getMeasurementNameFromValue = function getMeasurementNameFromValue(aMeasurementNameValue) {
	    if (typeof aMeasurementNameValue !== 'string') {
	        throw new Error("Invalid Argument: <DALMeasurementName>.getMeasurementNameFromValue requires a typeof string argument");
	    }

	    var queryText = "\
			select * \
			from weather_data_point_name wdn \
				join weather_data_point_unit wdu \
					on wdn.weather_data_point_name_unit_id = wdu.weather_data_point_unit_id \
			where wdn.weather_data_point_name_value = $1 \
		";

	    var queryValues = [
	        aMeasurementNameValue
	    ];

	    return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	        .then(function(res) {
	            return DALMeasurementName.getMeasurementNameFromRow(res.rows[0]);
	        });
	};

	DALMeasurementName.prototype.getAllMeasurementNames = function getAllMeasurementNames() {
	    var queryText = "\
			select * \
			from weather_data_point_name wdn \
				join weather_data_point_unit wdu \
					on wdn.weather_data_point_name_unit_id = wdu.weather_data_point_unit_id \
		";

	    return this.pgWrapperInstance.RunQuery(queryText)
	        .then(function(res) {
	            return lazy(res.rows)
	                .map(function(row) {
	                    return DALMeasurementName.getMeasurementNameFromRow(row);
	                });
	        });
	};

	DALMeasurementName.prototype.insert = function insert(aMeasurementName) {
	    var self = this;

	    if (!Utils.instance_of(aMeasurementName, MeasurementName)) {
	        throw new Error("Invalid Argument: <DALMeasurementName>.insert requires instance_of MeasurementName");
	    }

	    var bInsertedUnit = (aMeasurementName.Unit().UnitID() === null)
	        ? this.dalUnitInstance.insert(aMeasurementName.Unit())
	        : bPromise.resolve(aMeasurementName.Unit());

	    return bInsertedUnit
	        .then(function(resUnit) {
	            aMeasurementName.Unit(resUnit);

	            var queryText = "\
					insert into weather_data_point_name (weather_data_point_name_value, weather_data_point_name_unit_id) \
					values ($1, $2) \
					returning weather_data_point_name_id \
				";

	            var queryValues = [
	                aMeasurementName.Value()
	                , resUnit.UnitID()
	            ];

	            return self.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues);
	        })
	        .then(function(res) {
	            return aMeasurementName.MeasurementNameID(res.rows[0].weather_data_point_name_id);
	        });
	};

	DALMeasurementName.prototype.deleteByID = function deleteByID(aMeasurementNameID, shouldDeleteSingle) {
	    if (typeof aMeasurementNameID !== 'string') {
	        throw new Error("Invalid Argument: <DALMeasurementName>.deleteByID requires a typeof string argument");
	    }

	    var queryText = "\
			delete from weather_data_point_name \
			where weather_data_point_name_id = $1 \
		";

	    var queryValues = [
	        aMeasurementNameID
	    ];

	    return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	        .then(function(res) {
	            if (shouldDeleteSingle && res.rowCount !== 1) {
	                throw new Error("Invalid Argument: <DALMeasurementName>.deleteByID expected to delete a single record.  Instead '" + res.rowCount + "' were deleted");
	            }
	        });
	};

	DALMeasurementName.prototype.deleteByValue = function deleteByValue(aMeasurementNameValue, shouldDeleteSingle) {
	    if (typeof aMeasurementNameValue !== 'string') {
	        throw new Error("Invalid Argument: <DALMeasurementName>.deleteByValue requires a typeof string argument");
	    }

	    var queryText = "\
			delete from weather_data_point_name \
			where weather_data_point_name_value = $1 \
		";

	    var queryValues = [
	        aMeasurementNameValue
	    ];

	    return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	        .then(function(res) {
	            if (shouldDeleteSingle && res.rowCount !== 1) {
	                throw new Error("Invalid Argument: <DALMeasurementName>.deleteByName expected to delete a single record.  Instead '" + res.rowCount + "' were deleted");
	            }
	        });
	};


	//---------//
	// Exports //
	//---------//

	module.exports = DALMeasurementName;


/***/ },
/* 388 */
/*!*******************************!*\
  !*** ./db/models/dal/unit.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	//---------//
	// Imports //
	//---------//

	var Unit = __webpack_require__(/*! ../unit */ 374)
	    , nh = __webpack_require__(/*! node-helpers */ 90);


	//------//
	// Init //
	//------//

	var PGWrapper = nh.psqlWrapper.PGWrapper
	    , Utils = nh.utils
	    , lazy = nh.lazyExtensions;


	//-------------//
	// Constructor //
	//-------------//

	function DALUnit(aPGWrapper) {
	    if (!Utils.instance_of(aPGWrapper, PGWrapper)) {
	        throw new Error("Invalid Argument: DALUnit constructor expects an instance_of PGWrapper");
	    }
	    this.pgWrapperInstance = aPGWrapper;
	}


	//-------------------//
	// Static Extensions //
	//-------------------//

	DALUnit.getUnitFromRow = function getUnitFromRow(row) {
	    return new Unit()
	        .UnitID(row.weather_data_point_unit_id)
	        .Name(row.weather_data_point_unit_name);
	};


	//-----------------------//
	// Prototyped Extensions //
	//-----------------------//

	DALUnit.prototype.getUnitFromID = function getUnitFromID(aUnitID) {
	    if (typeof aUnitID !== 'string') {
	        throw new Error("Invalid Argument: <DALUnit>.getUnitFromID requires a typeof string argument");
	    }

	    var queryText = "\
			select * \
			from weather_data_point_unit ws \
			where ws.weather_data_point_unit_id = $1 \
		";

	    var queryValues = [
	        aUnitID
	    ];

	    return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	        .then(function(res) {
	            return DALUnit.getUnitFromRow(res.rows[0]);
	        });
	};

	DALUnit.prototype.getUnitFromName = function getUnitFromName(aUnitName) {
	    if (typeof aUnitName !== 'string') {
	        throw new Error("Invalid Argument: <DALUnit>.getUnitFromName requires a typeof string argument");
	    }

	    var queryText = "\
			select * \
			from weather_data_point_unit ws \
			where ws.weather_data_point_unit_name = $1 \
		";

	    var queryValues = [
	        aUnitName
	    ];

	    return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	        .then(function(res) {
	            return DALUnit.getUnitFromRow(res.rows[0]);
	        });
	};

	DALUnit.prototype.getAllUnits = function getAllUnits() {
	    var queryText = "select * from weather_data_point_unit";

	    return this.pgWrapperInstance.RunQuery(queryText)
	        .then(function(res) {
	            return lazy(res.rows)
	                .map(function(row) {
	                    return DALUnit.getUnitFromRow(row);
	                });
	        });
	};

	DALUnit.prototype.insert = function insert(aUnit) {
	    if (!Utils.instance_of(aUnit, Unit)) {
	        throw new Error("Invalid Argument: <DALUnit>.insert requires instance_of Unit");
	    }

	    var queryText = "\
			insert into weather_data_point_unit (weather_data_point_unit_name) \
			values ($1) \
			returning weather_data_point_unit_id \
		";

	    var queryValues = [
	        aUnit.Name()
	    ];

	    return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	        .then(function(res) {
	            return aUnit.UnitID(res.rows[0].weather_data_point_unit_id);
	        });
	};

	DALUnit.prototype.deleteByID = function deleteByID(aUnitID, shouldDeleteSingle) {
	    if (typeof aUnitID !== 'string') {
	        throw new Error("Invalid Argument: <DALUnit>.deleteByID requires a typeof string argument");
	    }

	    var queryText = "\
			delete from weather_data_point_unit \
			where weather_data_point_unit_id = $1 \
		";

	    var queryValues = [
	        aUnitID
	    ];

	    return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	        .then(function(res) {
	            if (shouldDeleteSingle && res.rowCount !== 1) {
	                throw new Error("Invalid Argument: <DALUnit>.deleteByID expected to delete a single record.  Instead '" + res.rowCount + "' were deleted");
	            }
	        });
	};

	DALUnit.prototype.deleteByName = function deleteByName(aUnitName, shouldDeleteSingle) {
	    if (typeof aUnitName !== 'string') {
	        throw new Error("Invalid Argument: <DALUnit>.deleteByName requires a typeof string argument");
	    }

	    var queryText = "\
			delete from weather_data_point_unit \
			where weather_data_point_unit_name = $1 \
		";

	    var queryValues = [
	        aUnitName
	    ];

	    return this.pgWrapperInstance.RunParameterizedQuery(queryText, queryValues)
	        .then(function(res) {
	            if (shouldDeleteSingle && res.rowCount !== 1) {
	                throw new Error("Invalid Argument: <DALUnit>.deleteByName expected to delete a single record.  Instead '" + res.rowCount + "' were deleted");
	            }
	        });
	};


	//---------//
	// Exports //
	//---------//

	module.exports = DALUnit;


/***/ },
/* 389 */
/*!******************************!*\
  !*** ./src/shared/routes.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';


	//---------//
	// Imports //
	//---------//

	var nh = __webpack_require__(/*! node-helpers */ 90)
	  , path = __webpack_require__(/*! path */ 11);


	//------//
	// Init //
	//------//

	var lazy = nh.lazyExtensions;


	//------//
	// Main //
	//------//

	function ARoute(name_, url_, path_) {
	  this.name = name_;
	  this.url = '/' + url_;
	  this.path = path.join('app/components/', path_ + '.html');
	}

	function Routes() {
	  var my = { routeSeq: null };

	  this.routeSeq = function routeSeq(nothing) {
	    if (typeof nothing !== 'undefined') {
	      throw new Error("Invalid Argument: <Routes>.routeSeq is read-only");
	    }

	    // if my.routeSeq hasn't been initialized yet, then let's initialize it
	    if (my.routeSeq === null) {
	      var objRoutes = __webpack_require__(/*! ./routesObj.json */ 390);
	      my.routeSeq = [];
	      Object.keys(objRoutes).forEach(function(r) {
	        my.routeSeq.push(new ARoute(
	          r
	          , objRoutes[r].url
	          , objRoutes[r].path
	        ));
	      });

	      my.routeSeq = lazy(my.routeSeq);
	    }

	    return my.routeSeq;
	  };
	}


	//---------//
	// Exports //
	//---------//

	module.exports = Routes;


/***/ },
/* 390 */
/*!***********************************!*\
  !*** ./src/shared/routesObj.json ***!
  \***********************************/
/***/ function(module, exports) {

	module.exports = {
		"home": {
			"url": "home",
			"path": "static/home"
		},
		"about": {
			"url": "about",
			"path": "static/about"
		}
	};

/***/ }
/******/ ]);